
module pyon.internal.structures;

#include "rts.h"
#include "prim.h"
#include "memory_py.h"
#include "apply_py.h"
#include "structures.h"
#include "list.h"
import procedure exit (int) -> ();

#include "new_pyasm_records.h"

// Allocate some memory.  Use the flag to determine what kind of allocation.
procedure inline allocate (bool is_pointerless, uint size) -> pointer {
  if (is_pointerless) {
    pointer primcall pyon_alloc_nopointers (size);
  } else {
    pointer primcall pyon_alloc (size);
  };
};

data pointer repr_info = InfoTableHeader {
  TAG_CON
};

data owned repr_Box = Repr {
  ObjectHeader { repr_info },
  SA {sizeof owned, alignof owned},
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  Box_convert_to_boxed,
  Box_convert_to_bare,
  NOT_POINTERLESS
};

// Exactly the same as 'repr_Box'.  It's a separate definition because
// it has a different type in the Mem stage.
data owned repr_StoredBox = Repr {
  ObjectHeader { repr_info },
  SA {sizeof owned, alignof owned},
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  Box_convert_to_boxed,
  Box_convert_to_bare,
  NOT_POINTERLESS
};

// Exactly the same as 'repr_Box'.  It's a separate definition because
// it has a different type in the Mem stage.
data owned repr_StuckRef = Repr {
  ObjectHeader { repr_info },
  SA {sizeof owned, alignof owned},
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  Box_convert_to_boxed,
  Box_convert_to_bare,
  NOT_POINTERLESS
};

// Exactly the same as 'repr_Box'.  It's a separate definition because
// it has a different type in the Mem stage.
data owned repr_Stream = Repr {
  ObjectHeader { repr_info },
  SA {sizeof owned, alignof owned},
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  Box_convert_to_boxed,
  Box_convert_to_bare,
  NOT_POINTERLESS
};

// Argument writes a single pointer.  Load the result.
function Box_convert_to_boxed (owned writer) -> owned {
  data owned result;
  () = () call writer(result);
  owned load result;
};

// Write the object's address to the destination
function inline Box_convert_to_bare (owned src, pointer dst) -> () {
  !dst = src;
  ();
};

// A referenced object is just a pointer to the object
function inline repr_Referenced (owned elt_repr) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof Repr)) as owned;
  ret @! Repr.sizealign = SA {sizeof pointer, alignof pointer};
  ret @! Repr.is_pointerless = NOT_POINTERLESS;

  letrec {
    function copy (pointer src, pointer dst) -> () {
      // Allocate some new memory
      new_obj = pointer primcall allocate (elt_repr @! Repr.is_pointerless,
                                           elt_repr @! Repr.sizealign.size);

      // Copy into it
      () = () call (elt_repr @! Repr.copy) (pointer load src, new_obj);
      !dst = new_obj;
      ();
    }
  };
  ret @! Repr.copy = copy;
  ret @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof pointer, alignof pointer);
  ret @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof pointer, alignof pointer, copy);

  ret;
};

// A reference to an "empty" object.
// The referenced object will never be accessed.  The reference does not
// necessarily point to a valid address, depending on how the memory allocator
// works.
data owned repr_EmptyReference = Repr {
  ObjectHeader { repr_info },
  SA {word 0, word 1},
  dummy_copy,
  make_Boxed_0,
  from_Boxed_0,
  IS_POINTERLESS
};

function inline dummy_copy (pointer src, pointer dst) -> () {
  (); // Do nothing
};

function inline repr_arr
  (FinIndInt count, owned elt_repr) -> owned {
  FinIndInt {size} = count;

  SA {repr_size, repr_align} = elt_repr @! Repr.sizealign;
  typedef elt_type = bytes(value repr_size, value repr_align);
  typedef array_type = const_array(value size, elt_type);

  ret = (pointer primcall pyon_alloc (sizeof Repr)) as owned;
  ret @! Repr.sizealign = SA {sizeof array_type, alignof array_type};
  ret @! Repr.is_pointerless = elt_repr @! Repr.is_pointerless;

  elt_copy = elt_repr @! Repr.copy;
  letrec {
    function copy (pointer src, pointer dst) -> () {
      _ = while (int i = int 0) (i < size) {
        () = () call elt_copy (src @ array_type[i], dst @ array_type[i]);
        i + int 1;
      };
      ();
    }
  };
  ret @! Repr.copy = copy;
  ret @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof array_type, alignof array_type);
  ret @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof array_type, alignof array_type, copy);
  ret;
};

// Parameter-passing convention dictionary of ints
data owned repr_int = Repr {
  ObjectHeader { repr_info },
  SA {sizeof int32, alignof int32},
  copy4F,
  make_Boxed_4,
  from_Boxed_4,
  IS_POINTERLESS
};

// Parameter-passing convention dictionary of floats
data owned repr_float = Repr {
  ObjectHeader { repr_info },
  SA {sizeof float, alignof float},
  copy4F,
  make_Boxed_4,
  from_Boxed_4,
  IS_POINTERLESS
};

// Parameter-passing convention dictionary of bool
data owned repr_bool = Repr {
  ObjectHeader { repr_info },
  SA {sizeof bool, alignof bool},
  copy1F,
  make_Boxed_1,
  from_Boxed_1,
  IS_POINTERLESS
};

// Parameter-passing convention dictionary of EffTok,
// which contains no data
data owned repr_EffTok = Repr {
  ObjectHeader { repr_info },
  SA {word 0, word 1},
  dummy_copy,
  make_Boxed_0,
  from_Boxed_0,
  IS_POINTERLESS
};

function copy_Repr (pointer src, pointer dst) -> () {
  dst @! Repr.sizealign = src @! Repr.sizealign;
  dst @! Repr.copy = src @! Repr.copy;
  dst @! Repr.convert_to_boxed = src @! Repr.convert_to_boxed;
  dst @! Repr.convert_to_bare = src @! Repr.convert_to_bare;
  dst @! Repr.is_pointerless = src @! Repr.is_pointerless;
  ();
};

function inline repr_Maybe (owned repr_arg) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof Repr)) as owned;

  SA {arg_size, arg_align} = repr_arg @! Repr.sizealign;
  typedef arg = bytes(value arg_size, value arg_align);

  ret @! Repr.sizealign = SA {sizeof Maybe(arg), alignof Maybe(arg)};
  ret @! Repr.is_pointerless = repr_arg @! Repr.is_pointerless;
  copy = owned call copy_Maybe (repr_arg @! Repr.copy,
                                sizeof arg, alignof arg);
  ret @! Repr.copy = copy;
  ret @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof Maybe(arg), alignof Maybe(arg));
  ret @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof Maybe(arg), alignof Maybe(arg), copy);
  ret;
};

function copy_Maybe (owned copy_arg, uint arg_size, uint arg_align,
                     pointer src, pointer dst) -> () {
  typedef arg = bytes(value arg_size, value arg_align);
  if (src @! Maybe(arg).isjust == uint8 1) {
    // Nothing
    dst @! Maybe(arg).isjust = uint8 1;
    ();
  } else {
    dst @! Maybe(arg).isjust = uint8 0;
    () call copy_arg (src @ Maybe(arg).member, dst @ Maybe(arg).member);
  };
};

function inline repr_PyonTuple2 (owned repr1, owned repr2) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof Repr)) as owned;
  SA {size1, align1} = repr1 @! Repr.sizealign;
  SA {size2, align2} = repr2 @! Repr.sizealign;
  typedef tuple = PyonTuple2(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2));

  ret @! Repr.sizealign = SA {sizeof tuple, alignof tuple};
  ret @! Repr.is_pointerless =
    repr1 @! Repr.is_pointerless &&
    repr2 @! Repr.is_pointerless;
  copy = owned call copy_PyonTuple2
    (repr1 @! Repr.copy, repr2 @! Repr.copy,
     size1, align1, size2, align2);
  ret @! Repr.copy = copy;

  ret @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof tuple, alignof tuple);
  ret @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof tuple, alignof tuple, copy);

  ret;
};

function inline copy_PyonTuple2(owned copy1, owned copy2,
                         uint size1, uint align1, uint size2, uint align2,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple2(bytes(value size1, value align1), bytes(value size2, value align2));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () call copy2 (src @ tuple.member2, dst @ tuple.member2);
};

function inline repr_PyonTuple3 (owned repr1, owned repr2, owned repr3) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof Repr)) as owned;
  SA {size1, align1} = repr1 @! Repr.sizealign;
  SA {size2, align2} = repr2 @! Repr.sizealign;
  SA {size3, align3} = repr3 @! Repr.sizealign;
  typedef tuple = PyonTuple3(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2),
			     bytes(value size3, value align3));

  ret @! Repr.sizealign = SA {sizeof tuple, alignof tuple};
  ret @! Repr.is_pointerless =
    repr1 @! Repr.is_pointerless &&
    repr2 @! Repr.is_pointerless &&
    repr3 @! Repr.is_pointerless;
  copy = owned call copy_PyonTuple3
    (repr1 @! Repr.copy, repr2 @! Repr.copy,
     repr3 @! Repr.copy,
     size1, align1, size2, align2, size3, align3);
  ret @! Repr.copy = copy;
  ret @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof tuple, alignof tuple);
  ret @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof tuple, alignof tuple, copy);

  ret;
};

function inline copy_PyonTuple3(owned copy1, owned copy2, owned copy3,
                         uint size1, uint align1, uint size2, uint align2,
			 uint size3, uint align3,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple3(bytes(value size1, value align1),
  	  	  	     bytes(value size2, value align2),
  	  	  	     bytes(value size3, value align3));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () = () call copy2 (src @ tuple.member2, dst @ tuple.member2);
  () call copy3 (src @ tuple.member3, dst @ tuple.member3);
};

function inline repr_PyonTuple4
    (owned repr1, owned repr2, owned repr3, owned repr4) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof Repr)) as owned;
  SA {size1, align1} = repr1 @! Repr.sizealign;
  SA {size2, align2} = repr2 @! Repr.sizealign;
  SA {size3, align3} = repr3 @! Repr.sizealign;
  SA {size4, align4} = repr4 @! Repr.sizealign;
  typedef tuple = PyonTuple4(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2),
			     bytes(value size3, value align3),
			     bytes(value size4, value align4));

  ret @! Repr.sizealign = SA {sizeof tuple, alignof tuple};
  ret @! Repr.is_pointerless =
    repr1 @! Repr.is_pointerless &&
    repr2 @! Repr.is_pointerless &&
    repr3 @! Repr.is_pointerless &&
    repr4 @! Repr.is_pointerless;
  copy = owned call copy_PyonTuple4
    (repr1 @! Repr.copy, repr2 @! Repr.copy,
     repr3 @! Repr.copy, repr4 @! Repr.copy,
     size1, align1, size2, align2, size3, align3, size4, align4);
  ret @! Repr.copy = copy;
  ret @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof tuple, alignof tuple);
  ret @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof tuple, alignof tuple, copy);
  ret;
};

function inline copy_PyonTuple4(owned copy1, owned copy2, owned copy3,
                         owned copy4,
                         uint size1, uint align1, uint size2, uint align2,
			 uint size3, uint align3, uint size4, uint align4,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple4(bytes(value size1, value align1),
  	  	  	     bytes(value size2, value align2),
  	  	  	     bytes(value size3, value align3),
  	  	  	     bytes(value size4, value align4));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () = () call copy2 (src @ tuple.member2, dst @ tuple.member2);
  () = () call copy3 (src @ tuple.member3, dst @ tuple.member3);
  () call copy4 (src @ tuple.member4, dst @ tuple.member4);
};

#if 0
data pointer TraversableDict_info = InfoTableHeader {
  TAG_CON
};

data owned OpaqueTraversableDict_list = TraversableDict {
  ObjectHeader { TraversableDict_info },
  list_traverse,
  list_build
};
#endif

// Is this redundant with 'repr_Complex' in complex.pyasm?
function inline complex_pass_conv (pointer repr, pointer ret) -> () {
  SA {size, align} = repr @! Repr.sizealign;
  typedef cpx = complex(bytes(value size, value align));

  ret @! Repr.sizealign = SA {sizeof cpx, alignof cpx};
  ret @! Repr.is_pointerless = repr @! Repr.is_pointerless;
  copy = owned call copy_complex (size, align, repr @! Repr.copy);
  ret @! Repr.copy = copy;
  ret @! Repr.convert_to_boxed =
      owned call make_Boxed (sizeof cpx, alignof cpx);
  ret @! Repr.convert_to_bare =
      owned call from_Boxed (sizeof cpx, alignof cpx, copy);
  ();
};

function inline copy_complex
  (uint size, uint align, owned copy_member, pointer src, pointer dst) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call copy_member (src @ cpx.real, dst @ cpx.real);
  () = () call copy_member (src @ cpx.imag, dst @ cpx.imag);
  ();
};

function inline additiveDict_complex
  (pointer member_additive, pointer ret) -> ()
{
  () primcall exit (int -1);
  // FIXME
/*
  member_size = member_additive @! AdditiveDict(unit).repr.size;
  member_align = member_additive @! AdditiveDict(unit).repr.align;
  typedef member = bytes(value member_size, value member_align);
  typedef member_dict = AdditiveDict(member);

  member_copy = member_additive @! member_dict.repr.copy;
  typedef cpx = complex(member);
  typedef dictionary = AdditiveDict(cpx);

  () = () call complex_pass_conv
    (type, member_additive @ member_dict.repr, ret @ dictionary.repr);

  ret @! dictionary.add =
    owned call complex_add (member_size, member_align,
                            member_additive @! member_dict.add);
  ret @! dictionary.subtract =
    owned call complex_sub (member_size, member_align,
                            member_additive @! member_dict.subtract);
  ret @! dictionary.negate =
    owned call complex_negate (member_size, member_align,
                               member_additive @! member_dict.negate);
  () = () call member_copy (ret @ dictionary.zero.real,
                            member_additive @ member_dict.zero);
  () = () call member_copy (ret @ dictionary.zero.imag,
                            member_additive @ member_dict.zero);
  (); */
};

function inline makeComplex(float re, float im, pointer ret) -> () {
  typedef cfloa = complex (float);
  ret @! cfloa.real = re;
  ret @! cfloa.imag = im;
  ();
};

function inline complex_add(uint size, uint align, owned member_add,
                     pointer x, pointer y, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_add (x @ cpx.real, y @ cpx.real, ret @ cpx.real);
  () call member_add (x @ cpx.imag, y @ cpx.imag, ret @ cpx.imag);
};

function inline complex_sub(uint size, uint align, owned member_sub,
                     pointer x, pointer y, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_sub (x @ cpx.real, y @ cpx.real, ret @ cpx.real);
  () call member_sub (x @ cpx.imag, y @ cpx.imag, ret @ cpx.imag);
};

function inline complex_negate(uint size, uint align, owned member_negate,
                        pointer x, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_negate (x @ cpx.real, ret @ cpx.real);
  () call member_negate (x @ cpx.imag, ret @ cpx.imag);
};

data pointer int_info = InfoTableHeader {
  TAG_CON
};