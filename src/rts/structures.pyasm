
module pyon.internal.structures;

#include "rts.h"
#include "prim.h"
#include "memory_py.h"
#include "apply_py.h"
#include "structures.h"
#include "list.h"
import procedure exit (int) -> ();

#include "new_pyasm_records.h"

data pointer repr_info = InfoTableHeader {
  dummy_finalizer,
  TAG_CON
};

data owned repr_Box_value = PassConv {
  ObjectHeader { int 1, repr_info },
  sizeof owned,
  alignof owned,
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  dummy_finalizer
};

// Return the representation of a Boxed object.  The parameter is a type
// parameter.
function inline repr_Box (unit _) -> owned {
  repr_Box_value;
};

// Exactly the same as repr_Box, but it has a different System F type
function inline repr_Boxed (unit _) -> owned {
  repr_Box_value;
};

// Exactly the same as repr_Box, but it has a different System F type
function inline repr_Referenced (unit _, owned elt_repr) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  ret @! PassConv.size = sizeof pointer;
  ret @! PassConv.align = alignof pointer;

  letrec {
    function copy (pointer src, pointer dst) -> () {
      // Allocate some new memory
      new_obj = pointer primcall pyon_alloc (elt_repr @! PassConv.size);

      // Copy into it
      () = () call (elt_repr @! PassConv.copy) (pointer load src, new_obj);
      !dst = new_obj;
      ();
    }
  };
  ret @! PassConv.copy = copy;

  letrec {
    function finalize (pointer self) -> () {
      contents = pointer load self;
      () = () call (elt_repr @! PassConv.finalize) (contents);
      () primcall pyon_dealloc (contents);
    }
  };
  ret @! PassConv.finalize = finalize;
  ret;
};

// A reference to an "empty" object.
// The referenced object will never be accessed.  The reference does not
// necessarily point to a valid address, depending on how the memory allocator
// works.
data owned repr_EmptyRef = PassConv {
  ObjectHeader { int 1, repr_info },
  word 0,
  word 1,
  dummy_copy,
  dummy_finalizer
};

function inline dummy_copy (pointer src, pointer dst) -> () {
  (); // Do nothing
};

function inline repr_EmptyReference (unit _) -> owned {
  repr_EmptyRef;
};

// Exactly the same as repr_Box, but it has a different System F type
function inline repr_Stream (unit _, unit _) -> owned {
  repr_Box_value;
};

function inline repr_array
  (unit _, unit _, IndexedInt count, owned elt_repr) -> owned {
  IndexedInt {size} = count;
  typedef elt_type = bytes(value elt_repr @! PassConv.size,
                           value elt_repr @! PassConv.align);
  typedef array_type = const_array(value count, elt_type);

  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  ret @! PassConv.size = sizeof array_type;
  ret @! PassConv.align = alignof array_type;

  elt_copy = elt_repr @! PassConv.copy;
  letrec {
    function copy (pointer src, pointer dst) -> () {
      _ = while (int i = int 0) (i < size) {
        () = () call elt_copy (src @ array_type[i], dst @ array_type[i]);
        i + int 1;
      };
      ();
    }
  };
  ret @! PassConv.copy = copy;

  elt_finalize = elt_repr @! PassConv.finalize;
  letrec {
    function finalize (pointer self) -> () {
      _ = while (int i = int 0) (i < size) {
        () = () call elt_finalize (self @ array_type[i]);
        i + int 1;
      };
      ();
    }
  };
  ret @! PassConv.finalize = finalize;
  ret;
};

// Parameter-passing convention dictionary of ints
data owned repr_int = PassConv {
  ObjectHeader { int 1, repr_info },
  sizeof int32,
  alignof int32,
  copy4F,
  dummy_finalizer
};

// Parameter-passing convention dictionary of floats
data owned repr_float = PassConv {
  ObjectHeader { int 1, repr_info },
  sizeof float,
  alignof float,
  copy4F,
  dummy_finalizer
};

// Parameter-passing convention dictionary of bool
data owned repr_bool = PassConv {
  ObjectHeader { int 1, repr_info },
  sizeof bool,
  alignof bool,
  copy1F,
  dummy_finalizer
};

function copy_Repr (unit _, pointer src, pointer dst) -> () {
  dst @! PassConv.size = src @! PassConv.size;
  dst @! PassConv.align = src @! PassConv.align;
  dst @! PassConv.copy = src @! PassConv.copy;
  dst @! PassConv.finalize = src @! PassConv.finalize;
  ();
};

function inline repr_PyonTuple2 (unit _, unit _,
                                 owned repr1, owned repr2) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  size1 = repr1 @! PassConv.size;
  align1 = repr1 @! PassConv.align;
  size2 = repr2 @! PassConv.size;
  align2 = repr2 @! PassConv.align;
  typedef tuple = PyonTuple2(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2));

  ret @! PassConv.size = sizeof tuple;
  ret @! PassConv.align = alignof tuple;
  ret @! PassConv.copy = owned call copy_PyonTuple2
    (repr1 @! PassConv.copy, repr2 @! PassConv.copy,
     size1, align1, size2, align2);
  ret @! PassConv.finalize = dummy_finalizer;
  ret;
};

function inline copy_PyonTuple2(owned copy1, owned copy2,
                         uint size1, uint align1, uint size2, uint align2,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple2(bytes(value size1, value align1), bytes(value size2, value align2));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () call copy2 (src @ tuple.member2, dst @ tuple.member2);
};

function inline repr_PyonTuple3 (unit _, unit _, unit _,
                                 owned repr1, owned repr2, owned repr3) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  size1 = repr1 @! PassConv.size;
  align1 = repr1 @! PassConv.align;
  size2 = repr2 @! PassConv.size;
  align2 = repr2 @! PassConv.align;
  size3 = repr3 @! PassConv.size;
  align3 = repr3 @! PassConv.align;
  typedef tuple = PyonTuple3(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2),
			     bytes(value size3, value align3));

  ret @! PassConv.size = sizeof tuple;
  ret @! PassConv.align = alignof tuple;
  ret @! PassConv.copy = owned call copy_PyonTuple3
    (repr1 @! PassConv.copy, repr2 @! PassConv.copy,
     repr3 @! PassConv.copy,
     size1, align1, size2, align2, size3, align3);
  ret @! PassConv.finalize = dummy_finalizer;
  ret;
};

function inline copy_PyonTuple3(owned copy1, owned copy2, owned copy3,
                         uint size1, uint align1, uint size2, uint align2,
			 uint size3, uint align3,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple3(bytes(value size1, value align1),
  	  	  	     bytes(value size2, value align2),
  	  	  	     bytes(value size3, value align3));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () = () call copy2 (src @ tuple.member2, dst @ tuple.member2);
  () call copy3 (src @ tuple.member3, dst @ tuple.member3);
};

function inline repr_PyonTuple4
    (unit _, unit _, unit _, unit _,
     owned repr1, owned repr2, owned repr3, owned repr4) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  size1 = repr1 @! PassConv.size;
  align1 = repr1 @! PassConv.align;
  size2 = repr2 @! PassConv.size;
  align2 = repr2 @! PassConv.align;
  size3 = repr3 @! PassConv.size;
  align3 = repr3 @! PassConv.align;
  size4 = repr4 @! PassConv.size;
  align4 = repr4 @! PassConv.align;
  typedef tuple = PyonTuple4(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2),
			     bytes(value size3, value align3),
			     bytes(value size4, value align4));

  ret @! PassConv.size = sizeof tuple;
  ret @! PassConv.align = alignof tuple;
  ret @! PassConv.copy = owned call copy_PyonTuple4
    (repr1 @! PassConv.copy, repr2 @! PassConv.copy,
     repr3 @! PassConv.copy, repr4 @! PassConv.copy,
     size1, align1, size2, align2, size3, align3, size4, align4);
  ret @! PassConv.finalize = dummy_finalizer;
  ret;
};

function inline copy_PyonTuple4(owned copy1, owned copy2, owned copy3,
                         owned copy4,
                         uint size1, uint align1, uint size2, uint align2,
			 uint size3, uint align3, uint size4, uint align4,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple4(bytes(value size1, value align1),
  	  	  	     bytes(value size2, value align2),
  	  	  	     bytes(value size3, value align3),
  	  	  	     bytes(value size4, value align4));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () = () call copy2 (src @ tuple.member2, dst @ tuple.member2);
  () = () call copy3 (src @ tuple.member3, dst @ tuple.member3);
  () call copy4 (src @ tuple.member4, dst @ tuple.member4);
};

#if 0
data pointer TraversableDict_info = InfoTableHeader {
  dummy_finalizer,
  TAG_CON
};

data owned OpaqueTraversableDict_list = TraversableDict {
  ObjectHeader { int 1, TraversableDict_info },
  list_traverse,
  list_build
};
#endif

function inline complex_pass_conv (unit _, pointer repr, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  typedef cpx = complex(bytes(value size, value align));

  ret @! PassConv.size = sizeof cpx;
  ret @! PassConv.align = alignof cpx;
  ret @! PassConv.copy =
      owned call copy_complex (size, align, repr @! PassConv.copy);
  ret @! PassConv.finalize =
      owned call finalize_complex (size, align, repr @! PassConv.finalize);
  ();
};

function inline copy_complex
  (uint size, uint align, owned copy_member, pointer src, pointer dst) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call copy_member (src @ cpx.real, dst @ cpx.real);
  () = () call copy_member (src @ cpx.imag, dst @ cpx.imag);
  ();
};

function finalize_complex
  (uint size, uint align, owned finalize_member, pointer self) -> () {
  // Not implemented
  ();
};

function inline repr_AdditiveDict (unit _, pointer repr, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  copy = repr @! PassConv.copy;
  typedef dictionary = AdditiveDict(bytes(value size, value align));

  ret @! PassConv.size = sizeof dictionary;
  ret @! PassConv.align = alignof dictionary;
  ret @! PassConv.copy = owned call AdditiveDict_copy (size, align, copy);
  ret @! PassConv.finalize = dummy_finalizer;
  ();
};

function AdditiveDict_copy
  (uint size, uint align, owned copy_value, pointer src, pointer dst) -> () {
  typedef dictionary = AdditiveDict(bytes(value size, value align));

  dst @! dictionary.add = src @! dictionary.add;
  dst @! dictionary.subtract = src @! dictionary.subtract;
  dst @! dictionary.negate = src @! dictionary.negate;
  () call (copy_value) (src @ dictionary.zero, dst @ dictionary.zero);  
};

function inline repr_MultiplicativeDict
  (unit _, pointer value_repr, pointer ret) -> () {
  size = value_repr @! PassConv.size;
  align = value_repr @! PassConv.align;
  copy = value_repr @! PassConv.copy;
  typedef dictionary = MultiplicativeDict(bytes(value size, value align));

  ret @! PassConv.size = sizeof dictionary;
  ret @! PassConv.align = alignof dictionary;
  ret @! PassConv.copy = owned call MultiplicativeDict_copy (size, align, copy);
  ret @! PassConv.finalize = dummy_finalizer;
  ();
};

function MultiplicativeDict_copy
  (uint size, uint align, owned copy_value, pointer src, pointer dst) -> () {
  typedef dictionary = MultiplicativeDict(bytes(value size, value align));

  () = () call AdditiveDict_copy(size, align, copy_value,
                                 src @ dictionary.additive,
                                 dst @ dictionary.additive);
  dst @! dictionary.mul = src @! dictionary.mul;
  dst @! dictionary.fromInt = src @! dictionary.fromInt;
  () call (copy_value) (src @ dictionary.one, dst @ dictionary.one);
};

// Construct an Additive dictionary
function inline additiveDict
  (unit _, pointer repr,
   owned add, owned sub, owned negate, owned write_zero, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  typedef dictionary = AdditiveDict(bytes(value size, value align));

  ret @! dictionary.add = add;
  ret @! dictionary.subtract = sub;
  ret @! dictionary.negate = negate;
  () call write_zero (ret @ dictionary.zero);
};

function multiplicativeDict
  (unit _, pointer repr,
   owned write_additive,
   owned mul, owned from_int, owned write_one, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  typedef dictionary = MultiplicativeDict(bytes(value size, value align));

  () = () call write_additive (ret @ dictionary.additive);
  ret @! dictionary.mul = mul;
  ret @! dictionary.fromInt = from_int;
  () call write_one (ret @ dictionary.one);
};

function inline additiveDict_complex
  (unit type, pointer member_additive, pointer ret) -> ()
{
  () primcall exit (int -1);
  // FIXME
/*
  member_size = member_additive @! AdditiveDict(unit).repr.size;
  member_align = member_additive @! AdditiveDict(unit).repr.align;
  typedef member = bytes(value member_size, value member_align);
  typedef member_dict = AdditiveDict(member);

  member_copy = member_additive @! member_dict.repr.copy;
  typedef cpx = complex(member);
  typedef dictionary = AdditiveDict(cpx);

  () = () call complex_pass_conv
    (type, member_additive @ member_dict.repr, ret @ dictionary.repr);

  ret @! dictionary.add =
    owned call complex_add (member_size, member_align,
                            member_additive @! member_dict.add);
  ret @! dictionary.subtract =
    owned call complex_sub (member_size, member_align,
                            member_additive @! member_dict.subtract);
  ret @! dictionary.negate =
    owned call complex_negate (member_size, member_align,
                               member_additive @! member_dict.negate);
  () = () call member_copy (ret @ dictionary.zero.real,
                            member_additive @ member_dict.zero);
  () = () call member_copy (ret @ dictionary.zero.imag,
                            member_additive @ member_dict.zero);
  (); */
};

function inline makeComplex(float re, float im, pointer ret) -> () {
  typedef cfloa = complex (float);
  ret @! cfloa.real = re;
  ret @! cfloa.imag = im;
  ();
};

function inline complex_add(uint size, uint align, owned member_add,
                     pointer x, pointer y, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_add (x @ cpx.real, y @ cpx.real, ret @ cpx.real);
  () call member_add (x @ cpx.imag, y @ cpx.imag, ret @ cpx.imag);
};

function inline complex_sub(uint size, uint align, owned member_sub,
                     pointer x, pointer y, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_sub (x @ cpx.real, y @ cpx.real, ret @ cpx.real);
  () call member_sub (x @ cpx.imag, y @ cpx.imag, ret @ cpx.imag);
};

function inline complex_negate(uint size, uint align, owned member_negate,
                        pointer x, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_negate (x @ cpx.real, ret @ cpx.real);
  () call member_negate (x @ cpx.imag, ret @ cpx.imag);
};
