
module pyon.internal.structures;

#include "rts.h"
#include "prim.h"
#include "memory_py.h"
#include "apply_py.h"
#include "structures.h"
#include "list.h"
import procedure exit (int) -> ();

#include "new_pyasm_records.h"

// Allocate some memory.  Use the flag to determine what kind of allocation.
procedure inline allocate (bool is_pointerless, uint size) -> pointer {
  if (is_pointerless) {
    pointer primcall pyon_alloc_nopointers (size);
  } else {
    pointer primcall pyon_alloc (size);
  };
};

data pointer repr_info = InfoTableHeader {
  TAG_CON
};

data owned repr_Box = PassConv {
  ObjectHeader { repr_info },
  sizeof owned,
  alignof owned,
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  Box_convert_to_boxed,
  Box_convert_to_bare,
  dummy_finalizer,
  NOT_POINTERLESS
};

// Exactly the same as 'repr_Box'.  It's a separate definition because
// it has a different type in the Mem stage.
data owned repr_Stream = PassConv {
  ObjectHeader { repr_info },
  sizeof owned,
  alignof owned,
#if WORD_SIZE == 4
  copy4F,
#elif WORD_SIZE == 8
  copy8F,
#else
# error "Don't know how to copy Boxed values"
#endif
  Box_convert_to_boxed,
  Box_convert_to_bare,
  dummy_finalizer,
  NOT_POINTERLESS
};

// Argument writes a single pointer.  Load the result.
function Box_convert_to_boxed (owned writer) -> owned {
  data owned result;
  () = () call writer(result);
  owned load result;
};

// Write the object's address to the destination
function inline Box_convert_to_bare (owned src, pointer dst) -> () {
  !dst = src;
  ();
};

// A referenced object is just a pointer to the object
function inline repr_Referenced (owned elt_repr) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  ret @! PassConv.size = sizeof pointer;
  ret @! PassConv.align = alignof pointer;
  ret @! PassConv.is_pointerless = NOT_POINTERLESS;

  letrec {
    function copy (pointer src, pointer dst) -> () {
      // Allocate some new memory
      new_obj = pointer primcall allocate (elt_repr @! PassConv.is_pointerless,
                                           elt_repr @! PassConv.size);

      // Copy into it
      () = () call (elt_repr @! PassConv.copy) (pointer load src, new_obj);
      !dst = new_obj;
      ();
    }
  };
  ret @! PassConv.copy = copy;
  ret @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof pointer, alignof pointer);
  ret @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof pointer, alignof pointer, copy);

  letrec {
    function finalize (pointer self) -> () {
      contents = pointer load self;
      () = () call (elt_repr @! PassConv.finalize) (contents);
      () primcall pyon_dealloc (contents);
    }
  };
  ret @! PassConv.finalize = finalize;
  ret;
};

// A reference to an "empty" object.
// The referenced object will never be accessed.  The reference does not
// necessarily point to a valid address, depending on how the memory allocator
// works.
data owned repr_EmptyReference = PassConv {
  ObjectHeader { repr_info },
  word 0,
  word 1,
  dummy_copy,
  make_Boxed_0,
  from_Boxed_0,
  dummy_finalizer,
  IS_POINTERLESS
};

function inline dummy_copy (pointer src, pointer dst) -> () {
  (); // Do nothing
};

function inline repr_array
  (FinIndInt count, owned elt_repr) -> owned {
  FinIndInt {size} = count;

  typedef elt_type = bytes(value elt_repr @! PassConv.size,
                           value elt_repr @! PassConv.align);
  typedef array_type = const_array(value size, elt_type);

  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  ret @! PassConv.size = sizeof array_type;
  ret @! PassConv.align = alignof array_type;
  ret @! PassConv.is_pointerless = elt_repr @! PassConv.is_pointerless;

  elt_copy = elt_repr @! PassConv.copy;
  letrec {
    function copy (pointer src, pointer dst) -> () {
      _ = while (int i = int 0) (i < size) {
        () = () call elt_copy (src @ array_type[i], dst @ array_type[i]);
        i + int 1;
      };
      ();
    }
  };
  ret @! PassConv.copy = copy;
  ret @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof array_type, alignof array_type);
  ret @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof array_type, alignof array_type, copy);

  elt_finalize = elt_repr @! PassConv.finalize;
  letrec {
    function finalize (pointer self) -> () {
      _ = while (int i = int 0) (i < size) {
        () = () call elt_finalize (self @ array_type[i]);
        i + int 1;
      };
      ();
    }
  };
  ret @! PassConv.finalize = finalize;
  ret;
};

// Parameter-passing convention dictionary of ints
data owned repr_int = PassConv {
  ObjectHeader { repr_info },
  sizeof int32,
  alignof int32,
  copy4F,
  make_Boxed_4,
  from_Boxed_4,
  dummy_finalizer,
  IS_POINTERLESS
};

// Parameter-passing convention dictionary of floats
data owned repr_float = PassConv {
  ObjectHeader { repr_info },
  sizeof float,
  alignof float,
  copy4F,
  make_Boxed_4,
  from_Boxed_4,
  dummy_finalizer,
  IS_POINTERLESS
};

// Parameter-passing convention dictionary of bool
data owned repr_bool = PassConv {
  ObjectHeader { repr_info },
  sizeof bool,
  alignof bool,
  copy1F,
  make_Boxed_1,
  from_Boxed_1,
  dummy_finalizer,
  IS_POINTERLESS
};

// Parameter-passing convention dictionary of EffTok,
// which contains no data
data owned repr_EffTok = PassConv {
  ObjectHeader { repr_info },
  word 0,
  word 1,
  dummy_copy,
  make_Boxed_0,
  from_Boxed_0,
  dummy_finalizer,
  IS_POINTERLESS
};

function copy_Repr (pointer src, pointer dst) -> () {
  dst @! PassConv.size = src @! PassConv.size;
  dst @! PassConv.align = src @! PassConv.align;
  dst @! PassConv.copy = src @! PassConv.copy;
  dst @! PassConv.convert_to_boxed = src @! PassConv.convert_to_boxed;
  dst @! PassConv.convert_to_bare = src @! PassConv.convert_to_bare;
  dst @! PassConv.finalize = src @! PassConv.finalize;
  dst @! PassConv.is_pointerless = src @! PassConv.is_pointerless;
  ();
};

function inline repr_Maybe (owned repr_arg) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;

  typedef arg = bytes(value repr_arg @! PassConv.size,
                      value repr_arg @! PassConv.align);

  ret @! PassConv.size = sizeof Maybe(arg);
  ret @! PassConv.align = alignof Maybe(arg);
  ret @! PassConv.is_pointerless = repr_arg @! PassConv.is_pointerless;
  copy = owned call copy_Maybe (repr_arg @! PassConv.copy,
                                sizeof arg, alignof arg);
  ret @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof Maybe(arg), alignof Maybe(arg));
  ret @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof Maybe(arg), alignof Maybe(arg), copy);
  ret @! PassConv.finalize =
    owned call finalize_Maybe(repr_arg @! PassConv.finalize,
                              sizeof arg, alignof arg);
  ret;
};

function copy_Maybe (owned copy_arg, uint arg_size, uint arg_align,
                     pointer src, pointer dst) -> () {
  typedef arg = bytes(value arg_size, value arg_align);
  if (src @! Maybe(arg).isjust == uint8 0) {
    // Nothing
    dst @! Maybe(arg).isjust = uint8 0;
    ();
  } else {
    dst @! Maybe(arg).isjust = uint8 1;
    () call copy_arg (src @ Maybe(arg).member, dst @ Maybe(arg).member);
  };
};

function finalize_Maybe (owned finalize_arg, uint arg_size, uint arg_align,
                         pointer p) -> () {
  typedef arg = bytes(value arg_size, value arg_align);
  if (p @! Maybe(arg).isjust == uint8 0) {
    // Nothing
    ();
  } else {
    // Just
    () call finalize_arg (p @ Maybe(arg).member);
  };
  
};

function inline repr_PyonTuple2 (owned repr1, owned repr2) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  size1 = repr1 @! PassConv.size;
  align1 = repr1 @! PassConv.align;
  size2 = repr2 @! PassConv.size;
  align2 = repr2 @! PassConv.align;
  typedef tuple = PyonTuple2(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2));

  ret @! PassConv.size = sizeof tuple;
  ret @! PassConv.align = alignof tuple;
  ret @! PassConv.is_pointerless =
    repr1 @! PassConv.is_pointerless &&
    repr2 @! PassConv.is_pointerless;
  copy = owned call copy_PyonTuple2
    (repr1 @! PassConv.copy, repr2 @! PassConv.copy,
     size1, align1, size2, align2);
  ret @! PassConv.copy = copy;

  ret @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof tuple, alignof tuple);
  ret @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof tuple, alignof tuple, copy);

  ret @! PassConv.finalize = dummy_finalizer;
  ret;
};

function inline copy_PyonTuple2(owned copy1, owned copy2,
                         uint size1, uint align1, uint size2, uint align2,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple2(bytes(value size1, value align1), bytes(value size2, value align2));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () call copy2 (src @ tuple.member2, dst @ tuple.member2);
};

function inline repr_PyonTuple3 (owned repr1, owned repr2, owned repr3) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  size1 = repr1 @! PassConv.size;
  align1 = repr1 @! PassConv.align;
  size2 = repr2 @! PassConv.size;
  align2 = repr2 @! PassConv.align;
  size3 = repr3 @! PassConv.size;
  align3 = repr3 @! PassConv.align;
  typedef tuple = PyonTuple3(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2),
			     bytes(value size3, value align3));

  ret @! PassConv.size = sizeof tuple;
  ret @! PassConv.align = alignof tuple;
  ret @! PassConv.is_pointerless =
    repr1 @! PassConv.is_pointerless &&
    repr2 @! PassConv.is_pointerless &&
    repr3 @! PassConv.is_pointerless;
  copy = owned call copy_PyonTuple3
    (repr1 @! PassConv.copy, repr2 @! PassConv.copy,
     repr3 @! PassConv.copy,
     size1, align1, size2, align2, size3, align3);
  ret @! PassConv.copy = copy;
  ret @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof tuple, alignof tuple);
  ret @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof tuple, alignof tuple, copy);

  ret @! PassConv.finalize = dummy_finalizer;
  ret;
};

function inline copy_PyonTuple3(owned copy1, owned copy2, owned copy3,
                         uint size1, uint align1, uint size2, uint align2,
			 uint size3, uint align3,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple3(bytes(value size1, value align1),
  	  	  	     bytes(value size2, value align2),
  	  	  	     bytes(value size3, value align3));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () = () call copy2 (src @ tuple.member2, dst @ tuple.member2);
  () call copy3 (src @ tuple.member3, dst @ tuple.member3);
};

function inline repr_PyonTuple4
    (owned repr1, owned repr2, owned repr3, owned repr4) -> owned {
  ret = (pointer primcall pyon_alloc (sizeof PassConv)) as owned;
  size1 = repr1 @! PassConv.size;
  align1 = repr1 @! PassConv.align;
  size2 = repr2 @! PassConv.size;
  align2 = repr2 @! PassConv.align;
  size3 = repr3 @! PassConv.size;
  align3 = repr3 @! PassConv.align;
  size4 = repr4 @! PassConv.size;
  align4 = repr4 @! PassConv.align;
  typedef tuple = PyonTuple4(bytes(value size1, value align1),
  	  	             bytes(value size2, value align2),
			     bytes(value size3, value align3),
			     bytes(value size4, value align4));

  ret @! PassConv.size = sizeof tuple;
  ret @! PassConv.align = alignof tuple;
  ret @! PassConv.is_pointerless =
    repr1 @! PassConv.is_pointerless &&
    repr2 @! PassConv.is_pointerless &&
    repr3 @! PassConv.is_pointerless &&
    repr4 @! PassConv.is_pointerless;
  copy = owned call copy_PyonTuple4
    (repr1 @! PassConv.copy, repr2 @! PassConv.copy,
     repr3 @! PassConv.copy, repr4 @! PassConv.copy,
     size1, align1, size2, align2, size3, align3, size4, align4);
  ret @! PassConv.copy = copy;
  ret @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof tuple, alignof tuple);
  ret @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof tuple, alignof tuple, copy);
  ret @! PassConv.finalize = dummy_finalizer;
  ret;
};

function inline copy_PyonTuple4(owned copy1, owned copy2, owned copy3,
                         owned copy4,
                         uint size1, uint align1, uint size2, uint align2,
			 uint size3, uint align3, uint size4, uint align4,
                         pointer src, pointer dst) -> () {
  typedef tuple = PyonTuple4(bytes(value size1, value align1),
  	  	  	     bytes(value size2, value align2),
  	  	  	     bytes(value size3, value align3),
  	  	  	     bytes(value size4, value align4));
  () = () call copy1 (src @ tuple.member1, dst @ tuple.member1);
  () = () call copy2 (src @ tuple.member2, dst @ tuple.member2);
  () = () call copy3 (src @ tuple.member3, dst @ tuple.member3);
  () call copy4 (src @ tuple.member4, dst @ tuple.member4);
};

#if 0
data pointer TraversableDict_info = InfoTableHeader {
  TAG_CON
};

data owned OpaqueTraversableDict_list = TraversableDict {
  ObjectHeader { TraversableDict_info },
  list_traverse,
  list_build
};
#endif

// Is this redundant with 'repr_Complex' in complex.pyasm?
function inline complex_pass_conv (pointer repr, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  typedef cpx = complex(bytes(value size, value align));

  ret @! PassConv.size = sizeof cpx;
  ret @! PassConv.align = alignof cpx;
  ret @! PassConv.is_pointerless = repr @! PassConv.is_pointerless;
  copy =
      owned call copy_complex (size, align, repr @! PassConv.copy);
  ret @! PassConv.copy = copy;
  ret @! PassConv.convert_to_boxed =
      owned call make_Boxed (sizeof cpx, alignof cpx);
  ret @! PassConv.convert_to_bare =
      owned call from_Boxed (sizeof cpx, alignof cpx, copy);
  ret @! PassConv.finalize =
      owned call finalize_complex (size, align, repr @! PassConv.finalize);
  ();
};

function inline copy_complex
  (uint size, uint align, owned copy_member, pointer src, pointer dst) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call copy_member (src @ cpx.real, dst @ cpx.real);
  () = () call copy_member (src @ cpx.imag, dst @ cpx.imag);
  ();
};

function finalize_complex
  (uint size, uint align, owned finalize_member, pointer self) -> () {
  // Not implemented
  ();
};

#if 0
// Construct an Additive dictionary
function inline additiveDict
  (pointer repr,
   owned add, owned sub, owned negate, owned write_zero, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  typedef dictionary = AdditiveDict(bytes(value size, value align));

  ret @! dictionary.add = add;
  ret @! dictionary.subtract = sub;
  ret @! dictionary.negate = negate;
  () call write_zero (ret @ dictionary.zero);
};

function multiplicativeDict
  (pointer repr,
   owned write_additive,
   owned mul, owned from_int, owned write_one, pointer ret) -> () {
  size = repr @! PassConv.size;
  align = repr @! PassConv.align;
  typedef dictionary = MultiplicativeDict(bytes(value size, value align));

  () = () call write_additive (ret @ dictionary.additive);
  ret @! dictionary.mul = mul;
  ret @! dictionary.fromInt = from_int;
  () call write_one (ret @ dictionary.one);
};
#endif

function inline additiveDict_complex
  (pointer member_additive, pointer ret) -> ()
{
  () primcall exit (int -1);
  // FIXME
/*
  member_size = member_additive @! AdditiveDict(unit).repr.size;
  member_align = member_additive @! AdditiveDict(unit).repr.align;
  typedef member = bytes(value member_size, value member_align);
  typedef member_dict = AdditiveDict(member);

  member_copy = member_additive @! member_dict.repr.copy;
  typedef cpx = complex(member);
  typedef dictionary = AdditiveDict(cpx);

  () = () call complex_pass_conv
    (type, member_additive @ member_dict.repr, ret @ dictionary.repr);

  ret @! dictionary.add =
    owned call complex_add (member_size, member_align,
                            member_additive @! member_dict.add);
  ret @! dictionary.subtract =
    owned call complex_sub (member_size, member_align,
                            member_additive @! member_dict.subtract);
  ret @! dictionary.negate =
    owned call complex_negate (member_size, member_align,
                               member_additive @! member_dict.negate);
  () = () call member_copy (ret @ dictionary.zero.real,
                            member_additive @ member_dict.zero);
  () = () call member_copy (ret @ dictionary.zero.imag,
                            member_additive @ member_dict.zero);
  (); */
};

function inline makeComplex(float re, float im, pointer ret) -> () {
  typedef cfloa = complex (float);
  ret @! cfloa.real = re;
  ret @! cfloa.imag = im;
  ();
};

function inline complex_add(uint size, uint align, owned member_add,
                     pointer x, pointer y, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_add (x @ cpx.real, y @ cpx.real, ret @ cpx.real);
  () call member_add (x @ cpx.imag, y @ cpx.imag, ret @ cpx.imag);
};

function inline complex_sub(uint size, uint align, owned member_sub,
                     pointer x, pointer y, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_sub (x @ cpx.real, y @ cpx.real, ret @ cpx.real);
  () call member_sub (x @ cpx.imag, y @ cpx.imag, ret @ cpx.imag);
};

function inline complex_negate(uint size, uint align, owned member_negate,
                        pointer x, pointer ret) -> () {
  typedef cpx = complex(bytes(value size, value align));
  () = () call member_negate (x @ cpx.real, ret @ cpx.real);
  () call member_negate (x @ cpx.imag, ret @ cpx.imag);
};

data pointer int_info = InfoTableHeader {
  TAG_CON
};