
// Given a PAP or function, get the function
procedure pap_to_function (owned obj0) -> owned {

  // Check header; is it a function?
  r = while (owned obj = obj0) (obj @! PAP(unit).papTag == null) {
    // This is a PAP; get the operator
    obj @! PAP(unit).operator;
  };
  r;
};

// Get the arity of a PAP or function
procedure inline fun_arity(owned obj) -> uint16 {
  obj_tag = obj @! PAP(unit).papTag;
  if (obj_tag == null) {
    // This is a PAP
    obj @! PAP(unit).arity;
  }
  else {
    // This is a function
    // Read from the info table
    obj_tag @! InfoTable.arity;
  };
};

// Call a PAP that includes all arguments
procedure inline call_pap(owned pap, pointer ret) -> () {
  fun = owned primcall pap_to_function(pap);
  fun_info = fun @! Function.info;
  () primcall (fun_info @! InfoTable.inexact) (pap, ret);
};

// Evaluate a PAP if it has been applied to all arguments.
// Otherwise, copy the PAP reference into 'ret'.
procedure inline eval_pap(uint16 arity, owned pap, pointer ret) -> () {
  if (arity == uint16 0) {
    () primcall call_pap(pap, ret);
  }
  else {
    !ret = pap;
    ();
  };
};

// Evaluate a PAP if it has been applied to all arguments.
// The 'ret' pointer is used as temporary storage.
// Otherwise, return the PAP.
procedure inline eval_pap_f(uint16 arity, owned pap, pointer ret) -> owned {
  if (arity == uint16 0) {
    () = () primcall call_pap(pap, ret);
    owned load ret;
  }
  else {
    pap;
  };
};

///////////////////////////////////////////////////////////////////////////////
// Apply functions.
//
// All functions apply 'obj' to 'arg', and either return a new object or
// write their return value to the given address.
procedure apply_u_f (owned obj, unit _) -> owned {
  data owned ret; // Temporary storage for return value
  !ret = null as owned;

  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(unit);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, nil };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  owned primcall eval_pap_f(arity, new_pap, ret);
};

procedure apply_u (owned obj, unit _, pointer ret) -> () {
  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(unit);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, nil };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  () primcall eval_pap(arity, new_pap, ret);
};

procedure apply_p_f (owned obj, pointer arg) -> owned {
  data owned ret; // Temporary storage for return value
  !ret = null as owned;

  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(pointer);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  owned primcall eval_pap_f(arity, new_pap, ret);
};

procedure apply_p (owned obj, pointer arg, pointer ret) -> () {
  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(pointer);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  () primcall eval_pap(arity, new_pap, ret);
};

procedure apply_o_f (owned obj, owned arg) -> owned {
  data owned ret; // Temporary storage for return value
  !ret = null as owned;

  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(owned);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  owned primcall eval_pap_f(arity, new_pap, ret);
};

procedure apply_o (owned obj, owned arg, pointer ret) -> () {
  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(owned);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  () primcall eval_pap(arity, new_pap, ret);
};

procedure apply_c_f (owned obj, cursor arg) -> owned {
  data owned ret; // Temporary storage for return value
  !ret = null as owned;

  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(cursor);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  owned primcall eval_pap_f(arity, new_pap, ret);
};

procedure apply_c (owned obj, cursor arg, pointer ret) -> () {
  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(cursor);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  () primcall eval_pap(arity, new_pap, ret);
};

procedure apply_i32_f (owned obj, int32 arg) -> owned {
  data owned ret; // Temporary storage for return value
  !ret = null as owned;

  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(int32);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  owned primcall eval_pap_f(arity, new_pap, ret);
};

procedure apply_i32 (owned obj, int32 arg, pointer ret) -> () {
  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(int32);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  () primcall eval_pap(arity, new_pap, ret);
};

procedure apply_f32_f (owned obj, float arg) -> owned {
  data owned ret; // Temporary storage for return value
  !ret = null as owned;

  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(float);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  owned primcall eval_pap_f(arity, new_pap, ret);
};

procedure apply_f32 (owned obj, float arg, pointer ret) -> () {
  arity = uint16 primcall fun_arity(obj) - uint16 1;

  // Create a new PAP
  typedef pap_type = PAP(float);
  new_pap_ptr = pointer primcall triolet_alloc (sizeof pap_type);
  !new_pap_ptr = pap_type { null as owned,  // FIXME: object header
                            null, obj, arity, arg };
  new_pap = new_pap_ptr as owned;

  // Evaluate if it's fully applied
  () primcall eval_pap(arity, new_pap, ret);
};
