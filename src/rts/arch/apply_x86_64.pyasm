
// Given a PAP or function, get the function
procedure pap_to_function (owned obj0) -> owned {

  // Check header; is it a function?
  r = while (owned obj = obj0) (obj @! PAP(unit).papTag == null) {
    // This is a PAP; get the operator
    obj @! PAP(unit).operator;
  };
  r;
};

///////////////////////////////////////////////////////////////////////////////
// Apply functions.
//
// All functions apply 'obj' to 'arg', and either return a new object or
// write their return value to the given address.
procedure apply_u_f (owned obj, unit _) -> owned {
  () = () primcall exit(int -1);
  null as owned;
};

procedure apply_u (owned obj, unit _, pointer ret) -> () {
  () primcall exit(int -1);
};

procedure apply_p_f (owned obj, pointer arg) -> owned {
  () = () primcall exit(int -1);
  null as owned;
};

procedure apply_p (owned obj, pointer arg, pointer ret) -> () {
  () primcall exit(int -1);
};

procedure apply_o_f (owned obj, owned arg) -> owned {
  () = () primcall exit(int -1);
  null as owned;
};

procedure apply_o (owned obj, owned arg, pointer ret) -> () {
  () primcall exit(int -1);
};

procedure apply_i32_f (owned obj, int32 arg) -> owned {
  () = () primcall exit(int -1);
  null as owned;
};

procedure apply_i32 (owned obj, int arg, pointer ret) -> () {
  () primcall exit(int -1);
};

procedure apply_f32_f (owned obj, float arg) -> owned {
  () = () primcall exit(int -1);
  null as owned;
};

procedure apply_f32 (owned obj, float arg, pointer ret) -> () {
  () primcall exit(int -1);
};

#if 0
procedure apply_word (owned obj, pointer arg_ref, pointer ret) -> () {
  obj_info = obj @! ObjectHeader.info;
  obj_tag = obj_info @! InfoTableHeader.tag;

  if (obj_tag == TAG_FUN) {
    arity = uint16 primcall fun_arity(obj);
    if (arity == uint16 1) {
      // Calling a function with one argument.  Call the function now.
      () primcall (obj_info @! FunInfo(value int 0).inexact) (obj, arg_ref, ret);
    }
    else if (arity == uint16 0) {
      // TODO: Handle nullary functions
      () primcall exit (int -1);
    }
    else {
      // Undersaturated application
      // Create a PAP
      typedef my_pap = PAP(value int 0);
      new_pap = owned primcall pap_new (obj, uint16 1, uint16 1);
      POINTER_ARG_GET(arg, arg_ref);
      POINTER_ARG_PUT(new_pap @ my_pap.args as pointer, arg);
      !ret = new_pap;
      ();
    };
  } else if (obj_tag == TAG_PAP) {
    // Determine PAP's arity
    arity = uint16 primcall pap_arity(obj);
    typedef my_pap = PAP(value int 0);

    // Add argument to PAP
    new_pap = owned primcall pap_grow(obj, uint16 1);
    arg_offset = (obj @! my_pap.arg_size) as uint * PAP_WORDSIZE;
    POINTER_ARG_GET(arg, arg_ref);
    POINTER_ARG_PUT(new_pap @ my_pap.args ^+ arg_offset as int, arg);

    if (new_pap @! my_pap.nargs == arity) {
      // Function is fully applied
      () primcall pap_call (new_pap, ret);
    } else {
      // Return the new PAP
      !ret = new_pap;
      ();
    };
  }
  else {
    // Invalid tag
    () primcall exit (int -1);
  };
};

// Apply a function or PAP to the unit type
procedure apply_unit (owned obj, pointer ret) -> nil {
  typedef PAPu = PAP(unit);

  obj_header = owned load obj;

  letrec {
    procedure new_PAP (uint16 arity) -> nil {
      // Create a new PAP
      new_pap = pointer primcall malloc(sizeof(PAPu) as int);
      !new_pap = PAPu {typeObject_PAP_unit, obj, nil, arity - uint16 1};
      pap = new_pap as owned;

      // if fully applied, then call it
      if (arity == uint16 1) {
        fun = owned primcall pap_to_function(obj);
        () = () primcall (fun_info
      }
      else { nil; };
    }
  };

  if (obj_header == triolet_typeObject_function) {
    fun_info = obj @! Function.info;
    arity = fun_info @! FunInfo.arity;
    if (arity == uint16 1) {
      // Calling a function with one argument.  Call the function now.
      () primcall (fun_info @! FunInfo.inexact) (obj, null, ret);
      nil;
    }
    else {
      // Undersaturated application
      // Create a PAP
      !ret = new_pap as owned;
      nil;
    }
  }
  else {
    // Determine PAP's arity
    arity = obj @! PAP(unit).arity;

    // Create a new PAP
      new_pap = pointer primcall malloc(sizeof(PAPu) as int);
      !new_pap = PAPu {typeObject_PAP_unit, obj, nil, arity - uint16 1};
      !ret = new_pap as owned;
    typedef my_pap = PAP(value int 0);

    // Add argument to PAP
    new_pap = owned primcall pap_grow(obj, uint16 1);

    if (new_pap @! my_pap.nargs == arity) {
      // Function is fully applied
      () primcall pap_call (new_pap, ret);
    } else {
      // Return the new PAP
      !ret = new_pap;
      ();
    };
  }
  else {
    // Invalid tag
    () primcall exit (int -1);
  };
};
#endif