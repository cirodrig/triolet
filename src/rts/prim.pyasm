
module pyon.internal.prim;

#include "rts.h"
#include "memory_py.h"
#include "apply_py.h"
#include "prim.h"
#include "debug.h"

import procedure exit (int) -> ();

#include "new_pyasm_records.h"

procedure inline finite_IndInt (int n) -> IndInt {
  IndInt {FINITE, IndIntData {FinIndInt {n}}};
};

procedure inline from_finite_IndInt (IndInt ii) -> int {
  IndInt {tag, IndIntData {FinIndInt {n}}} = ii;
  if (tag == FINITE) { n; } else { () = () primcall exit (int -1); int 0; };
};

// Allocate some memory.  Use the flag to determine what kind of allocation.
procedure inline allocate (bool is_pointerless, uint size) -> pointer {
  if (is_pointerless) {
    pointer primcall pyon_alloc_nopointers (size);
  } else {
    pointer primcall pyon_alloc (size);
  };
};

function inline convertToBoxed (owned repr, owned writer) -> owned {
  owned call (repr @! PassConv.convert_to_boxed) (writer);
};

function inline convertToBare (owned repr, owned src, pointer dst) -> () {
  () call (repr @! PassConv.convert_to_bare) (src, dst);
};

// Since a partially applied instance of this function may be used to
// initialize a Repr object, we pass the fields of the Repr instead of passing
// the Repr.
function inline make_Boxed (uint size, uint align, owned writer) -> owned {
  typedef elt_type = bytes(value size, value align);
  typedef boxed_type = Boxed(elt_type);

  p = pointer primcall pyon_alloc (sizeof boxed_type);

  // TODO: initialize object Header
  () = () primcall pyon_db_pointer (writer as pointer);
  () = () call writer (p @ boxed_type.member);
  p as owned;
};

// Since a partially applied instance of this function may be used to
// initialize a Repr object, we pass the fields of the Repr instead of passing
// the Repr.
function inline from_Boxed (uint size, uint align, owned copy, owned boxed, pointer dst) -> () {
  typedef elt_type = bytes(value size, value align);
  typedef boxed_type = Boxed(elt_type);

  () call (copy) (boxed @ boxed_type.member, dst);
};

function inline make_Boxed_0 (owned writer) -> owned {
  p = pointer primcall pyon_alloc (sizeof Boxed(unit));

  // FIXME: initialize object header
  () = () call writer (p @ Boxed(unit).member);
  p as owned;
};

function inline make_Boxed_1 (owned writer) -> owned {
  p = pointer primcall pyon_alloc (sizeof Boxed(bytes(value uint 1, value uint 1)));

  // FIXME: initialize object header
  () = () call writer (p @ Boxed(unit).member);
  p as owned;
};

function inline make_Boxed_4 (owned writer) -> owned {
  p = pointer primcall pyon_alloc (sizeof Boxed(bytes(value uint 4, value uint 4)));

  // FIXME: initialize object header
  () = () call writer (p @ Boxed(unit).member);
  p as owned;
};

function inline from_Boxed_0 (owned src, pointer dst) -> () {
  (); // Do nothing
};

function inline from_Boxed_1 (owned src, pointer dst) -> () {
  !dst = src @! Boxed(uint8).member;
  ();
};

function inline from_Boxed_4 (owned src, pointer dst) -> () {
  !dst = src @! Boxed(uint32).member;
  ();
};

function inline storeBox (owned arg, pointer dst) -> () {
  !dst = arg;
  ();
};

function inline loadBox (pointer src) -> owned {
  owned load src;
};

function inline ptrToBox (pointer ptr) -> owned {
  ptr as owned;
};

function inline boxToPtr (owned box) -> pointer {
  box as pointer;
};

function eq_int (int x, int y) -> bool {
  x == y;
};

function ne_int (int x, int y) -> bool {
  x != y;
};

function lt_int (int x, int y) -> bool {
  x < y;
};

function le_int (int x, int y) -> bool {
  x <= y;
};

function gt_int (int x, int y) -> bool {
  x > y;
};

function ge_int (int x, int y) -> bool {
  x >= y;
};

function eq_float (float x, float y) -> bool {
  x == y;
};

function ne_float (float x, float y) -> bool {
  x != y;
};

function lt_float (float x, float y) -> bool {
  x < y;
};

function le_float (float x, float y) -> bool {
  x <= y;
};

function gt_float (float x, float y) -> bool {
  x > y;
};

function ge_float (float x, float y) -> bool {
  x >= y;
};

function negate_int (int x) -> int {
  int 0 - x;
};

function floordiv_int(int x, int y) -> int {
  x %/ y;
};

function mod_int(int x, int y) -> int {
  x % y;
};

function negate_float (float x) -> float {
  float 0.0 - x;
};

function fromint_float(int x) -> float {
  x as float;
};

function floordiv_float(float x, float y) -> int {
  x %/ y;
};

function mod_float(float x, float y) -> float {
  x % y;
};

function div_float(float x, float y) -> float {
  x / y;
};

// Interpret an int as a size index
function inline defineIntIndex (int n) -> SomeIndInt {
  SomeIndInt {FinIndInt {n}};
};

// Get a pointer to an array element
function inline subscript
 (owned repr, pointer base, int index) -> pointer {
   typedef elt_type = bytes(value repr @! PassConv.size,
                            value repr @! PassConv.align);
   base @ const_array(value int 0, elt_type)[index];
};

// Get a pointer to an array element.  Exactly the same as 'subscript'.
function inline subscript_out
 (owned repr, pointer base, int index) -> pointer {
   typedef elt_type = bytes(value repr @! PassConv.size,
                            value repr @! PassConv.align);
   base @ const_array(value int 0, elt_type)[index];
};

function inline min_ii (IndInt x, IndInt y) -> IndInt {
  IndInt {x_fin, IndIntData {FinIndInt {x_data}}} = x;
  IndInt {y_fin, IndIntData {FinIndInt {y_data}}} = y;

  if      (x_fin == POSINFTY || y_fin == NEGINFTY) { y; }
  else if (x_fin == NEGINFTY || y_fin == POSINFTY) { x; }
  else if (x_data < y_data) { IndInt primcall finite_IndInt(x_data); }
  else { IndInt primcall finite_IndInt(y_data); };
};

function inline minus_ii (IndInt x, IndInt y) -> IndInt {
  IndInt {x_fin, IndIntData {FinIndInt {x_data}}} = x;
  IndInt {y_fin, IndIntData {FinIndInt {y_data}}} = y;

  if (x_fin == POSINFTY) {
    if (y_fin == POSINFTY) {
      () = () primcall exit (int -1);
      x;
    } else {
      x;
    };
  }
  else if (x_fin == NEGINFTY) {
    if (y_fin == NEGINFTY) {
      () = () primcall exit (int -1);
      x;
    } else {
      x;
    };
  }
  else {
    // Finite case
    IndInt primcall finite_IndInt(x_data - y_data);
  };
};

function inline doall (FinIndInt ix, owned f) -> () {
  FinIndInt {count} = ix;
  _ = while (int n = int 0) (n < count) {
    () = () call f (n);
    n + int 1;
  };
  ();
};

function inline for
  (owned acc_repr, IndInt ix, pointer init, owned f, pointer ret) -> () {
  count = int primcall from_finite_IndInt(ix);
  // The for loop has an 'input' and an 'output' accumulator, and swaps
  // between them.
  acc_size = acc_repr @! PassConv.size;
  acc_align = acc_repr @! PassConv.align;
  acc_copy = acc_repr @! PassConv.copy;
  acc_finalize = acc_repr @! PassConv.finalize;
  typedef acc_type = bytes(value acc_size, value acc_align);
  typedef acc_pair = Pair(acc_type);

  // Setup
  accs = pointer primcall allocate (acc_repr @! PassConv.is_pointerless,
       	 	 	  	    sizeof acc_pair);
  () = () call acc_copy (init, accs @ acc_pair.fst);

  // Main loop.
  // At start, old_acc holds accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  // At termination, old_acc holds final accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  (_, final_acc, clear_acc) =
    while (int n = int 0,
           pointer old_acc = accs @ acc_pair.fst,
           pointer new_acc = accs @ acc_pair.snd)
          (n < count) {
    () = () call f (n, old_acc, new_acc);
    () = () call acc_finalize (old_acc);
    (n + int 1, new_acc, old_acc);
  };
  
  // Cleanup
  () = () call acc_copy (final_acc, ret);
  () = () call acc_finalize (final_acc);
  () = () primcall pyon_dealloc (accs);
  ();
};

// A parallel reduction.  The iteration space is partitioned at run time
// and 'generator' is called on a single member of the iteration space.
function blocked_reduce
  (owned acc_repr, FinIndInt size, int first,
   owned reducer, pointer init, owned generator, pointer ret) -> ()
{
  FinIndInt {count} = size;
  acc_size = acc_repr @! PassConv.size;
  acc_is_pointerless = acc_repr @! PassConv.is_pointerless;

  letrec {
    // Given the current accumulator value and the range to process,
    // compute and accumulate the reduction value over this range.
    function accumulate_range
      (pointer old_value, int lcount, int lfirst) -> pointer {
      // Reduce over this range
      local_value = pointer primcall allocate (acc_is_pointerless, acc_size);
      lsize = FinIndInt {lcount};
      () = () call generator (lsize, lfirst, local_value);

      // Accumulate with old value
      ret = pointer primcall allocate (acc_is_pointerless, acc_size);
      () = () call reducer (old_value, local_value, ret);
      () = () call (acc_repr @! PassConv.finalize) (local_value);
      ret;
    };

    // Out-of-place reducer
    function oop_reducer (pointer x, pointer y) -> pointer {
      ret = pointer primcall allocate (acc_is_pointerless, acc_size);
      () = () call reducer (x, y, ret);
      ret;
    }
  };

  // Main computation is written in C++
  final_value = pointer primcall pyon_C_blocked_reduce
    (acc_repr @! PassConv.copy, accumulate_range, oop_reducer,
     init, count, first);

  // Copy into the output
  () call (acc_repr @! PassConv.copy) (final_value, ret);
};

// A parallel reduction with no neutral element.
// The iteration space is partitioned at run time
// and 'generator' is called on a single member of the iteration space.
//
// We inject a distinguished pointer into the space of valid values for this
// data type.  That pointer serves as the neutral element, so that we can use
// the same parallel function as a regular reduction.
//
// TODO: Keep track of objects so we can deallocate them properly
function blocked_reduce1
  (owned acc_repr, FinIndInt size, int first,
   owned reducer, owned generator, pointer ret) -> ()
{
  // We use the address of this data as the neutral element of the reduction.
  // The data is never accessed.
  data int64 uninitialized_value;
 
  FinIndInt {count} = size;
  acc_size = acc_repr @! PassConv.size;
  acc_is_pointerless = acc_repr @! PassConv.is_pointerless;

  letrec {
    // Given the current accumulator value and the range to process,
    // compute and accumulate the reduction value over this range.
    function accumulate_range
        (pointer old_value, int lcount, int lfirst) -> pointer {
      lsize = FinIndInt {lcount};

      if (old_value == uninitialized_value) {
        // Reduce over this range and return the output directly
        local_value = pointer primcall allocate (acc_is_pointerless, acc_size);
        () = () call generator (lsize, lfirst, local_value);
        local_value;
      } else {
        local_value = pointer primcall allocate (acc_is_pointerless, acc_size);
        () = () call generator (lsize, lfirst, local_value);

        // Accumulate into output
        ret_value = pointer primcall allocate (acc_is_pointerless, acc_size);
        () = () call reducer (old_value, local_value, ret_value);

        () = () call (acc_repr @! PassConv.finalize) (local_value);
        ret_value;
      };
    };

    // Combine two extended values.  At least one must not be the neutral
    // element.
    function join_values (pointer x, pointer y) -> pointer {
      if (x == uninitialized_value) {
        if (y == uninitialized_value) {
          uninitialized_value;
        } else {
          y;
        };
      } else {
        if (y == uninitialized_value) {
          x;
        } else {
          ret_value = pointer primcall allocate (acc_is_pointerless, acc_size);
          () = () call reducer (x, y, ret_value);
          ret_value;
        };
      };
    }
  };

  // Main computation is written in C++
  final_val = pointer primcall pyon_C_blocked_reduce
    (acc_repr @! PassConv.copy, accumulate_range, join_values,
     uninitialized_value, count, first);

  () call (acc_repr @! PassConv.copy) (final_val, ret);
};

// Called from the C side of 'blocked_reduce'
procedure blocked_reduce_copy (owned f, pointer src, pointer dst) -> () {
  () call f (src, dst);
};

procedure blocked_reduce_accumulate_range
  (owned f, pointer init, int count, int first) -> pointer {
  pointer call f (init, count, first);
};

procedure blocked_reduce_reducer
  (owned f, pointer x, pointer y) -> pointer {
  pointer call f (x, y);
};

function inline blocked_doall
  (FinIndInt size, int first, owned worker) -> () {
  FinIndInt {count} = size;

  () primcall pyon_C_blocked_doall (worker, count, first);
};

procedure blocked_doall_worker (owned f, int count, int first) -> () {
  () call f (FinIndInt {count}, first);
};
