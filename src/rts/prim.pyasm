
module pyon.internal.prim;

#include "rts.h"
#include "memory_py.h"
#include "apply_py.h"
#include "prim.h"
#include "debug.h"
#include "new_pyasm_records.h"

function inline storeBox (unit _, owned arg, pointer dst) -> () {
  !dst = arg;
  ();
};

function inline loadBox (unit _, pointer src) -> owned {
  owned load src;
};

function inline ptrToBox (unit _, pointer ptr) -> owned {
  ptr as owned;
};

function inline boxToPtr (unit _, owned box) -> pointer {
  box as pointer;
};

function eq_int (int x, int y) -> bool {
  x == y;
};

function ne_int (int x, int y) -> bool {
  x != y;
};

function lt_int (int x, int y) -> bool {
  x < y;
};

function le_int (int x, int y) -> bool {
  x <= y;
};

function gt_int (int x, int y) -> bool {
  x > y;
};

function ge_int (int x, int y) -> bool {
  x >= y;
};

function eq_float (float x, float y) -> bool {
  x == y;
};

function ne_float (float x, float y) -> bool {
  x != y;
};

function lt_float (float x, float y) -> bool {
  x < y;
};

function le_float (float x, float y) -> bool {
  x <= y;
};

function gt_float (float x, float y) -> bool {
  x > y;
};

function ge_float (float x, float y) -> bool {
  x >= y;
};

function negate_int (int x) -> int {
  int 0 - x;
};

function floordiv_int(int x, int y) -> int {
  x %/ y;
};

function mod_int(int x, int y) -> int {
  x % y;
};

function negate_float (float x) -> float {
  float 0.0 - x;
};

function fromint_float(int x) -> float {
  x as float;
};

function floordiv_float(float x, float y) -> int {
  x %/ y;
};

function mod_float(float x, float y) -> float {
  x % y;
};

function div_float(float x, float y) -> float {
  x / y;
};

// Interpret an int as a size index
function inline defineIntIndex (int n) -> SomeIndexedInt {
  SomeIndexedInt {IndexedInt {n}};
};

// Get a pointer to an array element
function inline subscript
 (unit _, unit _, owned repr, pointer base, int index) -> pointer {
   typedef elt_type = bytes(value repr @! PassConv.size,
                            value repr @! PassConv.align);
   base @ const_array(value int 0, elt_type)[index];
};

// Get a pointer to an array element.  Exactly the same as 'subscript'.
function inline subscript_out
 (unit _, unit _, owned repr, pointer base, int index) -> pointer {
   typedef elt_type = bytes(value repr @! PassConv.size,
                            value repr @! PassConv.align);
   base @ const_array(value int 0, elt_type)[index];
};

function inline doall (unit _, unit _, unit _, IndexedInt ix, owned f) -> () {
  IndexedInt {count} = ix;
  _ = while (int n = int 0) (n < count) {
    () = () call f (n);
    n + int 1;
  };
  ();
};

function inline for
  (unit _, unit _,
   owned acc_repr, IndexedInt ix, pointer init, owned f, pointer ret) -> () {
  IndexedInt {count} = ix;

  // The for loop has an 'input' and an 'output' accumulator, and swaps
  // between them.
  acc_size = acc_repr @! PassConv.size;
  acc_align = acc_repr @! PassConv.align;
  acc_copy = acc_repr @! PassConv.copy;
  acc_finalize = acc_repr @! PassConv.finalize;
  typedef acc_type = bytes(value acc_size, value acc_align);
  typedef acc_pair = Pair(acc_type);

  // Setup
  accs = pointer primcall pyon_alloc (sizeof acc_pair);
  () = () call acc_copy (init, accs @ acc_pair.fst);

  // Main loop.
  // At start, old_acc holds accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  // At termination, old_acc holds final accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  (_, final_acc, clear_acc) =
    while (int n = int 0,
           pointer old_acc = accs @ acc_pair.fst,
           pointer new_acc = accs @ acc_pair.snd)
          (n < count) {
    () = () call f (n, old_acc, new_acc);
    () = () call acc_finalize (old_acc);
    (n + int 1, new_acc, old_acc);
  };
  
  // Cleanup
  () = () call acc_copy (final_acc, ret);
  () = () call acc_finalize (final_acc);
  () = () primcall pyon_dealloc (accs);
  ();
};

// A parallel reduction.  The iteration space is partitioned at run time
// and 'generator' is called on a single member of the iteration space.
function inline blocked_reduce
  (unit _, unit _, owned acc_repr, IndexedInt size, int first,
   owned reducer, pointer init, owned generator, pointer ret) -> ()
{
  IndexedInt {count} = size;
  acc_size = acc_repr @! PassConv.size;

  letrec {
    // Allocate memory for an accumulator value
    function allocate_mem (int _) -> pointer {
      pointer primcall pyon_alloc (acc_size);
    };

    // Get a copy of the initial value
    function get_initial_value (pointer ret) -> () {
      () call (acc_repr @! PassConv.copy) (init, ret);
    };

    // Given the current accumulator value and the range to process,
    // compute and accumulate the reduction value over this range.
    function accumulate_range (pointer old_value, int lcount, int lfirst, pointer ret) -> () {
      // Reduce over this range
      local_value = pointer primcall pyon_alloc (acc_repr @! PassConv.size);
      lsize = IndexedInt {lcount};
      () = () call generator (nil, lsize, lfirst, local_value);

      // Accumulate into output
      () = () call reducer (old_value, local_value, ret);

      () = () call (acc_repr @! PassConv.finalize) (local_value);
      () = () call (acc_repr @! PassConv.finalize) (old_value);
      ();
    }
  };

  // Main computation is written in C++
  () primcall pyon_C_blocked_reduce(allocate_mem,
                                    get_initial_value,
                                    accumulate_range,
                                    reducer,
                                    count, first, ret);
};

// Called from the C side of 'blocked_reduce'
procedure blocked_reduce_allocate (owned f) -> pointer {
  pointer call f (int 0);
};

// Called from the C side of 'blocked_reduce'
procedure blocked_reduce_initial_value (owned f, pointer ret) -> () {
  () call f (ret);
};

procedure blocked_reduce_accumulate_range
  (owned f, pointer init, int count, int first, pointer ret) -> () {
  () call f (init, count, first, ret);
};

procedure blocked_reduce_reducer
  (owned f, pointer x, pointer y, pointer ret) -> () {
  () call f (x, y, ret);
};