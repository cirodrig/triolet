
module pyon.internal.apply_new;

#include "rts.h"
#include "memory_py.h"
#include "debug.h"

import procedure exit (int) -> (); 
import data pointer pyon_type_tag_pap_size "pyon_type_tag_pap_size";

extern data pointer pyon.internal.apply_new.PAP_info;

extern procedure pyon.internal.apply_new.apply_i64_f(owned, int64) -> owned;
extern procedure pyon.internal.apply_new.apply_i64(owned, int64, pointer) -> ();

extern procedure pyon.internal.apply_new.apply_i32_f(owned, int32) -> owned;
extern procedure pyon.internal.apply_new.apply_i32(owned, int32, pointer) -> ();

extern procedure pyon.internal.apply_new.apply_f32_f(owned, float) -> owned;
extern procedure pyon.internal.apply_new.apply_f32(owned, float, pointer) -> ();

#include "new_pyasm_records.h"

#if defined(ARCH_X86)
# include "arch/apply_x86.h"
#elif defined(ARCH_X86_64)
# include "arch/apply_x86_64.h"
#else
# error "Unrecognized architecture"
#endif

///////////////////////////////////////////////////////////////////////////////

data pointer PAP_info = InfoTableHeader {dummy_finalizer, TAG_PAP};

// Look up the size (in words) of one of a PAP's arguments.
procedure pap_argument_size(int index, pointer type_tags) -> uint16 {
  typedef type_arr = const_array(value int 0, uint8);
  typedef size_arr = const_array(value int 0, uint8);
  // Look up the type tag
  type_tag = type_tags @! size_arr[index];
  // Look up the size of this type tag
  (pyon_type_tag_pap_size @! type_arr[type_tag as int]) as uint16;
};

// Compute the size of a PAP's argument block.
// Add up the sizes of the first nargs arguments, using the type tags to
// determine sizes.
// The return value is a number of PAP_WORDSIZE words.
procedure pap_arguments_size (int nargs, pointer type_tags) -> uint16 {
  typedef size_arr = const_array(value int 0, uint8);
  (_, _, size) = while (int count = nargs,
      	       	        pointer type_tags = type_tags,
			word size = word 0)
		       (count != int 0) {
    type_tag = uint8 load type_tags;
    arg_size = pyon_type_tag_pap_size @! size_arr[type_tag as int];
    (count - int 1,
     type_tags ^+ sizeof uint8 as int,
     size + arg_size as word);
  };
  size;
};

// Create a new PAP with the given number of arguments and argument size.
// The argument size is a number of PAP_WORDSIZE words.
// Return a pointer to the PAP itself.
// Its argument block isn't initialized.
procedure pap_new (owned fun, uint16 nargs, uint16 arg_size) -> owned {
  typedef my_pap = PAP(value arg_size as word * PAP_WORDSIZE);
  obj = pointer primcall pyon_alloc(sizeof my_pap);
  obj @! my_pap.header.refct = word 1;
  obj @! my_pap.header.info = PAP_info;
  obj @! my_pap.fun = fun;
  obj @! my_pap.nargs = nargs;
  obj @! my_pap.arg_size = arg_size;
  obj as owned;
};
// Create a new PAP, and initialize it from the contents of an existing PAP.
// The new PAP will have more arguments than the old one.
// The new arguments are uninitialized.
// Returns the new PAP.
procedure pap_grow(owned pap, uint16 n_new_args) -> owned {
  typedef old_pap_t = PAP(value word 0);
  fun = pap @! old_pap_t.fun;
  fun_info = fun @! ObjectHeader.info;
  n_old_args = pap @! old_pap_t.nargs;
  old_arg_size = pap @! old_pap_t.arg_size;

  // Compute size of new arguments
  new_arities = fun_info @ FunInfo(value int 0).arg_types[n_old_args as int];
  extra_arg_size = uint16 primcall pap_arguments_size (n_new_args, new_arities);
  new_arg_size = old_arg_size + extra_arg_size;

  // Allocate new PAP
  new_pap = owned primcall pap_new
    (fun, n_old_args + n_new_args, new_arg_size);

  // Initialize arguments that were in the old PAP
  () = () primcall memcpy (new_pap @ old_pap_t.args, pap @ old_pap_t.args,
                           (old_arg_size * PAP_WORDSIZE) as int);
  new_pap;
};

// Call a PAP.  The PAP must contain a number of arguments equal to the
// function arity.
// The function's indirect entry point is called.
procedure pap_call(owned pap, pointer ret) -> () {
  typedef my_pap = PAP(value word 0);
  fun = pap @! my_pap.fun;
  fun_info = fun @! ObjectHeader.info;
  args = pap @ my_pap.args;
  () primcall (fun_info @! FunInfo(value int 0).inexact) (fun, args, ret);
};

procedure inline fun_arity(owned f) -> uint16 {
  info = f @! ObjectHeader.info;
  info @! FunInfo(value int 0).arity;
};

procedure inline pap_arity(owned p) -> uint16 {
  uint16 primcall fun_arity (p @! PAP(value int 0).fun);
};


#if defined(ARCH_X86)
# include "arch/apply_x86.pyasm"
#elif defined(ARCH_X86_64)
# include "arch/apply_x86_64.pyasm"
#else
# error "Unrecognized architecture"
#endif
