
module pyon.internal.apply_new;

#include "rts.h"
#include "memory_py.h"
#include "debug.h"

import procedure exit (int) -> (); 
import data pointer pyon_type_tag_pap_size "pyon_type_tag_pap_size";

extern data pointer pyon.internal.apply_new.PAP_info;

#include "apply_py.h"

#include "new_pyasm_records.h"

// The word size.  Partially applied data is organized as words.
#define PAP_WORDSIZE (uint WORD_SIZE)

// For each data type that is handled by an 'apply' function, we define
// the data type's size, how to write it to memory at an address, and how
// to read it from memory into a variable.
#define POINTER_ARG_PUT(dst_addr, src) !(dst_addr) = (src)
#define POINTER_ARG_GET(dst_var, src) dst_var = pointer load (src)

// A partial application.  The argument is the size of the argument space
// in bytes.
//
// This is not arch-specific
record PAP(argsz) {
  const ObjectHeader header;		// Object header
  const owned fun;			// Partially applied function
  const uint16 nargs;                 // Number of arguments stored in PAP
  const uint16 arg_size;	      // Size of arguments in words
  const bytes(value argsz, value PAP_WORDSIZE) args; // Argument data
};

///////////////////////////////////////////////////////////////////////////////

data pointer PAP_info = InfoTableHeader {dummy_finalizer, TAG_PAP};

// Look up the size (in words) of one of a PAP's arguments.
procedure pap_argument_size(int index, pointer type_tags) -> uint16 {
  typedef type_arr = const_array(value int 0, uint8);
  typedef size_arr = const_array(value int 0, uint8);
  // Look up the type tag
  type_tag = type_tags @! size_arr[index];
  // Look up the size of this type tag
  (pyon_type_tag_pap_size @! type_arr[type_tag as int]) as uint16;
};

// Compute the size of a PAP's argument block.
// Add up the sizes of the first nargs arguments, using the type tags to
// determine sizes.
// The return value is a number of PAP_WORDSIZE words.
procedure pap_arguments_size (uint16 nargs, pointer type_tags) -> uint16 {
  typedef size_arr = const_array(value int 0, uint8);
  (_, _, size) = while (int count = nargs as int,
      	       	        pointer type_tags = type_tags,
			uint size = uint 0)
		       (count != int 0) {
    type_tag = uint8 load type_tags;
    arg_size = pyon_type_tag_pap_size @! size_arr[type_tag as int];
    (count - int 1,
     type_tags ^+ sizeof uint8 as int,
     size + arg_size as uint);
  };
  size;
};

// Create a new PAP with the given number of arguments and argument size.
// The argument size is a number of PAP_WORDSIZE words.
// Return a pointer to the PAP itself.
// Its argument block isn't initialized.
procedure pap_new (owned fun, uint16 nargs, uint16 arg_size) -> owned {
  typedef my_pap = PAP(value arg_size as uint * PAP_WORDSIZE);
  obj = pointer primcall pyon_alloc(sizeof my_pap);
  obj @! my_pap.header.refct = int 1;
  obj @! my_pap.header.info = PAP_info;
  obj @! my_pap.fun = fun;
  obj @! my_pap.nargs = nargs;
  obj @! my_pap.arg_size = arg_size;
  obj as owned;
};
// Create a new PAP, and initialize it from the contents of an existing PAP.
// The new PAP will have more arguments than the old one.
// The new arguments are uninitialized.
// Returns the new PAP.
procedure pap_grow(owned pap, uint16 n_new_args) -> owned {
  typedef old_pap_t = PAP(value int 0);
  fun = pap @! old_pap_t.fun;
  fun_info = fun @! ObjectHeader.info;
  n_old_args = pap @! old_pap_t.nargs;
  old_arg_size = pap @! old_pap_t.arg_size;

  // Compute size of new arguments
  new_arities = fun_info @ FunInfo(value int 0).arg_types[n_old_args as int];
  extra_arg_size = uint16 primcall pap_arguments_size (n_new_args, new_arities);
  new_arg_size = old_arg_size + extra_arg_size;

  // Allocate new PAP
  new_pap = owned primcall pap_new
    (fun, n_old_args + n_new_args, new_arg_size);

  // Initialize arguments that were in the old PAP
  () = () primcall memcpy (new_pap @ old_pap_t.args, pap @ old_pap_t.args,
                           old_arg_size as int * PAP_WORDSIZE as int);
  new_pap;
};

// Call a PAP.  The PAP must contain a number of arguments equal to the
// function arity.
// The function's indirect entry point is called.
procedure pap_call(owned pap, pointer ret) -> () {
  typedef my_pap = PAP(value int 0);
  fun = pap @! my_pap.fun;
  fun_info = fun @! ObjectHeader.info;
  args = pap @ my_pap.args;
  () primcall (fun_info @! FunInfo(value int 0).inexact) (fun, args, ret);
};

procedure inline fun_arity(owned f) -> uint16 {
  info = f @! ObjectHeader.info;
  info @! FunInfo(value int 0).arity;
};

procedure inline pap_arity(owned p) -> uint16 {
  uint16 primcall fun_arity (p @! PAP(value int 0).fun);
};

#if WORD_SIZE == 4
# include "arch/apply_x86.pyasm"
#elif WORD_SIZE == 8
# include "arch/apply_x86_64.pyasm"
#else
# error "Unrecognized architecture"
#endif
