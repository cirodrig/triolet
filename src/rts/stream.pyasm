
module pyon.internal.stream;

#include "rts.h"
#include "debug.h"
#include "apply_py.h"
#include "memory_py.h"
#include "structures.h"
#include "stream.h"

import procedure exit (pointer, pointer) -> ();

#include "new_pyasm_records.h"

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  dummy_finalizer,
  TAG_CON
};

procedure inline Stream_alloc () -> owned {
  s = pointer primcall pyon_alloc (sizeof Stream);
  // FIXME: initialize header
  s @! Stream.header.info = Stream_info;
  s as owned;
};

// Traverse a stream.  Simply return the stream.
function inline Stream_traverse (unit _, unit _, owned _, owned stream) -> owned {
  stream;
};

// Build a stream.  Simply return the stream.
function inline Stream_build (unit _, unit _, owned _, owned stream) -> owned {
  stream;
};

/*****************************************************************************/
/* return */
// A 'return' stream produces one value, then quits.  The value is produced
// by calling a function.
//
// The stream state is a bool, whose value says whether the stream's single
// output has been produced yet.
//   true  -> depleted
//   false -> value is available

// Create a stream that produces a single value
function inline Stream_return (unit _,
                        owned return_type_repr,
                        owned produce_value) -> owned {
  s = owned primcall Stream_alloc();
  s @! Stream.next = owned call Stream_return_next(produce_value);
  s @! Stream.initialize = Stream_return_initialize;
  s @! Stream.state_size = sizeof bool;
  s @! Stream.state_align = alignof bool;
  s @! Stream.state_finalize = dummy_finalizer; // It's plain old data
  s;
};

function inline Stream_return_next (owned produce_value,
                             pointer state,
                             pointer ret) -> bool {
  if (bool load state) {
    // Stream is depleted
    false;
  } else {
    // Stream has data
    !state = true;      // Remember that value was produced
    () = () call produce_value (ret);
    true;
  };
};

function inline Stream_return_initialize(pointer state) -> () {
  !state = false;
  ();
};

/*****************************************************************************/
/* bind */

// A bound stream consists of a producer stream and a consumer function that
// returns a stream.  The consumer transforms every element returned by the
// producer.
//
// The state of a bound stream consists of:
//  1. The current transformer stream, or NULL.
//     If non-null, the next value is pulled from this stream.  Otherwise,
//     We need to pull from the producer and create a new transformer stream.
//  2. A pointer to the current transformer stream's state, or NULL.
//  3. The producer stream's current output value.  This value
//     may be referenced by the transformer stream.  It's garbage if the
//     transformer stream is NULL.
//  4. The producer stream's state.
record Stream_bind_state(pstateT, presultT) {
  pointer tf;                   // Transformer stream (owned or NULL)
  pointer tf_state;             // Transformer stream's state
                                // (if transformer stream is not NULL)
  presultT pr_result;           // Producer's current output value
                                // (if transformer stream is not NULL)
  pstateT pr_state;             // Producer's state
};

// Chain streams together.
function inline Stream_bind (unit _, unit _,
                      owned pr_repr,   // Produced type representation
                      owned tf_repr,   // Transformed type representation
                      owned pr,        // Producer stream
                      owned tf)        // Transformer stream
    -> owned {
  pr_state_size = pr @! Stream.state_size;
  pr_state_align = pr @! Stream.state_align;
  pr_result_size = pr_repr @! PassConv.size;
  pr_result_align = pr_repr @! PassConv.align;
  typedef pr_state_type = bytes(value pr_state_size, value pr_state_align);
  typedef pr_result_type = bytes(value pr_result_size, value pr_result_align);
  typedef state_type = Stream_bind_state(pr_state_type, pr_result_type);

  s = owned primcall Stream_alloc ();

  letrec {
    function initialize (pointer state) -> () {
      // Initialize a bound stream.
      // Initialize the producer's state and clear the transformer's state.
      state @! state_type.tf = null;
      state @! state_type.tf_state = null;
      // pr_result is uninitialized
      () call (pr @! Stream.initialize) (state @ state_type.pr_state);
    }
  };

  s @! Stream.initialize = initialize;

  letrec {
    function next (pointer state, pointer out) -> bool {
      // Get a new value from the stream.
      letrec {
        // Try getting a value from the producer, then creating a transformer.
        procedure pull_from_producer () -> bool {
          pr_has_data = bool call (pr @! Stream.next)
            (state @ state_type.pr_state, state @ state_type.pr_result);
          if (pr_has_data) {
            // Create a new transformer stream
            tf_owned = owned call tf (state @ state_type.pr_result);

            // Initialize the transformer stream
            state @! state_type.tf = tf_owned as pointer;
            tf_state = pointer primcall pyon_alloc
              (tf_owned @! Stream.state_size);
            () = () call (tf_owned @! Stream.initialize) (tf_state);
            state @! state_type.tf_state = tf_state;
            
            // Pull from the transformer stream
            bool primcall pull_from_transformer ();
          } else {
            // Stream is depleted
            false;
          };
        }; // end pull_from_producer

        // Try getting the value from the transformer.
        procedure pull_from_transformer () -> bool {
          // Is there an active transformer stream?
          tf_stream = state @! state_type.tf;
          if (tf_stream == null) {
            // Create a new one
            bool primcall pull_from_producer ();
          } else {
            // Try to get a value from the current transformer object.
            // If that fails, try to get a new value from the producer object.
            tf_owned = tf_stream as owned;
            tf_state = state @! state_type.tf_state;
            tf_has_data = bool call (tf_owned @! Stream.next) (tf_state, out);
            if (tf_has_data) {
              true;
            } else {
              // Clean up transformer
              () = () call (tf_owned @! Stream.state_finalize) (tf_state);
              () = () primcall pyon_dealloc (tf_state);
              state @! state_type.tf = null;

              // Clean up the produced value
              () = () call (pr_repr @! PassConv.finalize)
                (state @ state_type.pr_result);

              // Get a new value from the producer, then retry
              bool primcall pull_from_producer ();
            };
          };
        } // end pull_from_transformer
      }; // end letrec
      bool primcall pull_from_transformer();
    } // end next
  }; // end letrec

  s @! Stream.next = next;
  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

/*****************************************************************************/
/* reinterpret a stream's domain as the list domain */

function inline Stream_asList (unit _, unit _, owned stream) -> owned {
  stream;
};

/*****************************************************************************/
/* generate */

// A stream consisting of the sequence f(0), f(1), ... f(limit-1).
// The stream state holds the next value to generate.
function Stream_generate
  (unit _, unit _, owned ret_repr, int limit, owned f) -> owned {
  s = owned primcall Stream_alloc();

  s @! Stream.initialize = Stream_generate_initialize;

  letrec {
    function next (pointer state, pointer ret) -> bool {
      // Get the current counter value
      n = int load state;
      if (n >= limit) {
        // Stream is depleted
        false;
      } else {
        // Update the counter
        !state = n + int 1;

        // Produce a value
        () = () call f (n, ret);
        true;
      };
    }
  };
  s @! Stream.next = next;
  s @! Stream.state_size = sizeof int;
  s @! Stream.state_align = alignof int;
  s @! Stream.state_finalize = dummy_finalizer; // It's plain old data 
  s;
};

function Stream_generate_initialize (pointer state) -> () {
  !state = int 0;
  ();
};

/*****************************************************************************/
/* map */

// State of Stream_map.
// The state consists of the produced value's representation and temporary
// storage for the produced value.
record Stream_map_state(pstateT, presultT) {
  pstateT pr_state;             // State of producer stream
  presultT pr_result;           // Holds output of producer
};

function Stream_map
  (unit _, unit _, unit _,
   owned pr_repr,               // Representation of a produced value
   owned tf_repr,               // Representation of a transformed value
   owned tf,                    // Transformer function
   owned pr)                    // Producer stream
   -> owned {
  pr_state_size = pr @! Stream.state_size;
  pr_state_align = pr @! Stream.state_align;
  typedef pr_state_type = bytes (value pr_state_size, value pr_state_align);
  pr_result_size = pr_repr @! PassConv.size;
  pr_result_align = pr_repr @! PassConv.align;
  typedef pr_result_type = bytes (value pr_result_size, value pr_result_align);

  typedef state_type = Stream_map_state (pr_state_type, pr_result_type);

  s = owned primcall Stream_alloc ();

  letrec {
    function initialize (pointer state) -> () {
      () = () call (pr @! Stream.initialize) (state @ state_type.pr_state);
      // pr_result is uninitialized
      ();
    }
  };
  
  s @! Stream.initialize = initialize;

  letrec {
    function next (pointer state, pointer out) -> bool {
      // Run the producer to get a value.  Write the value into the
      // reserved memory area.
      pr_has_data = bool call (pr @! Stream.next)
        (state @ state_type.pr_state, state @ state_type.pr_result);

      if (pr_has_data) {
        // Transform the value
        () = () call tf (state @ state_type.pr_result, out);
        true;
      } else {
        false;
      };
    }
  };

  s @! Stream.next = next;

  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;
  s @! Stream.state_finalize = dummy_finalizer;
  () = () primcall pyon_db_pointer (s as pointer);
  s;
};

/*****************************************************************************/
/* reduce */

function inline Stream_reduce
  (unit _, unit _,
   owned repr_element,
   owned reducer,
   pointer init,
   owned stream,
   pointer ret) -> () {
  elem_size = repr_element @! PassConv.size;
  elem_align = repr_element @! PassConv.align;
  elem_copy = repr_element @! PassConv.copy;
  elem_finalize = repr_element @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);

  // Setup
  st = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call (stream @! Stream.initialize) (st);

  // Allocate two accumulators and swap between them.
  // That way, the accumulator can be updated safely.
  accs = pointer primcall pyon_alloc (sizeof Pair(elem_type));
  reduce_tmp = pointer primcall pyon_alloc (elem_size);
  stream_next = stream @! Stream.next;
  () = () call elem_copy (init, accs @ Pair(elem_type).fst);

  // Main loop.
  // At start, old_acc holds accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  // At termination, old_acc holds final accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  (acc1, acc2, _) = while (pointer old_acc = accs @ Pair(elem_type).fst,
                           pointer new_acc = accs @ Pair(elem_type).snd,
                           bool not_depleted = true)
                          (not_depleted) {
    not_depleted = bool call stream_next (st, reduce_tmp);
    if (not_depleted) {
      () = () call reducer (old_acc, reduce_tmp, new_acc);
      () = () call elem_finalize (old_acc);
      () = () call elem_finalize (reduce_tmp);
      (new_acc, old_acc, true);
    } else {
      (old_acc, new_acc, false);
    };
  };

  // Cleanup
  () = () call (stream @! Stream.state_finalize) (st);
  () = () primcall pyon_dealloc(st);
  () = () call elem_copy (acc1, ret);
  () = () call elem_finalize (acc1);
  () = () primcall pyon_dealloc(accs);
  ();
};

function inline reduce
  (unit _, unit _,
   owned traversable,
   owned elem_repr,
   owned reducer,
   pointer initial_value,
   pointer container,
   pointer ret) -> () {
  // Traverse the object and reduce the resulting stream
  () = () primcall pyon_db_pointer(traversable as pointer);
  () = () primcall pyon_db_pointer(elem_repr as pointer);
  () = () primcall pyon_db_pointer(reducer as pointer);
  () = () primcall pyon_db_pointer(initial_value);
  () = () primcall pyon_db_pointer(container);
  stream = owned call (traversable @! TraversableDict.traverse)
                      (nil, elem_repr, container);
  () = () primcall pyon_db_pointer(stream as pointer);

  () = () call Stream_reduce (nil, nil, elem_repr, reducer,
                              initial_value, stream, ret);

  // Clean up
  ();
};

/*****************************************************************************/
/* reduce1 */

// Like reduce, except that we take the first element from the stream.
// Terminate with error if stream is empty.
function inline Stream_reduce1
  (unit _, unit _,
   owned repr_element,
   owned reducer,
   owned stream,
   pointer ret) -> () {
  elem_size = repr_element @! PassConv.size;
  elem_align = repr_element @! PassConv.align;
  elem_copy = repr_element @! PassConv.copy;
  elem_finalize = repr_element @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);

  // Setup
  st = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call (stream @! Stream.initialize) (st);

  // Allocate two accumulators and swap between them.
  // That way, the accumulator can be updated safely.
  accs = pointer primcall pyon_alloc (sizeof Pair(elem_type));
  reduce_tmp = pointer primcall pyon_alloc (elem_size);
  stream_next = stream @! Stream.next;

  // Take first value from stream.  Use it to initialize the accumulator.
  not_depleted = bool call stream_next (st, accs @ Pair(elem_type).fst);
  if (not_depleted) {
    // Main loop.
    // At start, old_acc holds accumulator, new_acc is uninitialized,
    // reduce_tmp is uninitialized.
    // At termination, old_acc holds final accumulator, new_acc is uninitialized,
    // reduce_tmp is uninitialized.
    (acc1, acc2, _) = while (pointer old_acc = accs @ Pair(elem_type).fst,
                             pointer new_acc = accs @ Pair(elem_type).snd,
                             bool not_depleted = true)
                            (not_depleted) {
      not_depleted = bool call stream_next (st, reduce_tmp);
      if (not_depleted) {
        () = () call reducer (old_acc, reduce_tmp, new_acc);
        () = () call elem_finalize (old_acc);
        () = () call elem_finalize (reduce_tmp);
        (new_acc, old_acc, true);
      } else {
        (old_acc, new_acc, false);
      };
    };

    // Cleanup
    () = () call (stream @! Stream.state_finalize) (st);
    () = () primcall pyon_dealloc(st);
    () = () call elem_copy (acc1, ret);
    () = () call elem_finalize (acc1);
    () = () primcall pyon_dealloc(accs);
    ();
  } else {
    // Stream is empty.  This is an error.
    () primcall exit (int -1);
  };
};

function inline reduce1
  (unit _, unit _,
   owned traversable,
   owned elem_repr,
   owned reducer,
   pointer container,
   pointer ret) -> () {
  // Traverse the object and reduce the resulting stream
  stream = owned call (traversable @! TraversableDict.traverse)
                      (nil, elem_repr, container);

  () = () call Stream_reduce1 (nil, elem_repr, reducer, stream, ret);

  // Clean up
  ();
};

/*****************************************************************************/
/* histogram */

// Given a stream of integers, use the elements of the stream to compute a
// histogram.
function histogramArray
  (unit _, unit _, IndexedInt size, owned stream, pointer ret) -> () {
  data int stream_val;      // The current value taken from the stream

  IndexedInt {hist_size} = size;
  typedef arrayT = array(value hist_size, int);

  // Initialize histogram to zeros
  _ = while (int index = int 0) (index < hist_size) {
    ret @! arrayT[index] = int 0;
    index + int 1;
  };

  // Setup
  st = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call (stream @! Stream.initialize) (st);
  stream_next = stream @! Stream.next;

  // Main loop.  Update histogram until stream is depleted.
  _ = while (bool not_depleted = true) (not_depleted) {
    // Pull a value from the stream
    not_depleted = bool call stream_next (st, stream_val);

    () = if (not_depleted) {
      // Add 1 to histogram entry, if not out-of-bounds
      insert_index = int load stream_val;
      if (insert_index >= int 0 && insert_index < hist_size) {
        ret @! arrayT[insert_index] = ret @! arrayT[insert_index] + int 1;
        ();
      } else { (); };
    } else { (); };
    not_depleted;
  };

  // Cleanup
  () = () call (stream @! Stream.state_finalize) (st);
  ();
};

function histogram
  (unit _, int hist_size, owned stream, pointer ret) -> () {
  typedef array_type = array(value hist_size, int);

  // Compute the histogram
  ret_array = pointer primcall pyon_alloc (sizeof array_type);
  () = () call histogramArray(nil, nil, IndexedInt {hist_size}, stream, ret_array);

  // Initialize the list
  ret @! PyonList.nelems = hist_size;
  ret @! PyonList.contents = ret_array;
  ();
};

/*****************************************************************************/
/* zip */

// State of Stream_zip.
// The state consists of the states of both input streams.
record Stream_zip_state(p1stateT, p2stateT) {
  p1stateT p1_state;
  p2stateT p2_state;
};

function Stream_zip
  (unit _, unit _, unit _,
   owned repr_data1,            // Representation of p1's output
   owned repr_data2,            // Representation of p2's output
   owned p1,
   owned p2) -> owned {
  p1_state_size = p1 @! Stream.state_size;
  p1_state_align = p1 @! Stream.state_align;
  typedef p1_state_type = bytes(value p1_state_size, value p1_state_align);
  p1_result_size = repr_data1 @! PassConv.size;
  p1_result_align = repr_data1 @! PassConv.align;
  typedef p1_result_type = bytes(value p1_result_size, value p1_result_align);
  p2_state_size = p2 @! Stream.state_size;
  p2_state_align = p2 @! Stream.state_align;
  typedef p2_state_type = bytes(value p2_state_size, value p2_state_align);
  p2_result_size = repr_data2 @! PassConv.size;
  p2_result_align = repr_data2 @! PassConv.align;
  typedef p2_result_type = bytes(value p2_result_size, value p2_result_align);

  typedef state_type = Stream_zip_state (p1_state_type, p2_state_type);
  typedef output_type = MPyonTuple2 (p1_result_type, p2_result_type);

  s = pointer primcall Stream_alloc();

  letrec {
    function initialize(pointer state) -> () {
      () = () call (p1 @! Stream.initialize) (state @ state_type.p1_state);
      () = () call (p2 @! Stream.initialize) (state @ state_type.p2_state);
      ();
    }
  };
  s @! Stream.initialize = initialize;

  p1_next = p1 @! Stream.next;
  p2_next = p2 @! Stream.next;

  letrec {
    function next(pointer state, pointer out) -> bool {
      p1_has_data = bool call p1_next
        (state @ state_type.p1_state, out @ output_type.member1);
      if (p1_has_data) {
        p2_has_data = bool call p2_next
        (state @ state_type.p2_state, out @ output_type.member2);
        if (p2_has_data) {
          true;
        } else {
          // Stream 2 is exhausted.  Discard result of stream 1.
          () = () call (repr_data1 @! PassConv.finalize)
            (out @ output_type.member1);
          false;
        };
      } else {
        false;
      };
    }
  };

  s @! Stream.next = next;
  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;

  letrec {
    function finalize(pointer state) -> () {
      () = () call (p1 @! Stream.state_finalize)
        (state @ state_type.p1_state);
      () = () call (p2 @! Stream.state_finalize)
        (state @ state_type.p2_state);
      ();
    }
  };

  s @! Stream.state_finalize = finalize;
  s;
};

function zip
  (unit _, unit _, unit _,
   owned traversable,           // Container methods
   owned repr_data1,            // Representation of p1's output
   owned repr_data2,            // Representation of p2's output
   pointer p1,
   pointer p2,
   pointer out)
   -> () {
   // Create a tuple representation object
   repr_tuple = owned call repr_PyonTuple2 (nil, nil, repr_data1, repr_data2);

   // Traverse input objects
   stream_p1 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data1, p1);
   stream_p2 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data2, p2);

   // Zip
   zip_stream = owned call Stream_zip
     (nil, nil, repr_data1, repr_data2, stream_p1, stream_p2);

   // Create output data
   () call (traversable @! TraversableDict.build)
     (nil, repr_tuple, zip_stream, out);
};

/*****************************************************************************/
/* zip3 */

// State of Stream_zip3.
// The state consists of the states of all three input streams.
record Stream_zip3_state(p1stateT, p2stateT, p3stateT) {
  p1stateT p1_state;
  p2stateT p2_state;
  p3stateT p3_state;
};

function Stream_zip3
  (unit _, unit _, unit _, unit _,
   owned repr_data1,            // Representation of p1's output
   owned repr_data2,            // Representation of p2's output
   owned repr_data3,            // Representation of p3's output
   owned p1,
   owned p2,
   owned p3) -> owned {
  p1_state_size = p1 @! Stream.state_size;
  p1_state_align = p1 @! Stream.state_align;
  typedef p1_state_type = bytes(value p1_state_size, value p1_state_align);
  p1_result_size = repr_data1 @! PassConv.size;
  p1_result_align = repr_data1 @! PassConv.align;
  typedef p1_result_type = bytes(value p1_result_size, value p1_result_align);
  p2_state_size = p2 @! Stream.state_size;
  p2_state_align = p2 @! Stream.state_align;
  typedef p2_state_type = bytes(value p2_state_size, value p2_state_align);
  p2_result_size = repr_data2 @! PassConv.size;
  p2_result_align = repr_data2 @! PassConv.align;
  typedef p2_result_type = bytes(value p2_result_size, value p2_result_align);
  p3_state_size = p3 @! Stream.state_size;
  p3_state_align = p3 @! Stream.state_align;
  typedef p3_state_type = bytes(value p3_state_size, value p3_state_align);
  p3_result_size = repr_data3 @! PassConv.size;
  p3_result_align = repr_data3 @! PassConv.align;
  typedef p3_result_type = bytes(value p3_result_size, value p3_result_align);

  typedef state_type = Stream_zip3_state
    (p1_state_type, p2_state_type, p3_state_type);
  typedef output_type = MPyonTuple3
    (p1_result_type, p2_result_type, p3_result_type);

  s = pointer primcall Stream_alloc();

  letrec {
    function initialize(pointer state) -> () {
      () = () call (p1 @! Stream.initialize) (state @ state_type.p1_state);
      () = () call (p2 @! Stream.initialize) (state @ state_type.p2_state);
      () = () call (p3 @! Stream.initialize) (state @ state_type.p3_state);
      ();
    }
  };
  s @! Stream.initialize = initialize;

  p1_next = p1 @! Stream.next;
  p2_next = p2 @! Stream.next;
  p3_next = p3 @! Stream.next;

  letrec {
    function next(pointer state, pointer out) -> bool {
      p1_has_data = bool call p1_next
        (state @ state_type.p1_state, out @ output_type.member1);
      if (p1_has_data) {
        p2_has_data = bool call p2_next
        (state @ state_type.p2_state, out @ output_type.member2);
        if (p2_has_data) {
          p3_has_data = bool call p3_next
          (state @ state_type.p3_state, out @ output_type.member3);
          if (p3_has_data) {
            true;
          } else {
            // Stream 3 is exhausted.  Discard results of streams 1 and 2.
            () = () call (repr_data2 @! PassConv.finalize)
              (out @ output_type.member2);
            () = () call (repr_data1 @! PassConv.finalize)
              (out @ output_type.member1);
            false;
          };
        } else {
          // Stream 2 is exhausted.  Discard result of stream 1.
          () = () call (repr_data1 @! PassConv.finalize)
            (out @ output_type.member1);
          false;
        };
      } else {
        false;
      };
    }
  };

  s @! Stream.next = next;
  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;

  letrec {
    function finalize(pointer state) -> () {
      () = () call (p1 @! Stream.state_finalize)
        (state @ state_type.p1_state);
      () = () call (p2 @! Stream.state_finalize)
        (state @ state_type.p2_state);
      () = () call (p3 @! Stream.state_finalize)
        (state @ state_type.p3_state);
      ();
    }
  };

  s @! Stream.state_finalize = finalize;
  s;
};

function zip3
  (unit _, unit _, unit _, unit _,
   owned traversable,           // Container methods
   owned repr_data1,            // Representation of p1's output
   owned repr_data2,            // Representation of p2's output
   owned repr_data3,            // Representation of p3's output
   pointer p1,
   pointer p2,
   pointer p3,
   pointer out)
   -> () {
   // Create a tuple representation object
   repr_tuple = owned call repr_PyonTuple3 (nil, nil, nil, repr_data1, repr_data2, repr_data3);

   // Traverse input objects
   stream_p1 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data1, p1);
   stream_p2 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data2, p2);
   stream_p3 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data3, p3);

   // Zip
   zip_stream = owned call Stream_zip3
     (nil, nil, nil, repr_data1, repr_data2, repr_data3, stream_p1, stream_p2, stream_p3);

   // Create output data
   () call (traversable @! TraversableDict.build)
     (nil, repr_tuple, zip_stream, out);
};

/*****************************************************************************/
/* zip4 */

// State of Stream_zip4.
// The state consists of the states of all three input streams.
record Stream_zip4_state(p1stateT, p2stateT, p3stateT, p4stateT) {
  p1stateT p1_state;
  p2stateT p2_state;
  p3stateT p3_state;
  p4stateT p4_state;
};

function Stream_zip4
  (unit _, unit _, unit _, unit _, unit _,
   owned repr_data1,            // Representation of p1's output
   owned repr_data2,            // Representation of p2's output
   owned repr_data3,            // Representation of p3's output
   owned repr_data4,            // Representation of p4's output
   owned p1,
   owned p2,
   owned p3,
   owned p4) -> owned {
  p1_state_size = p1 @! Stream.state_size;
  p1_state_align = p1 @! Stream.state_align;
  typedef p1_state_type = bytes(value p1_state_size, value p1_state_align);
  p1_result_size = repr_data1 @! PassConv.size;
  p1_result_align = repr_data1 @! PassConv.align;
  typedef p1_result_type = bytes(value p1_result_size, value p1_result_align);
  p2_state_size = p2 @! Stream.state_size;
  p2_state_align = p2 @! Stream.state_align;
  typedef p2_state_type = bytes(value p2_state_size, value p2_state_align);
  p2_result_size = repr_data2 @! PassConv.size;
  p2_result_align = repr_data2 @! PassConv.align;
  typedef p2_result_type = bytes(value p2_result_size, value p2_result_align);
  p3_state_size = p3 @! Stream.state_size;
  p3_state_align = p3 @! Stream.state_align;
  typedef p3_state_type = bytes(value p3_state_size, value p3_state_align);
  p3_result_size = repr_data3 @! PassConv.size;
  p3_result_align = repr_data3 @! PassConv.align;
  typedef p3_result_type = bytes(value p3_result_size, value p3_result_align);
  p4_state_size = p4 @! Stream.state_size;
  p4_state_align = p4 @! Stream.state_align;
  typedef p4_state_type = bytes(value p4_state_size, value p4_state_align);
  p4_result_size = repr_data4 @! PassConv.size;
  p4_result_align = repr_data4 @! PassConv.align;
  typedef p4_result_type = bytes(value p4_result_size, value p4_result_align);

  typedef state_type = Stream_zip4_state
    (p1_state_type, p2_state_type, p3_state_type, p4_state_type);
  typedef output_type = MPyonTuple4
    (p1_result_type, p2_result_type, p3_result_type, p4_result_type);

  s = pointer primcall Stream_alloc();

  letrec {
    function initialize(pointer state) -> () {
      () = () call (p1 @! Stream.initialize) (state @ state_type.p1_state);
      () = () call (p2 @! Stream.initialize) (state @ state_type.p2_state);
      () = () call (p3 @! Stream.initialize) (state @ state_type.p3_state);
      () = () call (p4 @! Stream.initialize) (state @ state_type.p4_state);
      ();
    }
  };
  s @! Stream.initialize = initialize;

  p1_next = p1 @! Stream.next;
  p2_next = p2 @! Stream.next;
  p3_next = p3 @! Stream.next;
  p4_next = p4 @! Stream.next;

  letrec {
    function next(pointer state, pointer out) -> bool {
      p1_has_data = bool call p1_next
        (state @ state_type.p1_state, out @ output_type.member1);
      if (p1_has_data) {
        p2_has_data = bool call p2_next
        (state @ state_type.p2_state, out @ output_type.member2);
        if (p2_has_data) {
          p3_has_data = bool call p3_next
          (state @ state_type.p3_state, out @ output_type.member3);
          if (p3_has_data) {
            p4_has_data = bool call p4_next
            (state @ state_type.p4_state, out @ output_type.member4);
            if (p4_has_data) {
              true;
            } else {
              // Stream 4 is exhausted.  Discard results of other streams.
              () = () call (repr_data3 @! PassConv.finalize)
                (out @ output_type.member3);
              () = () call (repr_data2 @! PassConv.finalize)
                (out @ output_type.member2);
              () = () call (repr_data1 @! PassConv.finalize)
                (out @ output_type.member1);
              false;
            };
          } else {
            // Stream 3 is exhausted.  Discard results of streams 1 and 2.
            () = () call (repr_data2 @! PassConv.finalize)
              (out @ output_type.member2);
            () = () call (repr_data1 @! PassConv.finalize)
              (out @ output_type.member1);
            false;
          };
        } else {
          // Stream 2 is exhausted.  Discard result of stream 1.
          () = () call (repr_data1 @! PassConv.finalize)
            (out @ output_type.member1);
          false;
        };
      } else {
        false;
      };
    }
  };

  s @! Stream.next = next;
  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;

  letrec {
    function finalize(pointer state) -> () {
      () = () call (p1 @! Stream.state_finalize)
        (state @ state_type.p1_state);
      () = () call (p2 @! Stream.state_finalize)
        (state @ state_type.p2_state);
      () = () call (p3 @! Stream.state_finalize)
        (state @ state_type.p3_state);
      () = () call (p4 @! Stream.state_finalize)
        (state @ state_type.p4_state);
      ();
    }
  };

  s @! Stream.state_finalize = finalize;
  s;
};

function zip4
  (unit _, unit _, unit _, unit _, unit _,
   owned traversable,           // Container methods
   owned repr_data1,            // Representation of p1's output
   owned repr_data2,            // Representation of p2's output
   owned repr_data3,            // Representation of p3's output
   owned repr_data4,            // Representation of p4's output
   pointer p1,
   pointer p2,
   pointer p3,
   pointer p4,
   pointer out)
   -> () {
   // Create a tuple representation object
   repr_tuple = owned call repr_PyonTuple4
     (nil, nil, nil, nil, repr_data1, repr_data2, repr_data3, repr_data4);

   // Traverse input objects
   stream_p1 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data1, p1);
   stream_p2 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data2, p2);
   stream_p3 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data3, p3);
   stream_p4 = owned call (traversable @! TraversableDict.traverse)
     (nil, repr_data4, p4);

   // Zip
   zip_stream = owned call Stream_zip4
     (nil, nil, nil, nil,
      repr_data1, repr_data2, repr_data3, repr_data4,
      stream_p1, stream_p2, stream_p3, stream_p4);

   // Create output data
   () call (traversable @! TraversableDict.build)
     (nil, repr_tuple, zip_stream, out);
};

/*****************************************************************************/
/* count */

data owned Stream_counter = Stream {
  INIT_OBJECT_HEADER,
  Stream_count_next,
  Stream_count_initialize,
  sizeof int,
  alignof int,
  dummy_finalizer
};

function inline Stream_count_initialize (pointer state) -> () {
  !state = int 0;
  ();
};

function inline Stream_count_next (pointer state, pointer out) -> bool {
  current = int load state;
  !state = current + int 1;
  !out = current;
  true;
};

// This function is polymorphic in the stream shape.  It always returns the
// same stream.
function inline Stream_count (unit _) -> owned {
  Stream_counter;
};

/*****************************************************************************/
/* range */

function inline Stream_range (int n) -> owned {
  owned call generate(nil, nil, IndexedInt {n}, repr_int, range_get_value);
};

// Get the value of the current element of a 'range' stream.  This is just the
// index.
function range_get_value (int n, pointer out) -> () {
  !out = n;
  ();
};

/*****************************************************************************/
/* generate */

// The stream state holds the next index to generate

function inline generate
  (unit _, unit _, IndexedInt indexed_count, owned elt_repr, owned generator)
  -> owned {
  IndexedInt {count} = indexed_count;
  s = pointer primcall Stream_alloc();

  letrec {
    function initialize (pointer state) -> () {
      !state = int 0;
      ();
    }
  };
  s @! Stream.initialize = initialize;

  letrec {
    function next (pointer state, pointer out) -> bool {
      ix = int load state;
      if (ix >= count) {
        // Stream is depleted
        false;
      } else {
        !state = ix + int 1;
        () = () call generator (ix, out);
        true;
      };
    }
  };
  s @! Stream.next = next;
  s @! Stream.state_size = sizeof int;
  s @! Stream.state_align = alignof int;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};