
module pyon.internal.stream;

#include "rts.h"
#include "debug.h"
#include "apply_py.h"
#include "memory_py.h"
#include "structures.h"
#include "stream.h"

import procedure exit (pointer, pointer) -> ();

#include "new_pyasm_records.h"

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  dummy_finalizer,
  TAG_CON
};

procedure inline Stream_alloc () -> owned {
  s = pointer primcall pyon_alloc (sizeof Stream);
  // FIXME: initialize header
  s as owned;
};

/*****************************************************************************/
/* return */
// A 'return' stream produces one value, then quits.  The value is produced
// by calling a function.
//
// The stream state is a bool, whose value says whether the stream's single
// output has been produced yet.
//   true  -> depleted
//   false -> value is available

// Create a stream that produces a single value
function inline Stream_return (unit _,
                        owned return_type_repr,
                        owned produce_value) -> owned {
  s = owned primcall Stream_alloc();
  s @! Stream.next = owned call Stream_return_next(produce_value);
  s @! Stream.initialize = Stream_return_initialize;
  s @! Stream.state_size = sizeof bool;
  s @! Stream.state_align = alignof bool;
  s @! Stream.state_finalize = dummy_finalizer; // It's plain old data
  s;
};

function inline Stream_return_next (owned produce_value,
                             pointer state,
                             pointer ret) -> bool {
  if (bool load state) {
    // Stream is depleted
    false;
  } else {
    // Stream has data
    !state = true;      // Remember that value was produced
    () = () call produce_value (ret);
    true;
  };
};

function inline Stream_return_initialize(pointer state) -> () {
  !state = false;
  ();
};

/*****************************************************************************/
/* bind */

// A bound stream consists of a producer stream and a consumer function that
// returns a stream.  The consumer transforms every element returned by the
// producer.
//
// The state of a bound stream consists of:
//  1. The current transformer stream, or NULL.
//     If non-null, the next value is pulled from this stream.  Otherwise,
//     We need to pull from the producer and create a new transformer stream.
//  2. A pointer to the current transformer stream's state, or NULL.
//  3. The producer stream's current output value.  This value
//     may be referenced by the transformer stream.  It's garbage if the
//     transformer stream is NULL.
//  4. The producer stream's state.
record Stream_bind_state(pstateT, presultT) {
  pointer tf;                   // Transformer stream (owned or NULL)
  pointer tf_state;             // Transformer stream's state
                                // (if transformer stream is not NULL)
  presultT pr_result;           // Producer's current output value
                                // (if transformer stream is not NULL)
  pstateT pr_state;             // Producer's state
};

// Chain streams together.
function inline Stream_bind (unit _, unit _,
                      owned pr_repr,   // Produced type representation
                      owned tf_repr,   // Transformed type representation
                      owned pr,        // Producer stream
                      owned tf)        // Transformer stream
    -> owned {
  pr_state_size = pr @! Stream.state_size;
  pr_state_align = pr @! Stream.state_align;
  pr_result_size = pr_repr @! PassConv.size;
  pr_result_align = pr_repr @! PassConv.align;
  typedef pr_state_type = bytes(value pr_state_size, value pr_state_align);
  typedef pr_result_type = bytes(value pr_result_size, value pr_result_align);
  typedef state_type = Stream_bind_state(pr_state_type, pr_result_type);

  s = owned primcall Stream_alloc ();

  letrec {
    function initialize (pointer state) -> () {
      // Initialize a bound stream.
      // Initialize the producer's state and clear the transformer's state.
      state @! state_type.tf = null;
      state @! state_type.tf_state = null;
      // pr_result is uninitialized
      () call (pr @! Stream.initialize) (state @ state_type.pr_state);
    }
  };

  s @! Stream.initialize = initialize;

  letrec {
    function next (pointer state, pointer out) -> bool {
      // Get a new value from the stream.
      letrec {
        // Try getting a value from the producer, then creating a transformer.
        procedure pull_from_producer () -> bool {
          pr_has_data = bool call (pr @! Stream.next)
            (state @ state_type.pr_state, state @ state_type.pr_result);
          if (pr_has_data) {
            // Create a new transformer stream
            tf_owned = owned call tf (state @ state_type.pr_result);

            // Initialize the transformer stream
            state @! state_type.tf = tf_owned as pointer;
            tf_state = pointer primcall pyon_alloc
              (tf_owned @! Stream.state_size);
            () = () call (tf_owned @! Stream.initialize) (tf_state);
            state @! state_type.tf_state = tf_state;
            
            // Pull from the transformer stream
            bool primcall pull_from_transformer ();
          } else {
            // Stream is depleted
            false;
          };
        }; // end pull_from_producer

        // Try getting the value from the transformer.
        procedure pull_from_transformer () -> bool {
          // Is there an active transformer stream?
          tf_stream = state @! state_type.tf;
          if (tf_stream == null) {
            // Create a new one
            bool primcall pull_from_producer ();
          } else {
            // Try to get a value from the current transformer object.
            // If that fails, try to get a new value from the producer object.
            tf_owned = tf_stream as owned;
            tf_state = state @! state_type.tf_state;
            tf_has_data = bool call (tf_owned @! Stream.next) (tf_state, out);
            if (tf_has_data) {
              true;
            } else {
              // Clean up transformer
              () = () call (tf_owned @! Stream.state_finalize) (tf_state);
              () = () primcall pyon_dealloc (tf_state);
              state @! state_type.tf = null;

              // Clean up the produced value
              () = () call (pr_repr @! PassConv.finalize)
                (state @ state_type.pr_result);

              // Get a new value from the producer, then retry
              bool primcall pull_from_producer ();
            };
          };
        } // end pull_from_transformer
      }; // end letrec
      bool primcall pull_from_transformer();
    } // end next
  }; // end letrec

  s @! Stream.next = next;
  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

/*****************************************************************************/
/* generate */

// A stream consisting of the sequence f(0), f(1), ... f(limit-1).
// The stream state holds the next value to generate.
function Stream_generate
  (unit _, unit _, owned ret_repr, int limit, owned f) -> owned {
  s = owned primcall Stream_alloc();

  s @! Stream.initialize = Stream_generate_initialize;

  letrec {
    function next (pointer state, pointer ret) -> bool {
      // Get the current counter value
      n = int load state;
      if (n >= limit) {
        // Stream is depleted
        false;
      } else {
        // Update the counter
        !state = n + int 1;

        // Produce a value
        () = () call f (n, ret);
        true;
      };
    }
  };
  s @! Stream.next = next;
  s @! Stream.state_size = sizeof int;
  s @! Stream.state_align = alignof int;
  s @! Stream.state_finalize = dummy_finalizer; // It's plain old data 
  s;
};

function Stream_generate_initialize (pointer state) -> () {
  !state = int 0;
  ();
};

/*****************************************************************************/
/* map */

// State of Stream_map.
// The state consists of the produced value's representation and temporary
// storage for the produced value.
record Stream_map_state(pstateT, presultT) {
  pstateT pr_state;             // State of producer stream
  presultT pr_result;           // Holds output of producer
};

function Stream_map
  (unit _, unit _,
   owned pr_repr,               // Representation of a produced value
   owned tf_repr,               // Representation of a transformed value
   owned tf,                    // Transformer function
   owned pr)                    // Producer stream
   -> owned {
  pr_state_size = pr @! Stream.state_size;
  pr_state_align = pr @! Stream.state_align;
  typedef pr_state_type = bytes (value pr_state_size, value pr_state_align);
  pr_result_size = pr_repr @! PassConv.size;
  pr_result_align = pr_repr @! PassConv.align;
  typedef pr_result_type = bytes (value pr_result_size, value pr_result_align);

  typedef state_type = Stream_map_state (pr_state_type, pr_result_type);

  s = owned primcall Stream_alloc ();

  letrec {
    function initialize (pointer state) -> () {
      () = () call (pr @! Stream.initialize) (state @ state_type.pr_state);
      // pr_result is uninitialized
      ();
    }
  };
  
  s @! Stream.initialize = initialize;

  letrec {
    function next (pointer state, pointer out) -> bool {
      // Run the producer to get a value.  Write the value into the
      // reserved memory area.
      pr_has_data = bool call (pr @! Stream.next)
        (state @ state_type.pr_state, state @ state_type.pr_result);

      if (pr_has_data) {
        // Transform the value
        () = () call tf (state @ state_type.pr_result, out);
        true;
      } else {
        false;
      };
    }
  };

  s @! Stream.next = next;

  s @! Stream.state_size = sizeof state_type;
  s @! Stream.state_align = alignof state_type;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

/*****************************************************************************/
/* reduce */

function inline Stream_reduce
  (unit _, unit _,
   owned repr_element,
   owned _,
   owned reducer,
   pointer init,
   owned stream,
   pointer ret) -> () {
  elem_size = repr_element @! PassConv.size;
  elem_align = repr_element @! PassConv.align;
  elem_copy = repr_element @! PassConv.copy;
  elem_finalize = repr_element @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);

  // Setup
  st = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call (stream @! Stream.initialize) (st);

  // Allocate two accumulators and swap between them.
  // That way, the accumulator can be updated safely.
  accs = pointer primcall pyon_alloc (sizeof Pair(elem_type));
  reduce_tmp = pointer primcall pyon_alloc (elem_size);
  stream_next = stream @! Stream.next;
  () = () call elem_copy (accs @ Pair(elem_type).fst, init);

  // Main loop.
  // At start, old_acc holds accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  // At termination, old_acc holds final accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  (acc1, acc2, _) = while (pointer old_acc = accs @ Pair(elem_type).fst,
                           pointer new_acc = accs @ Pair(elem_type).snd,
                           bool not_depleted = true)
                          (not_depleted) {
    not_depleted = bool call stream_next (st, reduce_tmp);
    if (not_depleted) {
      () = () call reducer (old_acc, reduce_tmp, new_acc);
      () = () call elem_finalize (old_acc);
      () = () call elem_finalize (reduce_tmp);
      (new_acc, old_acc, true);
    } else {
      (old_acc, new_acc, false);
    };
  };

  // Cleanup
  () = () call (stream @! Stream.state_finalize) (st);
  () = () primcall pyon_dealloc(st);
  () = () call elem_copy (acc1, ret);
  () = () call elem_finalize (acc1);
  () = () primcall pyon_dealloc(accs);
  ();
};

function inline reduce
  (unit _, unit _,
   owned traversable,
   owned elem_repr,
   owned container_repr,
   owned reducer,
   pointer initial_value,
   pointer container,
   pointer ret) -> () {
  // Traverse the object and reduce the resulting stream
  stream = owned call (traversable @! TraversableDict.traverse)
                      (nil, elem_repr, container);

  () = () call Stream_reduce (nil, nil, elem_repr, container_repr, reducer,
                              initial_value, stream, ret);

  // Clean up
  ();
};
