
module pyon.internal.stream;

#include "rts.h"
#include "debug.h"
#include "memory_py.h"
#include "structures.h"
#include "stream.h"

extern procedure builtin.exit "exit" (pointer, pointer) -> ();

#include "new_pyasm_records.h"

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  dummy_finalizer,
  TAG_CON
};

// A stream's state will never be copied.  Abort if we try to copy it.
function copy_stream_state(pointer src, pointer dst) -> () {
  () primcall exit (int -1);
};

/*****************************************************************************/
/* return */
#if 0
// A 'return' stream produces one value, then quits.  The value is produced
// by calling a function.
//
// The stream state is a bool, whose value says whether the stream's single
// output has been produced yet.
//   true  -> depleted
//   false -> value is available

// Create a stream that produces a single value
function Stream_return (unit _,
                        pointer return_type_repr,
                        owned produce_value) -> owned {
  s = (pointer primcall pyon_alloc (sizeof Stream)) as owned;
  // FIXME: initialize header

  s @! Stream.next = owned call Stream_return_next(produce_value);
  s @! Stream.initialize = Stream_return_initialize;
  () = () call copy_Repr (nil, return_type_repr, s @! Stream.return_repr);
  s @! Stream.state_repr.size = sizeof bool;
  s @! Stream.state_repr.align = alignof bool;
  s @! Stream.state_repr.copy = copy_stream_state;
  s @! Stream.state_repr.finalize = dummy_finalizer;
  s;
};

function Stream_return_next (owned produce_value,
                             pointer state,
                             pointer ret) -> bool {
  if (bool load state) {
    // Stream is depleted
    false;
  } else {
    // Stream has data
    !state = true;      // Remember that value was produced

    // Produce the value
    () = () call produce_value (ret);

    true;
  };
};

function Stream_return_initialize(pointer state) -> () {
  !state = false;
  ();
};

#endif

/*****************************************************************************/
/* bind */

// A bound stream consists of a producer stream and a consumer function that
// returns a stream.  The consumer transforms every element returned by the
// producer.
//
// The state of a bound stream consists of:
//  1. The current transformer stream, or NULL.
//     If non-null, the next value is pulled from this stream.  Otherwise,
//     We need to pull from the producer and create a new transformer stream.
//  2. A pointer to the current transformer stream's state, or NULL.
//  3. The producer stream's current output value.  This value
//     may be referenced by the transformer stream.  It's garbage if the
//     transformer stream is NULL.
//  4. The producer stream's state.
record Stream_bind_state(pstateT, presultT) {
  pointer transformer;          // Transformer stream (owned or NULL)
  pointer transformer_state;    // Transformer stream's state, or NULL
  presultT temporary_state;     // Producer's current output value
                                // (if transformer stream is not NULL)
  pstateT producer_state;       // Producer's state
};

#if 0
// Chain streams together.
function Stream_bind (unit _, unit _,
                      pointer produced_type_repr,
                      pointer transformed_type_repr,
                      owned producer,
                      owned transformer) -> owned {
  producer_state_size = producer @! Stream.state_repr.size;
  producer_state_align = producer @! Stream.state_repr.align;
  typedef produced_state =
    bytes(value producer_state_size, value producer_state_align);
  producer_result_size = produced_type_repr @! PassConv.size;
  producer_result_align = produced_type_repr @! PassConv.align;
  typedef produced_type =
    bytes(value producer_result_size, value producer_result_align);

  typedef stream_state = Stream_bind_state(produced_state, produced_type);

  produced_type_repr_val = PassConv load produced_type_repr;

  s = () primcall pyon_alloc (sizeof Stream);
  // FIXME: Initialize header

  s @! Stream.next = owned call Stream_bind_next
    (produced_type_repr_val, producer, transformer);
  s @! Stream.initialize = owned call Stream_bind_initialize
    (producer_result_size, producer_result_align, producer);
  () = () call copy_Repr (transformed_type_repr, s @! Stream.return_repr);
  s @! Stream.state_repr.size = sizeof stream_state;
  s @! Stream.state_repr.align = alignof stream_state;
  s @! Stream.state_repr.copy = copy_stream_state;
  s @! Stream.state_repr.finalize = dummy_finalizer;
  s;
};

// Initialize a bound stream.
function Stream_bind_initialize (word producer_result_size,
                                 word producer_result_align,
                                 owned producer,
                                 pointer state) -> () {
  producer_state_size = producer @! Stream.state_repr.size;
  producer_state_align = producer @! Stream.state_repr.align;
  typedef producer_state =
    bytes(value producer_state_size, value producer_state_align);
  typedef produced_type =
    bytes(value producer_result_size, value producer_result_align);

  typedef stream_state = Stream_bind_state(produced_state, produced_type);


  typedef stream_state = Stream_bind_state(produced_state);

  // Initialize the transformer pointer
  state @! stream_state.transformer = null;
  state @! stream_state.transformer_state = null;

  // Initialize the producer state
  () = () call (producer @! Stream.initialize)
    (state @ stream_state.producer_state);

  // Allocate the temporary storage
  state @! Stream_bind_state.temporary_state =
      pointer primcall pyon_alloc (produced_type_size);

  ();
};

// Get the next value from the stream.
// First, try to pull from the transformer.
// If that is not successful, try to pull a new value from the producer, then
// create a transformer and try to pull a value from it again.
// If the transformer and producer are both depleted, the stream is depleted.
function Stream_bind_next(owned produced_type_fini,
                          owned producer,
                          owned mk_transformer,
                          pointer state,
                          pointer ret) -> bool {
  letrec {
    function loop (int _) -> bool {
      // Is transformer active?
      transformer = state @! Stream_bind_state.transformer;
      if (transformer != null) {
        // Call the transformer stream
        transformer = state @! Stream_bind_state.transformer as owned;
        transformer_state = state @! Stream_bind_state.transformer_state;
        b = bool call (transformer @! Stream.next) (transformer_state, ret);

        // Was a value produced?
        if (b) {
          // Done
          true;
        } else {
          // Transformer is depleted; release transformer
          () = () call (transformer @! Stream.state_finalize) (transformer_state);
          () = () primcall pyon_dealloc(transformer_state);
          // DECREF(transformer as pointer)
          state @! Stream_bind_state.transformer = null;

          // Free temporary state
          () = () call produced_type_fini
              (state @! Stream_bind_state.temporary_state);

          // Retry
          bool call loop (int 0);
        };
      } else {
        // Produce a new value
        value_produced = bool call (producer @! Stream.next)
            (state @! Stream_bind_state.producer_state,
             state @! Stream_bind_state.temporary_state);
        
        if (value_produced) {
          // Run the transformer to create an output stream
          transformer_stream =
              owned call mk_transformer (state @! Stream_bind_state.temporary_state);

          // Begin producing from the output stream
          transformer_state =
            pointer primcall pyon_alloc (transformer_stream @! Stream.state_size);
          () = () call (transformer_stream @! Stream.initialize) (transformer_state);

          // Retry, with the new transformer stream
          state @! Stream_bind_state.transformer = transformer_stream;
          state @! Stream_bind_state.transformer_state = transformer_state;
          bool call loop (int 0);
        } else {
          // Stream is depleted
          false;
        };
      };
    }
  };
  bool call loop (int 0);
};

function Stream_bind_finalize (owned produced_type_fini,
                               owned finalize_producer,
                               pointer state) -> () {
  // Release the transformer
  transformer_ptr = state @! Stream_bind_state.transformer;
  () = if (transformer_ptr != null) {
    transformer = state @! Stream_bind_state.transformer as owned;
    transformer_state = state @! Stream_bind_state.transformer_state;
    () = () call (transformer @! Stream.state_finalize) (transformer_state);
    () = () primcall pyon_dealloc (transformer_state);
    // DECREF(transformer_ptr)

    // Finalize the temporary state
    () call produced_type_fini (state @! Stream_bind_state.temporary_state);
  } else {
    ();
  };
  // Free the temporary state
  () = () primcall pyon_dealloc (state @! Stream_bind_state.temporary_state);

  // Release the producer's state
  producer_state = state @! Stream_bind_state.producer_state;
  () = () call finalize_producer (producer_state);
  () primcall pyon_dealloc (producer_state);
};
#endif

/*****************************************************************************/
/* generate */

#if 0
// A stream consisting of the sequence f(0), f(1), ... f(limit-1).
// The stream state holds the next value to generate.
function Stream_generate
  (unit _, unit _, pointer return_conv, int limit, owned f) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)

  s @! Stream.next = owned call Stream_generate_next(limit, f);
  s @! Stream.initialize = Stream_generate_initialize;
  s @! Stream.return_repr.size = return_conv @! PassConv.size;
  s @! Stream.return_repr.align = return_conv @! PassConv.align;
  s @! Stream.return_repr.copy = return_conv @! PassConv.copy;
  s @! Stream.return_repr.finalize = return_conv @! PassConv.finalize;
  s @! Stream.state_size = sizeof int;
  s @! Stream.state_align = alignof int;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

function Stream_generate_next
  (int limit, owned f, pointer state, pointer ret) -> bool {
  // Get the current counter value
  n = int load state;
  if (n >= limit) {
    // Stream is depleted
    false;
  } else {
    // Update the counter
    !state = n + int 1;
    // Produce a value
    () = () call f (n, ret);
    true;
  };
};

function Stream_generate_initialize (pointer state) -> () {
  !state = int 0;
  ();
};
#endif

/*****************************************************************************/
/* map */

#if 0
// State of Stream_map.
// The state consists of the produced value's representation and temporary
// storage for the produced value.
record Stream_map_state {
  pointer producer_state;           // State of producer stream
  pointer temporary_state;          // Holds output of producer
};

function Stream_map
  (unit _, unit _, unit _,
   pointer produced_repr, pointer transformed_repr,
   owned transformer, owned producer) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)

  s @! Stream.next = owned call Stream_map_next
    (transformer, producer, produced_repr @! PassConv.finalize);
  s @! Stream.initialize = owned call Stream_map_initialize
    (transformed_repr @! PassConv.size,
     transformed_repr @! PassConv.align,
     producer);
  s @! Stream.return_repr.size = transformed_repr @! PassConv.size;
  s @! Stream.return_repr.align = transformed_repr @! PassConv.align;
  s @! Stream.return_repr.copy = transformed_repr @! PassConv.copy;
  s @! Stream.return_repr.finalize = transformed_repr @! PassConv.finalize;
  s @! Stream.state_size = sizeof Stream_map_state;
  s @! Stream.state_align = alignof Stream_map_state;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};
        
function Stream_map_next
  (owned transformer, owned producer, owned finalize_produced_state,
   pointer state, pointer ret) -> bool {
  temporary_state = state @! Stream_map_state.temporary_state;
  // Run the producer
  b = bool call (producer @! Stream.next)
    (state @! Stream_map_state.producer_state, temporary_state);

  if (b) {
    // Transform its result
    () = () call transformer (temporary_state, ret);

    // Finalize the temporary data
    () = () call finalize_produced_state (temporary_state);
    true;
  } else {
    false;
  };
};

function Stream_map_initialize
  (word produced_size, word produced_align, owned producer, pointer state) -> () {
  producer_state = pointer primcall pyon_alloc (producer @! Stream.state_size);
  () = () call (producer @! Stream.initialize) (producer_state);

  state @! Stream_map_state.producer_state = producer_state;
  state @! Stream_map_state.temporary_state =
    pointer primcall pyon_alloc (produced_size);
  ();
};
#endif

/*****************************************************************************/
/* reduce */

#if 0
function inline Stream_reduce
  (unit _, unit _,
   pointer passconv, pointer _,
   owned reducer,
   pointer init,
   owned stream,
   pointer ret) -> () {
  elem_size = passconv @! PassConv.size;
  elem_align = passconv @! PassConv.align;
  elem_copy = passconv @! PassConv.copy;
  elem_finalize = passconv @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);

  // Setup
  st = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call (stream @! Stream.initialize) (st);

  // Allocate two accumulators and swap between them.
  // That way, the accumulator can be updated safely.
  accs = pointer primcall pyon_alloc (sizeof Pair(elem_type));
  reduce_tmp = pointer primcall pyon_alloc (elem_size);
  stream_next = stream @! Stream.next;
  () = () call elem_copy (accs @ Pair(elem_type).fst, init);

  // Main loop.
  // At start, old_acc holds accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  // At termination, old_acc holds final accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  (acc1, acc2, _) = while (pointer old_acc = accs @ Pair(elem_type).fst,
                           pointer new_acc = accs @ Pair(elem_type).snd,
                           bool not_depleted = true)
                          (not_depleted) {
    not_depleted = bool call stream_next (st, reduce_tmp);
    if (not_depleted) {
      () = () call reducer (old_acc, reduce_tmp, new_acc);
      () = () call elem_finalize (old_acc);
      () = () call elem_finalize (reduce_tmp);
      (new_acc, old_acc, true);
    } else {
      (old_acc, new_acc, false);
    };
  };

  // Cleanup
  () = () call (stream @! Stream.state_finalize) (st);
  () = () call elem_copy (acc1, ret);
  () = () call elem_finalize (acc1);
  () = () primcall pyon_dealloc(accs);
  ();
};


function inline reduce
  (unit _, unit _, unit _,
   pointer traversable,
   pointer elem_repr,
   pointer container_repr,
   owned reducer,
   pointer initial_value,
   pointer container,
   pointer ret) -> () {
  // Traverse the object and reduce the resulting stream
  stream = owned call (traversable @! TraversableDict.traverse)
                      (nil, elem_repr, container);

  () = () call Stream_reduce (nil, nil, elem_repr, container_repr, reducer,
                              initial_value, stream, ret);

  // Clean up
  ();
};
#endif