
module pyon.internal.stream;

#include "rts.h"
#include "debug.h"
#include "prim.h"
#include "apply_py.h"
#include "memory_py.h"
#include "structures.h"
#include "stream.h"

import procedure exit (int) -> ();

#include "new_pyasm_records.h"

// Allocate some memory.  Use the flag to determine what kind of allocation.
procedure inline allocate (bool is_pointerless, uint size) -> pointer {
  if (is_pointerless) {
    pointer primcall pyon_alloc_nopointers (size);
  } else {
    pointer primcall pyon_alloc (size);
  };
};

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  TAG_CON
};

procedure inline Stream_alloc () -> owned {
  s = pointer primcall pyon_alloc (sizeof Obj(StreamData));
  // FIXME: initialize header
  s @! Obj(StreamData).header.info = Stream_info;
  s as owned;
};


/*****************************************************************************/
/* histogram */

// Given a stream of integers, use the elements of the stream to compute a
// histogram.
function histogramArray
  (FinIndInt size, owned stream, pointer ret) -> () {
  typedef Stream = Obj(StreamData);

  FinIndInt {hist_size} = size;
  typedef arrayT = array(value hist_size, int);

  // Initialize histogram to zeros
  _ = while (int index = int 0) (index < hist_size) {
    ret @! arrayT[index] = int 0;
    index + int 1;
  };

  // Setup
  stream_init_state = stream @! Stream.payload.state;
  stream_next = stream @! Stream.payload.next;

  // Main loop.  Update histogram until stream is depleted.
  letrec {
    procedure pull (owned stream_state) -> () {
      // Pull a value from the stream
      StreamNext {stream_tag, StreamNextData {next_state, result_val}} =
        StreamNext call stream_next (stream_state);

      if (stream_tag == STREAM_VALUE) {
        // Add 1 to histogram entry, if not out-of-bounds
        insert_index = result_val @! Obj(int).payload;

        () = if (insert_index >= int 0 && insert_index < hist_size) {
          ret @! arrayT[insert_index] = ret @! arrayT[insert_index] + int 1;
          ();
        } else { (); };

        () primcall pull (next_state);
      } else { (); };
    }
  };

  () primcall pull (stream_init_state);
};

// Initialize a histogram with zeros.
// Call the given function to compute the histogram.
function inline createHistogram
  (FinIndInt size_ix, owned initializer, pointer ret) -> () {
  FinIndInt {size} = size_ix;
  typedef array_type = array (value size, int);

  // Fill the array with zeros 
  _ = while (int i = int 0) (i < size) {
    ret @! array_type[i] = int 0;
    i + int 1;
  };

  letrec {
    function write_histogram (int index) -> unit {
      ret @! array_type[index] = ret @! array_type[index] + int 1;
      nil;
    }
  };
  _ = unit call initializer(write_histogram, nil);
  ();
};

/*****************************************************************************/
/* Counting stream */

data owned Stream_count = Obj(StreamData) {
  ObjectHeader { Stream_info },
  StreamData {
    Stream_count_init_state,
    Stream_count_next
  }
};

data owned Stream_count_init_state = Boxed(int) {
  ObjectHeader { int_info },
  int 0
};

// Get the next value from a counting stream.
// Return the state, and also increment the state.
function Stream_count_next (owned state) -> StreamNext {
  counter = state @! Boxed(int).member;

  new_state = pointer primcall pyon_alloc (sizeof Boxed(int));
  new_state @! Boxed(int).member = counter + int 1;

  StreamNext {STREAM_VALUE, StreamNextData {new_state as owned, state}};
};
