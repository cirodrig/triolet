
module pyon.internal.stream;

#include "pyasm.h"
#include "memory_py.h"
#include "stream.h"
#include "apply_py.h"

#include "pyasm_records.h"

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  Stream_dealloc,
  TAG_CON
};

// Deallocate a Stream
procedure Stream_dealloc (pointer self) -> () {
  DECREF(self @! Stream.next as pointer)
  DECREF(self @! Stream.initialize as pointer)
  DECREF(self @! Stream.state_finalize as pointer)
  () primcall pyon_dealloc (self);
};

/*****************************************************************************/
/* return */

// A "return" stream produces one value, then quits.  The value is produced
// by calling a function.

// Create a stream that produces a single value
function Stream_return (PassConv return_type, owned produce_value) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)
  s @! Stream.next = owned call Stream_return_next(return_type, produce_value);
  s @! Stream.initialize = Stream_return_initialize;
  s @! Stream.state_size = sizeof bool;
  s @! Stream.state_align = alignof bool;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

function Stream_return_next (PassConv return_type,
                             owned produce_value,
                             pointer state,
                             pointer ret) -> bool {
  b = bool load state;
  if (b) {
    // Stream is depleted
    false;
  } else {
    // Stream has data
    !state = true;      // Remember that value was produced

    // Produce the value
    () = () call produce_value (ret);

    true;
  };
};

function Stream_return_initialize(pointer state) -> () {
  !state = false;
  ();
};

/*****************************************************************************/
/* bind */

/* The state of a chained stream consists of:
 *  1. The transformer stream (or NULL)
 *  2. The transformer stream's state (if transformer stream is not NULL)
 *  3. The producer stream's state
 *  4. The producer's current output value
 *
 * The current output value has to be stored because the transformer stream
 * may reference it.
 */
record Stream_bind_state {
  pointer transformer;          // Transformer stream (owned or NULL)
  pointer transformer_state;    // Transformer stream's state, or NULL
  pointer producer_state;       // Producer's state
  pointer temporary_state;      // Producer's current output value
                                // (if transformer stream is not NULL)
};

// Chain streams together.
function Stream_bind (PassConv produced_type,
                      PassConv transformed_type,
                      owned producer,
                      owned transformer) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)
  s @! Stream.next =
      owned call Stream_bind_next(produced_type, transformed_type,
                                  producer, transformer);
  s @! Stream.initialize =
      owned call Stream_bind_initialize(produced_type, transformed_type,
                                        producer);
  s @! Stream.state_size = sizeof Stream_bind_state;
  s @! Stream.state_align = alignof Stream_bind_state;
  s @! Stream.state_finalize =
      owned call Stream_bind_finalize(produced_type,
                                      producer @! Stream.state_finalize);
  s;
};

// Initialize a bound stream.
function Stream_bind_initialize (PassConv produced_type,
                                 PassConv transformed_type,
                                 owned producer,
                                 pointer state) -> () {
  // Initialize the transformer pointer
  state @! Stream_bind_state.transformer = null;
  state @! Stream_bind_state.transformer_state = null;

  // Initialize the producer state
  pstate =
      pointer primcall pyon_alloc(producer @! Stream.state_size);
  () = () call (producer @! Stream.initialize) (pstate);
  state @! Stream_bind_state.producer_state = pstate;

  // Allocate the temporary storage
  PassConv {produced_size, _, _, _} = produced_type;
  state @! Stream_bind_state.temporary_state =
      pointer primcall pyon_alloc (produced_size);

  ();
};

// Get the next value from the stream.
// First, try to pull from the transformer.
// If that is not successful, try to pull a new value from the producer, then
// create a transformer and try to pull a value from it again.
// If the transformer and producer are both depleted, the stream is depleted.
function Stream_bind_next(PassConv produced_type,
                          PassConv transformed_type,
                          owned producer,
                          owned mk_transformer,
                          pointer state,
                          pointer ret) -> bool {
  // Is transformer active?
  transformer = state @! Stream_bind_state.transformer;
  if (transformer != null) {
    // Call the transformer stream
    transformer = state @! Stream_bind_state.transformer as owned;
    transformer_state = state @! Stream_bind_state.transformer_state;
    b = bool call (transformer @! Stream.next) (transformer_state, ret);

    // Was a value produced?
    if (b) {
      // Done
      true;
    } else {
      // Transformer is depleted; release transformer
      () = () call (transformer @! Stream.state_finalize) (transformer_state);
      () = () primcall pyon_dealloc(transformer_state);
      DECREF(transformer as pointer)
      state @! Stream_bind_state.transformer = null;

      // Free temporary state
      PassConv {_, _, _, produced_type_finalize} = produced_type;
      () = () call produced_type_finalize
          (state @! Stream_bind_state.temporary_state);

      // Retry
      bool call Stream_bind_next(produced_type, transformed_type, producer,
                                 transformer, state, ret);
    };
  } else {
    // Produce a new value
    value_produced = bool call (producer @! Stream.next)
        (state @! Stream_bind_state.producer_state,
         state @! Stream_bind_state.temporary_state);
    
    if (value_produced) {
      // Run the transformer to create an output stream
      transformer_stream =
          owned call mk_transformer (state @! Stream_bind_state.temporary_state);

      // Begin producing from the output stream
      transformer_state =
        pointer primcall pyon_alloc (transformer_stream @! Stream.state_size);
      () = () call (transformer_stream @! Stream.initialize) (transformer_state);
      state @! Stream_bind_state.transformer_state = transformer_state;

      // Retry
      bool call Stream_bind_next(produced_type, transformed_type, producer,
                                 transformer, state, ret);
    } else {
      // Stream is depleted
      false;
    };
  };
};

function Stream_bind_finalize (PassConv produced_type,
                               owned finalize_producer,
                               pointer state) -> () {
  // Release the transformer
  transformer = state @! Stream_bind_state.transformer;
  () = if (transformer != null) {
    transformer = state @! Stream_bind_state.transformer as owned;
    transformer_state = state @! Stream_bind_state.transformer_state;
    () = () call (transformer @! Stream.state_finalize) (transformer_state);
    () = () primcall pyon_dealloc (transformer_state);
    DECREF(transformer as pointer)

    // Finalize the temporary state
    PassConv {_, _, _, finalize_temporary} = produced_type;
    () call finalize_temporary (state @! Stream_bind_state.temporary_state);
  } else {
    ();
  };
  // Free the temporary state
  () = () primcall pyon_dealloc (state @! Stream_bind_state.temporary_state);

  // Release the producer's state
  producer_state = state @! Stream_bind_state.producer_state;
  () = () call finalize_producer (producer_state);
  () primcall pyon_dealloc (producer_state);
};
