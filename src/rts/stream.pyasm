
module pyon.internal.stream;

#include "rts.h"
#include "debug.h"
#include "prim.h"
#include "apply_py.h"
#include "memory_py.h"
#include "structures.h"
#include "stream.h"

import procedure exit (int) -> ();

#include "new_pyasm_records.h"

// Allocate some memory.  Use the flag to determine what kind of allocation.
procedure inline allocate (bool is_pointerless, uint size) -> pointer {
  if (is_pointerless) {
    pointer primcall pyon_alloc_nopointers (size);
  } else {
    pointer primcall pyon_alloc (size);
  };
};

#if 0
// A dynamic shape value with no further information
data owned DynShapeUnit_value = Obj(unit) {
  ObjectHeader {DynShapeUnit_info},
  nil
};

data pointer DynShapeUnit_info = InfoTableHeader {
  TAG_CON
};
#endif

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  TAG_CON
};

procedure inline Stream_alloc () -> owned {
  s = pointer primcall pyon_alloc (sizeof Obj(StreamData));
  // FIXME: initialize header
  s @! Obj(StreamData).header.info = Stream_info;
  s as owned;
};


/*****************************************************************************/
/* Counting stream */

data owned Stream_count = Obj(StreamData) {
  ObjectHeader { Stream_info },
  StreamData {
    Stream_count_init_state,
    Stream_count_next
  }
};

data owned Stream_count_init_state = Boxed(int) {
  ObjectHeader { int_info },
  int 0
};

// Get the next value from a counting stream.
// Return the state, and also increment the state.
function Stream_count_next (owned state) -> StreamNext {
  counter = state @! Boxed(int).member;

  new_state = pointer primcall pyon_alloc (sizeof Boxed(int));
  new_state @! Boxed(int).member = counter + int 1;

  StreamNext {STREAM_VALUE, StreamNextData {new_state as owned, state}};
};
