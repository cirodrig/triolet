
module pyon.internal.stream;

#include "rts.h"
#include "debug.h"
#include "memory_py.h"
#include "stream.h"
#include "apply_py.h"

#include "pyasm_records.h"

// The info table of a stream
data pointer Stream_info = InfoTableHeader {
  Stream_dealloc,
  TAG_CON
};

function passConv_iter (unit _, pointer _, pointer ret) -> () {
  ret @! PassConv.size = sizeof Stream;
  ret @! PassConv.align = sizeof Stream;
  ret @! PassConv.copy = Stream_copy;
  ret @! PassConv.finalize = Stream_dealloc;
  ();
};

procedure Stream_copy (pointer src, pointer dst) -> () {
  dst @! Stream.next = src @! Stream.next;
  dst @! Stream.initialize = src @! Stream.initialize;
  dst @! Stream.return_repr.size = src @! Stream.return_repr.size;
  dst @! Stream.return_repr.align = src @! Stream.return_repr.align;
  dst @! Stream.return_repr.copy = src @! Stream.return_repr.copy;
  dst @! Stream.return_repr.finalize = src @! Stream.return_repr.finalize;
  dst @! Stream.state_size = src @! Stream.state_size;
  dst @! Stream.state_align = src @! Stream.state_align;
  dst @! Stream.state_finalize = src @! Stream.state_finalize;
  ();  
};

// Deallocate a Stream
procedure Stream_dealloc (pointer self) -> () {
  // Not implemented
  ();
};

/*****************************************************************************/
/* return */

// A "return" stream produces one value, then quits.  The value is produced
// by calling a function.

// Create a stream that produces a single value
function Stream_return (unit _, unit _,
                        pointer return_type_repr,
                        owned produce_value) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)
  s @! Stream.next = owned call Stream_return_next(s @ Stream.return_repr,
                                                   produce_value);
  s @! Stream.initialize = Stream_return_initialize;
  s @! Stream.return_repr.size = return_type_repr @! PassConv.size;
  s @! Stream.return_repr.align = return_type_repr @! PassConv.align;
  s @! Stream.return_repr.copy = return_type_repr @! PassConv.copy;
  s @! Stream.return_repr.finalize = return_type_repr @! PassConv.finalize;
  s @! Stream.state_size = sizeof bool;
  s @! Stream.state_align = alignof bool;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

function Stream_return_next (pointer return_type_repr,
                             owned produce_value,
                             pointer state,
                             pointer ret) -> bool {
  b = bool load state;
  if (b) {
    // Stream is depleted
    false;
  } else {
    // Stream has data
    !state = true;      // Remember that value was produced

    // Produce the value
    () = () call produce_value (ret);

    true;
  };
};

function Stream_return_initialize(pointer state) -> () {
  !state = false;
  ();
};

/*****************************************************************************/
/* bind */

/* The state of a chained stream consists of:
 *  1. The transformer stream (or NULL)
 *  2. The transformer stream's state (if transformer stream is not NULL)
 *  3. The producer stream's state
 *  4. The producer's current output value
 *
 * The current output value has to be stored because the transformer stream
 * may reference it.
 */
record Stream_bind_state {
  pointer transformer;          // Transformer stream (owned or NULL)
  pointer transformer_state;    // Transformer stream's state, or NULL
  pointer producer_state;       // Producer's state
  pointer temporary_state;      // Producer's current output value
                                // (if transformer stream is not NULL)
  PassConv produced_repr;
};

// Chain streams together.
function Stream_bind (unit _, unit _, unit _,
                      pointer produced_type_repr,
                      pointer transformed_type_repr,
                      owned producer,
                      owned transformer) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)
  produced_type_size = produced_type_repr @! PassConv.size;
  produced_type_fini = produced_type_repr @! PassConv.finalize;
  s @! Stream.next =
      owned call Stream_bind_next(produced_type_fini, producer, transformer);
  s @! Stream.initialize =
      owned call Stream_bind_initialize(produced_type_size, producer);
  s @! Stream.return_repr.size = transformed_type_repr @! PassConv.size;
  s @! Stream.return_repr.align = transformed_type_repr @! PassConv.align;
  s @! Stream.return_repr.copy = transformed_type_repr @! PassConv.copy;
  s @! Stream.return_repr.finalize = transformed_type_repr @! PassConv.finalize;
  s @! Stream.state_size = sizeof Stream_bind_state;
  s @! Stream.state_align = alignof Stream_bind_state;
  s @! Stream.state_finalize =
      owned call Stream_bind_finalize(produced_type_fini,
                                      producer @! Stream.state_finalize);
  s;
};

// Initialize a bound stream.
function Stream_bind_initialize (word produced_type_size,
                                 owned producer,
                                 pointer state) -> () {
  // Initialize the transformer pointer
  state @! Stream_bind_state.transformer = null;
  state @! Stream_bind_state.transformer_state = null;

  // Initialize the producer state
  pstate =
      pointer primcall pyon_alloc(producer @! Stream.state_size);
  () = () call (producer @! Stream.initialize) (pstate);
  state @! Stream_bind_state.producer_state = pstate;

  // Allocate the temporary storage
  state @! Stream_bind_state.temporary_state =
      pointer primcall pyon_alloc (produced_type_size);

  ();
};

// Get the next value from the stream.
// First, try to pull from the transformer.
// If that is not successful, try to pull a new value from the producer, then
// create a transformer and try to pull a value from it again.
// If the transformer and producer are both depleted, the stream is depleted.
function Stream_bind_next(owned produced_type_fini,
                          owned producer,
                          owned mk_transformer,
                          pointer state,
                          pointer ret) -> bool {
  letrec {
    function loop (int _) -> bool {
      // Is transformer active?
      transformer = state @! Stream_bind_state.transformer;
      if (transformer != null) {
        // Call the transformer stream
        transformer = state @! Stream_bind_state.transformer as owned;
        transformer_state = state @! Stream_bind_state.transformer_state;
        b = bool call (transformer @! Stream.next) (transformer_state, ret);

        // Was a value produced?
        if (b) {
          // Done
          true;
        } else {
          // Transformer is depleted; release transformer
          () = () call (transformer @! Stream.state_finalize) (transformer_state);
          () = () primcall pyon_dealloc(transformer_state);
          // DECREF(transformer as pointer)
          state @! Stream_bind_state.transformer = null;

          // Free temporary state
          () = () call produced_type_fini
              (state @! Stream_bind_state.temporary_state);

          // Retry
          bool call loop (int 0);
        };
      } else {
        // Produce a new value
        value_produced = bool call (producer @! Stream.next)
            (state @! Stream_bind_state.producer_state,
             state @! Stream_bind_state.temporary_state);
        
        if (value_produced) {
          // Run the transformer to create an output stream
          transformer_stream =
              owned call mk_transformer (state @! Stream_bind_state.temporary_state);

          // Begin producing from the output stream
          transformer_state =
            pointer primcall pyon_alloc (transformer_stream @! Stream.state_size);
          () = () call (transformer_stream @! Stream.initialize) (transformer_state);

          // Retry, with the new transformer stream
          state @! Stream_bind_state.transformer = transformer_stream;
          state @! Stream_bind_state.transformer_state = transformer_state;
          bool call loop (int 0);
        } else {
          // Stream is depleted
          false;
        };
      };
    }
  };
  bool call loop (int 0);
};

function Stream_bind_finalize (owned produced_type_fini,
                               owned finalize_producer,
                               pointer state) -> () {
  // Release the transformer
  transformer_ptr = state @! Stream_bind_state.transformer;
  () = if (transformer_ptr != null) {
    transformer = state @! Stream_bind_state.transformer as owned;
    transformer_state = state @! Stream_bind_state.transformer_state;
    () = () call (transformer @! Stream.state_finalize) (transformer_state);
    () = () primcall pyon_dealloc (transformer_state);
    // DECREF(transformer_ptr)

    // Finalize the temporary state
    () call produced_type_fini (state @! Stream_bind_state.temporary_state);
  } else {
    ();
  };
  // Free the temporary state
  () = () primcall pyon_dealloc (state @! Stream_bind_state.temporary_state);

  // Release the producer's state
  producer_state = state @! Stream_bind_state.producer_state;
  () = () call finalize_producer (producer_state);
  () primcall pyon_dealloc (producer_state);
};

/*****************************************************************************/
/* generate */

// A stream consisting of the sequence f(0), f(1), ... f(limit-1).
// The stream state holds the next value to generate.
function Stream_generate
  (unit _, unit _, pointer return_conv, int limit, owned f) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)

  s @! Stream.next = owned call Stream_generate_next(limit, f);
  s @! Stream.initialize = Stream_generate_initialize;
  s @! Stream.return_repr.size = return_conv @! PassConv.size;
  s @! Stream.return_repr.align = return_conv @! PassConv.align;
  s @! Stream.return_repr.copy = return_conv @! PassConv.copy;
  s @! Stream.return_repr.finalize = return_conv @! PassConv.finalize;
  s @! Stream.state_size = sizeof int;
  s @! Stream.state_align = alignof int;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

function Stream_generate_next
  (int limit, owned f, pointer state, pointer ret) -> bool {
  // Get the current counter value
  n = int load state;
  if (n >= limit) {
    // Stream is depleted
    false;
  } else {
    // Update the counter
    !state = n + int 1;
    // Produce a value
    () = () call f (n, ret);
    true;
  };
};

function Stream_generate_initialize (pointer state) -> () {
  !state = int 0;
  ();
};

/*****************************************************************************/
/* map */

// State of Stream_map.
// The state consists of the produced value's representation and temporary
// storage for the produced value.
record Stream_map_state {
  pointer producer_state;           // State of producer stream
  pointer temporary_state;          // Holds output of producer
};

function Stream_map
  (unit _, unit _, unit _,
   pointer produced_repr, pointer transformed_repr,
   owned transformer, owned producer) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)

  s @! Stream.next = owned call Stream_map_next
    (transformer, producer, produced_repr @! PassConv.finalize);
  s @! Stream.initialize = owned call Stream_map_initialize
    (transformed_repr @! PassConv.size,
     transformed_repr @! PassConv.align,
     producer);
  s @! Stream.return_repr.size = transformed_repr @! PassConv.size;
  s @! Stream.return_repr.align = transformed_repr @! PassConv.align;
  s @! Stream.return_repr.copy = transformed_repr @! PassConv.copy;
  s @! Stream.return_repr.finalize = transformed_repr @! PassConv.finalize;
  s @! Stream.state_size = sizeof Stream_map_state;
  s @! Stream.state_align = alignof Stream_map_state;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};
        
function Stream_map_next
  (owned transformer, owned producer, owned finalize_produced_state,
   pointer state, pointer ret) -> bool {
  temporary_state = state @! Stream_map_state.temporary_state;
  // Run the producer
  b = bool call (producer @! Stream.next)
    (state @! Stream_map_state.producer_state, temporary_state);

  if (b) {
    // Transform its result
    () = () call transformer (temporary_state, ret);

    // Finalize the temporary data
    () = () call finalize_produced_state (temporary_state);
    true;
  } else {
    false;
  };
};

function Stream_map_initialize
  (word produced_size, word produced_align, owned producer, pointer state) -> () {
  producer_state = pointer primcall pyon_alloc (producer @! Stream.state_size);
  () = () call (producer @! Stream.initialize) (producer_state);

  state @! Stream_map_state.producer_state = producer_state;
  state @! Stream_map_state.temporary_state =
    pointer primcall pyon_alloc (produced_size);
  ();
};

/*****************************************************************************/
/* reduce */

function inline Stream_reduce
  (unit _, unit _,
   pointer passconv, pointer _,
   owned reducer,
   pointer init,
   owned stream,
   pointer ret) -> () {
  elem_size = passconv @! PassConv.size;
  elem_align = passconv @! PassConv.align;
  elem_copy = passconv @! PassConv.copy;
  elem_finalize = passconv @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);

  // Setup
  st = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call (stream @! Stream.initialize) (st);

  // Allocate two accumulators and swap between them.
  // That way, the accumulator can be updated safely.
  accs = pointer primcall pyon_alloc (sizeof Pair(elem_type));
  reduce_tmp = pointer primcall pyon_alloc (elem_size);
  stream_next = stream @! Stream.next;
  () = () call elem_copy (accs @ Pair(elem_type).fst, init);

  // Main loop.
  // At start, old_acc holds accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  // At termination, old_acc holds final accumulator, new_acc is uninitialized,
  // reduce_tmp is uninitialized.
  (acc1, acc2, _) = while (pointer old_acc = accs @ Pair(elem_type).fst,
                           pointer new_acc = accs @ Pair(elem_type).snd,
                           bool not_depleted = true)
                          (not_depleted) {
    not_depleted = bool call stream_next (st, reduce_tmp);
    if (not_depleted) {
      () = () call reducer (old_acc, reduce_tmp, new_acc);
      () = () call elem_finalize (old_acc);
      () = () call elem_finalize (reduce_tmp);
      (new_acc, old_acc, true);
    } else {
      (old_acc, new_acc, false);
    };
  };

  // Cleanup
  () = () call (stream @! Stream.state_finalize) (st);
  () = () call elem_copy (acc1, ret);
  () = () call elem_finalize (acc1);
  () = () primcall pyon_dealloc(accs);
  ();
};


function inline reduce
  (unit _, unit _, unit _,
   pointer traversable,
   pointer elem_repr,
   pointer container_repr,
   owned reducer,
   pointer initial_value,
   pointer container,
   pointer ret) -> () {
  // Traverse the object and reduce the resulting stream
  stream = owned call (traversable @! TraversableDict.traverse)
                      (nil, elem_repr, container);

  () = () call Stream_reduce (nil, nil, elem_repr, container_repr, reducer,
                              initial_value, stream, ret);

  // Clean up
  ();
};
