
module pyon.internal.list;

#include "rts.h"
#include "debug.h"
#include "prim.h"
#include "memory_py.h"
#include "apply_py.h"
#include "stream.h"
#include "list.h"
#include "structures.h"

import procedure exit "exit" (int) -> ();

#include "new_pyasm_records.h"

function repr_list (owned elem_repr) -> owned {
  repr = pointer primcall pyon_alloc (sizeof PassConv);

  // FIXME: Initialize repr header
  repr @! PassConv.size = sizeof PyonList;
  repr @! PassConv.align = alignof PyonList;
  repr @! PassConv.is_pointerless = NOT_POINTERLESS;
  copy_function = owned call list_copy (elem_repr);
  repr @! PassConv.copy = copy_function;
  repr @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof PyonList, alignof PyonList);
  repr @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof PyonList, alignof PyonList, copy_function);
  repr @! PassConv.finalize = owned call list_finalize (elem_repr);
  repr as owned;
};

function list_copy (owned elem_repr, pointer src, pointer dst) -> () {
  nelems_ii = src @! PyonList.nelems;
  dst @! PyonList.nelems = nelems_ii;
  FinIndInt {nelems} = nelems_ii;

  // Copy list elements
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  copy_elem = elem_repr @! PassConv.copy;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef src_contents_type = const_array(value nelems, elem_type);
  typedef dst_contents_type = array(value nelems, elem_type);

  src_contents = src @! PyonList.contents;
  dst_contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof dst_contents_type);
  } else {
    pointer primcall pyon_alloc (sizeof dst_contents_type);
  };
  dst @! PyonList.contents = dst_contents;

  _ = while (int index = int 0) (index < nelems) {
    () = () call copy_elem (src_contents @ src_contents_type[index],
                            dst_contents @ dst_contents_type[index]);
    index + int 1;
  };
  ();
};

function list_finalize (owned elem_repr, pointer list) -> () {
  FinIndInt {nelems} = list @! PyonList.nelems;
  contents = list @! PyonList.contents;

  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  finalize_elem = elem_repr @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef contents_type = array(value nelems, elem_type);

  _ = while (int index = int 0) (index < nelems) {
    () = () call finalize_elem (contents @ contents_type[index]);
    index + int 1;
  };
  ();
};

// Create a list, leaving its elements uninitialized
procedure list_create_uninitialized (owned elem_repr,
                                     int nelems,
                                     pointer list) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value nelems, elem_type);
  
  list @! PyonList.nelems = FinIndInt {nelems};
  list @! PyonList.contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof array_type);
  } else {
    pointer primcall pyon_alloc (sizeof array_type);
  };
  ();
};

// Increase the size of a list.  The list's 'contents' field may be modified.
// The list's 'size' field is ignored.
// Returns the new list size.
//
// The old list contents are
// copied to the new list; the new contents are uninitialized.
procedure list_grow (pointer elem_repr, pointer list, int old_size) -> int {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);

  typedef old_array_type = array(value old_size, elem_type);
  new_size = old_size * int 2;
  typedef new_array_type = array(value new_size, elem_type);

  old_contents = list @! PyonList.contents;
  new_contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof new_array_type);
  } else {
    pointer primcall pyon_alloc (sizeof new_array_type);
  };

  // Copy old contents to new list
  _ = pointer primcall memcpy (new_contents,
                               old_contents,
                               sizeof old_array_type);

  // Free old contents
  () = () primcall pyon_dealloc(old_contents);

  // Save new list contents.
  // Don't save the new size anywhere; caller is responsible for keeping
  // track.
  list @! PyonList.contents = new_contents;
  new_size;
};

// Get the length of a list
function inline list_len (pointer p) -> int {
  FinIndInt {n} = p @! PyonList.nelems;
  n;
};

// Create a list from a stream of unknown size
function list_build
    (owned elem_repr, owned stream, pointer ret) -> () {
  typedef Stream = Obj(StreamData);

  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value int 0, elem_type);

  // Initialize list with 4 elements
  list_size = int 4;
  () = () primcall list_create_uninitialized (elem_repr, list_size, ret);

  // Set up stream
  stream_init_state = stream @! Stream.payload.state;
  stream_next = stream @! Stream.payload.next;

  // Populate the list contents (pull_values); then finish building the list.
  letrec {
    procedure pull_values (int n_elems, int list_size, owned stream_state) -> () {
      // Make sure list can hold another element
      new_list_size = if (n_elems == list_size) {
        int primcall list_grow (elem_repr, ret, list_size);
      } else {
        list_size;
      };

      // Pull from the stream
      StreamNext {result_tag, StreamNextData {next_state, result_val}} =
        StreamNext call stream_next (stream_state);

      if (result_tag == STREAM_VALUE) {
        // Copy this value to the destination.
        // The value was stored as a boxed object; convert it to a bare object.
        current_elem = (ret @! PyonList.contents) @ array_type[n_elems];
        () = () call (elem_repr @! PassConv.convert_to_bare) (result_val, current_elem);

        // Continue pulling
        () primcall pull_values (n_elems + int 1, new_list_size, next_state);
      } else {
        // Stream is depleted.  Finish constructing list.
        () primcall finish (n_elems);
      };
    };

    procedure finish (int n_elems) -> () {
      // Save the number of list elements that was created
      ret @! PyonList.nelems = FinIndInt {n_elems};
      ();   
    }
  };
  () primcall pull_values (int 0, list_size, stream_init_state);
};

// Allocate and construct a list, given a suitably initialized data array.
// The data array is stolen by the list.
// A pointer to the new list is returned.
procedure pyon_list_from_array (int n_elems,
                                pointer arr) -> pointer {
  l = pointer primcall pyon_alloc (sizeof PyonList);
  l @! PyonList.nelems = FinIndInt {n_elems};
  l @! PyonList.contents = arr;
  l;
};

// Copy the contents of a plain-old-data list into an array.
// The list is not modified.
procedure pyon_list_to_array_POD (owned elem_repr,
                                  pointer list,
                                  pointer arr) -> () {
  FinIndInt {n_elems} = list @! PyonList.nelems;
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value n_elems, elem_type);

  () = () primcall memcpy
    (arr,
     list @! PyonList.contents,
     sizeof array_type);
  ();
};

procedure pyon_list_length (pointer list) -> int {
  FinIndInt {n} = list @! PyonList.nelems;
  n;
};

// Allocate and return a copy of the POD list.
procedure pyon_list_copy_POD (owned elem_repr, pointer in_list) -> pointer {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  FinIndInt {nelems} = in_list @! PyonList.nelems;
  typedef array_type = array(value nelems, bytes(value elem_size, value elem_align));

  // Create a copy of the data array
  contents = pointer primcall pyon_alloc(sizeof array_type);
  () = () primcall memcpy
    (contents, in_list @! PyonList.contents, sizeof array_type);

  // Create and return a new list object
  pointer primcall pyon_list_from_array (nelems, contents);
};

// Free the POD list.
procedure pyon_list_free_POD (pointer list) -> () {
  () = () primcall pyon_dealloc(list @! PyonList.contents);
  () primcall pyon_dealloc(list);
};

///////////////////////////////////////////////////////////////////////////////
// Matrix functions

function repr_array2 (owned elem_repr) -> owned {
  repr = pointer primcall pyon_alloc (sizeof PassConv);

  // FIXME: initialize repr header
  repr @! PassConv.size = sizeof PyonArray2;
  repr @! PassConv.align = alignof PyonArray2;
  repr @! PassConv.is_pointerless = NOT_POINTERLESS;
  copy_function = owned call matrix_copy (elem_repr);
  repr @! PassConv.copy = copy_function;
  repr @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof PyonArray2, alignof PyonArray2);
  repr @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof PyonArray2, alignof PyonArray2, copy_function);
  repr @! PassConv.finalize = owned call matrix_finalize (elem_repr);
  repr as owned;
};

function matrix_copy (owned elem_repr, pointer src, pointer dst) -> () {
  first_y = src @! PyonArray2.first_y;
  stride_y = src @! PyonArray2.stride_y;
  FinIndInt {size_y} = src @! PyonArray2.size_y;
  first_x = src @! PyonArray2.first_x;
  stride_x = src @! PyonArray2.stride_x;
  FinIndInt {size_x} = src @! PyonArray2.size_x;
  src_contents = src @! PyonArray2.contents;

  dst @! PyonArray2.first_y = first_y;
  dst @! PyonArray2.stride_y = stride_y;
  dst @! PyonArray2.size_y = FinIndInt {size_y};
  dst @! PyonArray2.first_x = first_x;
  dst @! PyonArray2.stride_x = stride_x;
  dst @! PyonArray2.size_x = FinIndInt {size_x};

  // Copy list elements
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  copy_elem = elem_repr @! PassConv.copy;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef src_contents_type =
    const_array (value size_y, const_array(value size_x, elem_type));
  typedef dst_contents_type =
    array(value size_y, array(value size_x, elem_type));

  dst_contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof dst_contents_type);
  } else {
    pointer primcall pyon_alloc (sizeof dst_contents_type);
  };
  dst @! PyonArray2.contents = dst_contents;

  _ = while (int yindex = int 0) (yindex < size_y) {
    _ = while (int xindex = int 0) (xindex < size_x) {
      () = () call copy_elem (src_contents @ src_contents_type[yindex][xindex],
                              dst_contents @ dst_contents_type[yindex][xindex]);
      xindex + int 1;
    };
    yindex + int 1;
  };
  ();
};

function matrix_finalize (owned elem_repr, pointer matrix) -> () {
  FinIndInt {size_y} = matrix @! PyonArray2.size_y;
  FinIndInt {size_x} = matrix @! PyonArray2.size_x;
  contents = matrix @! PyonArray2.contents;

  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  finalize_elem = elem_repr @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef contents_type = array(value size_y, array(value size_x, elem_type));

  _ = while (int yindex = int 0) (yindex < size_y) {
    _ = while (int xindex = int 0) (xindex < size_x) {
      () = () call finalize_elem (contents @ contents_type[yindex][xindex]);
      xindex + int 1;
    };
    yindex + int 1;
  };
  ();
};

// Allocate and construct a matrix, given a suitably initialized data array.
// The data array is stolen by the matrix.
// A pointer to the new matrix is returned.
procedure pyon_matrix_from_array
  (int ymin, int ystride, int ysize,
   int xmin, int xstride, int xsize, pointer contents) -> pointer {
  mat = pointer primcall pyon_alloc (sizeof PyonArray2);
  mat @! PyonArray2.first_y = ymin;
  mat @! PyonArray2.stride_y = ystride;
  mat @! PyonArray2.size_y = FinIndInt {ysize};
  mat @! PyonArray2.first_x = xmin;
  mat @! PyonArray2.stride_x = xstride;
  mat @! PyonArray2.size_x = FinIndInt {xsize};
  mat @! PyonArray2.contents = contents;
  mat;
};

// Copy the contents of a plain-old-data matrix into an array.
// The matrix is not modified.
procedure pyon_matrix_to_array_POD (owned elem_repr,
                                    pointer mat,
                                    pointer arr) -> () {
  FinIndInt {h} = mat @! PyonArray2.size_y;
  FinIndInt {w} = mat @! PyonArray2.size_x;
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value h * w, elem_type);

  () = () primcall memcpy
    (arr,
     mat @! PyonArray2.contents,
     sizeof array_type);
  ();
};

// Allocate and return a copy of the POD matrix.
procedure pyon_matrix_copy_POD (owned elem_repr, pointer in_mat) -> pointer {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;

  ymin = in_mat @! PyonArray2.first_y;
  xmin = in_mat @! PyonArray2.first_x;
  ystride = in_mat @! PyonArray2.stride_y;
  xstride = in_mat @! PyonArray2.stride_x;
  FinIndInt {h} = in_mat @! PyonArray2.size_y;
  FinIndInt {w} = in_mat @! PyonArray2.size_x;
  typedef array_type = array(value h * w, bytes(value elem_size, value elem_align));

  // Create a copy of the data array
  contents = pointer primcall pyon_alloc(sizeof array_type);
  () = () primcall memcpy
    (contents, in_mat @! PyonArray2.contents, sizeof array_type);

  // Create and return a new matrix object
  pointer primcall pyon_matrix_from_array (ymin, ystride, h,
                                           xmin, xstride, w, contents);
};

// Free the POD matrix.
procedure pyon_matrix_free_POD (pointer mat) -> () {
  () = () primcall pyon_dealloc(mat @! PyonArray2.contents);
  () primcall pyon_dealloc(mat);
};

///////////////////////////////////////////////////////////////////////////////
// Exported to C for the C++ interface

data pointer pyon_List_size = sizeof PyonList;
data pointer pyon_List_alignment = alignof PyonList;

// Allocate a boxed list with the given length.
// The boolean parameter is true if the list contains POD data.
procedure pyon_List_initialize
  (int length, uint elt_size, uint elt_align, pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value length, elt_type);
  ret @! PyonList.nelems = FinIndInt {length};
  ret @! PyonList.contents = pointer primcall pyon_alloc(sizeof array_type);
  ();
};

procedure pyon_List_get_contents (pointer lst) -> pointer {
  lst @! PyonList.contents;
};

procedure pyon_Array0_size (uint size, uint align) -> uint {
  sizeof PyonArray0(bytes(value size, value align));
};

procedure pyon_Array0_alignment (uint size, uint align) -> uint {
  alignof PyonArray0(bytes(value size, value align));
};

procedure pyon_Array0_get_contents
  (pointer arr, uint size, uint align) -> pointer {
  arr @ PyonArray0(bytes(value size, value align)).content;
};

data pointer pyon_Array1_size = sizeof PyonArray1;
data pointer pyon_Array1_alignment = alignof PyonArray1;

procedure pyon_Array1_initialize
  (int min, int stride, int size, uint elt_size, uint elt_align,
   pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value size, elt_type);

  ret @! PyonArray1.first = min;
  ret @! PyonArray1.stride = stride;
  ret @! PyonArray1.size = FinIndInt {size};
  ret @! PyonArray1.contents = pointer primcall pyon_alloc(sizeof array_type);
  ();
};

procedure pyon_Array1_get_contents (pointer arr) -> pointer {
  arr @! PyonArray1.contents;
};

procedure pyon_Array1_get_bounds (pointer arr) -> PyonTuple3(int, int, int)
{
  FinIndInt {size} = arr @! PyonArray1.size;
  PyonTuple3(int, int, int)
  {arr @! PyonArray1.first,
   arr @! PyonArray1.stride,
   size};
};


data pointer pyon_Array2_size = sizeof PyonArray2;
data pointer pyon_Array2_alignment = alignof PyonArray2;

procedure pyon_Array2_initialize
  (int y_min, int y_stride, int y_size, int x_min, int x_stride, int x_size,
   uint elt_size, uint elt_align, pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value y_size, array(value x_size, elt_type));

  ret @! PyonArray2.first_y = y_min;
  ret @! PyonArray2.stride_y = y_stride;
  ret @! PyonArray2.size_y = FinIndInt {y_size};
  ret @! PyonArray2.first_x = x_min;
  ret @! PyonArray2.stride_x = x_stride;
  ret @! PyonArray2.size_x = FinIndInt {x_size};
  ret @! PyonArray2.contents = pointer primcall pyon_alloc(sizeof array_type);
  ();
};

procedure pyon_Array2_get_contents (pointer arr) -> pointer {
  arr @! PyonArray2.contents;
};

procedure pyon_Array2_get_bounds (pointer arr)
  -> PyonTuple6(int, int, int, int, int, int)
{
  FinIndInt {size_y} = arr @! PyonArray2.size_y;
  FinIndInt {size_x} = arr @! PyonArray2.size_x;
  PyonTuple6(int, int, int, int, int, int)
  {arr @! PyonArray2.first_y,
   arr @! PyonArray2.stride_y,
   size_y,
   arr @! PyonArray2.first_x,
   arr @! PyonArray2.stride_x,
   size_x};
};

///////////////////////////////////////////////////////////////////////////////
// Exported to C for the C interface

// Create a list from an array of CInt.
// The list holds a copy of the given array.
procedure pyon_List_PyonInt_FromArray (int n_elems, pointer arr) -> pointer {
  typedef array_type = array(value n_elems, int);
 
  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy (new_arr, arr, sizeof array_type);
  pointer primcall pyon_list_from_array(n_elems, new_arr);
};

// Copy the contents of a list into an array
procedure pyon_List_PyonInt_ToArray (pointer list, pointer dat) -> () {
  () primcall pyon_list_to_array_POD (repr_int, list, dat);
};

procedure pyon_List_PyonInt_Length (pointer list) -> int {
  l = int primcall pyon_list_length (list);
  l as int;
};

procedure pyon_List_PyonInt_Copy (pointer list) -> pointer {
  pointer primcall pyon_list_copy_POD (repr_int, list);
};

procedure pyon_List_PyonInt_Free (pointer list) -> () {
  pointer primcall pyon_list_free_POD (list);
};


procedure pyon_List_PyonFloat_FromArray (int n_elems, pointer arr) -> pointer {
  typedef array_type = array(value n_elems, float);
 
  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy (new_arr, arr, sizeof array_type);
  pointer primcall pyon_list_from_array(n_elems, new_arr);
};

// Copy the contents of a list into an array
procedure pyon_List_PyonFloat_ToArray (pointer list, pointer dat) -> () {
  () primcall pyon_list_to_array_POD (repr_float, list, dat);
};

procedure pyon_List_PyonFloat_Length (pointer list) -> int {
  l = int primcall pyon_list_length (list);
  l as int;
};

procedure pyon_List_PyonFloat_Copy (pointer list) -> pointer {
  pointer primcall pyon_list_copy_POD (repr_float, list);
};

procedure pyon_List_PyonFloat_Free (pointer list) -> () {
  pointer primcall pyon_list_free_POD (list);
};

procedure pyon_Matrix_PyonInt_FromArray
  (int ymin, int yend, int xmin, int xend, pointer arr) -> pointer {
  height = yend - ymin;
  width = xend - xmin;
  n_elems = height * width;
  typedef array_type = array(value n_elems, int);

  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy(new_arr, arr, sizeof array_type);
  pointer primcall pyon_matrix_from_array(ymin, int 1, height, xmin, int 1, width, new_arr);
};

procedure pyon_Matrix_PyonInt_ToArray(pointer mat, pointer dat) -> () {
  () primcall pyon_matrix_to_array_POD (repr_int, mat, dat);
};

procedure pyon_Matrix_PyonInt_Height (pointer mat) -> int {
  mat @! PyonArray2.size_y;
};

procedure pyon_Matrix_PyonInt_Width (pointer mat) -> int {
  mat @! PyonArray2.size_x;
};

procedure pyon_Matrix_PyonInt_Copy (pointer mat) -> pointer {
  pointer primcall pyon_matrix_copy_POD (repr_int, mat);
};

procedure pyon_Matrix_PyonInt_Free (pointer mat) -> () {
  pointer primcall pyon_matrix_free_POD (mat);
};

procedure pyon_Matrix_PyonFloat_FromArray
  (int ymin, int yend, int xmin, int xend, pointer arr) -> pointer {
  height = yend - ymin;
  width = xend - xmin;
  n_elems = height * width;
  typedef array_type = array(value n_elems, float);

  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy(new_arr, arr, sizeof array_type);
  pointer primcall pyon_matrix_from_array(ymin, int 1, height, xmin, int 1, width, new_arr);
};

procedure pyon_Matrix_PyonFloat_ToArray(pointer mat, pointer dat) -> () {
  () primcall pyon_matrix_to_array_POD (repr_float, mat, dat);
};

procedure pyon_Matrix_PyonFloat_Height (pointer mat) -> int {
  mat @! PyonArray2.size_y;
};

procedure pyon_Matrix_PyonFloat_Width (pointer mat) -> int {
  mat @! PyonArray2.size_x;
};

procedure pyon_Matrix_PyonFloat_Copy (pointer mat) -> pointer {
  pointer primcall pyon_matrix_copy_POD (repr_float, mat);
};

procedure pyon_Matrix_PyonFloat_Free (pointer mat) -> () {
  pointer primcall pyon_matrix_free_POD (mat);
};
