
module pyon.internal.list;

#include "rts.h"
#include "debug.h"
#include "prim.h"
#include "memory_py.h"
#include "apply_py.h"
#include "stream.h"
#include "list.h"
#include "structures.h"

import procedure exit "exit" (int) -> ();

#include "new_pyasm_records.h"

function repr_list (owned elem_repr) -> owned {
  repr = pointer primcall pyon_alloc (sizeof PassConv);

  // FIXME: Initialize repr header
  repr @! PassConv.size = sizeof PyonList;
  repr @! PassConv.align = alignof PyonList;
  repr @! PassConv.is_pointerless = NOT_POINTERLESS;
  copy_function = owned call list_copy (elem_repr);
  repr @! PassConv.copy = copy_function;
  repr @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof PyonList, alignof PyonList);
  repr @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof PyonList, alignof PyonList, copy_function);
  repr @! PassConv.finalize = owned call list_finalize (elem_repr);
  repr as owned;
};

function list_copy (owned elem_repr, pointer src, pointer dst) -> () {
  nelems_ii = src @! PyonList.nelems;
  dst @! PyonList.nelems = nelems_ii;
  FinIndInt {nelems} = nelems_ii;

  // Copy list elements
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  copy_elem = elem_repr @! PassConv.copy;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef src_contents_type = const_array(value nelems, elem_type);
  typedef dst_contents_type = array(value nelems, elem_type);

  src_contents = src @! PyonList.contents;
  dst_contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof dst_contents_type);
  } else {
    pointer primcall pyon_alloc (sizeof dst_contents_type);
  };
  dst @! PyonList.contents = dst_contents;

  _ = while (int index = int 0) (index < nelems) {
    () = () call copy_elem (src_contents @ src_contents_type[index],
                            dst_contents @ dst_contents_type[index]);
    index + int 1;
  };
  ();
};

function list_finalize (owned elem_repr, pointer list) -> () {
  FinIndInt {nelems} = list @! PyonList.nelems;
  contents = list @! PyonList.contents;

  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  finalize_elem = elem_repr @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef contents_type = array(value nelems, elem_type);

  _ = while (int index = int 0) (index < nelems) {
    () = () call finalize_elem (contents @ contents_type[index]);
    index + int 1;
  };
  ();
};

// Create a list, leaving its elements uninitialized
procedure list_create_uninitialized (owned elem_repr,
                                     int nelems,
                                     pointer list) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value nelems, elem_type);
  
  list @! PyonList.nelems = FinIndInt {nelems};
  list @! PyonList.contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof array_type);
  } else {
    pointer primcall pyon_alloc (sizeof array_type);
  };
  ();
};

// Increase the size of a list.  The list's 'contents' field may be modified.
// The list's 'size' field is ignored.
// Returns the new list size.
//
// The old list contents are
// copied to the new list; the new contents are uninitialized.
procedure list_grow (pointer elem_repr, pointer list, int old_size) -> int {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);

  typedef old_array_type = array(value old_size, elem_type);
  new_size = old_size * int 2;
  typedef new_array_type = array(value new_size, elem_type);

  old_contents = list @! PyonList.contents;
  new_contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof new_array_type);
  } else {
    pointer primcall pyon_alloc (sizeof new_array_type);
  };

  // Copy old contents to new list
  _ = pointer primcall memcpy (new_contents,
                               old_contents,
                               sizeof old_array_type);

  // Free old contents
  () = () primcall pyon_dealloc(old_contents);

  // Save new list contents.
  // Don't save the new size anywhere; caller is responsible for keeping
  // track.
  list @! PyonList.contents = new_contents;
  new_size;
};

// Get the length of a list
function inline list_len (pointer p) -> int {
  FinIndInt {n} = p @! PyonList.nelems;
  n;
};

// Create a list from a stream of unknown size
function list_build
    (owned elem_repr, owned stream, pointer ret) -> () {
  typedef Stream = Obj(StreamData);

  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value int 0, elem_type);

  // Initialize list with 4 elements
  list_size = int 4;
  () = () primcall list_create_uninitialized (elem_repr, list_size, ret);

  // Set up stream
  stream_init_state = stream @! Stream.payload.state;
  stream_next = stream @! Stream.payload.next;

  // Populate the list contents (pull_values); then finish building the list.
  letrec {
    procedure pull_values (int n_elems, int list_size, owned stream_state) -> () {
      // Make sure list can hold another element
      new_list_size = if (n_elems == list_size) {
        int primcall list_grow (elem_repr, ret, list_size);
      } else {
        list_size;
      };

      // Pull from the stream
      StreamNext {result_tag, StreamNextData {next_state, result_val}} =
        StreamNext call stream_next (stream_state);

      if (result_tag == STREAM_VALUE) {
        // Copy this value to the destination.
        // The value was stored as a boxed object; convert it to a bare object.
        current_elem = (ret @! PyonList.contents) @ array_type[n_elems];
        () = () call (elem_repr @! PassConv.convert_to_bare) (result_val, current_elem);

        // Continue pulling
        () primcall pull_values (n_elems + int 1, new_list_size, next_state);
      } else {
        // Stream is depleted.  Finish constructing list.
        () primcall finish (n_elems);
      };
    };

    procedure finish (int n_elems) -> () {
      // Save the number of list elements that was created
      ret @! PyonList.nelems = FinIndInt {n_elems};
      ();   
    }
  };
  () primcall pull_values (int 0, list_size, stream_init_state);
};

// Allocate and construct a list, given a suitably initialized data array.
// The data array is stolen by the list.
// A pointer to the new list is returned.
procedure pyon_list_from_array (int n_elems,
                                pointer arr) -> pointer {
  l = pointer primcall pyon_alloc (sizeof PyonList);
  l @! PyonList.nelems = FinIndInt {n_elems};
  l @! PyonList.contents = arr;
  l;
};

// Copy the contents of a plain-old-data list into an array.
// The list is not modified.
procedure pyon_list_to_array_POD (owned elem_repr,
                                  pointer list,
                                  pointer arr) -> () {
  FinIndInt {n_elems} = list @! PyonList.nelems;
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value n_elems, elem_type);

  () = () primcall memcpy
    (arr,
     list @! PyonList.contents,
     sizeof array_type);
  ();
};

procedure pyon_list_length (pointer list) -> int {
  FinIndInt {n} = list @! PyonList.nelems;
  n;
};

// Allocate and return a copy of the POD list.
procedure pyon_list_copy_POD (owned elem_repr, pointer in_list) -> pointer {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  FinIndInt {nelems} = in_list @! PyonList.nelems;
  typedef array_type = array(value nelems, bytes(value elem_size, value elem_align));

  // Create a copy of the data array
  contents = pointer primcall pyon_alloc(sizeof array_type);
  () = () primcall memcpy
    (contents, in_list @! PyonList.contents, sizeof array_type);

  // Create and return a new list object
  pointer primcall pyon_list_from_array (nelems, contents);
};

// Free the POD list.
procedure pyon_list_free_POD (pointer list) -> () {
  () = () primcall pyon_dealloc(list @! PyonList.contents);
  () primcall pyon_dealloc(list);
};

///////////////////////////////////////////////////////////////////////////////
// Matrix functions

function repr_array2 (owned elem_repr) -> owned {
  repr = pointer primcall pyon_alloc (sizeof PassConv);

  // FIXME: initialize repr header
  repr @! PassConv.size = sizeof PyonMatrix;
  repr @! PassConv.align = alignof PyonMatrix;
  repr @! PassConv.is_pointerless = NOT_POINTERLESS;
  copy_function = owned call matrix_copy (elem_repr);
  repr @! PassConv.copy = copy_function;
  repr @! PassConv.convert_to_boxed =
    owned call make_Boxed (sizeof PyonMatrix, alignof PyonMatrix);
  repr @! PassConv.convert_to_bare =
    owned call from_Boxed (sizeof PyonMatrix, alignof PyonMatrix, copy_function);
  repr @! PassConv.finalize = owned call matrix_finalize (elem_repr);
  repr as owned;
};

function matrix_copy (owned elem_repr, pointer src, pointer dst) -> () {
  FinIndInt {size_y} = src @! PyonMatrix.size_y;
  FinIndInt {size_x} = src @! PyonMatrix.size_x;
  src_contents = src @! PyonMatrix.contents;

  dst @! PyonMatrix.size_y = FinIndInt {size_y};
  dst @! PyonMatrix.size_x = FinIndInt {size_x};

  // Copy list elements
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  copy_elem = elem_repr @! PassConv.copy;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef src_contents_type =
    const_array (value size_y, const_array(value size_x, elem_type));
  typedef dst_contents_type =
    array(value size_y, array(value size_x, elem_type));

  dst_contents = if (elem_repr @! PassConv.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof dst_contents_type);
  } else {
    pointer primcall pyon_alloc (sizeof dst_contents_type);
  };
  dst @! PyonMatrix.contents = dst_contents;

  _ = while (int yindex = int 0) (yindex < size_y) {
    _ = while (int xindex = int 0) (xindex < size_x) {
      () = () call copy_elem (src_contents @ src_contents_type[yindex][xindex],
                              dst_contents @ dst_contents_type[yindex][xindex]);
      xindex + int 1;
    };
    yindex + int 1;
  };
  ();
};

function matrix_finalize (owned elem_repr, pointer matrix) -> () {
  FinIndInt {size_y} = matrix @! PyonMatrix.size_y;
  FinIndInt {size_x} = matrix @! PyonMatrix.size_x;
  contents = matrix @! PyonMatrix.contents;

  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  finalize_elem = elem_repr @! PassConv.finalize;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef contents_type = array(value size_y, array(value size_x, elem_type));

  _ = while (int yindex = int 0) (yindex < size_y) {
    _ = while (int xindex = int 0) (xindex < size_x) {
      () = () call finalize_elem (contents @ contents_type[yindex][xindex]);
      xindex + int 1;
    };
    yindex + int 1;
  };
  ();
};

// Allocate and construct a matrix, given a suitably initialized data array.
// The data array is stolen by the matrix.
// A pointer to the new matrix is returned.
procedure pyon_matrix_from_array (int height, int width, pointer contents) -> pointer {
  mat = pointer primcall pyon_alloc (sizeof PyonMatrix);
  mat @! PyonMatrix.size_y = FinIndInt {height};
  mat @! PyonMatrix.size_x = FinIndInt {width};
  mat @! PyonMatrix.contents = contents;
  mat;
};

// Copy the contents of a plain-old-data matrix into an array.
// The matrix is not modified.
procedure pyon_matrix_to_array_POD (owned elem_repr,
                                    pointer mat,
                                    pointer arr) -> () {
  FinIndInt {h} = mat @! PyonMatrix.size_y;
  FinIndInt {w} = mat @! PyonMatrix.size_x;
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value h * w, elem_type);

  () = () primcall memcpy
    (arr,
     mat @! PyonMatrix.contents,
     sizeof array_type);
  ();
};

// Allocate and return a copy of the POD matrix.
procedure pyon_matrix_copy_POD (owned elem_repr, pointer in_mat) -> pointer {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  FinIndInt {h} = in_mat @! PyonMatrix.size_y;
  FinIndInt {w} = in_mat @! PyonMatrix.size_x;
  typedef array_type = array(value h * w, bytes(value elem_size, value elem_align));

  // Create a copy of the data array
  contents = pointer primcall pyon_alloc(sizeof array_type);
  () = () primcall memcpy
    (contents, in_mat @! PyonMatrix.contents, sizeof array_type);

  // Create and return a new matrix object
  pointer primcall pyon_matrix_from_array (h, w, contents);
};

// Free the POD matrix.
procedure pyon_matrix_free_POD (pointer mat) -> () {
  () = () primcall pyon_dealloc(mat @! PyonMatrix.contents);
  () primcall pyon_dealloc(mat);
};

///////////////////////////////////////////////////////////////////////////////
// Exported to C

// Create a list from an array of CInt.
// The list holds a copy of the given array.
procedure pyon_List_PyonInt_FromArray (int n_elems, pointer arr) -> pointer {
  typedef array_type = array(value n_elems, int);
 
  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy (new_arr, arr, sizeof array_type);
  pointer primcall pyon_list_from_array(n_elems, new_arr);
};

// Copy the contents of a list into an array
procedure pyon_List_PyonInt_ToArray (pointer list, pointer dat) -> () {
  () primcall pyon_list_to_array_POD (repr_int, list, dat);
};

procedure pyon_List_PyonInt_Length (pointer list) -> int {
  l = int primcall pyon_list_length (list);
  l as int;
};

procedure pyon_List_PyonInt_Copy (pointer list) -> pointer {
  pointer primcall pyon_list_copy_POD (repr_int, list);
};

procedure pyon_List_PyonInt_Free (pointer list) -> () {
  pointer primcall pyon_list_free_POD (list);
};


procedure pyon_List_PyonFloat_FromArray (int n_elems, pointer arr) -> pointer {
  typedef array_type = array(value n_elems, float);
 
  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy (new_arr, arr, sizeof array_type);
  pointer primcall pyon_list_from_array(n_elems, new_arr);
};

// Copy the contents of a list into an array
procedure pyon_List_PyonFloat_ToArray (pointer list, pointer dat) -> () {
  () primcall pyon_list_to_array_POD (repr_float, list, dat);
};

procedure pyon_List_PyonFloat_Length (pointer list) -> int {
  l = int primcall pyon_list_length (list);
  l as int;
};

procedure pyon_List_PyonFloat_Copy (pointer list) -> pointer {
  pointer primcall pyon_list_copy_POD (repr_float, list);
};

procedure pyon_List_PyonFloat_Free (pointer list) -> () {
  pointer primcall pyon_list_free_POD (list);
};

procedure pyon_Matrix_PyonInt_FromArray (int height, int width, pointer arr) -> pointer {
  n_elems = height * width;
  typedef array_type = array(value n_elems, int);

  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy(new_arr, arr, sizeof array_type);
  pointer primcall pyon_matrix_from_array(height, width, new_arr);
};

procedure pyon_Matrix_PyonInt_ToArray(pointer mat, pointer dat) -> () {
  () primcall pyon_matrix_to_array_POD (repr_int, mat, dat);
};

procedure pyon_Matrix_PyonInt_Height (pointer mat) -> int {
  FinIndInt {h} = mat @! PyonMatrix.size_y;
  h as int;
};

procedure pyon_Matrix_PyonInt_Width (pointer mat) -> int {
  FinIndInt {w} = mat @! PyonMatrix.size_x;
  w as int;
};

procedure pyon_Matrix_PyonInt_Copy (pointer mat) -> pointer {
  pointer primcall pyon_matrix_copy_POD (repr_int, mat);
};

procedure pyon_Matrix_PyonInt_Free (pointer mat) -> () {
  pointer primcall pyon_matrix_free_POD (mat);
};

procedure pyon_Matrix_PyonFloat_FromArray (int height, int width, pointer arr) -> pointer {
  n_elems = height * width;
  typedef array_type = array(value n_elems, float);

  new_arr = pointer primcall pyon_alloc_nopointers (sizeof array_type);
  () = () primcall memcpy(new_arr, arr, sizeof array_type);
  pointer primcall pyon_matrix_from_array(height, width, new_arr);
};

procedure pyon_Matrix_PyonFloat_ToArray(pointer mat, pointer dat) -> () {
  () primcall pyon_matrix_to_array_POD (repr_float, mat, dat);
};

procedure pyon_Matrix_PyonFloat_Height (pointer mat) -> int {
  FinIndInt {h} = mat @! PyonMatrix.size_y;
  h as int;
};

procedure pyon_Matrix_PyonFloat_Width (pointer mat) -> int {
  FinIndInt {w} = mat @! PyonMatrix.size_x;
  w as int;
};

procedure pyon_Matrix_PyonFloat_Copy (pointer mat) -> pointer {
  pointer primcall pyon_matrix_copy_POD (repr_float, mat);
};

procedure pyon_Matrix_PyonFloat_Free (pointer mat) -> () {
  pointer primcall pyon_matrix_free_POD (mat);
};
