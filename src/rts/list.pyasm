
module pyon.internal.list;

#include "rts.h"
#include "debug.h"
#include "prim.h"
#include "memory_py.h"
#include "apply_py.h"
#include "stream.h"
#include "list.h"
#include "structures.h"

import procedure exit "exit" (int) -> ();

#include "new_pyasm_records.h"

function repr_list (owned elem_repr) -> owned {
  repr = pointer primcall pyon_alloc (sizeof Repr);

  // FIXME: Initialize repr header
  repr @! Repr.sizealign = SA {sizeof PyonList, alignof PyonList};
  repr @! Repr.is_pointerless = NOT_POINTERLESS;
  copy_function = owned call list_copy (elem_repr);
  repr @! Repr.copy = copy_function;
  repr @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof PyonList, alignof PyonList);
  repr @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof PyonList, alignof PyonList, copy_function);
  repr as owned;
};

function list_copy (owned elem_repr, pointer src, pointer dst) -> unit {
  dst @! PyonList.nelems = src @! PyonList.nelems;
  dst @! PyonList.contents = src @! PyonList.contents;
  nil;
};

// Create a list, leaving its elements uninitialized
procedure list_create_uninitialized (owned elem_repr,
                                     int nelems,
                                     pointer list) -> () {
  SA {elem_size, elem_align} = elem_repr @! Repr.sizealign;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value nelems, elem_type);
  
  list @! PyonList.nelems = FinIndInt {nelems};
  list @! PyonList.contents = if (elem_repr @! Repr.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof Boxed(array_type)) as owned;
  } else {
    pointer primcall pyon_alloc (sizeof Boxed(array_type)) as owned;
  };
  ();
};

// Increase the size of a list.  The list's 'contents' field may be modified.
// The list's 'size' field is ignored.
// Returns the new list size.
//
// The old list contents are
// copied to the new list; the new contents are uninitialized.
procedure list_grow (pointer elem_repr, pointer list, int old_size) -> int {
  SA {elem_size, elem_align} = elem_repr @! Repr.sizealign;
  typedef elem_type = bytes(value elem_size, value elem_align);

  typedef old_array_type = array(value old_size, elem_type);
  new_size = old_size * int 2;
  typedef new_array_type = array(value new_size, elem_type);

  old_contents = list @! PyonList.contents;
  new_contents = if (elem_repr @! Repr.is_pointerless) {
    pointer primcall pyon_alloc_nopointers (sizeof Boxed(new_array_type));
  } else {
    pointer primcall pyon_alloc (sizeof Boxed(new_array_type));
  };

  // Copy old contents to new list
  _ = pointer primcall memcpy (new_contents @ Boxed(new_array_type).member,
                               old_contents @ Boxed(old_array_type).member,
                               sizeof old_array_type);

  // Free old contents
  () = () primcall pyon_dealloc(old_contents);

  // Save new list contents.
  // Don't save the new size anywhere; caller is responsible for keeping
  // track.
  list @! PyonList.contents = new_contents as owned;
  new_size;
};

// Get the length of a list
function inline list_len (pointer p) -> int {
  FinIndInt {n} = p @! PyonList.nelems;
  n;
};

// Create a list from a stream of unknown size
function list_build
    (owned elem_repr, owned stream, pointer ret) -> unit {
  typedef Stream = Obj(StreamData);

  SA {elem_size, elem_align} = elem_repr @! Repr.sizealign;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = Boxed(array(value int 0, elem_type));

  // Initialize list with 4 elements
  list_size = int 4;
  () = () primcall list_create_uninitialized (elem_repr, list_size, ret);

  // Set up stream
  stream_init_state = stream @! Stream.payload.state;
  stream_next = stream @! Stream.payload.next;

  // Populate the list contents (pull_values); then finish building the list.
  letrec {
    procedure pull_values (int n_elems, int list_size, owned stream_state) -> unit {
      // Make sure list can hold another element
      new_list_size = if (n_elems == list_size) {
        int primcall list_grow (elem_repr, ret, list_size);
      } else {
        list_size;
      };

      // Pull from the stream
      StreamNext {result_tag, StreamNextData {next_state, result_val}} =
        StreamNext call stream_next (stream_state);

      if (result_tag == STREAM_VALUE) {
        // Copy this value to the destination.
        // The value was stored as a boxed object; convert it to a bare object.
        current_elem = (ret @! PyonList.contents) @ array_type.member[n_elems];
        _ = unit call (elem_repr @! Repr.convert_to_bare) (result_val, current_elem);

        // Continue pulling
        unit primcall pull_values (n_elems + int 1, new_list_size, next_state);
      } else {
        // Stream is depleted.  Finish constructing list.
        unit primcall finish (n_elems);
      };
    };

    procedure finish (int n_elems) -> unit {
      // Save the number of list elements that was created
      ret @! PyonList.nelems = FinIndInt {n_elems};
      nil;
    }
  };
  unit primcall pull_values (int 0, list_size, stream_init_state);
};

// Allocate and construct a list, given a suitably initialized array object.
// A pointer to the new list is returned.
procedure pyon_list_from_array (int n_elems,
                                owned arr) -> pointer {
  l = pointer primcall pyon_alloc (sizeof PyonList);
  l @! PyonList.nelems = FinIndInt {n_elems};
  l @! PyonList.contents = arr;
  l;
};

// Copy the contents of a plain-old-data list into an array.
// The list is not modified.
procedure pyon_list_to_array_POD (owned elem_repr,
                                  pointer list,
                                  pointer arr) -> () {
  FinIndInt {n_elems} = list @! PyonList.nelems;
  SA {elem_size, elem_align} = elem_repr @! Repr.sizealign;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value n_elems, elem_type);

  () = () primcall memcpy
    (arr,
     (list @! PyonList.contents) @ Boxed(array_type).member,
     sizeof array_type);
  ();
};

procedure pyon_list_length (pointer list) -> int {
  FinIndInt {n} = list @! PyonList.nelems;
  n;
};

// Free the POD list.
procedure pyon_list_free_POD (pointer list) -> () {
  () = () primcall pyon_dealloc(list @! PyonList.contents);
  () primcall pyon_dealloc(list);
};

///////////////////////////////////////////////////////////////////////////////
// Matrix functions

function repr_array2 (owned elem_repr) -> owned {
  repr = pointer primcall pyon_alloc (sizeof Repr);

  // FIXME: initialize repr header
  repr @! Repr.sizealign = SA {sizeof PyonArray2, alignof PyonArray2};
  repr @! Repr.is_pointerless = NOT_POINTERLESS;
  copy_function = owned call matrix_copy (elem_repr);
  repr @! Repr.copy = copy_function;
  repr @! Repr.convert_to_boxed =
    owned call make_Boxed (sizeof PyonArray2, alignof PyonArray2);
  repr @! Repr.convert_to_bare =
    owned call from_Boxed (sizeof PyonArray2, alignof PyonArray2, copy_function);
  repr as owned;
};

function matrix_copy (owned elem_repr, pointer src, pointer dst) -> unit {
  first_y = src @! PyonArray2.first_y;
  stride_y = src @! PyonArray2.stride_y;
  FinIndInt {size_y} = src @! PyonArray2.size_y;
  first_x = src @! PyonArray2.first_x;
  stride_x = src @! PyonArray2.stride_x;
  FinIndInt {size_x} = src @! PyonArray2.size_x;
  src_contents = src @! PyonArray2.contents;

  dst @! PyonArray2.first_y = first_y;
  dst @! PyonArray2.stride_y = stride_y;
  dst @! PyonArray2.size_y = FinIndInt {size_y};
  dst @! PyonArray2.first_x = first_x;
  dst @! PyonArray2.stride_x = stride_x;
  dst @! PyonArray2.size_x = FinIndInt {size_x};

  // Copy list elements
  dst @! PyonArray2.contents = src @! PyonArray2.contents;
  nil;
};

// Allocate and construct a matrix, given a suitably initialized data array.
// The data array is stolen by the matrix.
// A pointer to the new matrix is returned.
procedure pyon_matrix_from_array
  (int ymin, int ystride, int ysize,
   int xmin, int xstride, int xsize, pointer contents) -> pointer {
  mat = pointer primcall pyon_alloc (sizeof PyonArray2);
  mat @! PyonArray2.first_y = ymin;
  mat @! PyonArray2.stride_y = ystride;
  mat @! PyonArray2.size_y = FinIndInt {ysize};
  mat @! PyonArray2.first_x = xmin;
  mat @! PyonArray2.stride_x = xstride;
  mat @! PyonArray2.size_x = FinIndInt {xsize};
  mat @! PyonArray2.contents = contents;
  mat;
};

// Copy the contents of a plain-old-data matrix into an array.
// The matrix is not modified.
procedure pyon_matrix_to_array_POD (owned elem_repr,
                                    pointer mat,
                                    pointer arr) -> () {
  FinIndInt {h} = mat @! PyonArray2.size_y;
  FinIndInt {w} = mat @! PyonArray2.size_x;
  SA {elem_size, elem_align} = elem_repr @! Repr.sizealign;
  typedef elem_type = bytes(value elem_size, value elem_align);
  typedef array_type = array(value h * w, elem_type);

  () = () primcall memcpy
    (arr,
     mat @! PyonArray2.contents @ Boxed(array_type).member,
     sizeof array_type);
  ();
};

// Free the POD matrix.
procedure pyon_matrix_free_POD (pointer mat) -> () {
  () = () primcall pyon_dealloc(mat @! PyonArray2.contents);
  () primcall pyon_dealloc(mat);
};

///////////////////////////////////////////////////////////////////////////////
// Exported to C for the C++ interface

data pointer pyon_List_size = sizeof PyonList;
data pointer pyon_List_alignment = alignof PyonList;

// Allocate a boxed list with the given length.
// The boolean parameter is true if the list contains POD data.
procedure pyon_List_initialize
  (int length, uint elt_size, uint elt_align, pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value length, elt_type);
  ret @! PyonList.nelems = FinIndInt {length};
  ret @! PyonList.contents =
    pointer primcall pyon_alloc(sizeof Boxed(array_type)) as owned;
  ();
};

procedure pyon_List_get_contents (pointer lst, uint size, uint align) -> pointer {
  // Use the alignment of list contents to figure out where the array begins
  typedef contents_dummy_type = Boxed(bytes(value size, value align));
  lst @! PyonList.contents @ contents_dummy_type.member;
};

procedure pyon_List_get_length (pointer lst) -> uint {
  FinIndInt {n} = lst @! PyonList.nelems;
  n as uint;
};

procedure pyon_Array0_size (uint size, uint align) -> uint {
  sizeof PyonArray0(bytes(value size, value align));
};

procedure pyon_Array0_alignment (uint size, uint align) -> uint {
  alignof PyonArray0(bytes(value size, value align));
};

procedure pyon_Array0_get_contents
  (pointer arr, uint size, uint align) -> pointer {
  arr @ PyonArray0(bytes(value size, value align)).content;
};

data pointer pyon_Array1_size = sizeof PyonArray1;
data pointer pyon_Array1_alignment = alignof PyonArray1;

procedure pyon_Array1_initialize
  (int min, int stride, int size, uint elt_size, uint elt_align,
   pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value size, elt_type);

  ret @! PyonArray1.first = min;
  ret @! PyonArray1.stride = stride;
  ret @! PyonArray1.size = FinIndInt {size};
  ret @! PyonArray1.contents =
    pointer primcall pyon_alloc(sizeof Boxed(array_type)) as owned;
  ();
};

procedure pyon_Array1_get_contents (pointer arr, uint size, uint align) -> pointer {
  typedef contents_dummy_type = Boxed(bytes(value size, value align));
  arr @! PyonArray1.contents @ contents_dummy_type.member;
};

procedure pyon_Array1_get_bounds (pointer arr) -> PyonTuple3(int, int, int)
{
  FinIndInt {size} = arr @! PyonArray1.size;
  PyonTuple3(int, int, int)
  {arr @! PyonArray1.first,
   arr @! PyonArray1.stride,
   size};
};


data pointer pyon_Array2_size = sizeof PyonArray2;
data pointer pyon_Array2_alignment = alignof PyonArray2;

procedure pyon_Array2_initialize
  (int y_min, int y_stride, int y_size, int x_min, int x_stride, int x_size,
   uint elt_size, uint elt_align, pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value y_size, array(value x_size, elt_type));

  ret @! PyonArray2.first_y = y_min;
  ret @! PyonArray2.stride_y = y_stride;
  ret @! PyonArray2.size_y = FinIndInt {y_size};
  ret @! PyonArray2.first_x = x_min;
  ret @! PyonArray2.stride_x = x_stride;
  ret @! PyonArray2.size_x = FinIndInt {x_size};
  ret @! PyonArray2.contents =
    pointer primcall pyon_alloc(sizeof Boxed(array_type)) as owned;
  ();
};

procedure pyon_Array2_get_contents (pointer arr, uint size, uint align) -> pointer {
  typedef contents_dummy_type = Boxed(bytes(value size, value align));
  arr @! PyonArray2.contents @ contents_dummy_type.member;
};

procedure pyon_Array2_get_bounds (pointer arr)
  -> PyonTuple6(int, int, int, int, int, int)
{
  FinIndInt {size_y} = arr @! PyonArray2.size_y;
  FinIndInt {size_x} = arr @! PyonArray2.size_x;
  PyonTuple6(int, int, int, int, int, int)
  {arr @! PyonArray2.first_y,
   arr @! PyonArray2.stride_y,
   size_y,
   arr @! PyonArray2.first_x,
   arr @! PyonArray2.stride_x,
   size_x};
};

data pointer pyon_Array3_size = sizeof PyonArray3;
data pointer pyon_Array3_alignment = alignof PyonArray3;

procedure pyon_Array3_initialize
  (int z_min, int z_stride, int z_size,
   int y_min, int y_stride, int y_size,
   int x_min, int x_stride, int x_size,
   uint elt_size, uint elt_align, pointer ret) -> () {
  typedef elt_type = bytes(value elt_size, value elt_align);
  typedef array_type = array(value y_size, array(value x_size, elt_type));

  ret @! PyonArray3.first_z = z_min;
  ret @! PyonArray3.stride_z = z_stride;
  ret @! PyonArray3.size_z = FinIndInt {z_size};
  ret @! PyonArray3.first_y = y_min;
  ret @! PyonArray3.stride_y = y_stride;
  ret @! PyonArray3.size_y = FinIndInt {y_size};
  ret @! PyonArray3.first_x = x_min;
  ret @! PyonArray3.stride_x = x_stride;
  ret @! PyonArray3.size_x = FinIndInt {x_size};
  ret @! PyonArray3.contents =
    pointer primcall pyon_alloc(sizeof Boxed(array_type)) as owned;
  ();
};

procedure pyon_Array3_get_contents (pointer arr, uint size, uint align) -> pointer {
  typedef contents_dummy_type = Boxed(bytes(value size, value align));
  arr @! PyonArray3.contents @ contents_dummy_type.member;
};

procedure pyon_Array3_get_bounds (pointer arr)
  -> PyonTuple3(PyonTuple3(int, int, int),
                PyonTuple3(int, int, int),
                PyonTuple3(int, int, int))
{
  FinIndInt {size_z} = arr @! PyonArray3.size_z;
  FinIndInt {size_y} = arr @! PyonArray3.size_y;
  FinIndInt {size_x} = arr @! PyonArray3.size_x;
  PyonTuple3(PyonTuple3(int, int, int),
             PyonTuple3(int, int, int),
             PyonTuple3(int, int, int))
  {PyonTuple3(int, int, int)
   {arr @! PyonArray3.first_z,
    arr @! PyonArray3.stride_z,
    size_z},
   PyonTuple3(int, int, int)
   {arr @! PyonArray3.first_y,
    arr @! PyonArray3.stride_y,
    size_y},
   PyonTuple3(int, int, int)
   {arr @! PyonArray3.first_x,
    arr @! PyonArray3.stride_x,
    size_x}};
};


///////////////////////////////////////////////////////////////////////////////
// Exported to C for the C interface

// Create a list from an array of CInt.
// The list holds a copy of the given array.
procedure pyon_List_PyonInt_FromArray (int n_elems, pointer arr) -> pointer {
  typedef array_type = array(value n_elems, int);
 
  new_arr = pointer primcall pyon_alloc_nopointers (sizeof Boxed(array_type));
  () = () primcall memcpy (new_arr @ Boxed(array_type).member, arr, sizeof array_type);
  pointer primcall pyon_list_from_array(n_elems, new_arr as owned);
};

// Copy the contents of a list into an array
procedure pyon_List_PyonInt_ToArray (pointer list, pointer dat) -> () {
  () primcall pyon_list_to_array_POD (repr_int, list, dat);
};

procedure pyon_List_PyonInt_Length (pointer list) -> int {
  l = int primcall pyon_list_length (list);
  l as int;
};

procedure pyon_List_PyonInt_Copy (pointer list) -> pointer {
  pointer call list_copy (repr_int, list);
};

procedure pyon_List_PyonInt_Free (pointer list) -> () {
  pointer primcall pyon_list_free_POD (list);
};


procedure pyon_List_PyonFloat_FromArray (int n_elems, pointer arr) -> pointer {
  typedef array_type = array(value n_elems, float);
 
  new_arr = pointer primcall pyon_alloc_nopointers (sizeof Boxed(array_type));
  () = () primcall memcpy (new_arr @ Boxed(array_type).member, arr,
                           sizeof array_type);
  pointer primcall pyon_list_from_array(n_elems, new_arr as owned);
};

// Copy the contents of a list into an array
procedure pyon_List_PyonFloat_ToArray (pointer list, pointer dat) -> () {
  () primcall pyon_list_to_array_POD (repr_float, list, dat);
};

procedure pyon_List_PyonFloat_Length (pointer list) -> int {
  l = int primcall pyon_list_length (list);
  l as int;
};

procedure pyon_List_PyonFloat_Copy (pointer list) -> pointer {
  pointer call list_copy (repr_float, list);
};

procedure pyon_List_PyonFloat_Free (pointer list) -> () {
  pointer primcall pyon_list_free_POD (list);
};

procedure pyon_Matrix_PyonInt_FromArray
  (int ymin, int yend, int xmin, int xend, pointer arr) -> pointer {
  height = yend - ymin;
  width = xend - xmin;
  n_elems = height * width;
  typedef array_type = array(value n_elems, int);

  new_arr = pointer primcall pyon_alloc_nopointers (sizeof Boxed(array_type));
  () = () primcall memcpy(new_arr @ Boxed(array_type).member, arr, sizeof array_type);
  pointer primcall pyon_matrix_from_array(ymin, int 1, height,
                                          xmin, int 1, width,
                                          new_arr as owned);
};

procedure pyon_Matrix_PyonInt_ToArray(pointer mat, pointer dat) -> () {
  () primcall pyon_matrix_to_array_POD (repr_int, mat, dat);
};

procedure pyon_Matrix_PyonInt_Height (pointer mat) -> int {
  mat @! PyonArray2.size_y;
};

procedure pyon_Matrix_PyonInt_Width (pointer mat) -> int {
  mat @! PyonArray2.size_x;
};

procedure pyon_Matrix_PyonInt_Copy (pointer mat) -> pointer {
  pointer call matrix_copy (repr_int, mat);
};

procedure pyon_Matrix_PyonInt_Free (pointer mat) -> () {
  pointer primcall pyon_matrix_free_POD (mat);
};

procedure pyon_Matrix_PyonFloat_FromArray
  (int ymin, int yend, int xmin, int xend, pointer arr) -> pointer {
  height = yend - ymin;
  width = xend - xmin;
  n_elems = height * width;
  typedef array_type = array(value n_elems, float);

  new_arr = pointer primcall pyon_alloc_nopointers (sizeof Boxed(array_type));
  () = () primcall memcpy(new_arr @ Boxed(array_type).member, arr, sizeof array_type);
  pointer primcall pyon_matrix_from_array(ymin, int 1, height,
                                          xmin, int 1, width,
                                          new_arr as owned);
};

procedure pyon_Matrix_PyonFloat_ToArray(pointer mat, pointer dat) -> () {
  () primcall pyon_matrix_to_array_POD (repr_float, mat, dat);
};

procedure pyon_Matrix_PyonFloat_Height (pointer mat) -> int {
  mat @! PyonArray2.size_y;
};

procedure pyon_Matrix_PyonFloat_Width (pointer mat) -> int {
  mat @! PyonArray2.size_x;
};

procedure pyon_Matrix_PyonFloat_Copy (pointer mat) -> pointer {
  pointer call matrix_copy (repr_float, mat);
};

procedure pyon_Matrix_PyonFloat_Free (pointer mat) -> () {
  pointer primcall pyon_matrix_free_POD (mat);
};
