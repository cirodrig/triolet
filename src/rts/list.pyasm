
module pyon.internal.list;

#include "pyasm.h"
#include "debug.h"
#include "memory_py.h"
#include "apply_py.h"
#include "stream.h"
#include "list.h"
#include "structures.h"

#include "pyasm_records.h"

// Duplicate a list
function list_copy(pointer elem_repr, pointer src, pointer dst) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  elem_copy = elem_repr @! PassConv.copy;
  num_elems = src @! PyonList.nelems;

  // Allocate a multiple of the list element's alignment to each element
  // so that all elements will be aligned
  pad_elem_size = PAD(elem_size, elem_align);

  // Duplicate contents
  PYON_DB_ALLOC(word 1001)
  contents = pointer primcall pyon_alloc (pad_elem_size * num_elems);
  () = () primcall list_copy_elems
      (elem_copy, pad_elem_size, num_elems, src @! PyonList.contents, contents);

  dst @! PyonList.nelems = src @! PyonList.nelems;
  dst @! PyonList.contents = contents;
  ();
};

// Copy all list elements
procedure list_copy_elems (owned elem_copy,
                           word pad_elem_size,
                           word num_elems,
                           pointer src,
                           pointer dst) -> () {
  if (num_elems == word 0) {
    ();
  } else {
    () = () call elem_copy(src, dst);
    () primcall list_copy_elems(elem_copy,
                                pad_elem_size,
                                num_elems - word 1,
                                src ^+ pad_elem_size as int,
                                dst ^+ pad_elem_size as int);
  };
};

// Finalize a list
function list_finalize (pointer elem_repr, pointer list) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  elem_fini = elem_repr @! PassConv.finalize;
  pad_elem_size = PAD(elem_size, elem_align);

  num_elems = list @! PyonList.nelems;
  contents = list @! PyonList.contents;

  // Finalize list contents
  () = () primcall list_finalize_elems
      (elem_fini, elem_size, num_elems, contents);

  // Free the array
  PYON_DB_DEALLOC(word 1501)
  () primcall pyon_dealloc (contents);
};

procedure list_finalize_elems (owned elem_finalize,
                               word elem_size,
                               word nelems,
                               pointer contents) -> () {
  if (nelems == word 0) {
    ();
  } else {
    () = () call elem_finalize(contents);
    () primcall list_finalize_elems (elem_finalize,
                                     elem_size,
                                     nelems - word 1,
                                     contents ^+ elem_size as int);
  };
};

// Create a list, leaving its elements uninitialized
procedure list_create_uninitialized (pointer elem_repr,
                                     word size,
                                     pointer list) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  pad_elem_size = PAD(elem_size, elem_align);
  PYON_DB_ALLOC(word 1002)
  contents = pointer primcall pyon_alloc (pad_elem_size * size);
  
  list @! PyonList.nelems = size;
  list @! PyonList.contents = contents;
  ();
};

// Increase the size of a list.  The list's 'contents' field may be modified.
//
// The new size parameter is the number of elements the new list should
// contain.  This must be no less than the current number of elements,
// and may be larger than the final list.  The old list contents are
// copied to the new list; the new contents are uninitialized.
procedure list_grow (pointer elem_repr, pointer list, word new_size) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  pad_elem_size = PAD(elem_size, elem_align);

  new_size_bytes = pad_elem_size * new_size;
  old_size_bytes = pad_elem_size * list @! PyonList.nelems;
  old_contents = list @! PyonList.contents;

  // Allocate new list contents
  PYON_DB_ALLOC(word 1003)
  new_contents = pointer primcall pyon_alloc (new_size_bytes);

  // Copy old contents to new list
  _ = pointer primcall memcpy (new_contents,
                               old_contents,
                               old_size_bytes);

  // Free old contents
  PYON_DB_DEALLOC(word 1502)
  () = () primcall pyon_dealloc(old_contents);

  // Save new list contents.
  // Don't save the new size anywhere; caller is responsible for keeping
  // track.
  list @! PyonList.contents = new_contents;
  ();
};

// Create a list from a stream of unknown size
function list_build (unit _, unit _, pointer elem_repr, owned stream, pointer list) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  pad_elem_size = PAD(elem_size, elem_align);

  // Initialize list with 4 elements
  list_size = word 4;
  () = () primcall list_create_uninitialized (elem_repr, list_size, list);

  // Set up stream
  PYON_DB_ALLOC(word 1004)
  stream_state = pointer primcall pyon_alloc (stream @! Stream.state_size);
  () = () call  (stream @! Stream.initialize) (stream_state);

  // Populate the list contents
  n_elems = word primcall list_build_pull (elem_repr, list, pad_elem_size,
                                           stream @! Stream.next,
                                           stream_state, word 0, list_size);
  list @! PyonList.nelems = n_elems;

  // Finalize the stream
  () = () call (stream @! Stream.state_finalize) (stream_state);
  PYON_DB_DEALLOC(word 1503)
  () = () primcall pyon_dealloc (stream_state);

  ();   
};

// Pull elements from the stream until it is exhausted.  Write into the list.
procedure list_build_pull (pointer elem_repr,
                           pointer list,
                           word pad_elem_size,
                           owned stream_next,
                           pointer stream_state,
                           word n_elems,
                           word list_size) -> word {
  // Make sure list can hold another element
  b_full = n_elems == list_size;
  new_list_size = if (b_full) {
    new_list_size = list_size * word 2;
    () = () primcall list_grow (elem_repr, list, new_list_size);
    new_list_size;
  } else {
    list_size;
  };

  // Pull from the straem
  current_elem = (list @! PyonList.contents) ^+ (n_elems * pad_elem_size) as int;
  b = bool call stream_next (stream_state, current_elem);
  if (b) {
    // Continue pulling
    word primcall list_build_pull (elem_repr, list, pad_elem_size, stream_next,
                                   stream_state, n_elems + word 1,
                                   new_list_size);
  } else {
    // Stream is depleted
    n_elems;
  };
};

// Create a stream that traverses the list
function list_traverse (unit _, pointer elem_repr, pointer list) -> owned {
  ALLOC_OBJECT(s, Stream, Stream_info)
  s @! Stream.next = owned call list_traverse_next (elem_repr, list);
  s @! Stream.initialize = list_traverse_initialize;
  s @! Stream.state_size = sizeof word;
  s @! Stream.state_align = alignof word;
  s @! Stream.state_finalize = dummy_finalizer;
  s;
};

// Return the current list element, go to next
function list_traverse_next (pointer elem_repr,
                             pointer list,
                             pointer state,
                             pointer ret) -> bool {
  index = word load state;
  if (index < list @! PyonList.nelems) {

    // Go to next index
    !state = index + word 1;

    // Put output
    elem_size = elem_repr @! PassConv.size;
    elem_align = elem_repr @! PassConv.align;
    elem_copy = elem_repr @! PassConv.copy;
    pad_elem_size = PAD(elem_size, elem_align);
    () = () call copy ((list @! PyonList.contents) ^+ ((pad_elem_size * index) as int), ret);
    true;
  } else {
    // List is depleted
    false;
  };
};

// Initialize the stream state.  The state is the current list index, and
// it should be initialized to the first list index, zero.
function list_traverse_initialize(pointer state) -> () {
  !state = word 0;
  ();
};

// Allocate and construct a list, given a suitably initialized data array.
// The data array is stolen by the list.
// A pointer to the new list is returned.
procedure pyon_list_from_array (word n_elems,
                                pointer array) -> pointer {
  l = pointer primcall pyon_alloc (sizeof PyonList);
  l @! PyonList.nelems = n_elems;
  l @! PyonList.contents = array;
  l;
};

// Copy the contents of a plain-old-data list into an array.
// The list is not modified.
procedure pyon_list_to_array_POD (pointer elem_repr,
                                  pointer list,
                                  pointer array) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  pad_elem_size = PAD(elem_size, elem_align);

  () = () primcall memcpy (array, list @! PyonList.contents,
                           pad_elem_size * list @! PyonList.nelems);
  ();
};

procedure pyon_list_length (pointer list) -> word {
  list @! PyonList.nelems;
};

// Allocate and return a copy of the POD list.
procedure pyon_list_copy_POD (pointer elem_repr, pointer in_list) -> pointer {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  pad_elem_size = PAD(elem_size, elem_align);

  new_list = pointer primcall pyon_alloc(sizeof PyonList);
  nelems = in_list @! PyonList.nelems;
  new_list @! PyonList.nelems = nelems;

  data_size = pad_elem_size * nelems;
  contents = pointer primcall pyon_alloc(data_size);
  () = () primcall memcpy(contents, new_list @! PyonList.contents, data_size);
  new_list;
};

// Free the POD list.
procedure pyon_list_free_POD (pointer list) -> () {
  () = () primcall pyon_dealloc(list @! PyonList.contents);
  () primcall pyon_dealloc(list);
};

/*****************************************************************************/
/* Testing */

// Write one element of a list.  The element should start out uninitialized.
procedure list_poke (pointer elem_repr,
                     pointer list,
                     word index,
                     pointer value) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  elem_copy = elem_repr @! PassConv.copy;
  pad_elem_size = PAD(elem_size, elem_align);

  elem_ptr = (list @! PyonList.contents) ^+ (pad_elem_size * index) as int;
  () call elem_copy(value, elem_ptr);
};

// Read one element of a list.
procedure list_peek (pointer elem_repr,
                     pointer list,
                     word index,
                     pointer value) -> () {
  elem_size = elem_repr @! PassConv.size;
  elem_align = elem_repr @! PassConv.align;
  elem_copy = elem_repr @! PassConv.copy;
  pad_elem_size = PAD(elem_size, elem_align);

  elem_ptr = (list @! PyonList.contents) ^+ (pad_elem_size * index) as int;
  () call elem_copy(elem_ptr, value);  
};

// Initialize a predefined six-element list of integers.
// Contents are from Sloane's A002485.
function list_db (pointer list) -> () {
  PYON_DB_ALLOC(word 1005)
  my_int = pointer primcall pyon_alloc (sizeof int);
  () = () primcall list_create_uninitialized (int_pass_conv, word 6, list);
  !my_int = int 1;
  () = () primcall list_poke(int_pass_conv, list, word 0, my_int);
  !my_int = int 3;
  () = () primcall list_poke(int_pass_conv, list, word 1, my_int);
  !my_int = int 22;
  () = () primcall list_poke(int_pass_conv, list, word 2, my_int);
  !my_int = int 333;
  () = () primcall list_poke(int_pass_conv, list, word 3, my_int);
  !my_int = int 355;
  () = () primcall list_poke(int_pass_conv, list, word 4, my_int);
  !my_int = int 103993;
  () = () primcall list_poke(int_pass_conv, list, word 5, my_int);
  PYON_DB_DEALLOC(word 1504)
  () primcall pyon_dealloc (my_int);
};

// A routine to test several of the above routines
procedure list_test () -> () {
  PYON_DB_ALLOC(word 1006)
  my_list = pointer primcall pyon_alloc (sizeof PyonList);
  PYON_DB_ALLOC(word 1007)
  my_int = pointer primcall pyon_alloc (sizeof int);

  // Create list
  () = () primcall list_create_uninitialized (int_pass_conv, word 5, my_list);
  !my_int = int 333;
  () = () primcall list_poke(int_pass_conv, my_list, word 0, my_int);
  !my_int = int 444;
  () = () primcall list_poke(int_pass_conv, my_list, word 1, my_int);
  !my_int = int 555;
  () = () primcall list_poke(int_pass_conv, my_list, word 2, my_int);
  !my_int = int 666;
  () = () primcall list_poke(int_pass_conv, my_list, word 3, my_int);
  !my_int = int 777;
  () = () primcall list_poke(int_pass_conv, my_list, word 4, my_int);

  // Duplicate list
  PYON_DB_ALLOC(word 1008)
  my_list2 = pointer primcall pyon_alloc (sizeof PyonList);
  () = () call list_build (nil, nil, int_pass_conv, owned call list_traverse(int_pass_conv, my_list), my_list2);

  // Read list
  () = () primcall list_peek(int_pass_conv, my_list2, word 0, my_int);
  () = () primcall pyon_db_int(int load my_int);
  () = () primcall list_peek(int_pass_conv, my_list2, word 1, my_int);
  () = () primcall pyon_db_int(int load my_int);
  () = () primcall list_peek(int_pass_conv, my_list2, word 2, my_int);
  () = () primcall pyon_db_int(int load my_int);
  () = () primcall list_peek(int_pass_conv, my_list2, word 3, my_int);
  () = () primcall pyon_db_int(int load my_int);
  () = () primcall list_peek(int_pass_conv, my_list2, word 4, my_int);
  () = () primcall pyon_db_int(int load my_int);

  // Free stuff
  () = () call list_finalize(int_pass_conv, my_list);
  () = () call list_finalize(int_pass_conv, my_list2);
  PYON_DB_DEALLOC(word 1505)
  () = () primcall pyon_dealloc(my_list);
  PYON_DB_DEALLOC(word 1506)
  () = () primcall pyon_dealloc(my_list2);
  PYON_DB_DEALLOC(word 1507)
  () = () primcall pyon_dealloc(my_int);
  ();
};