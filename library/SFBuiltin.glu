{- System F builtin constructors.
--
-- At this point in compilation, side effects are ignored.  These constructors
-- therefore have no side effects.
-}

-- Integer arithmetic

operator left 45 * = timesZ;
operator left 40 + = plusZ;
operator left 40 - = subtractZ;

let subtractZ (x : Int) (y : Int) -> Int = x + -1 * y;

-- Integer comparison propositions

operator 20 == = equalZ;
operator 20 /= = notEqualZ;
operator 20 >= = greaterOrEqualZ;
operator 20 >  = greaterThanZ;
operator 20 <= = lessOrEqualZ;
operator 20 <  = lessThanZ;

let equalZ          (x : Int) (y : Int) -> Prop = isZeroZ (x - y);
let notEqualZ       (x : Int) (y : Int) -> Prop = x > y || x < y;
let greaterOrEqualZ (x : Int) (y : Int) -> Prop = isNnegZ (x - y);
let greaterThanZ    (x : Int) (y : Int) -> Prop = isNnegZ (x - y + -1);
let lessOrEqualZ    (x : Int) (y : Int) -> Prop = isNnegZ (y - x);
let lessThanZ       (x : Int) (y : Int) -> Prop = isNnegZ (y - x + -1);

-- Logical propositions

operator right 10 || = or;
operator right 15 && = and;

-- Pyon types
data NoneType : Pure where None : NoneType;
constant Any : Pure;
data bool : Pure where True : bool | False : bool;
constant list : Pure -> Pure;
constant Stream : Pure -> Pure;

data PyonTuple0 : Pure where
  pyonTuple0 : PyonTuple0;
data PyonTuple1 : Pure -> Pure where
  pyonTuple1 : (a : Pure) -> a -> PyonTuple1 a;
data PyonTuple2 : Pure -> Pure -> Pure where
  pyonTuple2 : (a : Pure) -> (b : Pure) -> a -> b -> PyonTuple2 a b;
data PyonTuple3 : Pure -> Pure -> Pure -> Pure where
  pyonTuple3 : (a : Pure) -> (b : Pure) -> (c : Pure)
            -> a -> b -> c -> PyonTuple3 a b c;
data PyonTuple4 : Pure -> Pure -> Pure -> Pure -> Pure where
  pyonTuple4 : (a : Pure) -> (b : Pure) -> (c : Pure) -> (d : Pure)
            -> a -> b -> c -> d -> PyonTuple4 a b c d;
data PyonTuple5 : Pure -> Pure -> Pure -> Pure -> Pure -> Pure where
  pyonTuple5 : (a : Pure) -> (b : Pure) -> (c : Pure) -> (d : Pure)
            -> (e : Pure)
            -> a -> b -> c -> d -> e -> PyonTuple4 a b c d e;

let comparison (a : Pure) -> Pure = a -> a -> bool;
let binary (a : Pure) -> Pure = a -> a -> a;
let binary_any -> Pure = (a : Pure) -> binary a;

-- Parameter-passing conventions.
data PassConv : Pure -> Pure;

constant passConv_Int : PassConv Int;
constant passConv_Float : PassConv Float;
constant passConv_bool : PassConv bool;
constant passConv_NoneType : PassConv NoneType;
constant passConv_iter : (t : Pure) -> PassConv t -> PassConv (Stream t);
constant passConv_list : (t : Pure) -> PassConv (list t);
constant passConv_Any : PassConv Any;

constant passConv_pyonTuple0 : PassConv PyonTuple0;
constant passConv_pyonTuple1 :
    (t : Pure) -> PassConv t -> PassConv (PyonTuple1 t);
constant passConv_pyonTuple2 :
    (t : Pure) -> (u : Pure)
 -> PassConv t -> PassConv u
 -> PassConv (PyonTuple2 t u);
constant passConv_pyonTuple3 :
    (t : Pure) -> (u : Pure) -> (v : Pure)
 -> PassConv t -> PassConv u -> PassConv v
 -> PassConv (PyonTuple3 t u v);
constant passConv_pyonTuple4 :
    (t : Pure) -> (u : Pure) -> (v : Pure) -> (w : Pure)
 -> PassConv t -> PassConv u -> PassConv v -> PassConv w
 -> PassConv (PyonTuple4 t u v w);
constant passConv_pyonTuple5 :
    (t : Pure) -> (u : Pure) -> (v : Pure) -> (w : Pure) -> (x : Pure)
 -> PassConv t -> PassConv u -> PassConv v -> PassConv w -> PassConv x
 -> PassConv (PyonTuple5 t u v w x);

-- Dictionary types for Pyon classes.
data EqDict : Pure -> Pure where
  eqDict : (a : Pure) -> comparison a -> comparison a -> EqDict a;

data OrdDict : Pure -> Pure where
  ordDict : (a : Pure)
         -> EqDict a
         -> comparison a
         -> comparison a
         -> comparison a
         -> comparison a
         -> OrdDict a;

data TraversableDict : (Pure -> Pure) -> Pure where
  traversableDict : (t : Pure -> Pure)
                 -> ((a : Pure) -> PassConv a -> (t a -> Stream a))
                 -> TraversableDict t;

data AdditiveDict : Pure -> Pure where
  additiveDict : (a : Pure) -> (NoneType -> a) -> binary a -> binary a
              -> AdditiveDict a;

data VectorDict : Pure -> Pure where
  vectorDict : (a : Pure)
            -> AdditiveDict a
            -> (a -> Float -> a)
            -> (a -> Float)
            -> VectorDict a;

-- Class dictionary members for predefined instances.

constant Eq_EQ_Int : comparison Int;
constant Eq_NE_Int : comparison Int;
constant Ord_GT_Int : comparison Int;
constant Ord_GE_Int : comparison Int;
constant Ord_LT_Int : comparison Int;
constant Ord_LE_Int : comparison Int;

constant Eq_EQ_Float : comparison Float;
constant Eq_NE_Float : comparison Float;
constant Ord_GT_Float : comparison Float;
constant Ord_GE_Float : comparison Float;
constant Ord_LT_Float : comparison Float;
constant Ord_LE_Float : comparison Float;

constant Eq_EQ_Tuple2 : (a : Pure) -> (b : Pure)
                     -> EqDict a -> EqDict b
                     -> (comparison (PyonTuple2 a b));
constant Eq_NE_Tuple2 : (a : Pure) -> (b : Pure)
                     -> EqDict a -> EqDict b
                     -> (comparison (PyonTuple2 a b));
constant Ord_GT_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));
constant Ord_GE_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));
constant Ord_LT_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));
constant Ord_LE_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));

let Traversable_TRAVERSE_Stream
    (a : Pure)
    (pc : PassConv a)
    (s : Stream a)
 -> Stream a
  = s;
constant Traversable_TRAVERSE_list
  : (a : Pure)
 -> PassConv a
 -> list a
 -> Stream a;

constant Additive_ZERO_Int : NoneType -> Int;
constant Additive_ADD_Int : binary Int;
constant Additive_SUB_Int : binary Int;

constant Additive_ZERO_Float : NoneType -> Float;
constant Additive_ADD_Float : binary Float;
constant Additive_SUB_Float : binary Float;

-- Builtin functions
constant oper_MUL : binary_any;
constant oper_DIV : binary_any;
constant oper_MOD : binary Int;
constant oper_POWER : binary_any;
constant oper_FLOORDIV : binary_any;
constant oper_BITWISEAND : binary Int;
constant oper_BITWISEOR : binary Int;
constant oper_BITWISEXOR : binary Int;
constant oper_NEGATE : (a : Pure) -> a -> a;

constant oper_CAT_MAP : (a : Pure)
                     -> (b : Pure)
                     -> PassConv a
                     -> PassConv b
                     -> (Stream a -> (a -> Stream b) -> Stream b);

constant oper_GUARD : (a : Pure) -> bool -> Stream a -> Stream a;

constant oper_DO : (a : Pure) -> a -> Stream a;

constant fun_makelist : (a : Pure)
                     -> (Stream a -> list a);

constant fun_map : (t : Pure -> Pure) -> (a : Pure) -> (b : Pure)
                -> TraversableDict t
                -> PassConv (t a)
                -> PassConv (t b)
                -> ((a -> b) -> t a -> t b);

constant fun_reduce : (t : Pure -> Pure) -> (a : Pure)
                   -> TraversableDict t
                   -> ((a -> a -> a) -> a -> t a -> a);

constant fun_reduce1 : (t : Pure -> Pure) -> (a : Pure)
                    -> TraversableDict t
                    -> ((a -> a -> a) -> t a -> a);

constant fun_zip : (s : Pure -> Pure)
                -> (t : Pure -> Pure)
                -> (a : Pure)
                -> (b : Pure)
                -> TraversableDict s
                -> TraversableDict t
                -> (s a -> t b -> Stream (PyonTuple2 a b));

constant fun_iota : Stream Int;

constant fun_undefined : (a : Pure) -> a;

