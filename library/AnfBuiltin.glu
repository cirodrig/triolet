{- ANF builtin constructors and functions.
-}

-- Friendly notation for state expressions

operator 50 @ = AtS;
operator 50 :@: = AtE;

operator right 45 ** = SconjS;
operator right 45 :**: = SconjE;

operator 5 | = reversed_WhereS;
operator 5 :|: = reversed_WhereE;

let reversed_WhereS (a : State) (p : Prop) -> State = WhereS p a;
let reversed_WhereE (a : Effect) (p : Prop) -> Effect = WhereE p a;

let comparison (a : Object) -> Pure =
    (la : Addr) -> (lb : Addr) -> (lr : Addr)
 -> Ptr la -> Ptr lb -> Ptr lr
 -> Undef boolO @ lr
 -> Action (a :@: la :**: a :@: lb) (boolO @ lr);

let binary (a : Object) -> Pure =
    (la : Addr) -> (lb : Addr) -> (lr : Addr)
 -> Ptr la -> Ptr lb -> Ptr lr
 -> Undef a @ lr
 -> Action (a :@: la :**: a :@: lb) (a @ lr);

let noneFunction (a : Object) -> Pure =
    (l : Addr) -> (rl : Addr)
 -> Ptr l -> Ptr rl -> Undef a @ rl
 -> Action (NoneTypeO :@: l) (a @ rl);

let traversalFunction (t : Object -> Object) -> Pure =
    (a : Object) -> PassConv a
 -> Action EmpE (   (la : Addr) -> (lo : Addr)
                 -> Ptr la -> Ptr lo
                 -> Undef (StreamO a) @ lo
                 -> Action (t a :@: la) (StreamO a @ lo));

-------------------------------------------------------------------------------

constant PassConv : Object -> Pure;

constant passConv_int : PassConv intO;
constant passConv_float : PassConv floatO;
constant passConv_bool : PassConv boolO;
constant passConv_list : (a : Object) -> PassConv a -> PassConv (listO a);
constant passConv_Stream : (a : Object) -> PassConv a -> PassConv (StreamO a);

constant passConv_PyonTuple2 :
    (a : Object) -> (b : Object)
 -> PassConv a -> PassConv b
 -> PassConv (PyonTuple2O a b);

constant Action : Effect is(covar) -> Linear -> Pure;

-- Pointer type
constant Ptr : Addr -> Pure;

-- | Copy data from source to destination
constant copy :
    (a : Object)
 -> PassConv a
 -> (ia : Addr)			-- Source address
 -> (oa : Addr)			-- Destination address
 -> Ptr ia			-- Source pointer
 -> Ptr oa			-- Destination pointer
 -> Undef a @ oa		-- Destination state
 -> Action (a :@: ia) (a @ oa);

constant reading :
    (eff : Effect)		-- Effect type
 -> (pt : Linear)		-- Input state type
 -> (rt : Linear)		-- Return type
 -> (a : Object)		-- Readable object type
 -> (l : Addr)			-- Object address
 -> (pt -> Action (eff :**: a :@: l) rt)
 -> a @ l			-- State to be read
 -> pt				-- Input state
 -> Action eff (| a @ l, rt |); -- Return the state and return value

constant local :
    (eff : Effect)		-- Effect type
 -> (pt : Linear)		-- Input state type
 -> (rt : Linear)		-- Return type
 -> (a : Object)		-- Writable object type
 -> PassConv a			-- Parameter passing information
 -> ((l : Addr) -> Ptr l -> Undef a @ l -> pt -> Action eff (| rt, a @ l |))
 -> pt				-- Input state
 -> Action eff rt;

-------------------------------------------------------------------------------
-- Pyon value data types

data NoneTypeV : Pure where
  NoneV : NoneTypeV;

data boolV : Pure where
  TrueV : boolV | FalseV : boolV;

-------------------------------------------------------------------------------
-- Pyon data types as object types

-- An undefined object
constant Undef : Object -> Object;

constant NoneTypeO : Object;
constant AnyO : Object;
constant boolO : Object;
constant intO : Object;
constant floatO : Object;
constant listO : Object -> Object;
constant StreamO : Object -> Object;

constant PyonTuple0O : Object;
constant PyonTuple1O : Object -> Object;
constant PyonTuple2O : Object -> Object -> Object;

-------------------------------------------------------------------------------
-- Pyon dictionary types

data EqDict : Object -> Pure where
  eqDict : (a : Object) -> comparison a -> comparison a -> EqDict a;

data OrdDict : Object -> Pure where
  ordDict : (a : Object) -> EqDict a
         -> comparison a -> comparison a -> comparison a -> comparison a
         -> OrdDict a;

data TraversableDict : (Object -> Object) -> Pure where
  traversableDict : (t : Object -> Object)
                 -> traversalFunction t
                 -> TraversableDict t;

data AdditiveDict : Object -> Pure where
  additiveDict :
      (a : Object)
   -> noneFunction a
   -> binary a
   -> binary a
   -> AdditiveDict a;

-------------------------------------------------------------------------------

constant oper_DO :
    (a : Object) -> PassConv a -> Action EmpE ((la : Addr) -> (lo : Addr) -> Ptr la -> Ptr lo -> Undef (StreamO a) @ lo -> Action (a :@: la) (StreamO a @ lo));

constant oper_CAT_MAP :
    (a : Object)
 -> (b : Object)
 -> PassConv a
 -> PassConv b
 -> Action EmpE (   (li : Addr)
                 -> (lo : Addr)
                 -> Ptr li
                 -> ((lj : Addr) -> (lo : Addr) -> Ptr lj -> Ptr lo -> Undef (StreamO b) @ lo -> Action (a :@: lj) (StreamO b @ lo))
                 -> Ptr lo
                 -> Undef (StreamO b) @ lo
                 -> Action (StreamO a :@: li) (StreamO b @ lo));

constant makelist :
    (a : Object)
 -> PassConv a
 -> Action EmpE (   (li : Addr) -> (lo : Addr)
                 -> Ptr li -> Ptr lo
                 -> Undef (listO a) @ lo
                 -> Action (StreamO a :@: li) (listO a @ lo));

constant store_int :
    (a : Addr)
 -> Ptr a
 -> Int
 -> Undef intO @ a
 -> Action EmpE (intO @ a);

constant store_float :
    (a : Addr)
 -> Ptr a
 -> Float
 -> Undef floatO @ a
 -> Action EmpE (floatO @ a);

constant store_bool :
    (a : Addr)
 -> Ptr a
 -> boolV
 -> Undef boolO @ a
 -> Action EmpE (boolO @ a);

constant store_NoneType :
    (a : Addr)
 -> Ptr a
 -> NoneTypeV
 -> Undef NoneTypeO @ a
 -> Action EmpE (NoneTypeO @ a);

constant intro_PyonTuple2 :
    (a : Object)
 -> (b : Object)
 -> PassConv a
 -> PassConv b
 -> (la : Addr)
 -> (lb : Addr)
 -> (lo : Addr)
 -> Ptr la
 -> Ptr lb
 -> Ptr lo
 -> Undef (PyonTuple2O a b) @ lo
 -> Action (a :@: la :**: b :@: lb) (PyonTuple2O a b @ lo);

constant elim_bool :
    (eff : Effect)
 -> (pt : Linear)		-- Input state type
 -> (rt : Linear)
 -> (pt -> Action eff rt)
 -> (pt -> Action eff rt)
 -> pt
 -> Action eff rt;

constant elim_PyonTuple2 :
    (eff : Effect)
 -> (pt : Linear)		-- Input state type
 -> (rt : Linear)
 -> (a : Object)
 -> (b : Object)
 -> (   (la : Addr) -> (lb : Addr) -> Ptr la -> Ptr lb -> pt
     -> Action (eff :**: a :@: la :**: b :@: lb) rt)
 -> pt
 -> Action eff rt;

constant Eq_EQ_int : comparison intO;
constant Eq_NE_int : comparison intO;
constant Eq_EQ_float : comparison floatO;
constant Eq_NE_float : comparison floatO;

constant Ord_GT_int : comparison intO;
constant Ord_GE_int : comparison intO;
constant Ord_LT_int : comparison intO;
constant Ord_LE_int : comparison intO;
constant Ord_GT_float : comparison intO;
constant Ord_GE_float : comparison intO;
constant Ord_LT_float : comparison intO;
constant Ord_LE_float : comparison intO;

constant Additive_ZERO_int : noneFunction intO;
constant Additive_ADD_int : binary intO;
constant Additive_SUB_int : binary intO;
constant Additive_ZERO_float : noneFunction floatO;
constant Additive_ADD_float : binary floatO;
constant Additive_SUB_float : binary floatO;

constant Traversable_TRAVERSE_Stream : traversalFunction StreamO;
constant Traversable_TRAVERSE_list : traversalFunction listO;

constant oper_DIV : (a : Object) -> PassConv a -> Action EmpE (binary a);
constant oper_MOD : binary intO;
constant oper_FLOORDIV : (a : Object) -> PassConv a -> Action EmpE (binary a);
constant oper_POWER : (a : Object) -> PassConv a -> Action EmpE (binary a);
constant oper_NEGATE :
    (a : Object)
 -> PassConv a
 -> Action EmpE ((li : Addr) -> (lo : Addr) -> Ptr li -> Ptr lo -> Undef a @ lo -> Action (a :@: li) (a @ lo));

constant oper_BITWISEAND : binary intO;
constant oper_BITWISEOR : binary intO;
constant oper_BITWISEXOR : binary intO;