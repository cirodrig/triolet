
constant Action : Effect is(covar) -> Pure -> Pure;
constant Stream : Effect is(covar) -> Pure -> Pure;

-- Integer arithmetic

operator left 45 * = timesZ;
operator left 40 + = plusZ;
operator left 40 - = subtractZ;

let subtractZ (x : Int) (y : Int) -> Int = x + -1 * y;

-- Integer comparison propositions

operator 20 == = equalZ;
operator 20 /= = notEqualZ;
operator 20 >= = greaterOrEqualZ;
operator 20 >  = greaterThanZ;
operator 20 <= = lessOrEqualZ;
operator 20 <  = lessThanZ;

let equalZ          (x : Int) (y : Int) -> Prop = isZeroZ (x - y);
let notEqualZ       (x : Int) (y : Int) -> Prop = x > y || x < y;
let greaterOrEqualZ (x : Int) (y : Int) -> Prop = isNnegZ (x - y);
let greaterThanZ    (x : Int) (y : Int) -> Prop = isNnegZ (x - y + -1);
let lessOrEqualZ    (x : Int) (y : Int) -> Prop = isNnegZ (y - x);
let lessThanZ       (x : Int) (y : Int) -> Prop = isNnegZ (y - x + -1);

-- Logical propositions

operator right 10 || = or;
operator right 15 && = and;

-- Side effect stuff

constant Ptr : Addr -> Pure;
constant Stored : Pure -> Object;
constant subscript : Addr -> Int -> Addr;

operator 5 :|: = reversed_WhereE;
operator right 45 :**: = SconjE;
operator 50 :@: = AtE;

let reversed_WhereE (e : Effect) (p : Prop) -> Effect = WhereE p e;

let listElementEffect (base : Addr) (o : Object) (offset : Int) -> Effect =
  o :@: subscript base offset;

let listContentsEffect (base : Addr) (o : Object) (size : Int) -> Effect =
  SetE (fun i : Int => listElementEffect base o i :|: 0 <= i && i < size);

-- Pyon types
data NoneType : Pure where None : NoneType;
constant Any : Pure;
data bool : Pure where True : bool | False : bool;
constant list : Pure -> Pure;

data PyonTuple0 : Pure where
  pyonTuple0 : PyonTuple0;
data PyonTuple1 : Pure -> Pure where
  pyonTuple1 : (a : Pure) -> a -> PyonTuple1 a;
data PyonTuple2 : Pure -> Pure -> Pure where
  pyonTuple2 : (a : Pure) -> (b : Pure) -> a -> b -> PyonTuple2 a b;
data PyonTuple3 : Pure -> Pure -> Pure -> Pure where
  pyonTuple3 : (a : Pure) -> (b : Pure) -> (c : Pure)
            -> a -> b -> c -> PyonTuple3 a b c;
data PyonTuple4 : Pure -> Pure -> Pure -> Pure -> Pure where
  pyonTuple4 : (a : Pure) -> (b : Pure) -> (c : Pure) -> (d : Pure)
            -> a -> b -> c -> d -> PyonTuple4 a b c d;
data PyonTuple5 : Pure -> Pure -> Pure -> Pure -> Pure -> Pure where
  pyonTuple5 : (a : Pure) -> (b : Pure) -> (c : Pure) -> (d : Pure)
            -> (e : Pure)
            -> a -> b -> c -> d -> e -> PyonTuple4 a b c d e;

let comparison (a : Pure) -> Pure = a -> a -> Action EmpE bool;
let binary (a : Pure) -> Pure = a -> a -> Action EmpE a;
let binary_any -> Pure = (a : Pure) -> binary a;

-- Dictionary types for Pyon classes.
data EqDict : Pure -> Pure where
  eqDict : (a : Pure) -> comparison a -> comparison a -> EqDict a;

data OrdDict : Pure -> Pure where
  ordDict : (a : Pure)
         -> EqDict a
         -> comparison a
         -> comparison a
         -> comparison a
         -> comparison a
         -> OrdDict a;

data TraversableDict : (Pure -> Pure) -> Pure where
  traversableDict : (t : Pure -> Pure)
                 -> ((a : Pure) -> t a -> Stream EmpE a)
                 -> TraversableDict t;

data AdditiveDict : Pure -> Pure where
  additiveDict : (a : Pure) -> a -> binary a -> binary a
              -> AdditiveDict a;

data VectorDict : Pure -> Pure where
  vectorDict : (a : Pure)
            -> AdditiveDict a
            -> (a -> Float -> Action EmpE a)
            -> (a -> Action EmpE Float)
            -> VectorDict a;

-- Class dictionary members for predefined instances.

constant Eq_EQ_Int : comparison Int;
constant Eq_NE_Int : comparison Int;
constant Ord_GT_Int : comparison Int;
constant Ord_GE_Int : comparison Int;
constant Ord_LT_Int : comparison Int;
constant Ord_LE_Int : comparison Int;

constant Eq_EQ_Float : comparison Float;
constant Eq_NE_Float : comparison Float;
constant Ord_GT_Float : comparison Float;
constant Ord_GE_Float : comparison Float;
constant Ord_LT_Float : comparison Float;
constant Ord_LE_Float : comparison Float;

constant Eq_EQ_Tuple2 : (a : Pure) -> (b : Pure)
                     -> EqDict a -> EqDict b
                     -> Action EmpE (comparison (PyonTuple2 a b));
constant Eq_NE_Tuple2 : (a : Pure) -> (b : Pure)
                     -> EqDict a -> EqDict b
                     -> Action EmpE (comparison (PyonTuple2 a b));
constant Ord_GT_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> Action EmpE (comparison (PyonTuple2 a b));
constant Ord_GE_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> Action EmpE (comparison (PyonTuple2 a b));
constant Ord_LT_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> Action EmpE (comparison (PyonTuple2 a b));
constant Ord_LE_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> Action EmpE (comparison (PyonTuple2 a b));

let Traversable_TRAVERSE_Stream (a : Pure) (s : Stream EmpE a)
  -> Stream EmpE a =
  s;
constant Traversable_TRAVERSE_list : (a : Pure) -> list a -> Stream EmpE a;

constant Additive_ZERO_Int : Int;
constant Additive_ADD_Int : binary Int;
constant Additive_SUB_Int : binary Int;

constant Additive_ZERO_Float : Float;
constant Additive_ADD_Float : binary Float;
constant Additive_SUB_Float : binary Float;

-- Builtin functions
constant oper_MUL : binary_any;
constant oper_DIV : binary_any;
constant oper_MOD : binary Int;
constant oper_POWER : binary_any;
constant oper_FLOORDIV : binary_any;
constant oper_BITWISEAND : binary Int;
constant oper_BITWISEOR : binary Int;
constant oper_BITWISEXOR : binary Int;
constant oper_NEGATE : (a : Pure) -> a -> Action EmpE a;

constant oper_CAT_MAP : (eff : Effect)
                     -> (a : Pure)
                     -> (b : Pure)
                     -> (a -> Stream eff b)
                     -> Stream eff a
                     -> Stream eff b;

let oper_CAT_MAP_noeffect -> (   (a : Pure)
                              -> (b : Pure)
                              -> (a -> Stream EmpE b)
                              -> Stream EmpE a
                              -> Stream EmpE b)
 = oper_CAT_MAP EmpE;

constant oper_GUARD : (a : Pure) -> bool -> Stream EmpE a -> Stream EmpE a;

constant oper_DO : (a : Pure) -> a -> Stream EmpE a;

constant fun_makelist : (t : Pure -> Pure) -> (a : Pure)
                     -> TraversableDict t
                     -> Action EmpE (t a -> Action EmpE (list a));

constant fun_map : (t : Pure -> Pure) -> (a : Pure) -> (b : Pure)
                -> TraversableDict t
                -> Action EmpE ((a -> Action EmpE b) -> t a -> Action EmpE (t b));

constant fun_reduce : (t : Pure -> Pure) -> (a : Pure)
                   -> TraversableDict t
                   -> Action EmpE ((a -> a -> Action EmpE a) -> a -> t a -> Action EmpE a);

constant fun_reduce1 : (t : Pure -> Pure) -> (a : Pure)
                    -> TraversableDict t
                    -> Action EmpE ((a -> a -> Action EmpE a) -> t a -> Action EmpE a);

constant fun_zip : (s : Pure -> Pure)
                -> (t : Pure -> Pure)
                -> (a : Pure)
                -> (b : Pure)
                -> TraversableDict s
                -> TraversableDict t
                -> Action EmpE (s a -> t b -> Stream EmpE (PyonTuple2 a b));

constant fun_iota : Stream EmpE Int;

constant fun_undefined : (a : Pure) -> Action EmpE a;

-- List traversal with side effects
constant loadListElement : (a : Pure)
                        -> (base : Addr)
                        -> Ptr base
                        -> (index : Int)
                        -> Action (Stored a :@: subscript base index) a;

-- Stream that loops over an index range
constant generate : (eff : Effect)
                 -> (a : Pure)
                 -> (bound : Int)
                 -> ((i : Int) -> Stream eff a)
                 -> Stream eff a;

constant unpackList :
    (a : Pure)                          -- List element type
 -> (r : Pure)                          -- Return type
 -> (inv : Effect)                      -- Invariant effect type
 -> (base : Addr)                       -- List base address
 -> Ptr base                            -- List pointer
 -> (   (size : Int)
     -> (data_base : Addr)
     -> Ptr data_base
     -> Action (Stored (list a) :@: base :**:
                listContentsEffect data_base (Stored a) size :**:
                inv) r)
 -> Action (Stored (list a) :@: base :**: inv) r;
