
-------------------------------------------------------------------------------
-- Integer index arithmetic

plus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (plus_i m n) attribute(inline) =
  let type sum_t = plus_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (plus_fii @m @n fa fb)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty @n. iNegInfty @sum_t
      }
  };


minus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (minus_i m n) attribute(inline) =
  let type sum_t = minus_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (minus_fii @m @n fa fb)
      ; iPosInfty @n. iNegInfty @sum_t
      ; iNegInfty @n. iPosInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty @n. iPosInfty @sum_t
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty @n. iNegInfty @sum_t
      ; iNegInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  };


min_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (min_i m n) attribute(inline) =
  let type sum_t = min_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (min_fii @m @n fa fb)
      ; iPosInfty @n.
          case fa of fiInt @m (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n).
	  case fb of fiInt @n (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iNegInfty @m.
      iNegInfty @sum_t
  };


max_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (max_i m n) attribute(inline) =
  let type sum_t = max_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (max_fii @m @n fa fb)
      ; iNegInfty @n.
          case fa of fiInt @m (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iPosInfty @n. iPosInfty @sum_t
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n).
	  case fb of fiInt @n (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      iPosInfty @sum_t
  };


-- Operations on finite indexed ints aren't inlined until near the end,
-- because they don't enable other optimizations.  By delaying inlining,
-- code doesn't expand as much.

plus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	 -> FIInt (plus_i m n)
	 attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(plus_i m n) (x_i +# y_i);


minus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	  -> FIInt (minus_i m n)
	  attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(minus_i m n) (x_i -# y_i);


min_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (min_i m n)
	attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(min_i m n) (min_int x_i y_i);


max_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (max_i m n)
	attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(max_i m n) (max_int x_i y_i);


-- Determine if there are integers that are greater than or equal to @x@,
-- but less than @y@.
-- The result is False if @x == y@.
range_nonempty_ii @(m n : intindex) (x : IInt m) (y : IInt n) -> bool
  attribute(inline) =
  case x of {
    iInt @m (fx : FIInt m).
      case fx of fiInt @m (x_i : int).
      case y of {
        iInt @n (fy : FIInt n).
          case fy of fiInt @n (y_i : int).
          x_i <# y_i
      ; iPosInfty @n. True
      ; iNegInfty @n. False
      }
  ; iNegInfty @m.
      case y of {
        iNegInfty @n. False
      ; iInt @n (fy : FIInt n). True
      ; iPosInfty @n. True
      }
  ; iPosInfty @m. False
  };

fromIndInt @(N : intindex) (ii : IInt N) -> FIInt N attribute(inline) =
  case ii of {
    iInt @N (fii : FIInt N). fii;
    iPosInfty @N. except @(FIInt N);
    iNegInfty @N. except @(FIInt N)
  };

-- Compute the intersection of a slice with an interval.  The result is a new
-- interval and its mapping to points on the old interval.
--
-- A reference implementation of this function is in Slice.hs.

intersectSliceWithRange @(lo hi : intindex)
		        (range_lo_iint : IInt lo)
                        (range_hi_iint : IInt hi)
                        (slice_object : SliceObject)
                        -> InternalSlice =
  case slice_object of
    sliceObject (m_slice_lo : MaybeVal int)
                (m_slice_hi : MaybeVal int)
                (m_m_stride : MaybeVal (MaybeVal int)).

  let counting_up : bool =
        case m_m_stride of {
          nothingVal @(MaybeVal int). True
        ; justVal @(MaybeVal int) (m_stride : MaybeVal int).
            case m_stride of { nothingVal @int. True
                             ; justVal @int (stride : int). stride ># 0
                             }
        } in

  let lo_bound : MaybeVal int =
        case range_lo_iint of {
          iInt @lo (range_flo : FIInt lo).
            case range_flo of fiInt @lo (range_lo : int).
            if counting_up
            then case m_slice_lo of {
                   nothingVal @int.
                     justVal @int range_lo
                 ; justVal @int (slice_lo : int).
                     justVal @int (max_int range_lo slice_lo)
                 }
            else case m_slice_hi of {
                   nothingVal @int.
                     justVal @int range_lo
                 ; justVal @int (slice_hi : int).
                     justVal @int (max_int range_lo (slice_hi +# 1))
                 }
        ; iNegInfty @lo.
            if counting_up
            then m_slice_lo
            else case m_slice_hi of {
                   nothingVal @int. nothingVal @int
                 ; justVal @int (slice_hi : int).
                     justVal @int (slice_hi +# 1)
                 }
        ; iPosInfty @lo.
            except @(MaybeVal int)
        } in

  let hi_bound : MaybeVal int =
        case range_hi_iint of {
          iInt @hi (range_fhi : FIInt hi).
            case range_fhi of fiInt @hi (range_hi : int).
            if counting_up
            then case m_slice_hi of {
                   nothingVal @int.
                     justVal @int range_hi
                 ; justVal @int (slice_hi : int).
                     justVal @int (min_int range_hi slice_hi)
                 }
            else case m_slice_lo of {
                   nothingVal @int.
                     justVal @int range_hi
                 ; justVal @int (slice_lo : int).
                     justVal @int (min_int range_hi (slice_lo +# 1))
                 }
        ; iPosInfty @hi.
            if counting_up
            then m_slice_hi
            else case m_slice_lo of {
                   nothingVal @int. nothingVal @int
                 ; justVal @int (slice_lo : int).
                     justVal @int (slice_lo +# 1)
                 }
        ; iNegInfty @hi.
            except @(MaybeVal int)
        } in

  if case lo_bound of {
       justVal @int (lo_bound_val : int).
         case hi_bound of {
           justVal @int (hi_bound_val : int).
             lo_bound_val ># hi_bound_val
         ; nothingVal @int. False
         }
     ; nothingVal @int. False
     }
  then -- Slice does not intersect range.  Return an empty slice.
       internalSlice @0 @0 zero_ii zero_ii 1 0
  else case m_m_stride of {
         nothingVal @(MaybeVal int).
           -- This is a range slice
           letfun
             k2 @(lo hi : intindex) (lo_ind : IInt lo) (hi_ind : IInt hi)
               -> InternalSlice =
               internalSlice @lo @hi lo_ind hi_ind 1 0 in

           letfun
             k1 @(lo : intindex) (lo_ind : IInt lo) -> InternalSlice =
               case hi_bound of {
                 justVal @int (hi_bound_val : int).
                   case defineIntIndex hi_bound_val of
                     someIInt @(hi : intindex) (hi_ind : FIInt hi).
                   k2 @lo @hi lo_ind (iInt @hi hi_ind)
               ; nothingVal @int.
                   k2 @lo @pos_infty lo_ind (iPosInfty @pos_infty)
               } in

           case lo_bound of {
             justVal @int (lo_bound_val : int).
               case defineIntIndex lo_bound_val of
                 someIInt @(lo : intindex) (lo_ind : FIInt lo).
               k1 @lo (iInt @lo lo_ind)
           ; nothingVal @int.
               k1 @neg_infty (iNegInfty @neg_infty)
           }

       ; justVal @(MaybeVal int) (m_stride : MaybeVal int).
           -- This is a strided slice
           let stride : int =
                 case m_stride of {
                   justVal @int (stride : int).
                     if stride ==# 0 then except @int else stride
                 ; nothingVal @int. 1
                 } in
           intersectStrideSliceWithRange
           lo_bound hi_bound m_slice_lo m_slice_hi stride
       };

intersectStrideSliceWithRange
  (lo_bound : MaybeVal int)
  (hi_bound : MaybeVal int)
  (slice_lo_bound : MaybeVal int)
  (slice_hi_bound : MaybeVal int)
  (stride : int)
  -> InternalSlice attribute(inline) =

  let counting_up : bool = stride ># 0 in
  case if counting_up
       then (1, lo_bound, hi_bound)
       else (-1,
             case hi_bound of {
               nothingVal @int. nothingVal @int
             ; justVal @int (hb : int). justVal @int (hb -# 1)},
             case lo_bound of {
               nothingVal @int. nothingVal @int
             ; justVal @int (lb : int). justVal @int (lb -# 1)}) of
    (sense : int, near_bound : MaybeVal int, far_bound : MaybeVal int).

  let first_point : int =
        case slice_lo_bound of {
          nothingVal @int.
            case near_bound of {
              nothingVal @int. except @int
            ; justVal @int (nb : int). nb
            }
        ; justVal @int (lb : int).
            case near_bound of {
              nothingVal @int. lb
            ; justVal @int (nb : int).
                if sense *# (nb -# lb) ># 0
                then nb +# (lb -# nb) %# stride
                else lb
            }
        } in

  let end_point : MaybeVal int =
        case slice_hi_bound of {
          nothingVal @int. far_bound
        ; justVal @int (hb : int).
            case far_bound of {
              nothingVal @int. justVal @int hb
            ; justVal @int (fb : int).
                justVal @int (if sense *# (fb -# hb) <# 0 then fb else hb)
            }
        } in

  letfun
    k @(size_index : intindex) (size_val : IInt size_index)
      -> InternalSlice =
      internalSlice @0 @size_index zero_ii size_val stride first_point
  in

  -- Determine size of range, then build slice object
  case end_point of {
    nothingVal @int.
      k @pos_infty (iPosInfty @pos_infty)
  ; justVal @int (ep : int).
      let delta : int = ep -# first_point in
      let count : int = delta //# stride +#
                        (if delta %# stride /=# 0 then 1 else 0) in
      case defineIntIndex (max_int 0 count)
        of someIInt @(size_index : intindex) (size_val : FIInt size_index).
      k @size_index (iInt @size_index size_val)
  };


safeIndex @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (ix : index (shape t))
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =

  let type sh = shape t in

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).
  
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index sh -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer sh).

  case boxed @sh (get_shape @a container) of boxed @sh (container_shape : sh).

  -- Check bounds, then return a value
  if shape_in_range container_shape ix
  then at_index @a repr container ix ret
  else except @(IEffect a);


safeSlice @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (sl : slice (shape t))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  shape_slice @t @a
  (unsafeMakeCoercion @(BoxedType sh) @(BoxedType sh))
  indexable repr container sl;

-------------------------------------------------------------------------------
-- Conversions

view1ToDarr1 @(a b : bare)
  (vw : view1 a)
  (elim : (N : intindex) -> FIInt N -> darr1 N a -> Writer b)
  (elim_empty : Writer b)
  (ret : OutPtr b)
  -> IEffect b attribute(inline) =
  case vw of {
    mk_view1 @a @(lo hi : intindex)
             (ilo : IInt lo) (ihi : IInt hi) (f : int -> Writer a).
      let flo : FIInt lo = fromIndInt @lo ilo in
      let fhi : FIInt hi = fromIndInt @hi ihi in

      let type N = minus_i hi lo in
      let delta : FIInt N = minus_fii @hi @lo fhi flo in
      case flo of fiInt @lo (lo_i : int).

      -- The darr is zero-indexed; subtract the offset
      letfun
        f2 (i : int) -> Writer a = f (AdditiveDict_int_sub i lo_i)
      in

      elim @N delta (mk_darr1 @N @a f2) ret;

    empty_view1 @a.
      elim_empty ret
  };


darr1ToView1 @(N : intindex) @(a : bare)
  (size : FIInt N)
  (darr : darr1 N a)
  -> view1 a attribute(inline) =
  case darr of mk_darr1 @N @a (f : int -> Writer a).
  mk_view1 @a @0 @N zero_ii (iInt @N size) f;


viewToSequence @(a : bare) (repr : Repr a) (vw : view1 a)
  -> Sequence a attribute(inline) =
  case boxed @(StoredBox (Sequence a))
    (view1ToDarr1 @a @(StoredBox (Sequence a)) vw
     (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a)
       -> Writer (StoredBox (Sequence a)).
       case darr of mk_darr1 @N @a (f : int -> Writer a).
       storedBox @(Sequence a) (generate @N @a (iInt @N size) repr f))
     (storedBox @(Sequence a) (Sequence_empty @a)))
  of boxed @(StoredBox (Sequence a)) (sb : StoredBox (Sequence a)).
  case sb of storedBox @(Sequence a) (sq : Sequence a).
  sq;


sequenceToView @(a : bare) (repr : Repr a) (sq : Sequence a)
  -> view1 a attribute(inline) =
  -- Write the entire sequence to a list
  case boxed @(list a) (Sequence_list_build @a repr sq)
  of boxed @(list a) (ls : list a).

  -- Then traverse the list
  case ls of make_list @a @(N : intindex)
                       (size : FIInt N) (aref : Referenced (arr N a)).
  case aref of referenced @(arr N a) (ay : arr N a).

  darr1ToView1 @N @a size (arr1D_traverse @N @a repr size ay);


-------------------------------------------------------------------------------
-- Traversable methods

arr1D_traverse @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N) (ay : arr N a)
  -> darr1 N a attribute(inline) =
  mk_darr1 @N @a
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr (subscript @N @a repr ay i) ret);

arr1D_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (s : darr1 N a)
  (ret : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline, inline_final) =

  case s of mk_darr1 @N @a (f : int -> Writer a).

  doall @N @(arr N a) @a size
  (\ (i : int) -> IEffect a. f i (subscript_out @N @a repr ret i));

arr2D_traverse @(M N : intindex) @(a : bare)
  (repr : Repr a) (height : FIInt M) (width : FIInt N) (ay : arr M (arr N a))
  -> darr2 M N a attribute(inline) =
  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in

  mk_darr2 @M @N @a
  (\ (j : int) (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr
     (subscript @N @a repr (subscript @M @(arr N a) row_repr ay j) i)
     ret);

arr2D_build @(M N : intindex) @(a : bare)
  (repr : Repr a) (height : FIInt M) (width : FIInt N)
  (s : darr2 M N a)
  (ret : OutPtr (arr M (arr N a)))
  -> IEffect (arr M (arr N a))
  attribute(inline, inline_final) =

  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in
  case s of mk_darr2 @M @N @a (f : int -> int -> Writer a).

  doall @M @(arr M (arr N a)) @(arr N a) height
  (\ (j : int) -> IEffect (arr N a).
     doall @N @(arr N a) @a width
     (\ (i : int) -> IEffect a.
        f j i (subscript_out @N @a repr (subscript_out @M @(arr N a) row_repr ret j) i)));

{-
Old array builder function, using a stream to write the array
  case s of linStream @(arr_shape N dim0) @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case size of fiInt @N (bound : int).

  letfun
    go (i : int) (state : st) -> EffTok =
      if EqDict_int_eq i bound
      then emptyEffTok
      else case stream_next state of {

             -- Obtain value from stream
             streamValue @st @(BoxedType a)
	       (next_state : st) (result : BoxedType a).
               -- Write into the array
	       seqEffTok (toEffTok @a (convertToBare @a repr result
	       		               (subscript_out @N @a repr ret i)))
                         (go (AdditiveDict_int_add i 1) next_state);

             streamEmpty @st @(BoxedType a).
	       except @EffTok
	   }
  in fromEffTok @(arr N a) (go 0 stream_state);
-}

TraversableDict_Stream_build @(sh : bare) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;

TraversableDict_Stream_traverse @(sh : bare) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;

TraversableDict_list_build @(a : bare)
  (repr : Repr a) (s : Stream dim1 a) (ret : OutPtr (list a))
  -> IEffect (list a) attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      Sequence_list_build @a repr sq ret
  ; viewStream @a (vw : view1 a).
      view1ToDarr1 @a @(list a) vw
      (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a)
        -> Writer (list a).
	 make_list @a @N size (referenced @(arr N a) (arr1D_build @N @a repr size darr)))
      (\ (ret : OutPtr (list a)) -> IEffect (list a).
        make_list @a @0 zero_fii (referenced @(arr 0 a) (\ (ret : OutPtr (arr 0 a)) -> IEffect (arr 0 a). fromEffTok @(arr 0 a) emptyEffTok)) ret)
      ret
  };

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : bare) (repr : Repr a) (ls : list a)
  -> Stream dim1 a attribute(inline) =
  case ls of make_list @a @(N : intindex)
                       (size : FIInt N) (aref : Referenced (arr N a)).
  case aref of referenced @(arr N a) (ay : arr N a).

  viewStream @a (darr1ToView1 @N @a size (arr1D_traverse @N @a repr size ay));

TraversableDict_view0_build
  @(a : bare) (repr : Repr a) (v : view0 a) -> view0 a attribute(inline) = v;

TraversableDict_view0_traverse
  @(a : bare) (repr : Repr a) (v : view0 a) -> view0 a attribute(inline) = v;

TraversableDict_view1_build
  @(a : bare) (repr : Repr a) (s : Stream1 a) -> view1 a attribute(inline) =
  case s of {
    viewStream @a (v : view1 a). v

  ; sequenceStream @a (sq : Sequence a).
      -- Convert to a list, then read the list
      case boxed @(list a) (Sequence_list_build @a repr sq)
      of boxed @(list a) (ls : list a).
      case ls of
        make_list @a @(N : intindex) (size : FIInt N) (ayref : Referenced (arr N a)).
      case ayref of referenced @(arr N a) (ay : arr N a).
      darr1ToView1 @N @a size (arr1D_traverse @N @a repr size ay)
  };

TraversableDict_view1_traverse
  @(a : bare) (repr : Repr a) (v : view1 a) -> Stream1 a attribute(inline) =
  viewStream @a v;

TraversableDict_view2_build
  @(a : bare) (repr : Repr a) (v : view2 a) -> view2 a attribute(inline) = v;

TraversableDict_view2_traverse
  @(a : bare) (repr : Repr a) (v : view2 a) -> view2 a attribute(inline) = v;

TraversableDict_array0_traverse
  @(a : bare) (repr : Repr a) (ay : array0 a) -> view0 a attribute(inline) =
  case ay of mk_array0 @a (x : a).
  mk_view0 @a (\ (none : NoneType) -> Writer a. copy @a repr x);

TraversableDict_array0_build
  @(a : bare) (repr : Repr a) (vw : view0 a) (ret : OutPtr (array0 a))
  -> IEffect (array0 a) attribute(inline) =

  case vw of mk_view0 @a (f : NoneType -> Writer a).
  mk_array0 @a (f None) ret;

TraversableDict_array1_traverse
  @(a : bare) (repr : Repr a) (ar : array1 a) -> Stream1 a attribute(inline) =
  case ar of
    mk_array1 @a @(lo hi : intindex)
    (flo : FIInt lo) (fhi : FIInt hi)
    (ayref : Referenced (arr (minus_i hi lo) a)).
  let type N = minus_i hi lo in
  case ayref of referenced @(arr N a) (ay : arr N a).
  
  -- Get the origin of the array
  case flo of fiInt @lo (lo_i : int).

  viewStream @a
  (mk_view1 @a @lo @hi (iInt @lo flo) (iInt @hi fhi)
   (\ (i : int) (ret : OutPtr a) -> IEffect a.
      let index : int = AdditiveDict_int_sub i lo_i in
      copy @a repr (subscript @N @a repr ay index) ret));

TraversableDict_array1_build
  @(a : bare) (repr : Repr a) (s : Stream1 a) (ret : OutPtr (array1 a))
  -> IEffect (array1 a) attribute(inline) =
  case s of {
    viewStream @a (v : view1 a).
      case v of {
        mk_view1 @a @(lo hi : intindex)
	(ilo : IInt lo) (ihi : IInt hi) (f : int -> Writer a).
          let flo : FIInt lo = fromIndInt @lo ilo in
          let fhi : FIInt hi = fromIndInt @hi ihi in

          let type N = minus_i hi lo in
          let delta : FIInt N = minus_fii @hi @lo fhi flo in
          case flo of fiInt @lo (lo_i : int).

          -- The array is zero-indexed; subtract the offset
          letfun
            f2 (i : int) -> Writer a = f (AdditiveDict_int_sub i lo_i)
          in

          mk_array1 @a @lo @hi flo fhi
          (referenced @(arr N a)
           (arr1D_build @N @a repr delta (mk_darr1 @N @a f2)))
          ret;

        empty_view1 @a.
          let type N0 = minus_i 0 0 in
          mk_array1 @a @0 @0 zero_fii zero_fii
          (referenced @(arr N0 a)
           (\ (ret : OutPtr (arr N0 a)) -> IEffect (arr N0 a).
              fromEffTok @(arr N0 a) emptyEffTok))
          ret
      }

  ; sequenceStream @a (sq : Sequence a).
      -- Convert to an array1
      Sequence_array1_build @a repr sq ret
  };

TraversableDict_array2_traverse
  @(a : bare) (repr : Repr a) (ar : array2 a) -> view2 a attribute(inline) =
  case ar of
    mk_array2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (fMlo : FIInt Mlo) (fMhi : FIInt Mhi)
    (fNlo : FIInt Nlo) (fNhi : FIInt Nhi)
    (ayref : Referenced (arr (minus_i Mhi Mlo) (arr (minus_i Nhi Nlo) a))).
  let type M = minus_i Mhi Mlo in
  let type N = minus_i Nhi Nlo in
  let width : FIInt N = minus_fii @Nhi @Nlo fNhi fNlo in
  case ayref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).

  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in
  case fMlo of fiInt @Mlo (Mlo_i : int).
  case fNlo of fiInt @Nlo (Nlo_i : int).

  mk_view2 @a @Mlo @Mhi @Nlo @Nhi
  (iInt @Mlo fMlo) (iInt @Mhi fMhi) (iInt @Nlo fNlo) (iInt @Nhi fNhi)
  (\ (j : int) (i : int) -> Writer a.
     let index_m : int = j -# Mlo_i in
     let index_n : int = i -# Nlo_i in

     copy @a repr
     (subscript @N @a repr
      (subscript @M @(arr N a) row_repr ay index_m) index_n));

TraversableDict_array2_build
  @(a : bare) (repr : Repr a) (v : view2 a) (ret : OutPtr (array2 a))
  -> IEffect (array2 a) attribute(inline) =
  case v of
    mk_view2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (iMlo : IInt Mlo) (iMhi : IInt Mhi)
    (iNlo : IInt Nlo) (iNhi : IInt Nhi)
    (f : int -> int -> Writer a).
  let fMlo : FIInt Mlo = fromIndInt @Mlo iMlo in
  let fMhi : FIInt Mhi = fromIndInt @Mhi iMhi in
  let fNlo : FIInt Nlo = fromIndInt @Nlo iNlo in
  let fNhi : FIInt Nhi = fromIndInt @Nhi iNhi in

  let type M = minus_i Mhi Mlo in
  let type N = minus_i Nhi Nlo in
  let height : FIInt M = minus_fii @Mhi @Mlo fMhi fMlo in
  let width : FIInt N = minus_fii @Nhi @Nlo fNhi fNlo in

  case fMlo of fiInt @Mlo (Mlo_i : int).
  case fNlo of fiInt @Nlo (Nlo_i : int).

  letfun
    f2 (j : int) (i : int) -> Writer a =
      f (AdditiveDict_int_sub j Mlo_i) (AdditiveDict_int_sub i Nlo_i)
  in

  mk_array2 @a @Mlo @Mhi @Nlo @Nhi fMlo fMhi fNlo fNhi
  (referenced @(arr M (arr N a))
   (arr2D_build @M @N @a repr height width (mk_darr2 @M @N @a f2)))
  ret;

-------------------------------------------------------------------------------
-- Indexable methods

IndexableDict_list_at_point
  @(a : bare)
  (repr : Repr a)
  (ls : list a)
  (index : Stored int)
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case ls of
    make_list @a @(N : intindex) (size : FIInt N) (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).
  case index of stored @int (index_i : int).
  copy @a repr (subscript @N @a repr ay index_i) ret;


IndexableDict_list_get_shape
  @(a : bare)
  (ls : list a)
  (ret : OutPtr dim1)
  -> IEffect dim1 attribute(inline) =
  case ls of
    make_list @a @(N : intindex) (size : FIInt N) (ayref : Referenced (arr N a)).
  mk_dim1 @0 @N zero_ii (iInt @N size) ret;

IndexableDict_view0_at_point
  @(a : bare)
  (repr : Repr a)
  (vw : view0 a)
  (index : Stored NoneType)
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case vw of mk_view0 @a (f : NoneType -> Writer a). f None ret;


IndexableDict_view0_get_shape
  @(a : bare)
  (vw : view0 a)
  (ret : OutPtr dim0)
  -> IEffect dim0 attribute(inline) =
  mk_dim0 ret;


IndexableDict_view1_at_point
  @(a : bare)
  (repr : Repr a)
  (vw : view1 a)
  (index : Stored int)
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case vw of {
    mk_view1 @a @(lo hi : intindex)
    (ilo : IInt lo) (ihi : IInt hi) (f : int -> Writer a).
      case index of stored @int (index_i : int).
      f index_i ret;

    empty_view1 @a.
      except @(IEffect a)
  };


IndexableDict_view1_get_shape
  @(a : bare)
  (vw : view1 a)
  (ret : OutPtr dim1)
  -> IEffect dim1 attribute(inline) =
  case vw of {
    mk_view1 @a @(lo hi : intindex)
    (ilo : IInt lo) (ihi : IInt hi) (f : int -> Writer a).
      mk_dim1 @lo @hi ilo ihi ret;

    empty_view1 @a.
      mk_dim1 @0 @0 zero_ii zero_ii ret
  };


IndexableDict_view2_at_point
  @(a : bare)
  (repr : Repr a)
  (vw : view2 a)
  (index : PyonTuple2 (Stored int) (Stored int))
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case vw of
    mk_view2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (imlo : IInt Mlo) (imhi : IInt Mhi)
    (inlo : IInt Nlo) (inhi : IInt Nhi)
    (f : int -> int -> Writer a).
  case index of pyonTuple2 @(Stored int) @(Stored int)
                (ix_y : Stored int) (ix_x : Stored int).
  case ix_y of stored @int (ix_y_i : int).
  case ix_x of stored @int (ix_x_i : int).
  f ix_y_i ix_x_i ret;


IndexableDict_view2_get_shape
  @(a : bare)
  (vw : view2 a)
  (ret : OutPtr dim2)
  -> IEffect dim2 attribute(inline) =
  case vw of
    mk_view2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (imlo : IInt Mlo) (imhi : IInt Mhi)
    (inlo : IInt Nlo) (inhi : IInt Nhi)
    (f : int -> int -> Writer a).
  mk_dim2 @Mlo @Mhi @Nlo @Nhi imlo imhi inlo inhi ret;


IndexableDict_array0_at_point
  @(a : bare)
  (repr : Repr a)
  (ary : array0 a)
  (index : Stored NoneType)
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case ary of mk_array0 @a (x : a). copy @a repr x ret;


IndexableDict_array0_get_shape
  @(a : bare)
  (ary : array0 a)
  (ret : OutPtr dim0)
  -> IEffect dim0 attribute(inline) =
  mk_dim0 ret;


IndexableDict_array1_at_point
  @(a : bare)
  (repr : Repr a)
  (ary : array1 a)
  (index : Stored int)
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case ary of
    mk_array1 @a @(lo hi : intindex)
    (flo : FIInt lo) (fhi : FIInt hi) (ayref : Referenced (arr (minus_i hi lo) a)).
  let type N = minus_i hi lo in
  case ayref of referenced @(arr N a) (ay : arr N a).
  case index of stored @int (index_i : int).
  copy @a repr (subscript @N @a repr ay index_i) ret;


IndexableDict_array1_get_shape
  @(a : bare)
  (ary : array1 a)
  (ret : OutPtr dim1)
  -> IEffect dim1 attribute(inline) =
  case ary of
    mk_array1 @a @(lo hi : intindex)
    (flo : FIInt lo) (fhi : FIInt hi) (ayref : Referenced (arr (minus_i hi lo) a)).
  let type N = minus_i hi lo in
  mk_dim1 @lo @hi (iInt @lo flo) (iInt @hi fhi) ret;


IndexableDict_array2_at_point
  @(a : bare)
  (repr : Repr a)
  (ary : array2 a)
  (index : PyonTuple2 (Stored int) (Stored int))
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case ary of
    mk_array2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (fmlo : FIInt Mlo) (fmhi : FIInt Mhi)
    (fnlo : FIInt Nlo) (fnhi : FIInt Nhi)
    (ayref : Referenced (arr (minus_i Mhi Mlo) (arr (minus_i Nhi Nlo) a))).
  let type M = minus_i Mhi Mlo in
  let type N = minus_i Nhi Nlo in
  let width : FIInt N = minus_fii @Nhi @Nlo fnhi fnlo in
  case ayref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).

  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in

  case index of pyonTuple2 @(Stored int) @(Stored int)
                (ix_y : Stored int) (ix_x : Stored int).
  case ix_y of stored @int (ix_y_i : int).
  case ix_x of stored @int (ix_x_i : int).
  copy @a repr (subscript @N @a repr
                (subscript @M @(arr N a) row_repr ay ix_y_i) ix_x_i) ret;


IndexableDict_array2_get_shape
  @(a : bare)
  (ary : array2 a)
  (ret : OutPtr dim2)
  -> IEffect dim2 attribute(inline) =
  case ary of
    mk_array2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (fmlo : FIInt Mlo) (fmhi : FIInt Mhi)
    (fnlo : FIInt Nlo) (fnhi : FIInt Nhi)
    (ayref : Referenced (arr (minus_i Mhi Mlo) (arr (minus_i Nhi Nlo) a))).
  mk_dim2 @Mlo @Mhi @Nlo @Nhi
  (iInt @Mlo fmlo) (iInt @Mhi fmhi)
  (iInt @Nlo fnlo) (iInt @Nhi fnhi) ret;

-------------------------------------------------------------------------------
-- Shape functions

ShapeDict_dim0_flatten @(a : bare) (s : Stream dim0 a)
  -> Stream dim1 a attribute(inline) =
  case s of mk_view0 @a (f : NoneType -> Writer a).
  viewStream @a
  (mk_view1 @a @0 @1 zero_ii one_ii (\ (i : int) -> Writer a. f None));


ShapeDict_dim0_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (s : Stream dim0 a)
  -> Stream dim0 b attribute(inline) =
  case s of mk_view0 @a (f : NoneType -> Writer a).
  mk_view0 @b
  (\ (i : NoneType) -> Writer b.
    case boxed @a (f None) of boxed @a (x : a). transformer x);


ShapeDict_dim0_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  -> Stream dim0 c attribute(inline) =
  case sA of mk_view0 @a (fA : NoneType -> Writer a).
  case sB of mk_view0 @b (fB : NoneType -> Writer b).
  mk_view0 @c
  (\ (i : NoneType) -> Writer c.
    case boxed @a (fA None) of boxed @a (x : a).
    case boxed @b (fB None) of boxed @b (y : b).
    transformer x y);


ShapeDict_dim0_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  (sC : Stream dim0 c)
  -> Stream dim0 d attribute(inline) =
  case sA of mk_view0 @a (fA : NoneType -> Writer a).
  case sB of mk_view0 @b (fB : NoneType -> Writer b).
  case sC of mk_view0 @c (fC : NoneType -> Writer c).
  mk_view0 @d
  (\ (i : NoneType) -> Writer d.
    case boxed @a (fA None) of boxed @a (x : a).
    case boxed @b (fB None) of boxed @b (y : b).
    case boxed @c (fC None) of boxed @c (z : c).
    transformer x y z);


ShapeDict_dim0_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  (sC : Stream dim0 c)
  (sD : Stream dim0 d)
  -> Stream dim0 e attribute(inline) =
  case sA of mk_view0 @a (fA : NoneType -> Writer a).
  case sB of mk_view0 @b (fB : NoneType -> Writer b).
  case sC of mk_view0 @c (fC : NoneType -> Writer c).
  case sD of mk_view0 @d (fD : NoneType -> Writer d).
  mk_view0 @e
  (\ (i : NoneType) -> Writer e.
    case boxed @a (fA None) of boxed @a (x : a).
    case boxed @b (fB None) of boxed @b (y : b).
    case boxed @c (fC None) of boxed @c (z : c).
    case boxed @d (fD None) of boxed @d (w : d).
    transformer x y z w);

ShapeDict_dim0_inRange (sh : dim0) (ix : Stored NoneType)
  -> bool attribute(inline) =
  True;

ShapeDict_dim0_slice @(t : bare -> bare) @(a : bare)
  (has_shape : coerce @box (BoxedType (shape t)) (Boxed dim0))
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (sl : slice dim0)
  -> view0 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  mk_view0 @a
  (\ (i : NoneType) -> Writer a.
    case boxed @(Stored NoneType) (stored @NoneType None) of
      boxed @(Stored NoneType) (ix : Stored NoneType).
    at_index @a repr container (coerce @(index dim0) @(index (shape t)) ix));


ShapeDict_dim1_flatten @(a : bare) (s : Stream dim1 a)
  -> Stream dim1 a attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      s
  ; viewStream @a (vw : view1 a).
      view1_flatten @a vw
  };


ShapeDict_dim1_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (s : Stream dim1 a)
  -> Stream dim1 b attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      sequenceStream @b (Sequence_map @a @b repr_a repr_b transformer sq)
  ; viewStream @a (vw : view1 a).
      viewStream @b (view1_map @a @b repr_a repr_b transformer vw)
  };


ShapeDict_dim1_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sA : Stream dim1 a)
  (sB : Stream dim1 b)
  -> Stream dim1 c attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view1 b). viewToSequence @b repr_b vwB
            } in
      sequenceStream @c
      (Sequence_zipWith @a @b @c repr_a repr_b repr_c transformer sqA sqB)

  ; viewStream @a (vwA : view1 a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          sequenceStream @c
          (Sequence_zipWith @a @b @c repr_a repr_b repr_c transformer
           (viewToSequence @a repr_a vwA) sqB)
      ; viewStream @b (vwB : view1 b).
          viewStream @c
          (view1_zipWith @a @b @c repr_a repr_b repr_c transformer vwA vwB)
    }
  };

ShapeDict_dim1_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sA : Stream dim1 a)
  (sB : Stream dim1 b)
  (sC : Stream dim1 c)
  -> Stream dim1 d attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view1 b). viewToSequence @b repr_b vwB
            } in
      let sqC : Sequence c =
            case sC of {
              sequenceStream @c (sqC : Sequence c). sqC
            ; viewStream @c (vwC : view1 c). viewToSequence @c repr_c vwC
            } in
      sequenceStream @d
      (Sequence_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d
       transformer sqA sqB sqC)

  ; viewStream @a (vwA : view1 a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          let sqC : Sequence c =
                case sC of {
                  sequenceStream @c (sqC : Sequence c). sqC
                ; viewStream @c (vwC : view1 c). viewToSequence @c repr_c vwC
                } in
          sequenceStream @d
          (Sequence_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d transformer
           (viewToSequence @a repr_a vwA) sqB sqC)

      ; viewStream @b (vwB : view1 b).
          case sC of {
            sequenceStream @c (sqC : Sequence c).
              sequenceStream @d
              (Sequence_zipWith3 @a @b @c @d
               repr_a repr_b repr_c repr_d transformer
               (viewToSequence @a repr_a vwA)
               (viewToSequence @b repr_b vwB)
               sqC)

          ; viewStream @c (vwC : view1 c).
              viewStream @d
              (view1_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d
               transformer vwA vwB vwC)
          }
      }
  };


ShapeDict_dim1_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sA : Stream dim1 a)
  (sB : Stream dim1 b)
  (sC : Stream dim1 c)
  (sD : Stream dim1 d)
  -> Stream dim1 e attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view1 b). viewToSequence @b repr_b vwB
            } in
      let sqC : Sequence c =
            case sC of {
              sequenceStream @c (sqC : Sequence c). sqC
            ; viewStream @c (vwC : view1 c). viewToSequence @c repr_c vwC
            } in
      let sqD : Sequence d =
            case sD of {
              sequenceStream @d (sqD : Sequence d). sqD
            ; viewStream @d (vwD : view1 d). viewToSequence @d repr_d vwD
            } in
      sequenceStream @e
      (Sequence_zipWith4 @a @b @c @d @e repr_a repr_b repr_c repr_d repr_e
       transformer sqA sqB sqC sqD)

  ; viewStream @a (vwA : view1 a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          let sqC : Sequence c =
                case sC of {
                  sequenceStream @c (sqC : Sequence c). sqC
                ; viewStream @c (vwC : view1 c). viewToSequence @c repr_c vwC
                } in
          let sqD : Sequence d =
                case sD of {
                  sequenceStream @d (sqD : Sequence d). sqD
                ; viewStream @d (vwD : view1 d). viewToSequence @d repr_d vwD
                } in
          sequenceStream @e
          (Sequence_zipWith4 @a @b @c @d @e
           repr_a repr_b repr_c repr_d repr_e transformer
           (viewToSequence @a repr_a vwA) sqB sqC sqD)

      ; viewStream @b (vwB : view1 b).
          case sC of {
            sequenceStream @c (sqC : Sequence c).
              let sqD : Sequence d =
                    case sD of {
                      sequenceStream @d (sqD : Sequence d).
                        sqD
                    ; viewStream @d (vwD : view1 d).
                        viewToSequence @d repr_d vwD
                    } in
              sequenceStream @e
              (Sequence_zipWith4 @a @b @c @d @e
               repr_a repr_b repr_c repr_d repr_e transformer
               (viewToSequence @a repr_a vwA)
               (viewToSequence @b repr_b vwB)
               sqC sqD)

          ; viewStream @c (vwC : view1 c).
              case sD of {
                sequenceStream @d (sqD : Sequence d).
                  sequenceStream @e
                  (Sequence_zipWith4 @a @b @c @d @e
                   repr_a repr_b repr_c repr_d repr_e transformer
                   (viewToSequence @a repr_a vwA)
                   (viewToSequence @b repr_b vwB)
                   (viewToSequence @c repr_c vwC)
                   sqD)
              ; viewStream @d (vwD : view1 d).
                  viewStream @e
                  (view1_zipWith4 @a @b @c @d @e
                   repr_a repr_b repr_c repr_d repr_e
                   transformer vwA vwB vwC vwD)
              }
          }
      }
  };


ShapeDict_dim1_inRange (extent : dim1) (ix : Stored int)
  -> bool attribute(inline) =
  case extent of
    mk_dim1 @(Nlo Nhi : intindex) (ilo : IInt Nlo) (ihi : IInt Nhi).
  case ix of stored @int (ix_i : int).
  let in_range_lo : bool =
        case ilo of {
          iInt @Nlo (flo : FIInt Nlo). 
            case flo of fiInt @Nlo (lo_i : int). ix_i >=# lo_i
        ; iNegInfty @Nlo.
            True
        ; iPosInfty @Nlo.
            except @bool
        } in
  let in_range_hi : bool =
        case ihi of {
          iInt @Nhi (fhi : FIInt Nhi).
            case fhi of fiInt @Nhi (hi_i : int). ix_i <# hi_i
        ; iPosInfty @Nhi.
            True
        ; iNegInfty @Nhi.
            except @bool
        } in
  and in_range_lo in_range_hi;


ShapeDict_dim1_slice @(t : bare -> bare) @(a : bare)
  (is_dim1 : coerce @box (BoxedType (shape t)) (Boxed dim1))
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice dim1)
  -> view1 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim1 shp of
    mk_dim1 @(Nlo Nhi : intindex) (i_nlo : IInt Nlo) (i_nhi : IInt Nhi).

  case intersectSliceWithRange @Nlo @Nhi i_nlo i_nhi slice_argument of
    internalSlice @(Slo Shi : intindex)
                  (i_slo : IInt Slo) (i_shi : IInt Shi)
                  (stride : int)
                  (offset : int).

  mk_view1 @a @Slo @Shi i_slo i_shi
  (\ (i : int) -> Writer a.
    let i2 : int = i *# stride +# offset in
    case boxed @(Stored int) (stored @int i2) of
      boxed @(Stored int) (i2_s : Stored int).
    at_index @a repr container (coerce @(index dim1) @(index (shape t)) i2_s));


ShapeDict_dim2_flatten @(a : bare) (s : Stream dim2 a)
  -> Stream dim1 a attribute(inline) =
  case s of
    mk_view2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (imlo : IInt Mlo) (imhi : IInt Mhi)
    (inlo : IInt Nlo) (inhi : IInt Nhi)
    (f : int -> int -> Writer a).
  let fmlo : FIInt Mlo = fromIndInt @Mlo imlo in
  case fmlo of fiInt @Mlo (mlo_i : int).
  let fnlo : FIInt Nlo = fromIndInt @Nlo inlo in
  case fnlo of fiInt @Nlo (nlo_i : int).
  case inhi of {
    iInt @Nhi (fnhi : FIInt Nhi).
      -- Flatten to a 1D stream
      case fnhi of fiInt @Nhi (nhi_i : int).
      let size_n : int = nhi_i -# nlo_i in

      letfun
        k @(size_index : intindex) (size_ii : IInt size_index)
          -> Stream dim1 a =

          viewStream @a
          (mk_view1 @a @0 @size_index zero_ii size_ii
           (\ (i : int) -> Writer a.
             -- Compute Y and X indices from the linearized index
             let y : int = mlo_i +# i //# size_n in
             let x : int = nlo_i +# i %# size_n in
             f y x))
      in
      case imhi of {
        iInt @Mhi (fmhi : FIInt Mhi).
          case fmhi of fiInt @Mhi (mhi_i : int).
          let size_m : int = mhi_i -# mlo_i in
          let size : int = size_n *# size_m in

          case defineIntIndex size of
            someIInt @(size_index : intindex) (size_fii : FIInt size_index).
            k @size_index (iInt @size_index size_fii)

      ; iPosInfty @Mhi.
          k @pos_infty (iPosInfty @pos_infty)

      ; iNegInfty @Mhi.
          except @(Stream dim1 a)
      }

  ; iPosInfty @Nhi.
      -- Create a view spanning the N dimension only,
      -- since the extent in the N dimension is infinite
      viewStream @a
      (mk_view1 @a @0 @pos_infty zero_ii (iPosInfty @pos_infty)
       (\ (i : int) -> Writer a. f mlo_i (i +# nlo_i)))

  ; iNegInfty @Nhi.
      except @(Stream dim1 a)
  };


ShapeDict_dim2_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (input_stream : Stream dim2 a)
  -> Stream dim2 b attribute(inline) =
  case input_stream of
    mk_view2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (imlo : IInt Mlo) (imhi : IInt Mhi)
    (inlo : IInt Nlo) (inhi : IInt Nhi)
    (f : int -> int -> Writer a).
  mk_view2 @b @Mlo @Mhi @Nlo @Nhi imlo imhi inlo inhi
  (\ (j : int) (i : int) -> Writer b.
    case boxed @a (f j i) of boxed @a (x : a). transformer x);


ShapeDict_dim2_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sA : Stream dim2 a)
  (sB : Stream dim2 b)
  -> Stream dim2 c attribute(inline) =
  case sA of
    mk_view2 @a @(MloA MhiA NloA NhiA : intindex)
    (imloA : IInt MloA) (imhiA : IInt MhiA)
    (inloA : IInt NloA) (inhiA : IInt NhiA)
    (fA : int -> int -> Writer a).
  case sB of
    mk_view2 @b @(MloB MhiB NloB NhiB : intindex)
    (imloB : IInt MloB) (imhiB : IInt MhiB)
    (inloB : IInt NloB) (inhiB : IInt NhiB)
    (fB : int -> int -> Writer b).

  -- Find the intersection of the two regions
  let type MloC = max_i MloA MloB in
  let type MhiC = min_i MhiA MhiB in
  let type NloC = max_i NloA NloB in
  let type NhiC = min_i NhiA NhiB in
  let imloC : IInt MloC = max_ii @MloA @MloB imloA imloB in
  let imhiC : IInt MhiC = min_ii @MhiA @MhiB imhiA imhiB in
  let inloC : IInt NloC = max_ii @NloA @NloB inloA inloB in
  let inhiC : IInt NhiC = min_ii @NhiA @NhiB inhiA inhiB in

  -- Is the intersection nonempty?
  if and (range_nonempty_ii @MloC @MhiC imloC imhiC)
         (range_nonempty_ii @NloC @NhiC inloC inhiC)
  then mk_view2 @c @MloC @MhiC @NloC @NhiC imloC imhiC inloC inhiC
       (\ (j : int) (i : int) -> Writer c.
         case boxed @a (fA j i) of boxed @a (x : a).
         case boxed @b (fB j i) of boxed @b (y : b).
         transformer x y)
  else mk_view2 @c @0 @0 @0 @0 zero_ii zero_ii zero_ii zero_ii
       (\ (j : int) (i : int) (ret : OutPtr c) -> IEffect c.
          except @(IEffect c));


ShapeDict_dim2_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sA : Stream dim2 a)
  (sB : Stream dim2 b)
  (sC : Stream dim2 c)
  -> Stream dim2 d attribute(inline) =
  case sA of
    mk_view2 @a @(MloA MhiA NloA NhiA : intindex)
    (imloA : IInt MloA) (imhiA : IInt MhiA)
    (inloA : IInt NloA) (inhiA : IInt NhiA)
    (fA : int -> int -> Writer a).
  case sB of
    mk_view2 @b @(MloB MhiB NloB NhiB : intindex)
    (imloB : IInt MloB) (imhiB : IInt MhiB)
    (inloB : IInt NloB) (inhiB : IInt NhiB)
    (fB : int -> int -> Writer b).
  case sC of
    mk_view2 @c @(MloC MhiC NloC NhiC : intindex)
    (imloC : IInt MloC) (imhiC : IInt MhiC)
    (inloC : IInt NloC) (inhiC : IInt NhiC)
    (fC : int -> int -> Writer c).

  -- Find the intersection of the two regions
  let type MloD = max_i (max_i MloA MloB) MloC in
  let type MhiD = min_i (min_i MhiA MhiB) MhiC in
  let type NloD = max_i (max_i NloA NloB) NloC in
  let type NhiD = min_i (min_i NhiA NhiB) NhiC in
  let imloD : IInt MloD = max_ii @(max_i MloA MloB) @MloC
                          (max_ii @MloA @MloB imloA imloB) imloC in
  let imhiD : IInt MhiD = min_ii @(min_i MhiA MhiB) @MhiC
                          (min_ii @MhiA @MhiB imhiA imhiB) imhiC in
  let inloD : IInt NloD = max_ii @(max_i NloA NloB) @NloC
                          (max_ii @NloA @NloB inloA inloB) inloC in
  let inhiD : IInt NhiD = min_ii @(min_i NhiA NhiB) @NhiC
                          (min_ii @NhiA @NhiB inhiA inhiB) inhiC in

  -- Is the intersection nonempty?
  if and (range_nonempty_ii @MloD @MhiD imloD imhiD)
         (range_nonempty_ii @NloD @NhiD inloD inhiD)
  then mk_view2 @d @MloD @MhiD @NloD @NhiD imloD imhiD inloD inhiD
       (\ (j : int) (i : int) -> Writer d.
         case boxed @a (fA j i) of boxed @a (x : a).
         case boxed @b (fB j i) of boxed @b (y : b).
         case boxed @c (fC j i) of boxed @c (z : c).
         transformer x y z)
  else mk_view2 @d @0 @0 @0 @0 zero_ii zero_ii zero_ii zero_ii
       (\ (j : int) (i : int) (ret : OutPtr d) -> IEffect d.
          except @(IEffect d));


ShapeDict_dim2_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sA : Stream dim2 a)
  (sB : Stream dim2 b)
  (sC : Stream dim2 c)
  (sD : Stream dim2 d)
  -> Stream dim2 e attribute(inline) =
  case sA of
    mk_view2 @a @(MloA MhiA NloA NhiA : intindex)
    (imloA : IInt MloA) (imhiA : IInt MhiA)
    (inloA : IInt NloA) (inhiA : IInt NhiA)
    (fA : int -> int -> Writer a).
  case sB of
    mk_view2 @b @(MloB MhiB NloB NhiB : intindex)
    (imloB : IInt MloB) (imhiB : IInt MhiB)
    (inloB : IInt NloB) (inhiB : IInt NhiB)
    (fB : int -> int -> Writer b).
  case sC of
    mk_view2 @c @(MloC MhiC NloC NhiC : intindex)
    (imloC : IInt MloC) (imhiC : IInt MhiC)
    (inloC : IInt NloC) (inhiC : IInt NhiC)
    (fC : int -> int -> Writer c).
  case sD of
    mk_view2 @d @(MloD MhiD NloD NhiD : intindex)
    (imloD : IInt MloD) (imhiD : IInt MhiD)
    (inloD : IInt NloD) (inhiD : IInt NhiD)
    (fD : int -> int -> Writer d).

  -- Find the intersection of the two regions
  let type MloE = max_i (max_i (max_i MloA MloB) MloC) MloD in
  let type MhiE = min_i (min_i (min_i MhiA MhiB) MhiC) MhiD in
  let type NloE = max_i (max_i (max_i NloA NloB) NloC) NloD in
  let type NhiE = min_i (min_i (min_i NhiA NhiB) NhiC) NhiD in
  let imloE : IInt MloE = max_ii @(max_i (max_i MloA MloB) MloC) @MloD
                          (max_ii @(max_i MloA MloB) @MloC
                           (max_ii @MloA @MloB imloA imloB) imloC) imloD in
  let imhiE : IInt MhiE = min_ii @(min_i (min_i MhiA MhiB) MhiC) @MhiD
                          (min_ii @(min_i MhiA MhiB) @MhiC
                           (min_ii @MhiA @MhiB imhiA imhiB) imhiC) imhiD in
  let inloE : IInt NloE = max_ii @(max_i (max_i NloA NloB) NloC) @NloD
                          (max_ii @(max_i NloA NloB) @NloC
                           (max_ii @NloA @NloB inloA inloB) inloC) inloD in
  let inhiE : IInt NhiE = min_ii @(min_i (min_i NhiA NhiB) NhiC) @NhiD
                          (min_ii @(min_i NhiA NhiB) @NhiC
                           (min_ii @NhiA @NhiB inhiA inhiB) inhiC) inhiD in

  -- Is the intersection nonempty?
  if and (range_nonempty_ii @MloE @MhiE imloE imhiE)
         (range_nonempty_ii @NloE @NhiE inloE inhiE)
  then mk_view2 @e @MloE @MhiE @NloE @NhiE imloE imhiE inloE inhiE
       (\ (j : int) (i : int) -> Writer e.
         case boxed @a (fA j i) of boxed @a (x : a).
         case boxed @b (fB j i) of boxed @b (y : b).
         case boxed @c (fC j i) of boxed @c (z : c).
         case boxed @d (fD j i) of boxed @d (w : d).
         transformer x y z w)
  else mk_view2 @e @0 @0 @0 @0 zero_ii zero_ii zero_ii zero_ii
       (\ (j : int) (i : int) (ret : OutPtr e) -> IEffect e.
          except @(IEffect e));

ShapeDict_dim2_inRange (dim : dim2) (ix : index dim2) -> bool
  attribute(inline) =
  let type Sint = Stored int in
  case ix of pyonTuple2 @Sint @Sint (y_s : Sint) (x_s : Sint).
  case y_s of stored @int (y : int).
  case x_s of stored @int (x : int).

  case dim of
    mk_dim2 @(Mlo Mhi Nlo Nhi : intindex)
    (iMlo : IInt Mlo)
    (iMhi : IInt Mhi)
    (iNlo : IInt Nlo)
    (iNhi : IInt Nhi).

  let in_range_Mlo : bool =
        case iMlo of {
          iInt @Mlo (flo : FIInt Mlo). 
            case flo of fiInt @Mlo (lo_i : int). y >=# lo_i
        ; iNegInfty @Mlo.
            True
        ; iPosInfty @Mlo.
            except @bool
        } in
  let in_range_Mhi : bool =
        case iMhi of {
          iInt @Mhi (fhi : FIInt Mhi).
            case fhi of fiInt @Mhi (hi_i : int). y <# hi_i
        ; iPosInfty @Mhi.
            True
        ; iNegInfty @Mhi.
            except @bool
        } in
  let in_range_Nlo : bool =
        case iNlo of {
          iInt @Nlo (flo : FIInt Nlo). 
            case flo of fiInt @Nlo (lo_i : int). x >=# lo_i
        ; iNegInfty @Nlo.
            True
        ; iPosInfty @Nlo.
            except @bool
        } in
  let in_range_Nhi : bool =
        case iNhi of {
          iInt @Nhi (fhi : FIInt Nhi).
            case fhi of fiInt @Nhi (hi_i : int). x <# hi_i
        ; iPosInfty @Nhi.
            True
        ; iNegInfty @Nhi.
            except @bool
        } in
  and (and in_range_Mlo in_range_Mhi) (and in_range_Nlo in_range_Nhi);

ShapeDict_dim2_slice @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (sl : slice dim2)
  -> view2 a
  attribute(inline) =

  -- Get the container's shape
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2 @(Mlo Mhi Nlo Nhi : intindex)
    (iMlo : IInt Mlo)
    (iMhi : IInt Mhi)
    (iNlo : IInt Nlo)
    (iNhi : IInt Nhi).

  -- Get the slice components
  case sl of pyonTuple2 @SliceObject @SliceObject
       	     (slice_y : SliceObject) (slice_x : SliceObject).

  -- Compute the intersection of the container and slice.
  -- Each dimension is computed independently.
  case intersectSliceWithRange @Mlo @Mhi iMlo iMhi slice_y of
    internalSlice @(sliceMlo sliceMhi : intindex)
    (slice_iMlo : IInt sliceMlo)
    (slice_iMhi : IInt sliceMhi)
    (slice_ystride : int)
    (slice_yoffset : int).
  case intersectSliceWithRange @Nlo @Nhi iNlo iNhi slice_x of
    internalSlice @(sliceNlo sliceNhi : intindex)
    (slice_iNlo : IInt sliceNlo)
    (slice_iNhi : IInt sliceNhi)
    (slice_xstride : int)
    (slice_xoffset : int).

  -- Create a view
  mk_view2 @a @sliceMlo @sliceMhi @sliceNlo @sliceNhi
  slice_iMlo slice_iMhi slice_iNlo slice_iNhi
  (\ (y : int) (x : int) -> Writer a.
     let index_y : int = y *# slice_ystride +# slice_yoffset in
     let index_x : int = x *# slice_xstride +# slice_xoffset in
     let type Sint = Stored int in
     case boxed @(PyonTuple2 Sint Sint)
     	  (pyonTuple2 @Sint @Sint (stored @int index_y) (stored @int index_x)) of
       boxed @(PyonTuple2 Sint Sint) (ix : PyonTuple2 Sint Sint).
     at_index @a repr container (coerce @(index dim2) @(index (shape t)) ix));

-------------------------------------------------------------------------------
-- ShapeDict-like internal functions

view1_flatten @(a : bare) (vw : view1 a) -> Stream dim1 a
  attribute(inline) =
  -- Shift the indices so that the first index is 0
  case vw of {
    mk_view1 @a @(lo hi : intindex)
             (Nlo : IInt lo) (Nhi : IInt hi) (f : int -> Writer a).
      let fNlo : FIInt lo = fromIndInt @lo Nlo in
      case fNlo of fiInt @lo (lo_i : int).
      let size : IInt (minus_i hi lo) = minus_ii @hi @lo Nhi Nlo in

      viewStream @a
      (mk_view1 @a @0 @(minus_i hi lo) zero_ii size
       (\ (i : int) -> Writer a. f (i -# lo_i)));

    empty_view1 @a.
      -- Don't reuse the view value here because the extra use interferes with
      -- optimization
      viewStream @a (empty_view1 @a)
  };


view1_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
          (transformer : a -> Writer b) (vw : view1 a) -> view1 b
  attribute(inline) =
  case vw of {
    mk_view1 @a @(lo hi : intindex)
                 (Nlo : IInt lo) (Nhi : IInt hi) (f : int -> Writer a).
      mk_view1 @b @lo @hi Nlo Nhi
      (\ (i : int) -> Writer b.
        case boxed @a (f i) of boxed @a (x : a). transformer x);

    empty_view1 @a.
      empty_view1 @b
  };


view1_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c) (vwA : view1 a) (vwB : view1 b)
  -> view1 c
  attribute(inline) =
  case vwA of {
    mk_view1 @a @(loA hiA : intindex)
             (iloA : IInt loA) (ihiA : IInt hiA) (fA : int -> Writer a).
      case vwB of {
        mk_view1 @b @(loB hiB : intindex)
                 (iloB : IInt loB) (ihiB : IInt hiB) (fB : int -> Writer b).
          let type loC = max_i loA loB in
          let type hiC = min_i hiA hiB in
          let iloC : IInt loC = max_ii @loA @loB iloA iloB in
          let ihiC : IInt hiC = min_ii @hiA @hiB ihiA ihiB in
          if range_nonempty_ii @loC @hiC iloC ihiC
          then mk_view1 @c @loC @hiC iloC ihiC
               (\ (i : int) -> Writer c.
                 case boxed @a (fA i) of boxed @a (x : a).
                 case boxed @b (fB i) of boxed @b (y : b).
                 transformer x y)
          else empty_view1 @c;

        empty_view1 @b.
	  empty_view1 @c
      };

    empty_view1 @a.
      empty_view1 @c
  };


view1_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (vwA : view1 a) (vwB : view1 b) (vwC : view1 c)
  -> view1 d
  attribute(inline) =
  case vwA of {
    mk_view1 @a @(loA hiA : intindex)
             (iloA : IInt loA) (ihiA : IInt hiA) (fA : int -> Writer a).
      case vwB of {
        mk_view1 @b @(loB hiB : intindex)
                 (iloB : IInt loB) (ihiB : IInt hiB) (fB : int -> Writer b).
          case vwC of {
            mk_view1 @c @(loC hiC : intindex)
                     (iloC : IInt loC) (ihiC : IInt hiC) (fC : int -> Writer c).
              let type loD = max_i (max_i loA loB) loC in
              let type hiD = min_i (min_i hiA hiB) hiC in
              let iloD : IInt loD = max_ii @(max_i loA loB) @loC
                                    (max_ii @loA @loB iloA iloB) iloC in
              let ihiD : IInt hiD = min_ii @(min_i hiA hiB) @hiC
                                    (min_ii @hiA @hiB ihiA ihiB) ihiC in
              if range_nonempty_ii @loD @hiD iloD ihiD
              then mk_view1 @d @loD @hiD iloD ihiD
                   (\ (i : int) -> Writer d.
                     case boxed @a (fA i) of boxed @a (x : a).
                     case boxed @b (fB i) of boxed @b (y : b).
                     case boxed @c (fC i) of boxed @c (z : c).
                     transformer x y z)
              else empty_view1 @d;

            empty_view1 @c.
	      empty_view1 @d
	  };

        empty_view1 @b.
          empty_view1 @d
      };

    empty_view1 @a.
      empty_view1 @d
  };

view1_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (vwA : view1 a) (vwB : view1 b) (vwC : view1 c) (vwD : view1 d)
  -> view1 e
  attribute(inline) =
  case vwA of {
    mk_view1 @a @(loA hiA : intindex)
             (iloA : IInt loA) (ihiA : IInt hiA) (fA : int -> Writer a).
      case vwB of {
        mk_view1 @b @(loB hiB : intindex)
                 (iloB : IInt loB) (ihiB : IInt hiB) (fB : int -> Writer b).
          case vwC of {
            mk_view1 @c @(loC hiC : intindex)
                     (iloC : IInt loC) (ihiC : IInt hiC) (fC : int -> Writer c).
              case vwD of {
                mk_view1 @d @(loD hiD : intindex)
                         (iloD : IInt loD) (ihiD : IInt hiD) (fD : int -> Writer d).
                  let type loE = max_i (max_i (max_i loA loB) loC) loD in
                  let type hiE = min_i (min_i (min_i hiA hiB) hiC) hiD in
                  let iloE : IInt loE = max_ii @(max_i (max_i loA loB) loC) @loD
                                        (max_ii @(max_i loA loB) @loC
                                         (max_ii @loA @loB iloA iloB) iloC) iloD in
                  let ihiE : IInt hiE = min_ii @(min_i (min_i hiA hiB) hiC) @hiD
                                        (min_ii @(min_i hiA hiB) @hiC
                                         (min_ii @hiA @hiB ihiA ihiB) ihiC) ihiD in
                  if range_nonempty_ii @loE @hiE iloE ihiE
                  then mk_view1 @e @loE @hiE iloE ihiE
                       (\ (i : int) -> Writer e.
                         case boxed @a (fA i) of boxed @a (x : a).
                         case boxed @b (fB i) of boxed @b (y : b).
                         case boxed @c (fC i) of boxed @c (z : c).
                         case boxed @d (fD i) of boxed @d (w : d).
                         transformer x y z w)
                  else empty_view1 @e;

		empty_view1 @d.
                  empty_view1 @e
              };

	    empty_view1 @c.
              empty_view1 @e
          };

	empty_view1 @b.
          empty_view1 @e
      };

    empty_view1 @a.
      empty_view1 @e
  };

Sequence_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
          (transformer : a -> Writer b) (sq : Sequence a) -> Sequence b
  attribute(inline, inline_final) =
  case sq of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  letfun
    go (state : st) -> StreamNext st b =
      case next state of {
        streamValue @st @a (next_state : st) (value : BoxedType a).
          let output_value : BoxedType b =
                case boxed @a (convertToBare @a repr_a value) of boxed @a (x : a).
		convertToBoxed @b repr_b (transformer x)
          in streamValue @st @b next_state output_value;

        streamEmpty @st @a.
          streamEmpty @st @b
      }
  in sequence @b @st state go;


Sequence_zipWith
  @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sqA : Sequence a)
  (sqB : Sequence b)
  -> Sequence c
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).

  let type st_c = Stored (st_a, st_b) in
  
  letfun
    go (state : Boxed st_c) -> StreamNext (Boxed st_c) c =
      -- Unpack the state
      case state of boxed @st_c (u_state : st_c).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : BoxedType b).

	      -- Create output value
	      let value : BoxedType c =
	            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
		    convertToBoxed @c repr_c (transformer x y) in
	      let next_state : Boxed st_c =
	            boxed @st_c (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed st_c) @c next_state value;

	    streamEmpty @st_b @b.
	      streamEmpty @(Boxed st_c) @c
          };

	streamEmpty @st_a @a.
	  streamEmpty @(Boxed st_c) @c
      }
  in sequence @c @(Boxed st_c)
       (boxed @st_c (stored @(st_a, st_b) (state_a, state_b)))
       go;


Sequence_zipWith3
  @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sqA : Sequence a)
  (sqB : Sequence b)
  (sqC : Sequence c)
  -> Sequence d
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).
  case sqC
  of sequence @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c c).

  let type st_d = Stored (st_a, st_b, st_c) in
  
  letfun
    go (state : Boxed st_d) -> StreamNext (Boxed st_d) d =
      -- Unpack the state
      case state of boxed @st_d (u_state : st_d).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : BoxedType a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @c
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Create output value
                  let value : BoxedType d =
                        case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                        convertToBoxed @d repr_d (transformer x y z) in
                  let next_state : Boxed st_d =
                        boxed @st_d (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed st_d) @d next_state value;

                  streamEmpty @st_c @c.
                    streamEmpty @(Boxed st_d) @d
                };

              streamEmpty @st_b @b.
                streamEmpty @(Boxed st_d) @d
            };

        streamEmpty @st_a @a.
          streamEmpty @(Boxed st_d) @d
      }
  in sequence @d @(Boxed st_d)
       (boxed @st_d (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;


Sequence_zipWith4
  @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sqA : Sequence a)
  (sqB : Sequence b)
  (sqC : Sequence c)
  (sqD : Sequence d)
  -> Sequence e
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).
  case sqC
  of sequence @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c c).
  case sqD
  of sequence @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d d).

  let type st_e = Stored (st_a, st_b, st_c, st_d) in
  
  letfun
    go (state : Boxed st_e) -> StreamNext (Boxed st_e) e =
      -- Unpack the state
      case state of boxed @st_e (u_state : st_e).
      case u_state of stored @(st_a, st_b, st_c, st_d) (i_state : (st_a, st_b, st_c, st_d)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : BoxedType a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @c
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @d
                      (next_state_d : st_d) (value_d : BoxedType d).

                      -- Create output value
                      let value : BoxedType e =
                            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (convertToBare @d repr_d value_d) of boxed @d (w : d).
                            convertToBoxed @e repr_e (transformer x y z w) in
                      let next_state : Boxed st_e =
                            boxed @st_e (stored @(st_a, st_b, st_c, st_d) (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @(Boxed st_e) @e next_state value;

                      streamEmpty @st_d @d.
                        streamEmpty @(Boxed st_e) @e
                    };

                  streamEmpty @st_c @c.
                    streamEmpty @(Boxed st_e) @e
                };

              streamEmpty @st_b @b.
                streamEmpty @(Boxed st_e) @e
            };

        streamEmpty @st_a @a.
          streamEmpty @(Boxed st_e) @e
      }
  in sequence @e @(Boxed st_e)
       (boxed @st_e (stored @(st_a, st_b, st_c, st_d) (state_a, state_b, state_c, state_d)))
       go;

-------------------------------------------------------------------------------
-- High-level overloaded functions

fun_reduce @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (init : a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  let type sh = shape t in

  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Writer (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  fun_reduce_Stream @a repr reducer init
  (shape_flatten @a (traverse @a repr input))
  ret;


fun_reduce1 @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  let type sh = shape t in

  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Writer (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  fun_reduce1_Stream @a repr reducer
  (shape_flatten @a (traverse @a repr input))
  ret;


fun_map @(t : bare -> bare)
        @(a b : bare)
        (traversable : TraversableDict t)
        (shape_dict : ShapeDict (shape t))
        (repr_a : Repr a)
        (repr_b : Repr b)
        (transformer : a -> Writer b)
        (container : t a)
	(ret : OutPtr (t b))
        -> IEffect (t b)
 	attribute(inline) =
  let type sh = shape t in

  case traversable of
    traversableDict @t
    (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
    (build : (a : bare) -> Repr a -> Stream sh a -> Writer (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  build @b repr_b
  (shape_map @a @b repr_a repr_b transformer
   (traverse @a repr_a container))
  ret;


fun_zip @(t1 t2 : bare -> bare) @(a : bare) @(b : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (equal12 : coerce @box (BoxedType (shape t1)) (BoxedType (shape t2)))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b)
        (inputA : t1 a) (inputB : t2 b)
  -> Stream (shape t1) (PyonTuple2 a b)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (ret : OutPtr (PyonTuple2 a b))
    		-> IEffect (PyonTuple2 a b) =
      pyonTuple2 @a @b (copy @a reprA x) (copy @b reprB y) ret
  in

  shape_zipWith @a @b @(PyonTuple2 a b)
  reprA reprB (repr_PyonTuple2 @a @b reprA reprB)
  transformer stream1 stream2;

fun_zip3 @(t1 t2 t3 : bare -> bare) @(a b c : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (equal12 : coerce @box (BoxedType (shape t1)) (BoxedType (shape t2)))
        (equal23 : coerce @box (BoxedType (shape t2)) (BoxedType (shape t3)))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c)
  -> Stream (shape t1) (PyonTuple3 a b c)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Writer (t3 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (z : c) (ret : OutPtr (PyonTuple3 a b c))
    		-> IEffect (PyonTuple3 a b c) =
      pyonTuple3 @a @b @c (copy @a reprA x) (copy @b reprB y) (copy @c reprC z) ret
  in

  shape_zipWith3 @a @b @c @(PyonTuple3 a b c)
  reprA reprB reprC (repr_PyonTuple3 @a @b @c reprA reprB reprC)
  transformer stream1 stream2 stream3;


fun_zip4 @(t1 t2 t3 t4 : bare -> bare) @(a b c d : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (traversable4 : TraversableDict t4)
        (equal12 : coerce @box (BoxedType (shape t1)) (BoxedType (shape t2)))
        (equal23 : coerce @box (BoxedType (shape t2)) (BoxedType (shape t3)))
        (equal34 : coerce @box (BoxedType (shape t3)) (BoxedType (shape t4)))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c) (reprD : Repr d)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c) (inputD : t4 d)
  -> Stream (shape t1) (PyonTuple4 a b c d)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Writer (t3 a)).
  case traversable4
  of traversableDict @t4
       (traverse4 : (a : bare) -> Repr a -> t4 a -> Stream (shape t4) a)
       (build4 : (a : bare) -> Repr a -> Stream (shape t4) a -> Writer (t4 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in
  let stream4 : Stream (shape t1) d =
        coerce @(Stream (shape t4) d) @(Stream (shape t1) d)
	(traverse4 @d reprD inputD) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (BoxedType (shape t)) (BoxedType sh) ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (z : c) (w : d) (ret : OutPtr (PyonTuple4 a b c d))
    		-> IEffect (PyonTuple4 a b c d) =
      pyonTuple4 @a @b @c @d (copy @a reprA x) (copy @b reprB y) (copy @c reprC z) (copy @d reprD w) ret
  in

  shape_zipWith4 @a @b @c @d @(PyonTuple4 a b c d)
  reprA reprB reprC reprD (repr_PyonTuple4 @a @b @c @d reprA reprB reprC reprD)
  transformer stream1 stream2 stream3 stream4;


rows @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr : Repr a)
  (container : t a)
  -> view1 (StoredBox (view1 a))
  attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2 @(Mlo Mhi Nlo Nhi : intindex)
      (imlo : IInt Mlo) (imhi : IInt Mhi)
      (inlo : IInt Nlo) (inhi : IInt Nhi).

  mk_view1 @(StoredBox (view1 a)) @Mlo @Mhi imlo imhi
  (\ (y : int) -> Writer (StoredBox (view1 a)).
    storedBox @(view1 a)
    (mk_view1 @a @Nlo @Nhi inlo inhi
     (\ (x : int) (ret : OutPtr a) -> IEffect a.
       case boxed @(index dim2)
            (pyonTuple2 @(Stored int) @(Stored int)
             (stored @int y) (stored @int x)) of
         boxed @(index dim2) (ix : index dim2).
       at_index @a repr container
       (coerce @(index dim2) @(index (shape t)) ix)
       ret)));
  

cols @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr : Repr a)
  (container : t a)
  -> view1 (StoredBox (view1 a))
  attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2 @(Mlo Mhi Nlo Nhi : intindex)
      (imlo : IInt Mlo) (imhi : IInt Mhi)
      (inlo : IInt Nlo) (inhi : IInt Nhi).

  mk_view1 @(StoredBox (view1 a)) @Nlo @Nhi inlo inhi
  (\ (x : int) -> Writer (StoredBox (view1 a)).
    storedBox @(view1 a)
    (mk_view1 @a @Mlo @Mhi imlo imhi
     (\ (y : int) (ret : OutPtr a) -> IEffect a.
       case boxed @(index dim2)
            (pyonTuple2 @(Stored int) @(Stored int)
             (stored @int y) (stored @int x)) of
         boxed @(index dim2) (ix : index dim2).
       at_index @a repr container
       (coerce @(index dim2) @(index (shape t)) ix)
       ret)));


outerproduct @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim2 c
  attribute(inline) =

  -- Convert arguments to views
  let viewA : view1 a =
    case sa of {
      sequenceStream @a (sq : Sequence a). sequenceToView @a repr_a sq;
      viewStream @a (vw : view1 a). vw
    } in
  let viewB : view1 b =
    case sb of {
      sequenceStream @b (sq : Sequence b). sequenceToView @b repr_b sq;
      viewStream @b (vw : view1 b). vw
    } in

  -- Create a view2 combining the inputs
  case viewA of {
    mk_view1 @a @(Mlo Mhi : intindex)
    	     (imlo : IInt Mlo) (imhi : IInt Mhi) (fA : int -> Writer a).
      case viewB of {
        mk_view1 @b @(Nlo Nhi : intindex)
        	     (inlo : IInt Nlo) (inhi : IInt Nhi) (fB : int -> Writer b).

          mk_view2 @c @Mlo @Mhi @Nlo @Nhi imlo imhi inlo inhi
          (\ (y : int) (x : int) (ret : OutPtr c) -> IEffect c.
             case boxed @a (fA y) of boxed @a (value_a : a).
             case boxed @b (fB x) of boxed @b (value_b : b).
             transformer value_a value_b ret);

        empty_view1 @b.
          mk_view2 @c @0 @0 @0 @0 zero_ii zero_ii zero_ii zero_ii
          (\ (y : int) (x : int) (ret : OutPtr c) -> IEffect c.
            except @(IEffect c))
      };

    empty_view1 @a.
      mk_view2 @c @0 @0 @0 @0 zero_ii zero_ii zero_ii zero_ii
      (\ (y : int) (x : int) (ret : OutPtr c) -> IEffect c.
        except @(IEffect c))
  };

-------------------------------------------------------------------------------
-- Fold-like internal methods

fun_reduce_Stream @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (s : Stream dim1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case s of {
    viewStream @a (vw : view1 a).
      view1_reduce @a repr f init vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce @a repr f init sq ret
  };


fun_reduce1_Stream @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : Stream dim1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case s of {
    viewStream @a (vw : view1 a).
      view1_reduce1 @a repr f vw ret

  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce1 @a repr f sq ret
  };


fun_fold_Stream @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : Stream dim1 a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline) =
  case src of {
    viewStream @a (vw : view1 a).
      view1_fold @a @acc repr_a repr_acc f init vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_fold @a @acc repr_a repr_acc f init sq ret
  };


primitive_dim1_reduce @(N : intindex) @(a : bare)
  (repr : Repr a) (count : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (g : int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  for @N @a repr (iInt @N count) init
  (\ (i : int) (acc : a) (ret : OutPtr a) -> IEffect a.
    case boxed @a (g i) of boxed @a (x : a).
    f acc x ret)
  ret;


primitive_dim1_reduce1 @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (f : a -> a -> Writer a)
  (g : int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  
  case size of fiInt @N (count : int).
  if count <=# 0
  then except @(IEffect a)
  else -- Get the initial value from index 0
       case boxed @a (g 0) of boxed @a (init : a).

       -- Iterate over the remaining elements
       let size_minus_1 : FIInt (minus_i N 1) =
       	     minus_fii @N @1 size one_fii in

       for @(minus_i N 1) @a repr (iInt @(minus_i N 1) size_minus_1) init
       (\ (i : int) (x : a) (next_x : OutPtr a) -> IEffect a.
          case boxed @a (g (i +# 1)) of boxed @a (y : a).
          f x y next_x)
       ret;


darr1_reduce @(N : intindex) @(a : bare)
  (repr : Repr a)
  (size : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (src : darr1 N a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case src of mk_darr1 @N @a (g : int -> Writer a).
  primitive_dim1_reduce @N @a repr size f init g ret;


darr1_reduce1 @(N : intindex) @(a : bare)
  (repr : Repr a)
  (size : FIInt N)
  (f : a -> a -> Writer a)
  (src : darr1 N a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case src of mk_darr1 @N @a (g : int -> Writer a).
  primitive_dim1_reduce1 @N @a repr size f g ret;


darr1_fold @(N : intindex) @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (size : FIInt N)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : darr1 N a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =
  case src of mk_darr1 @N @a (g : int -> Writer a).

  for @N @acc repr_acc (iInt @N size) init
  (\ (i : int) (x : acc) (next_x : OutPtr acc) -> IEffect acc.
     case boxed @a (g i) of boxed @a (y : a).
     f x y next_x)
  ret;


view1_reduce1 @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (vw : view1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  view1ToDarr1 @a @a vw
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a) (ret : OutPtr a)
      -> IEffect a.
     darr1_reduce1 @N @a repr size f darr ret)
  (\ (ret : OutPtr a) -> IEffect a.
    -- Error to call 'reduce1' on an empty stream
    except @(IEffect a))
  ret;


view1_reduce @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (vw : view1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  view1ToDarr1 @a @a vw
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a) (ret : OutPtr a)
    -> IEffect a.
    darr1_reduce @N @a repr size f init darr ret)
  (\ (ret : OutPtr a) -> IEffect a. copy @a repr init ret)
  ret;


view1_fold @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : view1 a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =
  view1ToDarr1 @a @acc src
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a) (ret : OutPtr acc)
    -> IEffect acc.
    darr1_fold @N @a @acc repr_a repr_acc size f init darr ret)
  (\ (ret : OutPtr acc) -> IEffect acc. copy @acc repr_acc init ret)
  ret;


Sequence_reduce @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (sq : Sequence a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  Sequence_fold @a @a repr repr f init sq ret;

Sequence_reduce1 @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (sq : Sequence a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  -- Use the stream's first element as the initial value
  case sq of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  case next state of {
    streamValue @st @a (next_state : st) (init : BoxedType a).
      case boxed @a (convertToBare @a repr init) of boxed @a (u_init : a).
      let new_sequence : Sequence a =
            sequence @a @st next_state next in
      Sequence_fold @a @a repr repr f u_init new_sequence ret;

    streamEmpty @st @a.
      except @(IEffect a)
  };


Sequence_fold @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : Sequence a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =
  case src of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  letfun
    go (state : st) (accumulator : BoxedType acc) (ret : OutPtr acc)
      -> IEffect acc =
      case next state of {

        -- Obtain value from stream
        streamValue @st @a (next_state : st) (result : BoxedType a).
          -- Compute the new value
          let new_accumulator : BoxedType acc =
                case boxed @a (convertToBare @a repr_a result)
                of boxed @a (y : a).
                case boxed @acc (convertToBare @acc repr_acc accumulator)
                of boxed @acc (x : acc).
                convertToBoxed @acc repr_acc (f x y)

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty @st @a.
	  convertToBare @acc repr_acc accumulator ret
      }
  in go state (convertToBoxed @acc repr_acc (copy @acc repr_acc init)) ret;


-------------------------------------------------------------------------------
-- Methods specifically for 1D streams

range (n : int) -> Stream dim1 (Stored int)
  attribute(inline) =
  let vw : view1 (Stored int) =
        if n <# 0
        then empty_view1 @(Stored int)
	else case defineIntIndex n of someIInt @(N : intindex) (fin : FIInt N).
	     mk_view1 @(Stored int) @0 @N
	     (iInt @0 (fiInt @0 0))
	     (iInt @N fin)
	     (\ (i : int) (ret : OutPtr (Stored int)) -> IEffect (Stored int).
	        stored @int i ret) in
  viewStream @(Stored int) vw;


Stream1_empty @(a : bare) -> Stream1 a
  attribute(inline) =
  let zero : IInt 0 = iInt @0 (fiInt @0 0) in
  viewStream @a
  (empty_view1 @a);


Stream1_return @(a : bare) (repr : Repr a) (w : Writer a) -> Stream1 a
  attribute(inline) =
  let zero : IInt 0 = iInt @0 (fiInt @0 0) in
  let one : IInt 1 = iInt @1 (fiInt @1 1) in
  viewStream @a
  (mk_view1 @a @0 @1 zero one
   (\ (i : int) (ret : OutPtr a) -> IEffect a. w ret));


Stream1_guard @(a : bare) (repr : Repr a) (condition : bool) (s : Stream1 a)
  -> Stream1 a
  attribute(inline) =
  let sq : Sequence a =
        case s of {
	  viewStream @a (vw : view1 a). viewToSequence @a repr vw
	; sequenceStream @a (sq : Sequence a). sq
	} in
  sequenceStream @a (Sequence_guard @a repr condition sq);


Stream1_bind @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (s : Stream1 a)
  (t : a -> Stream1 b)
  -> Stream1 b
  attribute(inline) =
  let sq : Sequence a =
        case s of {
	  viewStream @a (vw : view1 a). viewToSequence @a repr_a vw
	; sequenceStream @a (sq : Sequence a). sq
	} in
  letfun
    sq_t (x : a) -> Sequence b =
      case t x of {
	  viewStream @b (vw : view1 b). viewToSequence @b repr_b vw
	; sequenceStream @b (sq : Sequence b). sq
      } in
  
  sequenceStream @b (Sequence_bind @a @b repr_a sq sq_t);


Sequence_empty @(a : bare) -> Sequence a
  attribute(inline, inline_final) =
  let type st = Boxed (Stored NoneType) in
  sequence @a @st
  (boxed @(Stored NoneType) (stored @NoneType None))
  (\ (x : st) -> StreamNext st a. streamEmpty @st @a);


Sequence_return @(a : bare)
  (repr : Repr a)
  (ret : Writer a)
  -> Sequence a
  attribute(inline, inline_final) =
  let type st = Boxed (Stored bool) in
  sequence @a @st
  (boxed @(Stored bool) (stored @bool False))
  (\ (depleted : st) -> StreamNext st a.
     case depleted of boxed @(Stored bool) (depleted_s : Stored bool).
     case depleted_s of stored @bool (depleted_u : bool).
     if depleted_u
     then streamEmpty @st @a
     else streamValue @st @a
     	  (boxed @(Stored bool) (stored @bool True))
	  (convertToBoxed @a repr ret));


Sequence_guard @(a : bare)
  (repr : Repr a) (condition : bool) (s : Sequence a) -> Sequence a
  attribute(inline) =
  if condition then s else Sequence_empty @a;


Sequence_bind @(a b : bare)
  (repr : Repr a)
  (src : Sequence a)
  (trans : a -> Sequence b)
  -> Sequence b
  attribute(inline, inline_final) =
  case src of
    sequence @a @(src_st : box)
    (src_state : src_st)
    (src_next : src_st -> StreamNext src_st a).

  let type bind_state = BindState src_st a b in

  letfun {
    next_from_source (src_state : src_st) -> StreamNext bind_state b =
      case src_next src_state of {
        streamValue @src_st @a (src_next_state : src_st) (src_value : BoxedType a).
          case boxed @a (convertToBare @a repr src_value) of boxed @a (x : a).
	  case trans x of
	    sequence @b @(trans_st : box)
	    (trans_state : trans_st)
	    (trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_next_state trans_state trans_next
      ; streamEmpty @src_st @a.
	  streamEmpty @bind_state @b
      };

    next_from_trans @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st b)
      -> StreamNext bind_state b =
      case trans_next trans_state of {
        streamValue @trans_st @b (trans_next_state : trans_st) (trans_value : BoxedType b).
          let next_state : bind_state =
	        bindFromTrans @src_st @a @b @trans_st
		src_state trans_next_state trans_next in
          streamValue @bind_state @b next_state trans_value
      ; streamEmpty @trans_st @b.
	  next_from_source src_state
      };

    next (state : bind_state) -> StreamNext bind_state b =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state
      ; bindFromTrans @src_st @a @b @(trans_st : box)
      	(src_state : src_st)
	(trans_state : trans_st)
	(trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_state trans_state trans_next
      }
  } in

  sequence @b @bind_state (bindFromSource @src_st @a @b src_state) next;


generate @(N : intindex) @(a : bare)
  (size : IInt N) (repr : Repr a) (f : int -> Writer a)
  -> Sequence a attribute(inline, inline_final) =
  case size of {
    iInt @N (fin_size : FIInt N).
      case fin_size of fiInt @N (bound : int).
      -- Finite stream
      let type st = Boxed (Stored int) in
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @(Stored int) (state_s : Stored int).
	  case state_s of stored @int (state_u : int).
	  if state_u <# bound
	  then let next_value : BoxedType a =
	             convertToBoxed @a repr (f state_u) in
	       let next_state : st =
	             boxed @(Stored int) (stored @int (state_u +# 1)) in
	       streamValue @st @a next_state next_value
	  else streamEmpty @st @a
      in
      sequence @a @st (boxed @(Stored int) (stored @int 0)) next
      
  ; iPosInfty @N.
      -- Infinite stream
      let type st = Boxed (Stored int) in
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @(Stored int) (state_s : Stored int).
	  case state_s of stored @int (state_u : int).
	  let next_value : BoxedType a =
	        convertToBoxed @a repr (f state_u) in
	  let next_state : st =
	        boxed @(Stored int) (stored @int (state_u +# 1)) in
	  streamValue @st @a next_state next_value
      in
      sequence @a @st (boxed @(Stored int) (stored @int 0)) next

  ; iNegInfty @N.
      -- Error
      except @(Sequence a)
  };


len @(t : bare -> bare) @(a : bare)
  (is_linear : coerce @box (BoxedType (shape t)) (Boxed dim1))
  (indexable : IndexableDict t)
  (container : t a)
  -> int
  attribute(inline) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @dim1
       (coerce @(Writer (shape t)) @(Writer dim1) (get_shape @a container)) of
    boxed @dim1 (sh : dim1).

  case sh of mk_dim1 @(Nlo Nhi : intindex) (ilo : IInt Nlo) (ihi : IInt Nhi).
  case fromIndInt @Nlo ilo of fiInt @Nlo (lo : int).
  case fromIndInt @Nhi ihi of fiInt @Nhi (hi : int).
  hi -# lo;


width @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (indexable : IndexableDict t)
  (container : t a)
  -> int attribute(inline) =

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @dim2
       (coerce @(Writer (shape t)) @(Writer dim2) (get_shape @a container)) of
    boxed @dim2 (shp : dim2).
  case shp of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).

  case fromIndInt @Nlo inp_xmin of fiInt @Nlo (lo : int).
  case fromIndInt @Nhi inp_xend of fiInt @Nhi (hi : int).
  hi -# lo;


height @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (indexable : IndexableDict t)
  (container : t a)
  -> int attribute(inline) =

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @dim2
       (coerce @(Writer (shape t)) @(Writer dim2) (get_shape @a container)) of
    boxed @dim2 (shp : dim2).
  case shp of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).

  case fromIndInt @Mlo inp_ymin of fiInt @Mlo (lo : int).
  case fromIndInt @Mhi inp_yend of fiInt @Mhi (hi : int).
  hi -# lo;

-------------------------------------------------------------------------------
-- Methods specifically for 2D streams

stencil2D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr_a : Repr a) (repr_b : Repr b)
  (ymin : int) (ymax : int) (xmin : int) (xmax : int)
  (stencilfn : view2 a -> Writer b)
  (inp : t a)
  -> Writer (array2 b)
  attribute(inline, inline_sequential) =

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  -- Stencil must span at least one element
  let yend : int = ymax +# 1 in
  let xend : int = xmax +# 1 in
  let stencil_size_y : int = yend -# ymin in
  let stencil_size_x : int = xend -# xmin in
  if or (stencil_size_y <=# 0) (stencil_size_x <=# 0)
  then except @(Writer (array2 b)) else

  -- Create stencil dimensions
  case defineIntIndex ymin of
    someIInt @(stencil_Mlo : intindex) (stencil_ymin : FIInt stencil_Mlo).
  case defineIntIndex xmin of
    someIInt @(stencil_Nlo : intindex) (stencil_xmin : FIInt stencil_Nlo).
  case defineIntIndex yend of
    someIInt @(stencil_Mhi : intindex) (stencil_yend : FIInt stencil_Mhi).
  case defineIntIndex xend of
    someIInt @(stencil_Nhi : intindex) (stencil_xend : FIInt stencil_Nhi).

  -- Inspect the input data
  case boxed @(shape t) (get_shape @a inp) of boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).
    case fromIndInt @Mlo inp_ymin of
      fiInt @Mlo (inp_ymin_i : int).
    case fromIndInt @Nlo inp_xmin of
      fiInt @Nlo (inp_xmin_i : int).
    case fromIndInt @Mhi inp_yend of
      fiInt @Mhi (inp_yend_i : int).
    case fromIndInt @Nhi inp_xend of
      fiInt @Nhi (inp_xend_i : int).

    -- Compute dimensions of input
    let type M = minus_i Mhi Mlo in
    let type N = minus_i Nhi Nlo in
    let inp_height : FIInt M =
    	  minus_fii @Mhi @Mlo (fromIndInt @Mhi inp_yend) (fromIndInt @Mlo inp_ymin) in
    case inp_height of fiInt @M (inp_height_i : int).
    let inp_width : FIInt N =
    	  minus_fii @Nhi @Nlo (fromIndInt @Nhi inp_xend) (fromIndInt @Nlo inp_xmin) in
    case inp_width of fiInt @N (inp_width_i : int).

    -- Compute dimensions of output
    let type Mout = minus_i M 0 in
    let type Nout = minus_i N 0 in
    let type out_array = arr Mout (arr Nout b) in

    let row_repr : Repr (arr Nout b) =
    	  repr_arr @Nout @b (minus_fii @N @0 inp_width zero_fii) repr_b in

    letfun {
      -- Read from the input array2 view.  Ensure that accesses do not go
      -- outside array bounds.
      safe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
        -> Writer a =
        -- Read one element from the input for a stencil at point (pty, ptx).
        -- The coordinate to read is (pty + yoff, ptx + xoff).
        -- The image is padded at the edges.
        let yindex : int = pty +# yoff in
        let xindex : int = ptx +# xoff in
        let bounded_yindex : int =
              max_int inp_ymin_i (min_int yindex (inp_yend_i -# 1)) in
        let bounded_xindex : int =
              max_int inp_xmin_i (min_int xindex (inp_xend_i -# 1)) in
	case boxed @(index dim2)
	     (pyonTuple2 @(Stored int) @(Stored int)
	      (stored @int bounded_yindex) (stored @int bounded_xindex)) of
	  boxed @(index dim2) (ix : index dim2).
        at_index @a repr_a inp (coerce @(index dim2) @(index (shape t)) ix);

      -- Read from the input array2 view.  Assume that the given
      -- offsets do not produce out-of-bounds array accesses.
      unsafe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
        -> Writer a =
        -- Read one element from the input for a stencil at point (pty, ptx).
        -- The coordinate to read is (pty + yoff, ptx + xoff).
        -- The image is padded at the edges.
        let yindex : int = pty +# yoff in
        let xindex : int = ptx +# xoff in
	case boxed @(index dim2)
	     (pyonTuple2 @(Stored int) @(Stored int)
	      (stored @int yindex) (stored @int xindex)) of
	  boxed @(index dim2) (ix : index dim2).
        at_index @a repr_a inp (coerce @(index dim2) @(index (shape t)) ix);

      -- Initialize a region of the output array.
      -- The region is given as an origin (y, x) and
      -- extent (delta y, delta x).
      init_array
        (origin_y : int) (origin_x : int) (delta_y : int) (delta_x : int)
        (getter : int -> int -> int -> int -> Writer a)
        (ret : OutPtr out_array)
        -> IEffect out_array =
        case defineIntIndex delta_y of
          someIInt @(Minit : intindex) (rgn_height : FIInt Minit).
        case defineIntIndex delta_x of
          someIInt @(Ninit : intindex) (rgn_width : FIInt Ninit).

        -- Loop over region
        doall @Minit @out_array @(arr Nout b) rgn_height
        (\ (loop_y : int) -> IEffect (arr Nout b).
          doall @Ninit @(arr Nout b) @b rgn_width
          (\ (loop_x : int) -> IEffect b.
             let y : int = origin_y +# loop_y in
             let x : int = origin_x +# loop_x in
             let mv : view2 a =
                   mk_view2 @a
                   @stencil_Mlo @stencil_Mhi @stencil_Nlo @stencil_Nhi
                   (iInt @stencil_Mlo stencil_ymin)
                   (iInt @stencil_Mhi stencil_yend)
                   (iInt @stencil_Nlo stencil_xmin)
                   (iInt @stencil_Nhi stencil_xend)
                   (getter y x) in
             -- Pass the array2 view to the stencil function
             stencilfn mv (subscript_out @Nout @b repr_b
                           (subscript_out @Mout @(arr Nout b)
                            row_repr ret y) x)))
    } in

    -- Bounds checking is needed around the edges of the array, but not in
    -- the interior.  Compute the size of the edges and the interior.
    let left_boundary_size : int =
          max_int 0 (AdditiveDict_int_negate xmin) in
    let right_boundary_size : int =
          max_int 0 xmax in
    let top_boundary_size : int =
          max_int 0 (AdditiveDict_int_negate ymin) in
    let bottom_boundary_size : int =
          max_int 0 ymax in
    let center_width : int =
     	  inp_width_i -# (left_boundary_size +# right_boundary_size) in
    let center_height : int =
          inp_height_i -# (top_boundary_size +# bottom_boundary_size) in

    -- Origin of center, left, and right regions
    let center_origin_y : int = top_boundary_size in

    -- Origin of center region
    let center_origin_x : int = left_boundary_size in
    let right_origin_x : int = inp_width_i -# right_boundary_size in
    let bottom_origin_y : int = inp_height_i -# bottom_boundary_size in

    -- Create return value
    mk_array2 @b @0 @M @0 @N zero_fii inp_height zero_fii inp_width
    (referenced @(arr (minus_i M 0) (arr (minus_i N 0) b))
     (if or (center_width <# 1) (center_height <# 1)
     then
       -- Input array2 is smaller than stencil.  Use one loop for the
       -- entire output array.
       init_array 0 0 inp_height_i inp_width_i safe_get
     else
       -- Use one loop each for the left, right, top, bottom, and center of
       -- the output.  The corners of the output array are part of the top
       -- and bottom strips.
       (\ (ret_array : OutPtr out_array)
          -> IEffect out_array.
          fromEffTok @out_array
          (seqEffTok
           (seqEffTok
            (toEffTok @out_array -- Top strip
             (init_array 0 0 top_boundary_size inp_width_i safe_get ret_array))
            (toEffTok @out_array -- Bottom strip
             (init_array bottom_origin_y 0 bottom_boundary_size inp_width_i safe_get ret_array)))
           (seqEffTok
            (seqEffTok
             (toEffTok @out_array -- Left strip
              (init_array center_origin_y 0 center_height left_boundary_size safe_get ret_array))
             (toEffTok @out_array -- Right strip
              (init_array center_origin_y right_origin_x center_height right_boundary_size safe_get ret_array)))
            (toEffTok @out_array -- Center region
             (init_array center_origin_y center_origin_x center_height center_width unsafe_get ret_array)))))));

-------------------------------------------------------------------------------
-- Loops

for @(N : intindex) @(acc : bare)
  (repr : Repr acc) (count : IInt N) (init : acc)
  (f : int -> acc -> Writer acc) (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of {
    iInt @N (fin : FIInt N).
      case fin of fiInt @N (bound : int).

      -- Main loop
      letfun
        loop (i : int) (x : acc) (r : OutPtr acc) -> IEffect acc =
          if EqDict_int_eq i bound
          then copy @acc repr x r
          else case boxed @acc (f i x) of boxed @acc (y : acc).
               loop (AdditiveDict_int_add i 1) y r
      in loop 0 init ret;

    -- An infinite loop will fail
    iPosInfty @N.
      except @(IEffect acc);

    -- Negative trip counts are not valid
    iNegInfty @N.
      except @(IEffect acc)
  };







{-



oper_DO @(a : bare) (repr : Repr a) (f : Writer a) -> Stream dim1 a
  attribute(inline_final) =

  -- Singleton stream.
  -- State is a boolean, which is false if the stream is depleted,
  -- true otherwise.
  letfun
    get_value (state : Boxed (Stored bool))
      -> StreamNext (Boxed (Stored bool)) (BoxedType a) =
      case state of boxed @(Stored bool) (u_state : Stored bool).
      case u_state of stored @bool (i_state : bool).
      if i_state
      then let next_state : Boxed (Stored bool) =
                 boxed @(Stored bool) (stored @bool False) in
           let retval : BoxedType a = convertToBoxed @a repr f in
           streamValue @(Boxed (Stored bool)) @(BoxedType a) next_state retval
      else streamEmpty @(Boxed (Stored bool)) @(BoxedType a)
  in
    let initial_state : Boxed (Stored bool) =
          boxed @(Stored bool) (stored @bool True) in
    linStream @dim1 @a @(Boxed (Stored bool)) initial_state get_value;

oper_CAT_MAP @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (src : Stream dim1 a)
  (trans : a -> Stream dim1 b)
  -> Stream dim1 b
  attribute(inline_final) =
  case src of linStream @dim1 @a @(src_st : box)
                (src_state : src_st)
		(src_next : src_st -> StreamNext src_st (BoxedType a)).
  letfun {
    -- Dispatch based on the current stream state
    next (state : BindState src_st a b)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state;

	bindFromTrans @src_st @a @b @(trans_st : box)
	  (src_state : src_st)
	  (trans_state : trans_st)
	  (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).
	  next_from_trans @trans_st src_state trans_state trans_next
      };

    -- Pull a value from the source stream
    next_from_source
      (src_state : src_st)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case src_next src_state of {
        streamValue @src_st @(BoxedType a)
	  (next_src_state : src_st) (src_value : BoxedType a).

	  -- Apply the transformer to this value
	  case boxed @a (convertToBare @a repr_a src_value)
	  of boxed @a (src_uvalue : a).

	  case trans src_uvalue of linStream @dim1 @b @(trans_st : box)
	                             (trans_state : trans_st)
				     (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).

          -- Pull a value from the transformed stream
          next_from_trans @trans_st next_src_state trans_state trans_next;

	streamEmpty @src_st @(BoxedType a).
	  -- Stream is depleted
	  streamEmpty @(BindState src_st a b) @(BoxedType b)
      };

    -- Pull a value from the transformed stream
    next_from_trans
      @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st (BoxedType b))
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case trans_next trans_state of {
        streamValue @trans_st @(BoxedType b)
	  (next_trans_state : trans_st) (trans_value : BoxedType b).

	  streamValue @(BindState src_st a b) @(BoxedType b)
	    (bindFromTrans @src_st @a @b @trans_st
	     src_state next_trans_state trans_next)
	    trans_value;

	streamEmpty @trans_st @(BoxedType b).
	  -- Pull a new value from the source stream
	  next_from_source src_state
      }
  } in linStream @dim1 @b @(BindState src_st a b)
         (bindFromSource @src_st @a @b src_state)
	 next;


-- 'bind' is a renamed version of 'oper_CAT_MAP'.
bind @(N : intindex) @(sh a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (src : Stream (arr_shape N dim0) a)
  (trans : a -> Stream sh b)
  -> Stream (arr_shape N sh) b 
  attribute(inline_final) =
  case oper_CAT_MAP @a @b repr_a repr_b
       (fun_asList_Stream @(arr_shape N dim0) @a src)
       (\ (x : a) -> Stream dim1 b. fun_asList_Stream @sh @b (trans x))
  of linStream @dim1 @b @(st : box) (state : st) (next : st -> StreamNext st (BoxedType b)).
  linStream @(arr_shape N sh) @b @st state next;



-} -- END


{-

-------------------------------------------------------------------------------
-- Array functions

array_traverse @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N) (ay : arr N a)
  -> Stream (arr_shape N dim0) a =
  generate @N @a (iInt @N size) repr
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr (subscript @N @a repr ay i) ret);

array_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (s : Stream (arr_shape N dim0) a)
  (ret : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline_final) =

  case s of linStream @(arr_shape N dim0) @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case size of fiInt @N (bound : int).

  letfun
    go (i : int) (state : st) -> EffTok =
      if EqDict_int_eq i bound
      then emptyEffTok
      else case stream_next state of {

             -- Obtain value from stream
             streamValue @st @(BoxedType a)
	       (next_state : st) (result : BoxedType a).
               -- Write into the array
	       seqEffTok (toEffTok @a (convertToBare @a repr result
	       		               (subscript_out @N @a repr ret i)))
                         (go (AdditiveDict_int_add i 1) next_state);

             streamEmpty @st @(BoxedType a).
	       except @EffTok
	   }
  in fromEffTok @(arr N a) (go 0 stream_state);

-------------------------------------------------------------------------------
-- List functions

histogram @(sh : bare)
  (size : int)
  (input : Stream sh (Stored int))
  (ret : OutPtr (list (Stored int)))
  -> IEffect (list (Stored int)) =
  case defineIntIndex size of someIInt @(N : intindex) (index : FIInt N).
  make_list @(Stored int) @N index
  (referenced @(arr N (Stored int))
   (histogramArray @sh @N index input))
  ret;

-------------------------------------------------------------------------------
-- Matrix functions

rows @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr : Repr a)
  (container : t a)
  -> Writer (view1 (view1 a)) =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
   @(Mlo M Nlo N : intindex)
    (ymin : IInt Mlo)
    (height : IInt M)
    (xmin : IInt Nlo)
    (width : IInt N).

  let fymin : FIInt Mlo = fromIndInt @Mlo ymin in
  let fheight : FIInt M = fromIndInt @M height in
  let fxmin : FIInt Nlo = fromIndInt @Nlo xmin in
  let fwidth : FIInt N = fromIndInt @N width in

  mk_view1 @(view1 a) @Mlo @M fymin fheight
  (\ (y : int) -> Writer (view1 a).
    mk_view1 @a @Nlo @N fxmin fwidth
    (\ (x : int) (ret : OutPtr a) -> IEffect a.
      case boxed @(index dim2)
           (pyonTuple2 @(Stored int) @(Stored int)
            (stored @int y) (stored @int x)) of
        boxed @(index dim2) (ix : index dim2).
      at_point @a repr container
      (coerce @(index dim2) @(index (shape t)) ix)
      ret));

cols @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr : Repr a)
  (container : t a)
  -> Writer (view1 (view1 a)) =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
   @(Mlo M Nlo N : intindex)
    (ymin : IInt Mlo)
    (height : IInt M)
    (xmin : IInt Nlo)
    (width : IInt N).

  let fymin : FIInt Mlo = fromIndInt @Mlo ymin in
  let fheight : FIInt M = fromIndInt @M height in
  let fxmin : FIInt Nlo = fromIndInt @Nlo xmin in
  let fwidth : FIInt N = fromIndInt @N width in

  mk_view1 @(view1 a) @Nlo @N fxmin fwidth
  (\ (x : int) -> Writer (view1 a).
    mk_view1 @a @Mlo @M fymin fheight
    (\ (y : int) (ret : OutPtr a) -> IEffect a.
      case boxed @(index dim2)
           (pyonTuple2 @(Stored int) @(Stored int)
            (stored @int y) (stored @int x)) of
        boxed @(index dim2) (ix : index dim2).
      at_point @a repr container
      (coerce @(index dim2) @(index (shape t)) ix)
      ret));

outerproduct @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim2 c
  attribute (inline_final) =

  -- Convert arguments to lists
  case boxed @(list a) (TraversableDict_list_build @a repr_a sa) of
    boxed @(list a) (la : list a).
  case la of make_list @a @(M : intindex)
       	     (size_y : FIInt M) (ayref_a : Referenced (arr M a)).
  case ayref_a of referenced @(arr M a) (ay_a : arr M a).

  case boxed @(list b) (TraversableDict_list_build @b repr_b sb) of
    boxed @(list b) (lb : list b).
  case lb of make_list @b @(N : intindex)
       	     (size_x : FIInt N) (ayref_b : Referenced (arr N b)).
  case ayref_b of referenced @(arr N b) (ay_b : arr N b).

  -- Create a array2 stream
  matrixStream @c @M @N (iInt @M size_y) (iInt @N size_x)
  (bind @M @(arr_shape N dim0) @a @c repr_a repr_c
  (array_traverse @M @a repr_a size_y ay_a)
  (\ (x : a) -> Stream (arr_shape N dim0) c.
    generate @N @c (iInt @N size_x) repr_c
    (\ (index : int) -> Writer c.
       let y : b = subscript @N @b repr_b ay_b index in
       f x y)));

{-
transpose @(a : bare)
  (repr : Repr a) (mat : array2 a) (ret : OutPtr (view2 a))
  -> IEffect (view2 a) =
  case mat of mk_array2 @a @(M : intindex) @(N : intindex)
       	      (height : FIInt M) (width : FIInt N)
      	      (aref : Referenced (arr M (arr N a))).
  case aref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).
  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in

  mk_view2 @a @N @M width height
  (\ (y : int) (x : int) -> Writer a.
    copy @a repr (subscript @N @a repr (subscript @M @(arr N a) row_repr ay x) y))
  ret;-}


-------------------------------------------------------------------------------
-- List container class functions



IndexableDict_list_at_point @(a : bare)
  (repr : Repr a) (ls : list a) (ix : Stored int) (ret : OutPtr a)
  -> IEffect a =

  -- Deconstruct data structures
  case ls of make_list @a @(N : intindex)
             (size : FIInt N) (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).
  case size of fiInt @N (size_int : int).
  case ix of stored @int (ix_u : int).

  copy @a repr (subscript @N @a repr ay ix_u) ret;


IndexableDict_list_at_slice @(a : bare)
  (repr : Repr a) (ls : list a)
  (slice : PyonTuple3 (Stored int) (Stored int) (Stored int))
  (ret : OutPtr (view1 a)) -> IEffect (view1 a) =

  case slice of pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
       	     	(start_s : Stored int) (delta_s : Stored int) (stride_s : Stored int).
  case start_s of stored @int (start : int).
  case delta_s of stored @int (delta : int).
  case stride_s of stored @int (stride : int).

  case ls of make_list @a @(N : intindex)
       	     (list_size : FIInt N) (ayref : Referenced (arr N a)).
  case list_size of fiInt @N (list_size_i : int).
  case ayref of referenced @(arr N a) (ay : arr N a).

  let count : int =
        -- Ceiling division
	let interval_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta stride) 1 in
	RemainderDict_int_floordiv interval_rounded stride in
  case defineIntIndex count of someIInt @(L : intindex) (count_i : FIInt L).
  mk_view1 @a @0 @L (fiInt @0 0) count_i
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     let index : int =
           AdditiveDict_int_add start (MultiplicativeDict_int_mul i stride) in
     copy @a repr (subscript @N @a repr ay index) ret)
  ret;


IndexableDict_list_get_shape @(a : bare)
  (ls : list a) (ret : OutPtr dim1) -> IEffect dim1 =

  case ls of make_list @a @(N : intindex)
       	     (length : FIInt N)
	     (aptr : Referenced (arr N a)).

  mk_dim1 @0 @N (iInt @0 (fiInt @0 0)) (iInt @N length) ret;


-------------------------------------------------------------------------------
-- view1 container class functions

TraversableDict_view1_traverse @(a : bare)
  (repr : Repr a) (ls : view1 a) -> Stream dim1 a =
  case ls of mk_view1 @a @(Nlo N : intindex)
       	     (xmin : FIInt Nlo) (size : FIInt N) (f : int -> Writer a).
  LinStream_flatten @(arr_shape N dim0) @a
  (generate @N @a (iInt @N size) repr f);


TraversableDict_view1_build @(a : bare)
  (repr : Repr a) (s : Stream dim1 a) (ret : OutPtr (view1 a))
  -> IEffect (view1 a) =

  -- Build a list, then create a list view from it
  case boxed @(list a) (TraversableDict_list_build @a repr s) of boxed @(list a) (ls : list a).
  case ls of make_list @a @(N : intindex) (list_size : FIInt N) (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).

  mk_view1 @a @0 @N  (fiInt @0 0) list_size
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
    copy @a repr (subscript @N @a repr ay i) ret)
  ret;


IndexableDict_ListView_at_point @(a : bare)
  (repr : Repr a) (ls : view1 a) (ix : int) (ret : OutPtr a) -> IEffect a =

  case ls of mk_view1 @a @(Nlo N : intindex)
             (xmin : FIInt Nlo) (size : FIInt N) (generator : int -> Writer a).
  case xmin of fiInt @Nlo (xmin_i : int).
  case size of fiInt @N (size_int : int).
  let xmax_i : int =
        AdditiveDict_int_sub (AdditiveDict_int_add xmin_i size_int) 1 in

  if or (OrdDict_int_lt ix xmin_i) (OrdDict_int_gt ix xmax_i)
  then except @(IEffect a)
  else generator ix ret;


IndexableDict_ListView_at_slice @(a : bare)
  (repr : Repr a) (ls : view1 a)
  (start : int) (delta : int) (stride : int)
  (ret : OutPtr (view1 a)) -> IEffect (view1 a) =

  case ls of mk_view1 @a @(Nlo N : intindex)
       	     (xmin : FIInt Nlo)
	     (list_size : FIInt N)
	     (generator : int -> Writer a).
  case xmin of fiInt @Nlo (xmin_i : int).
  case list_size of fiInt @N (list_size_i : int).
  let xmax_i : int =
        AdditiveDict_int_sub (AdditiveDict_int_add xmin_i list_size_i) 1 in
  
  let count : int =
        -- Ceiling division
	let interval_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta stride) 1 in
	RemainderDict_int_floordiv interval_rounded stride in
  case defineIntIndex count of someIInt @(L : intindex) (count_i : FIInt L).
  mk_view1 @a @0 @L  (fiInt @0 0) count_i
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     let index : int =
           AdditiveDict_int_add start (MultiplicativeDict_int_mul i stride) in
     generator index ret)
  ret;

-------------------------------------------------------------------------------
-- Stream Traversable functions



-------------------------------------------------------------------------------
-- List-specific stream functions

fun_asList_Stream @(sh a : bare)
  (shape_dict : ShapeDict sh) (src : Stream sh a) -> Stream dim1 a =
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  shape_flatten @a src;


range (n : int) -> Stream dim1 (Stored int) =
  case defineIntIndex n of someIInt @(ix : intindex) (val : FIInt ix).
    LinStream_flatten @(arr_shape ix dim0) @(Stored int)
    (rangeIndexed @ix (iInt @ix val));


rangeIndexed @(N : intindex) (count : IInt N)
  -> Stream (arr_shape N dim0) (Stored int) =
  generate @N @(Stored int) count repr_int
  (\ (i : int) -> Writer (Stored int). stored @int i);


oper_GUARD @(a : bare) (repr : Repr a) (arg : bool) (s : Stream dim1 a)
  -> Stream dim1 a =
  if arg then s else oper_EMPTY @a repr;


oper_EMPTY @(a : bare) (repr : Repr a) -> Stream dim1 a
  attribute(inline_final) =
  linStream @dim1 @a @(Boxed (Stored NoneType))
  (boxed @(Stored NoneType) (stored @NoneType None))
  (\ (state : Boxed (Stored NoneType)) -> StreamNext (Boxed (Stored NoneType)) (BoxedType a).
    streamEmpty @(Boxed (Stored NoneType)) @(BoxedType a));


generate @(N : intindex) @(a : bare)
         (count : IInt N) (repr : Repr a) (f : int -> Writer a)
 -> Stream (arr_shape N dim0) a
  attribute(inline, inline_final) =

  case count of {
    iInt @N (fin : FIInt N).
      -- Finite case
      case fin of fiInt @N (bound : int).
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

	  -- End of loop?
          if EqDict_int_eq i bound
          then streamEmpty @(Boxed (Stored int)) @(BoxedType a)
	  else let retval : BoxedType a =
                    convertToBoxed @a repr (f i) in

               -- Apply the generator function
               streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in linStream @(arr_shape N dim0) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next;

    iPosInfty @N (pf : Pf (eqZ N pos_infty)).
      -- Infinite case
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

          let retval : BoxedType a =
                convertToBoxed @a repr (f i) in

          -- Apply the generator function
          streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in linStream @(arr_shape N dim0) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next;

    iNegInfty @N (pf : Pf (eqZ N neg_infty)).
      except @(Stream (arr_shape N dim0) a)
  };

-------------------------------------------------------------------------------
-- Matrix-specific stream methods

fun_from_MatrixView_Stream @(a : bare)
  (s : Stream dim2 a) -> Stream dim2 a = s;

fun_asMatrix_Stream @(M N : intindex) @(a : bare)
  (size_y : IInt M)
  (size_x : IInt N)
  (src : Stream (arr_shape M (arr_shape N dim0)) a)
  -> Stream dim2 a =
  matrixStream @a @M @N size_y size_x src;


chunk_id @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size : IInt N)
  (s : Stream (arr_shape M (arr_shape N dim0)) a)
  -> Stream (arr_shape M dim0) (StoredBox (Stream (arr_shape N dim0) a)) =

  chunk @M @N @a @(StoredBox (Stream (arr_shape N dim0) a))
  repr
  (repr_Box @(Stream (arr_shape N dim0) a))
  size
  s
  (\ (x : (Stream (arr_shape N dim0) a))
     -> Writer (StoredBox (Stream (arr_shape N dim0) a)).
     storedBox @(Stream (arr_shape N dim0) a) x);

-------------------------------------------------------------------------------
-- Other shape methods

ShapeDict_matrix_flatten @(a : bare) (s : Stream dim2 a)
  -> Stream dim1 a =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	                 (size_y : IInt M) (size_x : IInt N)
			 (ls : LinStream (arr_shape M (arr_shape N dim0)) a).
  LinStream_flatten @(arr_shape M (arr_shape N dim0)) @a ls;


ShapeDict_matrix_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (s : Stream dim2 a) -> Stream dim2 b =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	                 (size_y : IInt M) (size_x : IInt N)
			 (ls : LinStream (arr_shape M (arr_shape N dim0)) a).
  matrixStream @b @M @N size_y size_x
  (LinStream_map @(arr_shape M (arr_shape N dim0)) @a @b repr_a repr_b f ls);


ShapeDict_matrix_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : Stream dim2 a) (src_b : Stream dim2 b)
  -> Stream dim2 c =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IInt Ma) (size_a_x : IInt Na)
    (ls_a : LinStream (arr_shape Ma (arr_shape Na dim0)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IInt Mb) (size_b_x : IInt Nb)
    (ls_b : LinStream (arr_shape Mb (arr_shape Nb dim0)) b).

  let size_y : IInt (min_i Ma Mb) = min_ii @Ma @Mb size_a_y size_b_y in
  let size_x : IInt (min_i Na Nb) = min_ii @Na @Nb size_a_x size_b_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @c @(min_i Ma Mb) @(min_i Na Nb) size_y size_x
  (bind
   @(min_i Ma Mb)
   @(arr_shape (min_i Na Nb) dim0)
   @(StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c))
   @c
   (repr_Box @(LinStream (arr_shape (min_i Na Nb) dim0) c))
   repr_c

   -- Zip in Y dimension
   (LinStream_zipWith_array
    @(StoredBox (LinStream (arr_shape Na dim0) a))
    @(StoredBox (LinStream (arr_shape Nb dim0) b))
    @(StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c))
    @Ma
    @Mb
    (repr_Box @(LinStream (arr_shape Na dim0) a))
    (repr_Box @(LinStream (arr_shape Nb dim0) b))
    (repr_Box @(LinStream (arr_shape (min_i Na Nb) dim0) c))
    (\ (inner_stream_a : StoredBox (LinStream (arr_shape Na dim0) a))
       (inner_stream_b : StoredBox (LinStream (arr_shape Nb dim0) b))
       -> Writer (StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c)).
       case inner_stream_a of
         storedBox @(LinStream (arr_shape Na dim0) a)
 	(sa : LinStream (arr_shape Na dim0) a).
       case inner_stream_b of
         storedBox @(LinStream (arr_shape Nb dim0) b)
 	(sb : LinStream (arr_shape Nb dim0) b).
       storedBox @(LinStream (arr_shape (min_i Na Nb) dim0) c)

         -- Zip in X dimension
         (LinStream_zipWith_array @a @b @c @Na @Nb repr_a repr_b repr_c f sa sb))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b))

   (\ (x : StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c))
      -> LinStream (arr_shape (min_i Na Nb) dim0) c.
      case x of storedBox @(LinStream (arr_shape (min_i Na Nb) dim0) c)
      	        (y : LinStream (arr_shape (min_i Na Nb) dim0) c).
      y));

    
ShapeDict_matrix_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : Stream dim2 a) (src_b : Stream dim2 b)
  (src_c : Stream dim2 c)
  -> Stream dim2 d =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IInt Ma) (size_a_x : IInt Na)
    (ls_a : LinStream (arr_shape Ma (arr_shape Na dim0)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IInt Mb) (size_b_x : IInt Nb)
    (ls_b : LinStream (arr_shape Mb (arr_shape Nb dim0)) b).

  case src_c of
    matrixStream @c @(Mc : intindex) @(Nc : intindex)
    (size_c_y : IInt Mc) (size_c_x : IInt Nc)
    (ls_c : LinStream (arr_shape Mc (arr_shape Nc dim0)) c).

  let size_y : IInt (min_i (min_i Ma Mb) Mc) =
        min_ii @(min_i Ma Mb) @Mc (min_ii @Ma @Mb size_a_y size_b_y) size_c_y in
  let size_x : IInt (min_i (min_i Na Nb) Nc) =
        min_ii @(min_i Na Nb) @Nc (min_ii @Na @Nb size_a_x size_b_x) size_c_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @d @(min_i (min_i Ma Mb) Mc) @(min_i (min_i Na Nb) Nc) size_y size_x
  (bind
   @(min_i (min_i Ma Mb) Mc)
   @(arr_shape (min_i (min_i Na Nb) Nc) dim0)
   @(StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
   @d
   (repr_Box @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
   repr_d

   -- Zip in Y dimension
   (LinStream_zipWith3_array
    @(StoredBox (LinStream (arr_shape Na dim0) a))
    @(StoredBox (LinStream (arr_shape Nb dim0) b))
    @(StoredBox (LinStream (arr_shape Nc dim0) c))
    @(StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
    @Ma
    @Mb
    @Mc
    (repr_Box @(LinStream (arr_shape Na dim0) a))
    (repr_Box @(LinStream (arr_shape Nb dim0) b))
    (repr_Box @(LinStream (arr_shape Nc dim0) c))
    (repr_Box @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
    (\ (inner_stream_a : StoredBox (LinStream (arr_shape Na dim0) a))
       (inner_stream_b : StoredBox (LinStream (arr_shape Nb dim0) b))
       (inner_stream_c : StoredBox (LinStream (arr_shape Nc dim0) c))
       -> Writer (StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d)).
       case inner_stream_a of
         storedBox @(LinStream (arr_shape Na dim0) a)
 	(sa : LinStream (arr_shape Na dim0) a).
       case inner_stream_b of
         storedBox @(LinStream (arr_shape Nb dim0) b)
 	(sb : LinStream (arr_shape Nb dim0) b).
       case inner_stream_c of
         storedBox @(LinStream (arr_shape Nc dim0) c)
 	(sc : LinStream (arr_shape Nc dim0) c).
       storedBox @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d)

         -- Zip in X dimension
         (LinStream_zipWith3_array @a @b @c @d @Na @Nb @Nc repr_a repr_b repr_c repr_d f sa sb sc))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b)
    (chunk_id @Mc @Nc @c repr_c size_c_x ls_c))

   (\ (x : StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
      -> LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d.
      case x of storedBox @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d)
      	        (y : LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d).
      y));


ShapeDict_matrix_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : Stream dim2 a) (src_b : Stream dim2 b)
  (src_c : Stream dim2 c) (src_d : Stream dim2 d)
  -> Stream dim2 e =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IInt Ma) (size_a_x : IInt Na)
    (ls_a : LinStream (arr_shape Ma (arr_shape Na dim0)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IInt Mb) (size_b_x : IInt Nb)
    (ls_b : LinStream (arr_shape Mb (arr_shape Nb dim0)) b).

  case src_c of
    matrixStream @c @(Mc : intindex) @(Nc : intindex)
    (size_c_y : IInt Mc) (size_c_x : IInt Nc)
    (ls_c : LinStream (arr_shape Mc (arr_shape Nc dim0)) c).

  case src_d of
    matrixStream @d @(Md : intindex) @(Nd : intindex)
    (size_d_y : IInt Md) (size_d_x : IInt Nd)
    (ls_d : LinStream (arr_shape Md (arr_shape Nd dim0)) d).

  let size_y : IInt (min_i (min_i (min_i Ma Mb) Mc) Md) =
        min_ii @(min_i (min_i Ma Mb) Mc) @Md
	(min_ii @(min_i Ma Mb) @Mc
	 (min_ii @Ma @Mb size_a_y size_b_y) size_c_y) size_d_y in
  let size_x : IInt (min_i (min_i (min_i Na Nb) Nc) Nd) =
        min_ii @(min_i (min_i Na Nb) Nc) @Nd
	(min_ii @(min_i Na Nb) @Nc
	 (min_ii @Na @Nb size_a_x size_b_x) size_c_x) size_d_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @e @(min_i (min_i (min_i Ma Mb) Mc) Md) @(min_i (min_i (min_i Na Nb) Nc) Nd) size_y size_x
  (bind
   @(min_i (min_i (min_i Ma Mb) Mc) Md)
   @(arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0)
   @(StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
   @e
   (repr_Box @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
   repr_e

   -- Zip in Y dimension
   (LinStream_zipWith4_array
    @(StoredBox (LinStream (arr_shape Na dim0) a))
    @(StoredBox (LinStream (arr_shape Nb dim0) b))
    @(StoredBox (LinStream (arr_shape Nc dim0) c))
    @(StoredBox (LinStream (arr_shape Nd dim0) d))
    @(StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
    @Ma
    @Mb
    @Mc
    @Md
    (repr_Box @(LinStream (arr_shape Na dim0) a))
    (repr_Box @(LinStream (arr_shape Nb dim0) b))
    (repr_Box @(LinStream (arr_shape Nc dim0) c))
    (repr_Box @(LinStream (arr_shape Nd dim0) d))
    (repr_Box @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
    (\ (inner_stream_a : StoredBox (LinStream (arr_shape Na dim0) a))
       (inner_stream_b : StoredBox (LinStream (arr_shape Nb dim0) b))
       (inner_stream_c : StoredBox (LinStream (arr_shape Nc dim0) c))
       (inner_stream_d : StoredBox (LinStream (arr_shape Nd dim0) d))
       -> Writer (StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e)).
       case inner_stream_a of
         storedBox @(LinStream (arr_shape Na dim0) a)
 	(sa : LinStream (arr_shape Na dim0) a).
       case inner_stream_b of
         storedBox @(LinStream (arr_shape Nb dim0) b)
 	(sb : LinStream (arr_shape Nb dim0) b).
       case inner_stream_c of
         storedBox @(LinStream (arr_shape Nc dim0) c)
 	(sc : LinStream (arr_shape Nc dim0) c).
       case inner_stream_d of
         storedBox @(LinStream (arr_shape Nd dim0) d)
 	(sd : LinStream (arr_shape Nd dim0) d).
       storedBox @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e)

         -- Zip in X dimension
         (LinStream_zipWith4_array @a @b @c @d @e @Na @Nb @Nc @Nd repr_a repr_b repr_c repr_d repr_e f sa sb sc sd))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b)
    (chunk_id @Mc @Nc @c repr_c size_c_x ls_c)
    (chunk_id @Md @Nd @d repr_d size_d_x ls_d))

   (\ (x : StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
      -> LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e.
      case x of storedBox @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e)
      	        (y : LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e).
      y));

ShapeDict_matrix_inRange
  (shape_value : dim2)
  (ix : index dim2)
  -> bool =
  case shape_value of
    mk_dim2 @(Mlo : intindex) @(M : intindex) @(Nlo : intindex) @(N : intindex)
    (ymin : IInt Mlo)
    (height : IInt M)
    (xmin : IInt Nlo)
    (width : IInt N).
  case ix of
    pyonTuple2 @(Stored int) @(Stored int)
    (y_s : Stored int) (x_s : Stored int).
  case y_s of stored @int (y : int).
  case x_s of stored @int (x : int).

  -- Check Y part of range
  if case ymin of {
       iInt @Mlo (fymin : FIInt Mlo).
         case fymin of fiInt @Mlo (ymin_i : int).
         case height of {
           iInt @M (fheight : FIInt M).
             -- Compare against lower and upper bounds
             case fheight of fiInt @M (height_i : int).

             let maxy_plus_one : int = AdditiveDict_int_add ymin_i height_i in
             and (OrdDict_int_ge y ymin_i) (OrdDict_int_lt y maxy_plus_one);

           iPosInfty @M (pf : Pf (eqZ M pos_infty)).
             -- Compare against lower bound only
             OrdDict_int_ge y ymin_i;

           iNegInfty @M (pf : Pf (eqZ M pos_infty)).
             except @bool
         };

       iPosInfty @Mlo (pf : Pf (eqZ Mlo pos_infty)). False;
       iNegInfty @Mlo (pf : Pf (eqZ Mlo neg_infty)). except @bool
     }
   then -- Check X part of range
        case xmin of {
        iInt @Nlo (fxmin : FIInt Nlo).
          case fxmin of fiInt @Nlo (xmin_i : int).
          case width of {
            iInt @N (fwidth : FIInt N).
              -- Compare against lower and upper bounds
              case fwidth of fiInt @N (width_i : int).

              let maxx_plus_one : int = AdditiveDict_int_add xmin_i width_i in
              and (OrdDict_int_ge x xmin_i) (OrdDict_int_lt x maxx_plus_one);

            iPosInfty @N (pf : Pf (eqZ N pos_infty)).
              -- Compare against lower bound only
              OrdDict_int_ge x xmin_i;

            iNegInfty @N (pf : Pf (eqZ N neg_infty)).
	      except @bool
          };

	  iPosInfty @Nlo (pf : Pf (eqZ Nlo pos_infty)). False;
	  iNegInfty @Nlo (pf : Pf (eqZ Nlo neg_infty)). except @bool
      }

   else False;


ShapeDict_matrix_coerceSlice
  (shape_value : dim2)
  (slice_value : slice dim2)
  (ret : OutPtr (Maybe (slice dim2)))
  -> IEffect (Maybe (slice dim2)) =

  case shape_value of
    mk_dim2 @(Mlo : intindex) @(M : intindex) @(Nlo : intindex) @(N : intindex)
    (ymin : IInt Mlo)
    (height : IInt M)
    (xmin : IInt Nlo)
    (width : IInt N).

  case slice_value of pyonTuple2
       		      @(PyonTuple3 (Stored int) (Stored int) (Stored int))
       		      @(PyonTuple3 (Stored int) (Stored int) (Stored int))
		      (y_slice : PyonTuple3 (Stored int) (Stored int) (Stored int))
		      (x_slice : PyonTuple3 (Stored int) (Stored int) (Stored int)).

  letfun
    -- Coercion in one dimension  
    coerce_slice
      @(Klo K : intindex)
      (kmin : IInt Klo)
      (extent : IInt K)
      (slice_1d : PyonTuple3 (Stored int) (Stored int) (Stored int))
      (continuation : int -> int -> int -> Writer (Maybe (slice dim2)))
      (ret : OutPtr (Maybe (slice dim2)))
      -> IEffect (Maybe (slice dim2)) =

      case slice_1d of
        pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
        (start_s : Stored int) (stop_s : Stored int) (stride_s : Stored int).
      case start_s of stored @int (start_i : int).
      case stop_s of stored @int (stop_i : int).
      case stride_s of stored @int (stride_i : int).

      case kmin of {
        iInt @Klo (kmin_f : FIInt Klo).
          case kmin_f of fiInt @Klo (kmin_i : int).

	  -- Start cannot be less than the minimum boundary
	  let real_start : int = max_int start_i kmin_i in

	  -- End cannot be greater than than minimum boundary + extent
	  let real_end : int =
	        case extent of {
		  iInt @K (extent_f : FIInt K).
		    case extent_f of fiInt @K (extent_i : int).
		      let limit : int = AdditiveDict_int_add kmin_i extent_i in
		      min_int stop_i limit;
		  iPosInfty @K (pf : Pf (eqZ K pos_infty)).
		    stop_i;
		  iNegInfty @K (pf : Pf (eqZ K neg_infty)).
		    except @int
                } in

	  -- Stride must be positive
          if OrdDict_int_le stride_i 0 then Nothing @(slice dim2) ret else

          -- Compute interval spanned by slice.  If negative, coerce to zero.
          let delta : int =
                let iv : int = AdditiveDict_int_sub real_end real_start
                in max_int iv 0 in

	  continuation real_start delta stride_i ret;

	iPosInfty @Klo (pf : Pf (eqZ Klo pos_infty)).
	  Nothing @(slice dim2) ret;

	iNegInfty @Klo (pf : Pf (eqZ Klo neg_infty)).
	  except @(IEffect (Maybe (slice dim2)))
      }
  in

  coerce_slice @Mlo @M ymin height y_slice
  (\ (y_start : int) (y_delta : int) (y_stride : int)
     (ret : OutPtr (Maybe (slice dim2)))
     -> IEffect (Maybe (slice dim2)).
    coerce_slice @Nlo @N xmin width x_slice
    (\ (x_start : int) (x_delta : int) (x_stride : int)
     (ret : OutPtr (Maybe (slice dim2)))
     -> IEffect (Maybe (slice dim2)).
     Just @(slice dim2)
       (pyonTuple2
        @(PyonTuple3 (Stored int) (Stored int) (Stored int))
	@(PyonTuple3 (Stored int) (Stored int) (Stored int))
	(pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
	 (stored @int y_start) (stored @int y_delta) (stored @int y_stride))
	(pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
	 (stored @int x_start) (stored @int x_delta) (stored @int x_stride)))
       ret)
    ret)
  ret;

{-
ShapeDict_Stream_flatten @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a : bare) -> Stream sh a -> Stream dim1 a =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_flatten;


ShapeDict_Stream_map @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b : bare) -> Repr a -> Repr b -> (a -> Writer b) -> Stream sh a -> Stream sh b =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_map;


ShapeDict_Stream_zipWith @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c : bare) -> Repr a -> Repr b -> Repr c ->
     (a -> b -> Writer c) ->
     Stream sh a -> Stream sh b -> Stream sh c =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith;


ShapeDict_Stream_zipWith3 @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c d : bare) -> Repr a -> Repr b -> Repr c -> Repr d ->
     (a -> b -> c -> Writer d) ->
     Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith3;


ShapeDict_Stream_zipWith4 @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c d e : bare) -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
     (a -> b -> c -> d -> Writer e) ->
     Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith4;
-}

-------------------------------------------------------------------------------
-- List shape methods

ShapeDict_list_flatten @(a : bare) (s : Stream dim1 a)
  -> Stream dim1 a =
  s;


ShapeDict_list_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : Stream dim1 a) -> Stream dim1 b =
  LinStream_map @dim1 @a @b repr_a repr_b f src;


ShapeDict_list_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : Stream dim1 a) (src_b : Stream dim1 b)
  -> Stream dim1 c =
  LinStream_zipWith @dim1 @a @b @c repr_a repr_b repr_c f src_a src_b;


ShapeDict_list_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : Stream dim1 a) (src_b : Stream dim1 b) (src_c : Stream dim1 c)
  -> Stream dim1 d =
  LinStream_zipWith3 @dim1 @a @b @c @d repr_a repr_b repr_c repr_d
  f src_a src_b src_c;


ShapeDict_list_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : Stream dim1 a) (src_b : Stream dim1 b) (src_c : Stream dim1 c) (src_d : Stream dim1 d)
  -> Stream dim1 e =
  LinStream_zipWith4 @dim1 @a @b @c @d @e repr_a repr_b repr_c repr_d repr_e
  f src_a src_b src_c src_d;


ShapeDict_list_inRange (shp : dim1) (ix : Stored int) -> bool =
  case shp of mk_dim1 @(Nlo N : intindex)
       	      (lo : IInt Nlo)
	      (len : IInt N).
  case ix of stored @int (ix_i : int).

  case lo of {
    iInt @Nlo (flo : FIInt Nlo).
      case flo of fiInt @Nlo (lo_i : int).
      case len of {
        iInt @N (flen : FIInt N).
	  -- Compare against lower and upper bounds
          case flen of fiInt @N (len_i : int).

          let maxindex_plus_one : int = AdditiveDict_int_add lo_i len_i in
	  and (OrdDict_int_ge ix_i lo_i) (OrdDict_int_lt ix_i maxindex_plus_one);

        iPosInfty @N (pf : Pf (eqZ N pos_infty)).
	  -- Compare against lower bound only
	  OrdDict_int_ge ix_i lo_i;

        iNegInfty @N (pf : Pf (eqZ N neg_infty)).
	  except @bool
      };

    iPosInfty @Nlo (pf : Pf (eqZ Nlo pos_infty)). False;
    iNegInfty @Nlo (pf : Pf (eqZ Nlo neg_infty)). except @bool
  };


ShapeDict_list_coerceSlice
  (shape_value : dim1)
  (slice_value : slice dim1)
  (ret : OutPtr (Maybe (slice dim1)))
  -> IEffect (Maybe (slice dim1)) =

  case shape_value of
    mk_dim1 @(Nlo N : intindex) (lo : IInt Nlo) (len : IInt N).
  case slice_value of
    pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
               (start_s : Stored int) (stop_s : Stored int) (stride_s : Stored int).
  case start_s of stored @int (start_i : int).
  case stop_s of stored @int (stop_i : int).
  case stride_s of stored @int (stride_i : int).

  case lo of {
    iInt @Nlo (flo : FIInt Nlo).
      case flo of fiInt @Nlo (lo_i : int).

      -- Start cannot be less than the minimum boundary
      let real_start : int = max_int start_i lo_i in

      -- End cannot be greater than than minimum boundary + extent
      let real_end : int =
            case len of {
	      iInt @N (flen : FIInt N).
	        case flen of fiInt @N (len_i : int).
                let limit : int = AdditiveDict_int_add lo_i len_i in
		min_int stop_i limit;
	      iPosInfty @N (pf : Pf (eqZ N pos_infty)).
	        stop_i;
	      iNegInfty @N (pf : Pf (eqZ N neg_infty)).
	        except @int
              } in

      -- Stride must be positive
      if OrdDict_int_le stride_i 0 then Nothing @(slice dim1) ret else

      -- Compute interval spanned by slice.  If negative, coerce to zero.
      let delta : int =
            let iv : int = AdditiveDict_int_sub real_end real_start
            in max_int iv 0 in

      Just @(slice dim1)
        (pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
	 (stored @int real_start)
	 (stored @int delta)
	 (stored @int stride_i))
        ret;

    iPosInfty @Nlo (pf : Pf (eqZ Nlo pos_infty)).
      Nothing @(slice dim1) ret;

    iNegInfty @Nlo (pf : Pf (eqZ Nlo pos_infty)).
      except @(IEffect (Maybe (slice dim1)))
  };


-------------------------------------------------------------------------------
-- Linear stream methods

LinStream_flatten @(sh a : bare) (s : LinStream sh a)
  -> LinStream dim1 a
  attribute(inline_final) =
  case s of linStream @sh @a @(st : box)
                       (state : st) (next : st -> StreamNext st (BoxedType a)).
  linStream @dim1 @a @st state next;


LinStream_map @(sh a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : LinStream sh a) -> LinStream sh b
  attribute(inline_final) =
  case src
  of linStream @sh @a @(src_st : box)
     (st : src_st) (next : src_st -> StreamNext src_st (BoxedType a)).

  letfun
    go (state : src_st) -> StreamNext src_st (BoxedType b) =
      case next state of {

        streamValue @src_st @(BoxedType a)
          (next_state : src_st) (value : BoxedType a).
          let output_value : BoxedType b =
                case boxed @a (convertToBare @a repr_a value) of boxed @a (x : a).
		convertToBoxed @b repr_b (f x)
          in streamValue @src_st @(BoxedType b) next_state output_value;

        streamEmpty @src_st @(BoxedType a).
          streamEmpty @src_st @(BoxedType b)
      }
  in linStream @sh @b @src_st st go;


LinStream_zipWith @(sh a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : LinStream sh a) (src_b : LinStream sh b)
  -> LinStream sh c
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b)))
      -> StreamNext (Boxed (Stored (st_a, st_b))) (BoxedType c) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b)) (u_state : Stored (st_a, st_b)).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

	      -- Create output value
	      let value : BoxedType c =
	            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
		    convertToBoxed @c repr_c (f x y) in
	      let next_state : Boxed (Stored (st_a, st_b)) =
	            boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed (Stored (st_a, st_b))) @(BoxedType c) next_state value;

	    streamEmpty @st_b @(BoxedType b).
	      streamEmpty @(Boxed (Stored (st_a, st_b))) @(BoxedType c)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b))) @(BoxedType c)
      }
  in linStream @sh @c @(Boxed (Stored (st_a, st_b)))
       (boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (state_a, state_b)))
       go;


LinStream_zipWith3 @(sh a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : LinStream sh a) (src_b : LinStream sh b) (src_c : LinStream sh c)
  -> LinStream sh d
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of linStream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c))) (BoxedType d) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c)) (u_state : Stored (st_a, st_b, st_c)).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Create output value
                  let value : BoxedType d =
                        case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                        convertToBoxed @d repr_d (f x y z) in
                  let next_state : Boxed (Stored (st_a, st_b, st_c)) =
                        boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d) next_state value;

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
      }
  in linStream @sh @d @(Boxed (Stored (st_a, st_b, st_c)))
       (boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;


LinStream_zipWith4 @(sh a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : LinStream sh a) (src_b : LinStream sh b) (src_c : LinStream sh c) (src_d : LinStream sh d)
  -> LinStream sh e
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of linStream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  case src_d
  of linStream @sh @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d (BoxedType d)).

  let type mystate = (st_a, st_b, st_c, st_d) in
  let type mystate_s = Stored mystate in
  let type mystate_bs = Boxed mystate_s in

  letfun
    go (state : mystate_bs)
      -> StreamNext mystate_bs (BoxedType e) =
      -- Unpack the state
      case state of boxed @mystate_s (u_state : mystate_s).
      case u_state of stored @mystate (i_state : mystate).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @(BoxedType d)
                      (next_state_d : st_d) (value_d : BoxedType d).

                      -- Create output value
                      let value : BoxedType e =
                            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (convertToBare @d repr_d value_d) of boxed @d (w : d).
                            convertToBoxed @e repr_e (f x y z w) in
                      let next_state : mystate_bs =
                            boxed @mystate_s (stored @mystate (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @mystate_bs @(BoxedType e) next_state value;

                    streamEmpty @st_d @(BoxedType d).
                      streamEmpty @mystate_bs @(BoxedType e)
                  };

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @mystate_bs @(BoxedType e)
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @mystate_bs @(BoxedType e)
          };

	streamEmpty @st_a @(BoxedType a).
          streamEmpty @mystate_bs @(BoxedType e)
      }
  in linStream @sh @e @mystate_bs
       (boxed @mystate_s (stored @mystate (state_a, state_b, state_c, state_d)))
       go;

-------------------------------------------------------------------------------
-- Other rewritable functions

LinStream_reduce @(sh a : bare) (repr_a : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (s : LinStream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  LinStream_fold @sh @a @a repr_a repr_a f init s ret;


LinStream_reduce1 @(sh a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : LinStream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  -- Use the stream's first element as the initial value
  case s of linStream @sh @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case stream_next stream_state of {
    streamValue @st @(BoxedType a) (next_state : st) (init : BoxedType a).
      case boxed @a (convertToBare @a repr init) of boxed @a (u_init : a).
      let new_stream : Stream dim1 a =
            linStream @dim1 @a @st next_state stream_next in
      LinStream_fold @dim1 @a @a repr repr f u_init new_stream ret;

    streamEmpty @st @(BoxedType a).
      except @(IEffect a)

-}


