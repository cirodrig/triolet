
{-



{-
-- List construction.
-- If the stream has a known size, allocate and initialize an array.
TraversableDict_list_build @(a : bare)
  (repr : Repr a) (s : Stream list_shape a) (o : OutPtr (list a))
  -> IEffect (list a) =
-}

oper_DO @(a : bare) (repr : Repr a) (f : Writer a) -> Stream list_shape a
  attribute(inline_final) =

  -- Singleton stream.
  -- State is a boolean, which is false if the stream is depleted,
  -- true otherwise.
  letfun
    get_value (state : Boxed (Stored bool))
      -> StreamNext (Boxed (Stored bool)) (BoxedType a) =
      case state of boxed @(Stored bool) (u_state : Stored bool).
      case u_state of stored @bool (i_state : bool).
      if i_state
      then let next_state : Boxed (Stored bool) =
                 boxed @(Stored bool) (stored @bool False) in
           let retval : BoxedType a = convertToBoxed @a repr f in
           streamValue @(Boxed (Stored bool)) @(BoxedType a) next_state retval
      else streamEmpty @(Boxed (Stored bool)) @(BoxedType a)
  in
    let initial_state : Boxed (Stored bool) =
          boxed @(Stored bool) (stored @bool True) in
    linStream @list_shape @a @(Boxed (Stored bool)) initial_state get_value;

oper_CAT_MAP @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (src : Stream list_shape a)
  (trans : a -> Stream list_shape b)
  -> Stream list_shape b
  attribute(inline_final) =
  case src of linStream @list_shape @a @(src_st : box)
                (src_state : src_st)
		(src_next : src_st -> StreamNext src_st (BoxedType a)).
  letfun {
    -- Dispatch based on the current stream state
    next (state : BindState src_st a b)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state;

	bindFromTrans @src_st @a @b @(trans_st : box)
	  (src_state : src_st)
	  (trans_state : trans_st)
	  (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).
	  next_from_trans @trans_st src_state trans_state trans_next
      };

    -- Pull a value from the source stream
    next_from_source
      (src_state : src_st)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case src_next src_state of {
        streamValue @src_st @(BoxedType a)
	  (next_src_state : src_st) (src_value : BoxedType a).

	  -- Apply the transformer to this value
	  case boxed @a (convertToBare @a repr_a src_value)
	  of boxed @a (src_uvalue : a).

	  case trans src_uvalue of linStream @list_shape @b @(trans_st : box)
	                             (trans_state : trans_st)
				     (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).

          -- Pull a value from the transformed stream
          next_from_trans @trans_st next_src_state trans_state trans_next;

	streamEmpty @src_st @(BoxedType a).
	  -- Stream is depleted
	  streamEmpty @(BindState src_st a b) @(BoxedType b)
      };

    -- Pull a value from the transformed stream
    next_from_trans
      @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st (BoxedType b))
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case trans_next trans_state of {
        streamValue @trans_st @(BoxedType b)
	  (next_trans_state : trans_st) (trans_value : BoxedType b).

	  streamValue @(BindState src_st a b) @(BoxedType b)
	    (bindFromTrans @src_st @a @b @trans_st
	     src_state next_trans_state trans_next)
	    trans_value;

	streamEmpty @trans_st @(BoxedType b).
	  -- Pull a new value from the source stream
	  next_from_source src_state
      }
  } in linStream @list_shape @b @(BindState src_st a b)
         (bindFromSource @src_st @a @b src_state)
	 next;


-- 'bind' is a renamed version of 'oper_CAT_MAP'.
bind @(N : intindex) @(sh a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (src : Stream (array_shape N unit_shape) a)
  (trans : a -> Stream sh b)
  -> Stream (array_shape N sh) b 
  attribute(inline_final) =
  case oper_CAT_MAP @a @b repr_a repr_b
       (fun_asList_Stream @(array_shape N unit_shape) @a src)
       (\ (x : a) -> Stream list_shape b. fun_asList_Stream @sh @b (trans x))
  of linStream @list_shape @b @(st : box) (state : st) (next : st -> StreamNext st (BoxedType b)).
  linStream @(array_shape N sh) @b @st state next;



-} -- END

-------------------------------------------------------------------------------
-- Array functions

array_traverse @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FinIndInt N) (ay : array N a)
  -> Stream (array_shape N unit_shape) a =
  generate @N @a (indInt @N size) repr
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr (subscript @N @a repr ay i) ret);

array_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FinIndInt N)
  (s : Stream (array_shape N unit_shape) a)
  (ret : OutPtr (array N a))
  -> IEffect (array N a)
  attribute(inline_final) =

  case s of linStream @(array_shape N unit_shape) @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case size of finIndInt @N (pf : Pf (neZ N pos_infty)) (bound : int).

  letfun
    go (i : int) (state : st) -> EffTok =
      if EqDict_int_eq i bound
      then emptyEffTok
      else case stream_next state of {

             -- Obtain value from stream
             streamValue @st @(BoxedType a)
	       (next_state : st) (result : BoxedType a).
               -- Write into the array
	       seqEffTok (toEffTok @a (convertToBare @a repr result
	       		               (subscript_out @N @a repr ret i)))
                         (go (AdditiveDict_int_add i 1) next_state);

             streamEmpty @st @(BoxedType a).
	       except @EffTok
	   }
  in fromEffTok @(array N a) (go 0 stream_state);

-------------------------------------------------------------------------------
-- List functions

histogram @(t : bare -> bare)
  (size : int)
  (input : Stream (shape t) (Stored int))
  (ret : OutPtr (list (Stored int)))
  -> IEffect (list (Stored int)) =
  case defineIntIndex size of someIndInt @(N : intindex) (index : FinIndInt N).
  make_list @(Stored int) @N index
  (referenced @(array N (Stored int))
   (histogramArray @(shape t) @N index input))
  ret;

-------------------------------------------------------------------------------
-- Matrix functions

rows @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (repr : Repr a)
  (container : t a)
  -> Writer (ListView (ListView a)) =
  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).

  with_shape @a @(ListView (ListView a)) container
  (matrixShapeEliminator @(ListView (ListView a))
   (\ @(M N : intindex) (height : FinIndInt M) (width : FinIndInt N)
      -> Writer (ListView (ListView a)).

      listView @(ListView a) @M height
      (\ (y : int) -> Writer (ListView a).
        listView @a @N width
        (\ (x : int) (ret : OutPtr a) -> IEffect a.
          at_point @a repr container y x ret))));

cols @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (repr : Repr a)
  (container : t a)
  -> Writer (ListView (ListView a)) =
  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).

  with_shape @a @(ListView (ListView a)) container
  (matrixShapeEliminator @(ListView (ListView a))
   (\ @(M N : intindex) (height : FinIndInt M) (width : FinIndInt N)
      -> Writer (ListView (ListView a)).

      listView @(ListView a) @N width
      (\ (x : int) -> Writer (ListView a).
        listView @a @M height
        (\ (y : int) (ret : OutPtr a) -> IEffect a.
          at_point @a repr container y x ret))));

outerproduct @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (sa : Stream list_shape a)
  (sb : Stream list_shape b)
  -> Stream matrix_shape c
  attribute (inline_final) =

  -- Convert arguments to lists
  case boxed @(list a) (TraversableDict_list_build @a repr_a sa) of
    boxed @(list a) (la : list a).
  case la of make_list @a @(M : intindex)
       	     (size_y : FinIndInt M) (ayref_a : Referenced (array M a)).
  case ayref_a of referenced @(array M a) (ay_a : array M a).

  case boxed @(list b) (TraversableDict_list_build @b repr_b sb) of
    boxed @(list b) (lb : list b).
  case lb of make_list @b @(N : intindex)
       	     (size_x : FinIndInt N) (ayref_b : Referenced (array N b)).
  case ayref_b of referenced @(array N b) (ay_b : array N b).

  -- Create a matrix stream
  matrixStream @c @M @N (indInt @M size_y) (indInt @N size_x)
  (bind @M @(array_shape N unit_shape) @a @c repr_a repr_c
  (array_traverse @M @a repr_a size_y ay_a)
  (\ (x : a) -> Stream (array_shape N unit_shape) c.
    generate @N @c (indInt @N size_x) repr_c
    (\ (index : int) -> Writer c.
       let y : b = subscript @N @b repr_b ay_b index in
       f x y)));

{-
transpose @(a : bare)
  (repr : Repr a) (mat : matrix a) (ret : OutPtr (MatrixView a))
  -> IEffect (MatrixView a) =
  case mat of make_matrix @a @(M : intindex) @(N : intindex)
       	      (height : FinIndInt M) (width : FinIndInt N)
      	      (aref : Referenced (array M (array N a))).
  case aref of referenced @(array M (array N a)) (ay : array M (array N a)).
  let row_repr : Repr (array N a) = repr_array @N @a width repr in

  matrixView @a @N @M width height
  (\ (y : int) (x : int) -> Writer a.
    copy @a repr (subscript @N @a repr (subscript @M @(array N a) row_repr ay x) y))
  ret;-}

stencil2D @(t : bare -> bare) @(a b : bare)
  (indexable : Indexable2Dict t) (repr_a : Repr a) (repr_b : Repr b)
  (ymin : int) (ymax : int) (xmin : int) (xmax : int)
  (stencilfn : MatrixView a -> Writer b)
  (inp : t a)
  -> Writer (matrix b) =

  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).

  with_shape @a @(matrix b) inp
  (matrixShapeEliminator @(matrix b)
   (\ @(M : intindex) @(N : intindex)
       (inp_height : FinIndInt M) (inp_width : FinIndInt N)
       -> Writer (matrix b).
      case inp_height of
        finIndInt @M (pf : Pf (neZ M pos_infty)) (inp_height_i : int).
      case inp_width of
        finIndInt @N (pf : Pf (neZ N pos_infty)) (inp_width_i : int).

      letfun
        safe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
	  -> Writer a =
          -- Read one element from the input for a stencil at point (pty, ptx).
          -- The coordinate to read is (pty + yoff, ptx + xoff).
          -- The image is padded at the edges.
          let yindex : int = AdditiveDict_int_add pty yoff in
	  let xindex : int = AdditiveDict_int_add ptx xoff in
	  let bounded_yindex : int =
	        if OrdDict_int_lt yindex 0
		then 0 else if OrdDict_int_ge yindex inp_height_i
		       	    then AdditiveDict_int_sub inp_height_i 1
			    else yindex in
	  let bounded_xindex : int =
	        if OrdDict_int_lt xindex 0
		then 0 else if OrdDict_int_ge xindex inp_width_i
		       	    then AdditiveDict_int_sub inp_width_i 1
			    else xindex in
	  at_point @a repr_a inp bounded_yindex bounded_xindex
       in

       make_matrix @b @M @N inp_height inp_width
       (referenced @(array M (array N b))
        (\ (array_ret : OutPtr (array M (array N b)))
	   -> IEffect (array M (array N b)).
           (doall @M @(array M (array N b)) @(array N b) inp_height
            (\ (y : int) -> IEffect (array N b).
               doall @N @(array N b) @b inp_width
               (\ (x : int) -> IEffect b.
                  -- TODO: Allow matrix views to have arbitrary lower bounds
                  except @(IEffect b))))))));


-------------------------------------------------------------------------------
-- List container class functions

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : bare) (repr : Repr a) (ls : list a)
  -> Stream list_shape a =
  case ls of make_list @a @(N : intindex)
                       (size : FinIndInt N) (aref : Referenced (array N a)).
  case aref of referenced @(array N a) (ay : array N a).
  LinStream_flatten @(array_shape N unit_shape) @a
  (array_traverse @N @a repr size ay);


IndexableDict_list_at_point @(a : bare)
  (repr : Repr a) (ls : list a) (ix : int) (ret : OutPtr a) -> IEffect a =

  -- Deconstruct data structures
  case ls of make_list @a @(N : intindex)
             (size : FinIndInt N) (ayref : Referenced (array N a)).
  case ayref of referenced @(array N a) (ay : array N a).
  case size of finIndInt @N (pf : Pf (neZ N pos_infty)) (size_int : int).

  copy @a repr (subscript @N @a repr ay ix) ret;


IndexableDict_list_at_slice @(a : bare)
  (repr : Repr a) (ls : list a)
  (start : int) (delta : int) (stride : int)
  (ret : OutPtr (ListView a)) -> IEffect (ListView a) =

  case ls of make_list @a @(N : intindex)
       	     (list_size : FinIndInt N) (ayref : Referenced (array N a)).
  case list_size of finIndInt @N (pf : Pf (neZ N pos_infty)) (list_size_i : int).
  case ayref of referenced @(array N a) (ay : array N a).

  let count : int =
        -- Ceiling division
	let interval_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta stride) 1 in
	RemainderDict_int_floordiv interval_rounded stride in
  case defineIntIndex count of someIndInt @(L : intindex) (count_i : FinIndInt L).
  listView @a @L count_i
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     let index : int =
           AdditiveDict_int_add start (MultiplicativeDict_int_mul i stride) in
     copy @a repr (subscript @N @a repr ay index) ret)
  ret;


IndexableDict_list_with_shape @(a b : bare)
  (ls : list a) (elim : ListShapeEliminator b) -> Writer b =

  case ls of make_list @a @(N : intindex)
    (size : FinIndInt N) (aref : Referenced (array N a)).
  case elim of listShapeEliminator @b
       	       (f : (index : intindex) -> FinIndInt index -> Writer b).
  f @N size;


-------------------------------------------------------------------------------
-- ListView container class functions

TraversableDict_ListView_traverse @(a : bare)
  (repr : Repr a) (ls : ListView a) -> Stream list_shape a =
  case ls of listView @a @(N : intindex)
       	     (size : FinIndInt N) (f : int -> Writer a).
  LinStream_flatten @(array_shape N unit_shape) @a
  (generate @N @a (indInt @N size) repr f);


TraversableDict_ListView_build @(a : bare)
  (repr : Repr a) (s : Stream list_shape a) (ret : OutPtr (ListView a))
  -> IEffect (ListView a) =

  -- Build a list, then create a list view from it
  case boxed @(list a) (TraversableDict_list_build @a repr s) of boxed @(list a) (ls : list a).
  case ls of make_list @a @(N : intindex) (list_size : FinIndInt N) (ayref : Referenced (array N a)).
  case ayref of referenced @(array N a) (ay : array N a).

  listView @a @N list_size
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
    copy @a repr (subscript @N @a repr ay i) ret)
  ret;


IndexableDict_ListView_at_point @(a : bare)
  (repr : Repr a) (ls : ListView a) (ix : int) (ret : OutPtr a) -> IEffect a =

  case ls of listView @a @(N : intindex)
             (size : FinIndInt N) (generator : int -> Writer a).
  case size of finIndInt @N (pf : Pf (neZ N pos_infty)) (size_int : int).

  if or (OrdDict_int_lt ix 0) (OrdDict_int_ge ix size_int)
  then except @(IEffect a)
  else generator ix ret;


IndexableDict_ListView_at_slice @(a : bare)
  (repr : Repr a) (ls : ListView a)
  (start : int) (delta : int) (stride : int)
  (ret : OutPtr (ListView a)) -> IEffect (ListView a) =

  case ls of listView @a @(N : intindex)
       	     (list_size : FinIndInt N) (generator : int -> Writer a).
  case list_size of finIndInt @N (pf : Pf (neZ N pos_infty)) (list_size_i : int).
  
  let count : int =
        -- Ceiling division
	let interval_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta stride) 1 in
	RemainderDict_int_floordiv interval_rounded stride in
  case defineIntIndex count of someIndInt @(L : intindex) (count_i : FinIndInt L).
  listView @a @L count_i
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     let index : int =
           AdditiveDict_int_add start (MultiplicativeDict_int_mul i stride) in
     generator index ret)
  ret;

-------------------------------------------------------------------------------
-- Stream Traversable functions

TraversableDict_Stream_build @(t : bare -> bare) @(a : bare)
  (repr : Repr a) (s : Stream (shape t) a)
  -> Stream (shape t) a = s;

TraversableDict_Stream_traverse @(t : bare -> bare) @(a : bare)
  (repr : Repr a) (s : Stream (shape t) a)
  -> Stream (shape t) a = s;


-------------------------------------------------------------------------------
-- List-specific stream functions

fun_asList_Stream @(sh a : bare)
  (shape_dict : ShapeDict sh) (src : Stream sh a) -> Stream list_shape a =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_flatten @a src;


range (n : int) -> Stream list_shape (Stored int) =
  case defineIntIndex n of someIndInt @(ix : intindex) (val : FinIndInt ix).
    LinStream_flatten @(array_shape ix unit_shape) @(Stored int)
    (rangeIndexed @ix (indInt @ix val));


rangeIndexed @(N : intindex) (count : IndInt N)
  -> Stream (array_shape N unit_shape) (Stored int) =
  generate @N @(Stored int) count repr_int
  (\ (i : int) -> Writer (Stored int). stored @int i);


oper_GUARD @(a : bare) (repr : Repr a) (arg : bool) (s : Stream list_shape a)
  -> Stream list_shape a =
  if arg then s else oper_EMPTY @a repr;


oper_EMPTY @(a : bare) (repr : Repr a) -> Stream list_shape a
  attribute(inline_final) =
  linStream @list_shape @a @(Boxed (Stored NoneType))
  (boxed @(Stored NoneType) (stored @NoneType None))
  (\ (state : Boxed (Stored NoneType)) -> StreamNext (Boxed (Stored NoneType)) (BoxedType a).
    streamEmpty @(Boxed (Stored NoneType)) @(BoxedType a));


generate @(N : intindex) @(a : bare)
         (count : IndInt N) (repr : Repr a) (f : int -> Writer a)
 -> Stream (array_shape N unit_shape) a
  attribute(inline_final) =

  case count of {
    indInt @N (fin : FinIndInt N).
      -- Finite case
      case fin of finIndInt @N (pf : Pf (neZ N pos_infty)) (bound : int).
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

	  -- End of loop?
          if EqDict_int_eq i bound
          then streamEmpty @(Boxed (Stored int)) @(BoxedType a)
	  else let retval : BoxedType a =
                    convertToBoxed @a repr (f i) in

               -- Apply the generator function
               streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in linStream @(array_shape N unit_shape) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next;

    indOmega @N (pf : Pf (eqZ N pos_infty)).
      -- Infinite case
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

          let retval : BoxedType a =
                convertToBoxed @a repr (f i) in

          -- Apply the generator function
          streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in linStream @(array_shape N unit_shape) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next
  };

-------------------------------------------------------------------------------
-- Matrix-specific stream methods

fun_from_MatrixView_Stream @(a : bare)
  (s : Stream matrix_shape a) -> Stream matrix_shape a = s;

fun_asMatrix_Stream @(M N : intindex) @(a : bare)
  (size_y : IndInt M)
  (size_x : IndInt N)
  (src : Stream (array_shape M (array_shape N unit_shape)) a)
  -> Stream matrix_shape a =
  matrixStream @a @M @N size_y size_x src;


chunk_id @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size : IndInt N)
  (s : Stream (array_shape M (array_shape N unit_shape)) a)
  -> Stream (array_shape M unit_shape) (StoredBox (Stream (array_shape N unit_shape) a)) =

  chunk @M @N @a @(StoredBox (Stream (array_shape N unit_shape) a))
  repr
  (repr_Box @(Stream (array_shape N unit_shape) a))
  size
  s
  (\ (x : (Stream (array_shape N unit_shape) a))
     -> Writer (StoredBox (Stream (array_shape N unit_shape) a)).
     storedBox @(Stream (array_shape N unit_shape) a) x);

-------------------------------------------------------------------------------
-- Matrix container class functions

TraversableDict_matrix_traverse @(a : bare)
  (repr : Repr a) (m : matrix a) -> Stream matrix_shape a =
  case m of make_matrix @a @(M : intindex) @(N : intindex)
            (size_y : FinIndInt M) (size_x : FinIndInt N)
	    (ayref : Referenced (array M (array N a))).
  case ayref of referenced @(array M (array N a)) (ay : array M (array N a)).

  matrixStream @a @M @N (indInt @M size_y) (indInt @N size_x)
  (bind @M @(array_shape N unit_shape) @(array N a) @a
   (repr_array @N @a size_x repr)
   repr
   (array_traverse @M @(array N a) (repr_array @N @a size_x repr) size_y ay)
   (array_traverse @N @a repr size_x));


TraversableDict_matrix_build @(a : bare)
  (repr : Repr a) (s : Stream matrix_shape a) (ret : OutPtr (matrix a))
  -> IEffect (matrix a) =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	    (size_y : IndInt M) (size_x : IndInt N)
	    (ls : LinStream (array_shape M (array_shape N unit_shape)) a).

  case size_y of {
    indInt @M (fsize_y : FinIndInt M).
      case size_x of {
        indInt @N (fsize_x : FinIndInt N).
          make_matrix @a @M @N fsize_y fsize_x
          (referenced @(array M (array N a))
           (array_build @M @(array N a) (repr_array @N @a fsize_x repr) fsize_y
            (chunk @M @N @a @(array N a) repr (repr_array @N @a fsize_x repr)
	     size_x ls
             (array_build @N @a repr fsize_x)))) ret;

        indOmega @N (pf : Pf (eqZ N pos_infty)).
	  except @(IEffect (matrix a))
      };

    indOmega @M (pf : Pf (eqZ M pos_infty)).
      except @(IEffect (matrix a))
  };


Indexable2Dict_matrix_at_point2 @(a : bare)
  (repr : Repr a)
  (mat : matrix a)
  (y : int)
  (x : int)
  (ret : OutPtr a)
  -> IEffect a =
  case mat of make_matrix @a @(M : intindex) @(N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (ayptr : Referenced (array M (array N a))).
  case ayptr of referenced @(array M (array N a)) (ay : array M (array N a)).
  let array_repr : Repr (array N a) = repr_array @N @a size_x repr in
  let value : a =
        subscript @N @a repr (subscript @M @(array N a) array_repr ay y) x in
  copy @a repr value ret;


Indexable2Dict_matrix_at_slice2 @(a : bare)
  (repr : Repr a)
  (mat : matrix a)
  (start_y : int) (delta_y : int) (stride_y : int)
  (start_x : int) (delta_x : int) (stride_x : int)
  (ret : OutPtr (MatrixView a))
  -> IEffect (MatrixView a) =

  case mat of make_matrix @a @(M : intindex) @(N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (ayptr : Referenced (array M (array N a))).
  case ayptr of referenced @(array M (array N a)) (ay : array M (array N a)).

  let count_y : int =
        -- Ceiling division
	let interval_y_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta_y stride_y) 1 in
	RemainderDict_int_floordiv interval_y_rounded stride_y in
  case defineIntIndex count_y of someIndInt @(K : intindex) (count_y_i : FinIndInt K).

  let count_x : int =
        -- Ceiling division
	let interval_x_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta_x stride_x) 1 in
	RemainderDict_int_floordiv interval_x_rounded stride_x in
  case defineIntIndex count_x of someIndInt @(L : intindex) (count_x_i : FinIndInt L).

  matrixView @a @K @L count_y_i count_x_i
  (\ (j : int) (i : int) (ret : OutPtr a) -> IEffect a.
     let y : int =
           AdditiveDict_int_add start_y (MultiplicativeDict_int_mul j stride_y) in
     let x : int =
           AdditiveDict_int_add start_x (MultiplicativeDict_int_mul i stride_x) in
     let array_repr : Repr (array N a) = repr_array @N @a size_x repr in
     let value : a =
           subscript @N @a repr (subscript @M @(array N a) array_repr ay y) x in
     copy @a repr value ret) ret;


Indexable2Dict_matrix_with_shape2 @(a b : bare)
  (mat : matrix a)
  (eliminator : MatrixShapeEliminator b)
  -> Writer b =
  case mat of make_matrix @a @(M : intindex) @(N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (ayptr : Referenced (array M (array N a))).
  case eliminator of
    matrixShapeEliminator @b
    (f : (K L : intindex) -> FinIndInt K -> FinIndInt L -> Writer b).

  f @M @N size_y size_x;

-------------------------------------------------------------------------------
-- MatrixView container class functions

TraversableDict_MatrixView_traverse @(a : bare)
  (repr : Repr a) (mat : MatrixView a) -> Stream matrix_shape a =

  case mat of matrixView @a @(M : intindex) @(N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (f : int -> int -> Writer a).
  matrixStream @a @M @N (indInt @M size_y) (indInt @N size_x)
  (bind @M @(array_shape N unit_shape) @(Stored int) @a repr_int repr
   (generate @M @(Stored int) (indInt @M size_y) repr_int (stored @int))
   (\ (y_stored : Stored int) -> Stream (array_shape N unit_shape) a.
      case y_stored of stored @int (y : int).
      generate @N @a (indInt @N size_x) repr
      (\ (x : int) -> Writer a. f y x)));

-------------------------------------------------------------------------------
-- Generic container methods

len @(t : bare -> bare) @(a : bare) (indexable : IndexableDict t)
  (x : t a) -> int =
  case indexable of indexableDict @t
       		    (at_point : (a : bare) -> Repr a -> t a -> int -> Writer a)
       		    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> Writer (ListView a))
       		    (with_shape : (a b : bare) -> t a -> ListShapeEliminator b -> Writer b).

  letfun
    get_len @(N : intindex) (fii : FinIndInt N) -> Writer (Stored int) =
    case fii of finIndInt @N (pf : Pf (neZ N pos_infty)) (x : int).
    stored @int x
  in

  case boxed @(Stored int)
       (with_shape @a @(Stored int) x
        (listShapeEliminator @(Stored int) get_len))
  of boxed @(Stored int) (si : Stored int).
  case si of stored @int (n : int).
  n;


safeIndex @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t) (repr : Repr a)
  (container : t a) (ix : int) -> Writer a =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> Writer (ListView a))
    (with_shape : (a b : bare) -> t a -> ListShapeEliminator b -> Writer b).
  letfun
    get_member @(N : intindex) (fii : FinIndInt N) (ret : OutPtr a) -> IEffect a =
      case fii of finIndInt @N (pf : Pf (neZ N pos_infty)) (size_int : int).

      -- Bounds checking
      if or (OrdDict_int_lt ix 0) (OrdDict_int_ge ix size_int)
      then except @(IEffect a)
      else at_point @a repr container ix ret

  in with_shape @a @a container (listShapeEliminator @a get_member);


safeSlice @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t) (repr : Repr a)
  (container : t a)
  (start : int) (stop : int) (stride : int) -> Writer (ListView a) =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> Writer (ListView a))
    (with_shape : (a b : bare) -> t a -> ListShapeEliminator b -> Writer b).
  letfun
    get_slice @(N : intindex)
      (fii : FinIndInt N) (ret : OutPtr (ListView a))
      -> IEffect (ListView a) =

      case fii of finIndInt @N (pf : Pf (neZ N pos_infty)) (size_i : int).

      -- If slice is out of bounds, coerce to bounds
      let real_start : int =
            if OrdDict_int_lt start 0 then 0 else start in
      let real_end : int =
            if OrdDict_int_gt stop size_i then size_i else stop in

      -- Stride must be positive
      if OrdDict_int_le stride 0 then except @(IEffect (ListView a)) else

      -- Compute interval spanned by slice.  If negative, coerce to zero.
      let delta : int =
            let iv : int = AdditiveDict_int_sub real_end real_start
            in if OrdDict_int_lt iv 0 then 0 else iv in

      -- Get the slice
      at_slice @a repr container real_start delta stride ret

  in with_shape @a @(ListView a) container
     (listShapeEliminator @(ListView a) get_slice);


width @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (container : t a) -> int =

  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).

  letfun
    get_width @(M N : intindex)
      (height_fii : FinIndInt M) (width_fii : FinIndInt N)
      (ret : OutPtr (Stored int)) -> IEffect (Stored int) =
      case width_fii of finIndInt @N (pf : Pf (neZ N pos_infty)) (w : int).
      stored @int w ret
  in

  case boxed @(Stored int) (with_shape @a @(Stored int) container
       	     	      	    (matrixShapeEliminator @(Stored int) get_width))
  of boxed @(Stored int) (width_s : Stored int).
    case width_s of stored @int (n : int). n;


height @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (container : t a) -> int =

  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).

  letfun
    get_height @(M N : intindex)
      (height_fii : FinIndInt M) (width_fii : FinIndInt N)
      (ret : OutPtr (Stored int)) -> IEffect (Stored int) =
      case height_fii of finIndInt @M (pf : Pf (neZ M pos_infty)) (h : int).
      stored @int h ret
  in

  case boxed @(Stored int) (with_shape @a @(Stored int) container
       	     	      	    (matrixShapeEliminator @(Stored int) get_height))
  of boxed @(Stored int) (height_s : Stored int).
    case height_s of stored @int (n : int). n;


safeIndex2 @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (repr : Repr a)
  (container : t a) (yix : int) (xix : int) -> Writer a =
  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).
  letfun
    get_member @(M N : intindex)
      (ysize : FinIndInt M) (xsize : FinIndInt N)
      (ret : OutPtr a) -> IEffect a =
      case ysize of finIndInt @M (pf : Pf (neZ M pos_infty)) (ysize_i : int).
      case xsize of finIndInt @N (pf : Pf (neZ N pos_infty)) (xsize_i : int).

      -- Bounds checking
      if or (or (OrdDict_int_lt xix 0) (OrdDict_int_ge xix xsize_i))
       	    (or (OrdDict_int_lt yix 0) (OrdDict_int_ge yix ysize_i))
      then except @(IEffect a)
      else at_point @a repr container yix xix ret

  in with_shape @a @a container (matrixShapeEliminator @a get_member);


safeSlice2 @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (repr : Repr a)
  (container : t a)
  (start_y : int) (stop_y : int) (stride_y : int)
  (start_x : int) (stop_x : int) (stride_x : int)
   -> Writer (MatrixView a) =
  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).
  letfun
    get_slice @(M N : intindex)
      (ysize : FinIndInt M) (xsize : FinIndInt N)
      (ret : OutPtr (MatrixView a))
      -> IEffect (MatrixView a) =

      case ysize of finIndInt @M (pf : Pf (neZ M pos_infty)) (ysize_i : int).
      case xsize of finIndInt @N (pf : Pf (neZ N pos_infty)) (xsize_i : int).

      -- If slice is out of bounds, coerce to bounds
      let real_start_y : int =
            if OrdDict_int_lt start_y 0 then 0 else start_y in
      let real_end_y : int =
            if OrdDict_int_gt stop_y ysize_i then ysize_i else stop_y in
      let real_start_x : int =
            if OrdDict_int_lt start_x 0 then 0 else start_x in
      let real_end_x : int =
            if OrdDict_int_gt stop_x xsize_i then xsize_i else stop_x in

      -- Stride must be positive
      if OrdDict_int_le stride_y 0 then except @(IEffect (MatrixView a)) else
      if OrdDict_int_le stride_x 0 then except @(IEffect (MatrixView a)) else

      -- Compute interval spanned by slice.  If negative, coerce to zero.
      let delta_y : int =
            let iv : int = AdditiveDict_int_sub real_end_y real_start_y
            in if OrdDict_int_lt iv 0 then 0 else iv in
      let delta_x : int =
            let iv : int = AdditiveDict_int_sub real_end_x real_start_x
            in if OrdDict_int_lt iv 0 then 0 else iv in

      -- Get the slice
      at_slice @a repr container real_start_y delta_y stride_y real_start_x delta_x stride_x ret

  in with_shape @a @(MatrixView a) container
     (matrixShapeEliminator @(MatrixView a) get_slice);


fun_reduce @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (init : a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  fun_reduce_Stream @(shape t) @a shape_dict
  repr reducer init (traverse @a repr input) ret;


fun_reduce1 @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  fun_reduce1_Stream @(shape t) @a shape_dict
  repr reducer (traverse @a repr input) ret;


fun_map @(t : bare -> bare) @(a : bare) @(b : bare)
        (traversable : TraversableDict t)
	(shape_dict : ShapeDict (shape t))
        (reprA : Repr a) (reprB : Repr b)
        (transformer : a -> Writer b)
        (input : t a)
        (ret : OutPtr (t b))
  -> IEffect (t b) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @b reprB (fun_map_Stream @(shape t) @a @b shape_dict
                  reprA reprB transformer
                  (traverse @a reprA input)) ret;

fun_zip @(t : bare -> bare) @(a : bare) @(b : bare)
        (traversable : TraversableDict t)
	(shape_dict : ShapeDict (shape t))
        (reprA : Repr a) (reprB : Repr b)
        (inputA : t a) (inputB : t b)
        (ret : OutPtr (t (PyonTuple2 a b)))
  -> IEffect (t (PyonTuple2 a b)) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @(PyonTuple2 a b)
  (repr_PyonTuple2 @a @b reprA reprB)
  (fun_zip_Stream @(shape t) @a @b shape_dict reprA reprB
   (traverse @a reprA inputA) (traverse @b reprB inputB))
  ret;

fun_zip3 @(t : bare -> bare) @(a : bare) @(b : bare) @(c : bare)
        (traversable : TraversableDict t)
	(shape_dict : ShapeDict (shape t))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c)
        (inputA : t a) (inputB : t b) (inputC : t c)
        (ret : OutPtr (t (PyonTuple3 a b c)))
  -> IEffect (t (PyonTuple3 a b c)) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @(PyonTuple3 a b c)
  (repr_PyonTuple3 @a @b @c reprA reprB reprC)
  (fun_zip3_Stream @(shape t) @a @b @c shape_dict reprA reprB reprC
   (traverse @a reprA inputA)
   (traverse @b reprB inputB)
   (traverse @c reprC inputC))
  ret;


fun_zip4 @(t : bare -> bare) @(a : bare) @(b : bare) @(c : bare) @(d : bare)
        (traversable : TraversableDict t)
	(shape_dict : ShapeDict (shape t))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c) (reprD : Repr d)
        (inputA : t a) (inputB : t b) (inputC : t c) (inputD : t d)
        (ret : OutPtr (t (PyonTuple4 a b c d)))
  -> IEffect (t (PyonTuple4 a b c d)) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @(PyonTuple4 a b c d)
  (repr_PyonTuple4 @a @b @c @d reprA reprB reprC reprD)
  (fun_zip4_Stream @(shape t) @a @b @c @d shape_dict reprA reprB reprC reprD
   (traverse @a reprA inputA)
   (traverse @b reprB inputB)
   (traverse @c reprC inputC)
   (traverse @d reprD inputD))
  ret;

-------------------------------------------------------------------------------
-- Generic stream methods

fun_reduce_Stream @(sh a : bare) (shape_dict : ShapeDict sh) (repr_a : Repr a)
  (f : a -> a -> Writer a) (init : a) (s : Stream sh a) (ret : OutPtr a)
  -> IEffect a =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  LinStream_reduce @list_shape @a repr_a f init (shape_flatten @a s) ret;


-- reduce1 extracts the first value from the stream, then calls 'fold'
-- for the remaining values
fun_reduce1_Stream @(sh a : bare)
  (shape_dict : ShapeDict sh)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : Stream sh a)
  (ret : OutPtr a)
  -> IEffect a =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  LinStream_reduce1 @list_shape @a repr f (shape_flatten @a s) ret;


fun_map_Stream @(sh a b : bare)
  (shape_dict : ShapeDict sh) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : Stream sh a)
  -> Stream sh b =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_map @a @b repr_a repr_b f src;


fun_zip_Stream @(sh a b : bare) (shape_dict : ShapeDict sh)
  (repr_a : Repr a) (repr_b : Repr b)
  (src_a : Stream sh a) (src_b : Stream sh b) -> Stream sh (PyonTuple2 a b) =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith @a @b @(PyonTuple2 a b)
  repr_a repr_b (repr_PyonTuple2 @a @b repr_a repr_b)
  (\ (x : a) (y : b) -> Writer (PyonTuple2 a b).
    pyonTuple2 @a @b (copy @a repr_a x) (copy @b repr_b y))
  src_a src_b;


fun_zip3_Stream @(sh a b c : bare) (shape_dict : ShapeDict sh)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (src_a : Stream sh a) (src_b : Stream sh b) (src_c : Stream sh c)
  -> Stream sh (PyonTuple3 a b c) =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith3 @a @b @c @(PyonTuple3 a b c)
  repr_a repr_b repr_c (repr_PyonTuple3 @a @b @c repr_a repr_b repr_c)
  (\ (x : a) (y : b) (z : c) -> Writer (PyonTuple3 a b c).
    pyonTuple3 @a @b @c (copy @a repr_a x) (copy @b repr_b y) (copy @c repr_c z))
  src_a src_b src_c;


fun_zip4_Stream @(sh a b c d : bare) (shape_dict : ShapeDict sh)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (src_a : Stream sh a) (src_b : Stream sh b) (src_c : Stream sh c) (src_d : Stream sh d)
  -> Stream sh (PyonTuple4 a b c d) =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith4 @a @b @c @d @(PyonTuple4 a b c d)
  repr_a repr_b repr_c repr_d (repr_PyonTuple4 @a @b @c @d repr_a repr_b repr_c repr_d)
  (\ (x : a) (y : b) (z : c) (w : d) -> Writer (PyonTuple4 a b c d).
    pyonTuple4 @a @b @c @d (copy @a repr_a x) (copy @b repr_b y) (copy @c repr_c z) (copy @d repr_d w))
  src_a src_b src_c src_d;

-------------------------------------------------------------------------------
-- Other shape methods

ShapeDict_matrix_flatten @(a : bare) (s : Stream matrix_shape a)
  -> Stream list_shape a =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	                 (size_y : IndInt M) (size_x : IndInt N)
			 (ls : LinStream (array_shape M (array_shape N unit_shape)) a).
  LinStream_flatten @(array_shape M (array_shape N unit_shape)) @a ls;


ShapeDict_matrix_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (s : Stream matrix_shape a) -> Stream matrix_shape b =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	                 (size_y : IndInt M) (size_x : IndInt N)
			 (ls : LinStream (array_shape M (array_shape N unit_shape)) a).
  matrixStream @b @M @N size_y size_x
  (LinStream_map @(array_shape M (array_shape N unit_shape)) @a @b repr_a repr_b f ls);


ShapeDict_matrix_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : Stream matrix_shape a) (src_b : Stream matrix_shape b)
  -> Stream matrix_shape c =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IndInt Ma) (size_a_x : IndInt Na)
    (ls_a : LinStream (array_shape Ma (array_shape Na unit_shape)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IndInt Mb) (size_b_x : IndInt Nb)
    (ls_b : LinStream (array_shape Mb (array_shape Nb unit_shape)) b).

  let size_y : IndInt (min_i Ma Mb) = min_ii @Ma @Mb size_a_y size_b_y in
  let size_x : IndInt (min_i Na Nb) = min_ii @Na @Nb size_a_x size_b_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @c @(min_i Ma Mb) @(min_i Na Nb) size_y size_x
  (bind
   @(min_i Ma Mb)
   @(array_shape (min_i Na Nb) unit_shape)
   @(StoredBox (LinStream (array_shape (min_i Na Nb) unit_shape) c))
   @c
   (repr_Box @(LinStream (array_shape (min_i Na Nb) unit_shape) c))
   repr_c

   -- Zip in Y dimension
   (LinStream_zipWith_array
    @(StoredBox (LinStream (array_shape Na unit_shape) a))
    @(StoredBox (LinStream (array_shape Nb unit_shape) b))
    @(StoredBox (LinStream (array_shape (min_i Na Nb) unit_shape) c))
    @Ma
    @Mb
    (repr_Box @(LinStream (array_shape Na unit_shape) a))
    (repr_Box @(LinStream (array_shape Nb unit_shape) b))
    (repr_Box @(LinStream (array_shape (min_i Na Nb) unit_shape) c))
    (\ (inner_stream_a : StoredBox (LinStream (array_shape Na unit_shape) a))
       (inner_stream_b : StoredBox (LinStream (array_shape Nb unit_shape) b))
       -> Writer (StoredBox (LinStream (array_shape (min_i Na Nb) unit_shape) c)).
       case inner_stream_a of
         storedBox @(LinStream (array_shape Na unit_shape) a)
 	(sa : LinStream (array_shape Na unit_shape) a).
       case inner_stream_b of
         storedBox @(LinStream (array_shape Nb unit_shape) b)
 	(sb : LinStream (array_shape Nb unit_shape) b).
       storedBox @(LinStream (array_shape (min_i Na Nb) unit_shape) c)

         -- Zip in X dimension
         (LinStream_zipWith_array @a @b @c @Na @Nb repr_a repr_b repr_c f sa sb))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b))

   (\ (x : StoredBox (LinStream (array_shape (min_i Na Nb) unit_shape) c))
      -> LinStream (array_shape (min_i Na Nb) unit_shape) c.
      case x of storedBox @(LinStream (array_shape (min_i Na Nb) unit_shape) c)
      	        (y : LinStream (array_shape (min_i Na Nb) unit_shape) c).
      y));

    
ShapeDict_matrix_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : Stream matrix_shape a) (src_b : Stream matrix_shape b)
  (src_c : Stream matrix_shape c)
  -> Stream matrix_shape d =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IndInt Ma) (size_a_x : IndInt Na)
    (ls_a : LinStream (array_shape Ma (array_shape Na unit_shape)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IndInt Mb) (size_b_x : IndInt Nb)
    (ls_b : LinStream (array_shape Mb (array_shape Nb unit_shape)) b).

  case src_c of
    matrixStream @c @(Mc : intindex) @(Nc : intindex)
    (size_c_y : IndInt Mc) (size_c_x : IndInt Nc)
    (ls_c : LinStream (array_shape Mc (array_shape Nc unit_shape)) c).

  let size_y : IndInt (min_i (min_i Ma Mb) Mc) =
        min_ii @(min_i Ma Mb) @Mc (min_ii @Ma @Mb size_a_y size_b_y) size_c_y in
  let size_x : IndInt (min_i (min_i Na Nb) Nc) =
        min_ii @(min_i Na Nb) @Nc (min_ii @Na @Nb size_a_x size_b_x) size_c_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @d @(min_i (min_i Ma Mb) Mc) @(min_i (min_i Na Nb) Nc) size_y size_x
  (bind
   @(min_i (min_i Ma Mb) Mc)
   @(array_shape (min_i (min_i Na Nb) Nc) unit_shape)
   @(StoredBox (LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d))
   @d
   (repr_Box @(LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d))
   repr_d

   -- Zip in Y dimension
   (LinStream_zipWith3_array
    @(StoredBox (LinStream (array_shape Na unit_shape) a))
    @(StoredBox (LinStream (array_shape Nb unit_shape) b))
    @(StoredBox (LinStream (array_shape Nc unit_shape) c))
    @(StoredBox (LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d))
    @Ma
    @Mb
    @Mc
    (repr_Box @(LinStream (array_shape Na unit_shape) a))
    (repr_Box @(LinStream (array_shape Nb unit_shape) b))
    (repr_Box @(LinStream (array_shape Nc unit_shape) c))
    (repr_Box @(LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d))
    (\ (inner_stream_a : StoredBox (LinStream (array_shape Na unit_shape) a))
       (inner_stream_b : StoredBox (LinStream (array_shape Nb unit_shape) b))
       (inner_stream_c : StoredBox (LinStream (array_shape Nc unit_shape) c))
       -> Writer (StoredBox (LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d)).
       case inner_stream_a of
         storedBox @(LinStream (array_shape Na unit_shape) a)
 	(sa : LinStream (array_shape Na unit_shape) a).
       case inner_stream_b of
         storedBox @(LinStream (array_shape Nb unit_shape) b)
 	(sb : LinStream (array_shape Nb unit_shape) b).
       case inner_stream_c of
         storedBox @(LinStream (array_shape Nc unit_shape) c)
 	(sc : LinStream (array_shape Nc unit_shape) c).
       storedBox @(LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d)

         -- Zip in X dimension
         (LinStream_zipWith3_array @a @b @c @d @Na @Nb @Nc repr_a repr_b repr_c repr_d f sa sb sc))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b)
    (chunk_id @Mc @Nc @c repr_c size_c_x ls_c))

   (\ (x : StoredBox (LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d))
      -> LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d.
      case x of storedBox @(LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d)
      	        (y : LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d).
      y));


ShapeDict_matrix_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : Stream matrix_shape a) (src_b : Stream matrix_shape b)
  (src_c : Stream matrix_shape c) (src_d : Stream matrix_shape d)
  -> Stream matrix_shape e =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IndInt Ma) (size_a_x : IndInt Na)
    (ls_a : LinStream (array_shape Ma (array_shape Na unit_shape)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IndInt Mb) (size_b_x : IndInt Nb)
    (ls_b : LinStream (array_shape Mb (array_shape Nb unit_shape)) b).

  case src_c of
    matrixStream @c @(Mc : intindex) @(Nc : intindex)
    (size_c_y : IndInt Mc) (size_c_x : IndInt Nc)
    (ls_c : LinStream (array_shape Mc (array_shape Nc unit_shape)) c).

  case src_d of
    matrixStream @d @(Md : intindex) @(Nd : intindex)
    (size_d_y : IndInt Md) (size_d_x : IndInt Nd)
    (ls_d : LinStream (array_shape Md (array_shape Nd unit_shape)) d).

  let size_y : IndInt (min_i (min_i (min_i Ma Mb) Mc) Md) =
        min_ii @(min_i (min_i Ma Mb) Mc) @Md
	(min_ii @(min_i Ma Mb) @Mc
	 (min_ii @Ma @Mb size_a_y size_b_y) size_c_y) size_d_y in
  let size_x : IndInt (min_i (min_i (min_i Na Nb) Nc) Nd) =
        min_ii @(min_i (min_i Na Nb) Nc) @Nd
	(min_ii @(min_i Na Nb) @Nc
	 (min_ii @Na @Nb size_a_x size_b_x) size_c_x) size_d_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @e @(min_i (min_i (min_i Ma Mb) Mc) Md) @(min_i (min_i (min_i Na Nb) Nc) Nd) size_y size_x
  (bind
   @(min_i (min_i (min_i Ma Mb) Mc) Md)
   @(array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape)
   @(StoredBox (LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e))
   @e
   (repr_Box @(LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e))
   repr_e

   -- Zip in Y dimension
   (LinStream_zipWith4_array
    @(StoredBox (LinStream (array_shape Na unit_shape) a))
    @(StoredBox (LinStream (array_shape Nb unit_shape) b))
    @(StoredBox (LinStream (array_shape Nc unit_shape) c))
    @(StoredBox (LinStream (array_shape Nd unit_shape) d))
    @(StoredBox (LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e))
    @Ma
    @Mb
    @Mc
    @Md
    (repr_Box @(LinStream (array_shape Na unit_shape) a))
    (repr_Box @(LinStream (array_shape Nb unit_shape) b))
    (repr_Box @(LinStream (array_shape Nc unit_shape) c))
    (repr_Box @(LinStream (array_shape Nd unit_shape) d))
    (repr_Box @(LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e))
    (\ (inner_stream_a : StoredBox (LinStream (array_shape Na unit_shape) a))
       (inner_stream_b : StoredBox (LinStream (array_shape Nb unit_shape) b))
       (inner_stream_c : StoredBox (LinStream (array_shape Nc unit_shape) c))
       (inner_stream_d : StoredBox (LinStream (array_shape Nd unit_shape) d))
       -> Writer (StoredBox (LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e)).
       case inner_stream_a of
         storedBox @(LinStream (array_shape Na unit_shape) a)
 	(sa : LinStream (array_shape Na unit_shape) a).
       case inner_stream_b of
         storedBox @(LinStream (array_shape Nb unit_shape) b)
 	(sb : LinStream (array_shape Nb unit_shape) b).
       case inner_stream_c of
         storedBox @(LinStream (array_shape Nc unit_shape) c)
 	(sc : LinStream (array_shape Nc unit_shape) c).
       case inner_stream_d of
         storedBox @(LinStream (array_shape Nd unit_shape) d)
 	(sd : LinStream (array_shape Nd unit_shape) d).
       storedBox @(LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e)

         -- Zip in X dimension
         (LinStream_zipWith4_array @a @b @c @d @e @Na @Nb @Nc @Nd repr_a repr_b repr_c repr_d repr_e f sa sb sc sd))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b)
    (chunk_id @Mc @Nc @c repr_c size_c_x ls_c)
    (chunk_id @Md @Nd @d repr_d size_d_x ls_d))

   (\ (x : StoredBox (LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e))
      -> LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e.
      case x of storedBox @(LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e)
      	        (y : LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e).
      y));


ShapeDict_Stream_flatten @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a : bare) -> Stream sh a -> Stream list_shape a =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_flatten;


ShapeDict_Stream_map @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b : bare) -> Repr a -> Repr b -> (a -> Writer b) -> Stream sh a -> Stream sh b =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_map;


ShapeDict_Stream_zipWith @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c : bare) -> Repr a -> Repr b -> Repr c ->
     (a -> b -> Writer c) ->
     Stream sh a -> Stream sh b -> Stream sh c =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith;


ShapeDict_Stream_zipWith3 @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c d : bare) -> Repr a -> Repr b -> Repr c -> Repr d ->
     (a -> b -> c -> Writer d) ->
     Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith3;


ShapeDict_Stream_zipWith4 @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c d e : bare) -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
     (a -> b -> c -> d -> Writer e) ->
     Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e =
  case shape_dict of shapeDict @sh 
    (shape_flatten : (a : bare) -> Stream sh a -> Stream list_shape a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith4;

-------------------------------------------------------------------------------
-- List shape methods

ShapeDict_list_flatten @(a : bare) (s : Stream list_shape a)
  -> Stream list_shape a =
  s;


ShapeDict_list_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : Stream list_shape a) -> Stream list_shape b =
  LinStream_map @list_shape @a @b repr_a repr_b f src;


ShapeDict_list_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : Stream list_shape a) (src_b : Stream list_shape b)
  -> Stream list_shape c =
  LinStream_zipWith @list_shape @a @b @c repr_a repr_b repr_c f src_a src_b;


ShapeDict_list_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : Stream list_shape a) (src_b : Stream list_shape b) (src_c : Stream list_shape c)
  -> Stream list_shape d =
  LinStream_zipWith3 @list_shape @a @b @c @d repr_a repr_b repr_c repr_d
  f src_a src_b src_c;


ShapeDict_list_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : Stream list_shape a) (src_b : Stream list_shape b) (src_c : Stream list_shape c) (src_d : Stream list_shape d)
  -> Stream list_shape e =
  LinStream_zipWith4 @list_shape @a @b @c @d @e repr_a repr_b repr_c repr_d repr_e
  f src_a src_b src_c src_d;

-------------------------------------------------------------------------------
-- Linear stream methods

LinStream_flatten @(sh a : bare) (s : LinStream sh a)
  -> LinStream list_shape a
  attribute(inline_final) =
  case s of linStream @sh @a @(st : box)
                       (state : st) (next : st -> StreamNext st (BoxedType a)).
  linStream @list_shape @a @st state next;


LinStream_map @(sh a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : LinStream sh a) -> LinStream sh b
  attribute(inline_final) =
  case src
  of linStream @sh @a @(src_st : box)
     (st : src_st) (next : src_st -> StreamNext src_st (BoxedType a)).

  letfun
    go (state : src_st) -> StreamNext src_st (BoxedType b) =
      case next state of {

        streamValue @src_st @(BoxedType a)
          (next_state : src_st) (value : BoxedType a).
          let output_value : BoxedType b =
                case boxed @a (convertToBare @a repr_a value) of boxed @a (x : a).
		convertToBoxed @b repr_b (f x)
          in streamValue @src_st @(BoxedType b) next_state output_value;

        streamEmpty @src_st @(BoxedType a).
          streamEmpty @src_st @(BoxedType b)
      }
  in linStream @sh @b @src_st st go;


LinStream_zipWith @(sh a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : LinStream sh a) (src_b : LinStream sh b)
  -> LinStream sh c
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b)))
      -> StreamNext (Boxed (Stored (st_a, st_b))) (BoxedType c) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b)) (u_state : Stored (st_a, st_b)).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

	      -- Create output value
	      let value : BoxedType c =
	            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
		    convertToBoxed @c repr_c (f x y) in
	      let next_state : Boxed (Stored (st_a, st_b)) =
	            boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed (Stored (st_a, st_b))) @(BoxedType c) next_state value;

	    streamEmpty @st_b @(BoxedType b).
	      streamEmpty @(Boxed (Stored (st_a, st_b))) @(BoxedType c)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b))) @(BoxedType c)
      }
  in linStream @sh @c @(Boxed (Stored (st_a, st_b)))
       (boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (state_a, state_b)))
       go;


LinStream_zipWith3 @(sh a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : LinStream sh a) (src_b : LinStream sh b) (src_c : LinStream sh c)
  -> LinStream sh d
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of linStream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c))) (BoxedType d) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c)) (u_state : Stored (st_a, st_b, st_c)).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Create output value
                  let value : BoxedType d =
                        case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                        convertToBoxed @d repr_d (f x y z) in
                  let next_state : Boxed (Stored (st_a, st_b, st_c)) =
                        boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d) next_state value;

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
      }
  in linStream @sh @d @(Boxed (Stored (st_a, st_b, st_c)))
       (boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;


LinStream_zipWith4 @(sh a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : LinStream sh a) (src_b : LinStream sh b) (src_c : LinStream sh c) (src_d : LinStream sh d)
  -> LinStream sh e
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of linStream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  case src_d
  of linStream @sh @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d (BoxedType d)).

  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c, st_d)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c, st_d))) (BoxedType e) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c, st_d)) (u_state : Stored (st_a, st_b, st_c, st_d)).
      case u_state of stored @(st_a, st_b, st_c, st_d) (i_state : (st_a, st_b, st_c, st_d)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @(BoxedType d)
                      (next_state_d : st_d) (value_d : BoxedType d).

                      -- Create output value
                      let value : BoxedType e =
                            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (convertToBare @d repr_d value_d) of boxed @d (w : d).
                            convertToBoxed @e repr_e (f x y z w) in
                      let next_state : Boxed (Stored (st_a, st_b, st_c, st_d)) =
                            boxed @(Stored (st_a, st_b, st_c, st_d)) (stored @(st_a, st_b, st_c, st_d) (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e) next_state value;

                    streamEmpty @st_d @(BoxedType d).
                      streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
                  };

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
      }
  in linStream @sh @e @(Boxed (Stored (st_a, st_b, st_c, st_d)))
       (boxed @(Stored (st_a, st_b, st_c, st_d)) (stored @(st_a, st_b, st_c, st_d) (state_a, state_b, state_c, state_d)))
       go;

-------------------------------------------------------------------------------
-- Other rewritable functions

LinStream_reduce @(sh a : bare) (repr_a : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (s : LinStream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  LinStream_fold @sh @a @a repr_a repr_a f init s ret;


LinStream_reduce1 @(sh a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : LinStream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  -- Use the stream's first element as the initial value
  case s of linStream @sh @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case stream_next stream_state of {
    streamValue @st @(BoxedType a) (next_state : st) (init : BoxedType a).
      case boxed @a (convertToBare @a repr init) of boxed @a (u_init : a).
      let new_stream : Stream list_shape a =
            linStream @list_shape @a @st next_state stream_next in
      LinStream_fold @list_shape @a @a repr repr f u_init new_stream ret;

    streamEmpty @st @(BoxedType a).
      except @(IEffect a)
  };


LinStream_fold @(sh a acc : bare) (repr_a : Repr a) (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (s : LinStream sh a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline_final) =
  case s of linStream @sh @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  letfun
    go (state : st) (accumulator : BoxedType acc) (ret : OutPtr acc)
      -> IEffect acc =
      case stream_next state of {

        -- Obtain value from stream
        streamValue @st @(BoxedType a) (next_state : st) (result : BoxedType a).
          -- Compute the new value
          let new_accumulator : BoxedType acc =
                case boxed @a (convertToBare @a repr_a result)
                of boxed @a (y : a).
                case boxed @acc (convertToBare @acc repr_acc accumulator)
                of boxed @acc (x : acc).
                convertToBoxed @acc repr_acc (f x y)

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty @st @(BoxedType a).
	  convertToBare @acc repr_acc accumulator ret
      }
  in go stream_state (convertToBoxed @acc repr_acc (copy @acc repr_acc init)) ret;

-------------------------------------------------------------------------------
-- Loops

for @(N : intindex) @(acc : bare)
  (repr : Repr acc) (count : IndInt N) (init : acc)
  (f : int -> acc -> Writer acc) (ret : OutPtr acc)
  -> IEffect acc =

  -- Unpack the indexed int
  case count of {
    indInt @N (fin : FinIndInt N).
      case fin of finIndInt @N (pf : Pf (neZ N pos_infty)) (bound : int).

      -- Main loop
      letfun
        loop (i : int) (x : acc) (r : OutPtr acc) -> IEffect acc =
          if EqDict_int_eq i bound
          then copy @acc repr x r
          else case boxed @acc (f i x) of boxed @acc (y : acc).
               loop (AdditiveDict_int_add i 1) y r
      in loop 0 init ret;

    -- An infinite loop will fail
    indOmega @N (pf : Pf (eqZ N pos_infty)).
      except @(IEffect acc)
  };
