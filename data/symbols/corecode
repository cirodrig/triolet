
range (n : int) -> Stream list_shape (Stored int) =
  case defineIntIndex n of someIndInt @(ix : intindex) (val : FinIndInt ix).
    fun_asList_Stream @(array_shape ix unit_shape) @(Stored int)
    (rangeIndexed @ix (indInt @ix val));

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : bare) (repr : Repr a) (ls : list a)
  -> Stream list_shape a =
  case ls of make_list @a @(N : intindex)
                       (size : FinIndInt N) (aref : Referenced (array N a)).
  case aref of referenced @(array N a) (ay : array N a).
  fun_asList_Stream @(array_shape N unit_shape) @a
  (generate @N @a (indInt @N size) repr
   (\ (i : int) (ret : OutPtr a) -> IEffect a.
      copy @a repr (subscript @N @a repr ay i) ret));

len @(a : bare) (ls : list a) -> int =
  -- Extract the list's length value
  case ls of make_list @a @(N : intindex)
    (size : FinIndInt N) (aref : Referenced (array N a)).
  case size of finIndInt @N (pf : Pf (neZ N pos_infty)) (x : int).
  x;

{-
-- List construction.
-- If the stream has a known size, allocate and initialize an array.
TraversableDict_list_build @(a : bare)
  (repr : Repr a) (s : Stream list_shape a) (o : OutPtr (list a))
  -> IEffect (list a) =
-}

-- Stream traversal and building.
-- These functions are trivial.
TraversableDict_Stream_build @(t : bare -> bare) @(a : bare)
  (repr : Repr a) (s : Stream (shape t) a)
  -> Stream (shape t) a = s;

TraversableDict_Stream_traverse @(t : bare -> bare) @(a : bare)
  (repr : Repr a) (s : Stream (shape t) a)
  -> Stream (shape t) a = s;

oper_GUARD @(a : bare) (repr : Repr a) (arg : bool) (s : Stream list_shape a)
  -> Stream list_shape a =
  if arg then s else oper_EMPTY @a repr;

oper_DO @(a : bare) (repr : Repr a) (f : Writer a) -> Stream list_shape a
  attribute(inline_final) =

  -- Singleton stream.
  -- State is a boolean, which is false if the stream is depleted,
  -- true otherwise.
  letfun
    get_value (state : Boxed (Stored bool))
      -> StreamNext (Boxed (Stored bool)) (BoxedType a) =
      case state of boxed @(Stored bool) (u_state : Stored bool).
      case u_state of stored @bool (i_state : bool).
      if i_state
      then let next_state : Boxed (Stored bool) =
                 boxed @(Stored bool) (stored @bool False) in
           let retval : BoxedType a = convertToBoxed @a repr f in
           streamValue @(Boxed (Stored bool)) @(BoxedType a) next_state retval
      else streamEmpty @(Boxed (Stored bool)) @(BoxedType a)
  in
    let initial_state : Boxed (Stored bool) =
          boxed @(Stored bool) (stored @bool True) in
    stream @list_shape @a @(Boxed (Stored bool)) initial_state get_value;

oper_CAT_MAP @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (src : Stream list_shape a)
  (trans : a -> Stream list_shape b)
  -> Stream list_shape b
  attribute(inline_final) =
  case src of stream @list_shape @a @(src_st : box)
                (src_state : src_st)
		(src_next : src_st -> StreamNext src_st (BoxedType a)).
  letfun {
    -- Dispatch based on the current stream state
    next (state : BindState src_st a b)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state;

	bindFromTrans @src_st @a @b @(trans_st : box)
	  (src_state : src_st)
	  (trans_state : trans_st)
	  (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).
	  next_from_trans @trans_st src_state trans_state trans_next
      };

    -- Pull a value from the source stream
    next_from_source
      (src_state : src_st)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case src_next src_state of {
        streamValue @src_st @(BoxedType a)
	  (next_src_state : src_st) (src_value : BoxedType a).

	  -- Apply the transformer to this value
	  case boxed @a (convertToBare @a repr_a src_value)
	  of boxed @a (src_uvalue : a).

	  case trans src_uvalue of stream @list_shape @b @(trans_st : box)
	                             (trans_state : trans_st)
				     (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).

          -- Pull a value from the transformed stream
          next_from_trans @trans_st next_src_state trans_state trans_next;

	streamEmpty @src_st @(BoxedType a).
	  -- Stream is depleted
	  streamEmpty @(BindState src_st a b) @(BoxedType b)
      };

    -- Pull a value from the transformed stream
    next_from_trans
      @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st (BoxedType b))
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case trans_next trans_state of {
        streamValue @trans_st @(BoxedType b)
	  (next_trans_state : trans_st) (trans_value : BoxedType b).

	  streamValue @(BindState src_st a b) @(BoxedType b)
	    (bindFromTrans @src_st @a @b @trans_st
	     src_state next_trans_state trans_next)
	    trans_value;

	streamEmpty @trans_st @(BoxedType b).
	  -- Pull a new value from the source stream
	  next_from_source src_state
      }
  } in stream @list_shape @b @(BindState src_st a b)
         (bindFromSource @src_st @a @b src_state)
	 next;


-- 'bind' is a renamed version of 'oper_CAT_MAP'.
bind @(N : intindex) @(sh a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (src : Stream (array_shape N unit_shape) a)
  (trans : a -> Stream sh b)
  -> Stream (array_shape N sh) b 
  attribute(inline_final) =
  case oper_CAT_MAP @a @b repr_a repr_b
       (fun_asList_Stream @(array_shape N unit_shape) @a src)
       (\ (x : a) -> Stream list_shape b. fun_asList_Stream @sh @b (trans x))
  of stream @list_shape @b @(st : box) (state : st) (next : st -> StreamNext st (BoxedType b)).
  stream @(array_shape N sh) @b @st state next;

fun_map @(t : bare -> bare) @(a : bare) @(b : bare)
        (traversable : TraversableDict t)
        (reprA : Repr a) (reprB : Repr b)
        (transformer : a -> Writer b)
        (input : t a)
        (ret : OutPtr (t b))
  -> IEffect (t b) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @b reprB (fun_map_Stream @(shape t) @a @b reprA reprB transformer
                  (traverse @a reprA input)) ret;

fun_zip @(t : bare -> bare) @(a : bare) @(b : bare)
        (traversable : TraversableDict t)
        (reprA : Repr a) (reprB : Repr b)
        (inputA : t a) (inputB : t b)
        (ret : OutPtr (t (PyonTuple2 a b)))
  -> IEffect (t (PyonTuple2 a b)) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @(PyonTuple2 a b)
  (repr_PyonTuple2 @a @b reprA reprB)
  (fun_zip_Stream @(shape t) @a @b reprA reprB
   (traverse @a reprA inputA) (traverse @b reprB inputB))
  ret;

fun_zip3 @(t : bare -> bare) @(a : bare) @(b : bare) @(c : bare)
        (traversable : TraversableDict t)
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c)
        (inputA : t a) (inputB : t b) (inputC : t c)
        (ret : OutPtr (t (PyonTuple3 a b c)))
  -> IEffect (t (PyonTuple3 a b c)) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @(PyonTuple3 a b c)
  (repr_PyonTuple3 @a @b @c reprA reprB reprC)
  (fun_zip3_Stream @(shape t) @a @b @c reprA reprB reprC
   (traverse @a reprA inputA)
   (traverse @b reprB inputB)
   (traverse @c reprC inputC))
  ret;

fun_zip4 @(t : bare -> bare) @(a : bare) @(b : bare) @(c : bare) @(d : bare)
        (traversable : TraversableDict t)
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c) (reprD : Repr d)
        (inputA : t a) (inputB : t b) (inputC : t c) (inputD : t d)
        (ret : OutPtr (t (PyonTuple4 a b c d)))
  -> IEffect (t (PyonTuple4 a b c d)) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @(PyonTuple4 a b c d)
  (repr_PyonTuple4 @a @b @c @d reprA reprB reprC reprD)
  (fun_zip4_Stream @(shape t) @a @b @c @d reprA reprB reprC reprD
   (traverse @a reprA inputA)
   (traverse @b reprB inputB)
   (traverse @c reprC inputC)
   (traverse @d reprD inputD))
  ret;

histogram @(t : bare -> bare)
  (size : int)
  (input : Stream (shape t) (Stored int))
  (ret : OutPtr (list (Stored int)))
  -> IEffect (list (Stored int)) =
  case defineIntIndex size of someIndInt @(N : intindex) (index : FinIndInt N).
  make_list @(Stored int) @N index
  (referenced @(array N (Stored int))
   (histogramArray @(shape t) @N index input))
  ret;

fun_reduce @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (init : a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  fun_reduce_Stream @(shape t) @a
  repr reducer init (traverse @a repr input) ret;

fun_reduce1 @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  fun_reduce1_Stream @(shape t) @a
  repr reducer (traverse @a repr input) ret;

for @(N : intindex) @(acc : bare)
  (repr : Repr acc) (count : IndInt N) (init : acc)
  (f : int -> acc -> Writer acc) (ret : OutPtr acc)
  -> IEffect acc =

  -- Unpack the indexed int
  case count of {
    indInt @N (fin : FinIndInt N).
      case fin of finIndInt @N (pf : Pf (neZ N pos_infty)) (bound : int).

      -- Main loop
      letfun
        loop (i : int) (x : acc) (r : OutPtr acc) -> IEffect acc =
          if EqDict_int_eq i bound
          then copy @acc repr x r
          else case boxed @acc (f i x) of boxed @acc (y : acc).
               loop (AdditiveDict_int_add i 1) y r
      in loop 0 init ret;

    -- An infinite loop will fail
    indOmega @N (pf : Pf (eqZ N pos_infty)).
      except @(IEffect acc)
  };
  
safeSubscript @(a : bare)
  (repr : Repr a) (ls : list a) (ix : int) (ret : OutPtr a) -> IEffect a =

  -- Deconstruct data structures
  case ls of make_list @a @(N : intindex)
             (size : FinIndInt N) (ayref : Referenced (array N a)).
  case ayref of referenced @(array N a) (ay : array N a).
  case size of finIndInt @N (pf : Pf (neZ N pos_infty)) (size_int : int).

  if or (OrdDict_int_lt ix 0) (OrdDict_int_ge ix size_int)
  then except @(IEffect a)
  else copy @a repr (subscript @N @a repr ay ix) ret;


-------------------------------------------------------------------------------
-- Stream functions

generate @(N : intindex) @(a : bare)
         (count : IndInt N) (repr : Repr a) (f : int -> Writer a)
 -> Stream (array_shape N unit_shape) a
  attribute(inline_final) =

  case count of {
    indInt @N (fin : FinIndInt N).
      -- Finite case
      case fin of finIndInt @N (pf : Pf (neZ N pos_infty)) (bound : int).
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

	  -- End of loop?
          if EqDict_int_eq i bound
          then streamEmpty @(Boxed (Stored int)) @(BoxedType a)
	  else let retval : BoxedType a =
                    convertToBoxed @a repr (f i) in

               -- Apply the generator function
               streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in stream @(array_shape N unit_shape) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next;

    indOmega @N (pf : Pf (eqZ N pos_infty)).
      -- Infinite case
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

          let retval : BoxedType a =
                convertToBoxed @a repr (f i) in

          -- Apply the generator function
          streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in stream @(array_shape N unit_shape) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next
  };


rangeIndexed @(N : intindex) (count : IndInt N)
  -> Stream (array_shape N unit_shape) (Stored int) =

  generate @N @(Stored int) count repr_int
  (\ (i : int) -> Writer (Stored int). stored @int i);


fun_fold_Stream @(a acc : bare) (repr_a : Repr a) (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (s : Stream list_shape a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline_final) =

  case s of stream @list_shape @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  letfun
    go (state : st) (accumulator : BoxedType acc) (ret : OutPtr acc)
      -> IEffect acc =
      case stream_next state of {

        -- Obtain value from stream
        streamValue @st @(BoxedType a) (next_state : st) (result : BoxedType a).
          -- Compute the new value
          let new_accumulator : BoxedType acc =
                case boxed @a (convertToBare @a repr_a result)
                of boxed @a (y : a).
                case boxed @acc (convertToBare @acc repr_acc accumulator)
                of boxed @acc (x : acc).
                convertToBoxed @acc repr_acc (f x y)

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty @st @(BoxedType a).
	  convertToBare @acc repr_acc accumulator ret
      }
  in go stream_state (convertToBoxed @acc repr_acc (copy @acc repr_acc init)) ret;


fun_reduce_Stream @(sh a : bare)
  (repr : Repr a) (f : a -> a -> Writer a) (init : a) (src : Stream sh a) (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  fun_fold_Stream @a @a repr repr f init (fun_asList_Stream @sh @a src) ret;


-- reduce1 extracts the first value from the stream, then calls 'fold'
-- for the remaining values
fun_reduce1_Stream @(sh a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : Stream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =

  -- Use the stream's first element as the initial value
  case s of stream @sh @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case stream_next stream_state of {
    streamValue @st @(BoxedType a) (next_state : st) (init : BoxedType a).
      case boxed @a (convertToBare @a repr init) of boxed @a (u_init : a).
      let new_stream : Stream list_shape a =
            stream @list_shape @a @st next_state stream_next in
      fun_fold_Stream @a @a repr repr f u_init new_stream ret;

    streamEmpty @st @(BoxedType a).
      except @(IEffect a)
  };


fun_asList_Stream @(sh a : bare) (src : Stream sh a) -> Stream list_shape a
  attribute(inline_final) =

  -- Reinterpret the stream as another type
  case src of stream @sh @a @(st : box)
    (state : st) (next : st -> StreamNext st (BoxedType a)).
    stream @list_shape @a @st state next;

fun_map_Stream @(sh a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : Stream sh a)
  -> Stream sh b
  attribute(inline_final) =
  case src
  of stream @sh @a @(src_st : box)
     (st : src_st) (next : src_st -> StreamNext src_st (BoxedType a)).

  letfun
    go (state : src_st) -> StreamNext src_st (BoxedType b) =
      case next state of {

        streamValue @src_st @(BoxedType a)
          (next_state : src_st) (value : BoxedType a).
          let output_value : BoxedType b =
                case boxed @a (convertToBare @a repr_a value) of boxed @a (x : a).
		convertToBoxed @b repr_b (f x)
          in streamValue @src_st @(BoxedType b) next_state output_value;

        streamEmpty @src_st @(BoxedType a).
          streamEmpty @src_st @(BoxedType b)
      }
  in stream @sh @b @src_st st go;

fun_zip_Stream @(sh a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (src_a : Stream sh a) (src_b : Stream sh b) -> Stream sh (PyonTuple2 a b)
  attribute(inline_final) =

  case src_a
  of stream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of stream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b)))
      -> StreamNext (Boxed (Stored (st_a, st_b))) (Boxed (PyonTuple2 a b)) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b)) (u_state : Stored (st_a, st_b)).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

	      -- Create output value
	      let value : Boxed (PyonTuple2 a b) =
	            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
		    boxed @(PyonTuple2 a b) (pyonTuple2 @a @b (copy @a repr_a x) (copy @b repr_b y)) in
	      let next_state : Boxed (Stored (st_a, st_b)) =
	            boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed (Stored (st_a, st_b))) @(Boxed (PyonTuple2 a b)) next_state value;

	    streamEmpty @st_b @(BoxedType b).
	      streamEmpty @(Boxed (Stored (st_a, st_b))) @(Boxed (PyonTuple2 a b))
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b))) @(Boxed (PyonTuple2 a b))
      }
  in stream @sh @(PyonTuple2 a b) @(Boxed (Stored (st_a, st_b)))
       (boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (state_a, state_b)))
       go;

fun_zip3_Stream @(sh a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (src_a : Stream sh a) (src_b : Stream sh b) (src_c : Stream sh c)
  -> Stream sh (PyonTuple3 a b c)
  attribute(inline_final) =

  case src_a
  of stream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of stream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of stream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c))) (Boxed (PyonTuple3 a b c)) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c)) (u_state : Stored (st_a, st_b, st_c)).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Create output value
                  let value : Boxed (PyonTuple3 a b c) =
                        case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                        boxed @(PyonTuple3 a b c) (pyonTuple3 @a @b @c (copy @a repr_a x) (copy @b repr_b y) (copy @c repr_c z)) in
                  let next_state : Boxed (Stored (st_a, st_b, st_c)) =
                        boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed (Stored (st_a, st_b, st_c))) @(Boxed (PyonTuple3 a b c)) next_state value;

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(Boxed (PyonTuple3 a b c))
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(Boxed (PyonTuple3 a b c))
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(Boxed (PyonTuple3 a b c))
      }
  in stream @sh @(PyonTuple3 a b c) @(Boxed (Stored (st_a, st_b, st_c)))
       (boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;

fun_zip4_Stream @(sh a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (src_a : Stream sh a) (src_b : Stream sh b) (src_c : Stream sh c) (src_d : Stream sh d)
  -> Stream sh (PyonTuple4 a b c d)
  attribute(inline_final) =

  case src_a
  of stream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of stream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of stream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  case src_d
  of stream @sh @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d (BoxedType d)).

  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c, st_d)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c, st_d))) (Boxed (PyonTuple4 a b c d)) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c, st_d)) (u_state : Stored (st_a, st_b, st_c, st_d)).
      case u_state of stored @(st_a, st_b, st_c, st_d) (i_state : (st_a, st_b, st_c, st_d)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @(BoxedType d)
                      (next_state_d : st_d) (value_d : BoxedType d).

                      -- Create output value
                      let value : Boxed (PyonTuple4 a b c d) =
                            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (convertToBare @d repr_d value_d) of boxed @d (w : d).
                            boxed @(PyonTuple4 a b c d) (pyonTuple4 @a @b @c @d (copy @a repr_a x) (copy @b repr_b y) (copy @c repr_c z) (copy @d repr_d w)) in
                      let next_state : Boxed (Stored (st_a, st_b, st_c, st_d)) =
                            boxed @(Stored (st_a, st_b, st_c, st_d)) (stored @(st_a, st_b, st_c, st_d) (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(Boxed (PyonTuple4 a b c d)) next_state value;

                    streamEmpty @st_d @(BoxedType d).
                      streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(Boxed (PyonTuple4 a b c d))
                  };

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(Boxed (PyonTuple4 a b c d))
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(Boxed (PyonTuple4 a b c d))
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(Boxed (PyonTuple4 a b c d))
      }
  in stream @sh @(PyonTuple4 a b c d) @(Boxed (Stored (st_a, st_b, st_c, st_d)))
       (boxed @(Stored (st_a, st_b, st_c, st_d)) (stored @(st_a, st_b, st_c, st_d) (state_a, state_b, state_c, state_d)))
       go;

