
{-



{-
-- List construction.
-- If the stream has a known size, allocate and initialize an array.
TraversableDict_list_build @(a : bare)
  (repr : Repr a) (s : Stream dim1 a) (o : OutPtr (list a))
  -> IEffect (list a) =
-}

oper_DO @(a : bare) (repr : Repr a) (f : Writer a) -> Stream dim1 a
  attribute(inline_final) =

  -- Singleton stream.
  -- State is a boolean, which is false if the stream is depleted,
  -- true otherwise.
  letfun
    get_value (state : Boxed (Stored bool))
      -> StreamNext (Boxed (Stored bool)) (BoxedType a) =
      case state of boxed @(Stored bool) (u_state : Stored bool).
      case u_state of stored @bool (i_state : bool).
      if i_state
      then let next_state : Boxed (Stored bool) =
                 boxed @(Stored bool) (stored @bool False) in
           let retval : BoxedType a = convertToBoxed @a repr f in
           streamValue @(Boxed (Stored bool)) @(BoxedType a) next_state retval
      else streamEmpty @(Boxed (Stored bool)) @(BoxedType a)
  in
    let initial_state : Boxed (Stored bool) =
          boxed @(Stored bool) (stored @bool True) in
    linStream @dim1 @a @(Boxed (Stored bool)) initial_state get_value;

oper_CAT_MAP @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (src : Stream dim1 a)
  (trans : a -> Stream dim1 b)
  -> Stream dim1 b
  attribute(inline_final) =
  case src of linStream @dim1 @a @(src_st : box)
                (src_state : src_st)
		(src_next : src_st -> StreamNext src_st (BoxedType a)).
  letfun {
    -- Dispatch based on the current stream state
    next (state : BindState src_st a b)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state;

	bindFromTrans @src_st @a @b @(trans_st : box)
	  (src_state : src_st)
	  (trans_state : trans_st)
	  (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).
	  next_from_trans @trans_st src_state trans_state trans_next
      };

    -- Pull a value from the source stream
    next_from_source
      (src_state : src_st)
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case src_next src_state of {
        streamValue @src_st @(BoxedType a)
	  (next_src_state : src_st) (src_value : BoxedType a).

	  -- Apply the transformer to this value
	  case boxed @a (convertToBare @a repr_a src_value)
	  of boxed @a (src_uvalue : a).

	  case trans src_uvalue of linStream @dim1 @b @(trans_st : box)
	                             (trans_state : trans_st)
				     (trans_next : trans_st -> StreamNext trans_st (BoxedType b)).

          -- Pull a value from the transformed stream
          next_from_trans @trans_st next_src_state trans_state trans_next;

	streamEmpty @src_st @(BoxedType a).
	  -- Stream is depleted
	  streamEmpty @(BindState src_st a b) @(BoxedType b)
      };

    -- Pull a value from the transformed stream
    next_from_trans
      @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st (BoxedType b))
      -> StreamNext (BindState src_st a b) (BoxedType b) =
      case trans_next trans_state of {
        streamValue @trans_st @(BoxedType b)
	  (next_trans_state : trans_st) (trans_value : BoxedType b).

	  streamValue @(BindState src_st a b) @(BoxedType b)
	    (bindFromTrans @src_st @a @b @trans_st
	     src_state next_trans_state trans_next)
	    trans_value;

	streamEmpty @trans_st @(BoxedType b).
	  -- Pull a new value from the source stream
	  next_from_source src_state
      }
  } in linStream @dim1 @b @(BindState src_st a b)
         (bindFromSource @src_st @a @b src_state)
	 next;


-- 'bind' is a renamed version of 'oper_CAT_MAP'.
bind @(N : intindex) @(sh a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (src : Stream (arr_shape N dim0) a)
  (trans : a -> Stream sh b)
  -> Stream (arr_shape N sh) b 
  attribute(inline_final) =
  case oper_CAT_MAP @a @b repr_a repr_b
       (fun_asList_Stream @(arr_shape N dim0) @a src)
       (\ (x : a) -> Stream dim1 b. fun_asList_Stream @sh @b (trans x))
  of linStream @dim1 @b @(st : box) (state : st) (next : st -> StreamNext st (BoxedType b)).
  linStream @(arr_shape N sh) @b @st state next;



-} -- END

fromIndInt @(N : intindex) (ii : IndInt N) -> FinIndInt N =
  case ii of {
    indInt @N (fii : FinIndInt N). fii;
    indOmega @N (pf : Pf (eqZ N pos_infty)). except @(FinIndInt N)
  };

-------------------------------------------------------------------------------
-- Array functions

array_traverse @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FinIndInt N) (ay : arr N a)
  -> Stream (arr_shape N dim0) a =
  generate @N @a (indInt @N size) repr
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr (subscript @N @a repr ay i) ret);

array_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FinIndInt N)
  (s : Stream (arr_shape N dim0) a)
  (ret : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline_final) =

  case s of linStream @(arr_shape N dim0) @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case size of finIndInt @N (bound : int).

  letfun
    go (i : int) (state : st) -> EffTok =
      if EqDict_int_eq i bound
      then emptyEffTok
      else case stream_next state of {

             -- Obtain value from stream
             streamValue @st @(BoxedType a)
	       (next_state : st) (result : BoxedType a).
               -- Write into the array
	       seqEffTok (toEffTok @a (convertToBare @a repr result
	       		               (subscript_out @N @a repr ret i)))
                         (go (AdditiveDict_int_add i 1) next_state);

             streamEmpty @st @(BoxedType a).
	       except @EffTok
	   }
  in fromEffTok @(arr N a) (go 0 stream_state);

-------------------------------------------------------------------------------
-- List functions

histogram @(sh : bare)
  (size : int)
  (input : Stream sh (Stored int))
  (ret : OutPtr (list (Stored int)))
  -> IEffect (list (Stored int)) =
  case defineIntIndex size of someIndInt @(N : intindex) (index : FinIndInt N).
  make_list @(Stored int) @N index
  (referenced @(arr N (Stored int))
   (histogramArray @sh @N index input))
  ret;

-------------------------------------------------------------------------------
-- Matrix functions

rows @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr : Repr a)
  (container : t a)
  -> Writer (view1 (view1 a)) =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
   @(Mlo M Nlo N : intindex)
    (ymin : IndInt Mlo)
    (height : IndInt M)
    (xmin : IndInt Nlo)
    (width : IndInt N).

  let fymin : FinIndInt Mlo = fromIndInt @Mlo ymin in
  let fheight : FinIndInt M = fromIndInt @M height in
  let fxmin : FinIndInt Nlo = fromIndInt @Nlo xmin in
  let fwidth : FinIndInt N = fromIndInt @N width in

  mk_view1 @(view1 a) @Mlo @M fymin fheight
  (\ (y : int) -> Writer (view1 a).
    mk_view1 @a @Nlo @N fxmin fwidth
    (\ (x : int) (ret : OutPtr a) -> IEffect a.
      case boxed @(index dim2)
           (pyonTuple2 @(Stored int) @(Stored int)
            (stored @int y) (stored @int x)) of
        boxed @(index dim2) (ix : index dim2).
      at_point @a repr container
      (coerce @(index dim2) @(index (shape t)) ix)
      ret));

cols @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr : Repr a)
  (container : t a)
  -> Writer (view1 (view1 a)) =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
   @(Mlo M Nlo N : intindex)
    (ymin : IndInt Mlo)
    (height : IndInt M)
    (xmin : IndInt Nlo)
    (width : IndInt N).

  let fymin : FinIndInt Mlo = fromIndInt @Mlo ymin in
  let fheight : FinIndInt M = fromIndInt @M height in
  let fxmin : FinIndInt Nlo = fromIndInt @Nlo xmin in
  let fwidth : FinIndInt N = fromIndInt @N width in

  mk_view1 @(view1 a) @Nlo @N fxmin fwidth
  (\ (x : int) -> Writer (view1 a).
    mk_view1 @a @Mlo @M fymin fheight
    (\ (y : int) (ret : OutPtr a) -> IEffect a.
      case boxed @(index dim2)
           (pyonTuple2 @(Stored int) @(Stored int)
            (stored @int y) (stored @int x)) of
        boxed @(index dim2) (ix : index dim2).
      at_point @a repr container
      (coerce @(index dim2) @(index (shape t)) ix)
      ret));

outerproduct @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim2 c
  attribute (inline_final) =

  -- Convert arguments to lists
  case boxed @(list a) (TraversableDict_list_build @a repr_a sa) of
    boxed @(list a) (la : list a).
  case la of make_list @a @(M : intindex)
       	     (size_y : FinIndInt M) (ayref_a : Referenced (arr M a)).
  case ayref_a of referenced @(arr M a) (ay_a : arr M a).

  case boxed @(list b) (TraversableDict_list_build @b repr_b sb) of
    boxed @(list b) (lb : list b).
  case lb of make_list @b @(N : intindex)
       	     (size_x : FinIndInt N) (ayref_b : Referenced (arr N b)).
  case ayref_b of referenced @(arr N b) (ay_b : arr N b).

  -- Create a array2 stream
  matrixStream @c @M @N (indInt @M size_y) (indInt @N size_x)
  (bind @M @(arr_shape N dim0) @a @c repr_a repr_c
  (array_traverse @M @a repr_a size_y ay_a)
  (\ (x : a) -> Stream (arr_shape N dim0) c.
    generate @N @c (indInt @N size_x) repr_c
    (\ (index : int) -> Writer c.
       let y : b = subscript @N @b repr_b ay_b index in
       f x y)));

{-
transpose @(a : bare)
  (repr : Repr a) (mat : array2 a) (ret : OutPtr (view2 a))
  -> IEffect (view2 a) =
  case mat of mk_array2 @a @(M : intindex) @(N : intindex)
       	      (height : FinIndInt M) (width : FinIndInt N)
      	      (aref : Referenced (arr M (arr N a))).
  case aref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).
  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in

  mk_view2 @a @N @M width height
  (\ (y : int) (x : int) -> Writer a.
    copy @a repr (subscript @N @a repr (subscript @M @(arr N a) row_repr ay x) y))
  ret;-}


stencil2D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (repr_a : Repr a) (repr_b : Repr b)
  (ymin : int) (ymax : int) (xmin : int) (xmax : int)
  (stencilfn : view2 a -> Writer b)
  (inp : t a)
  -> Writer (array2 b) =

  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  -- Stencil must span at least one element
  let stencil_size_y : int =
       AdditiveDict_int_add (AdditiveDict_int_sub ymax ymin) 1 in
  let stencil_size_x : int =
       AdditiveDict_int_add (AdditiveDict_int_sub xmax xmin) 1 in
  if or (OrdDict_int_le stencil_size_y 0) (OrdDict_int_le stencil_size_x 0)
  then except @(Writer (array2 b)) else

  -- Create stencil dimensions
  case defineIntIndex ymin of
    someIndInt @(stencil_Mlo : intindex) (stencil_ymin : FinIndInt stencil_Mlo).
  case defineIntIndex xmin of
    someIndInt @(stencil_Nlo : intindex) (stencil_xmin : FinIndInt stencil_Nlo).
  case defineIntIndex stencil_size_y of
    someIndInt @(stencil_M : intindex) (stencil_height : FinIndInt stencil_M).
  case defineIntIndex stencil_size_x of
    someIndInt @(stencil_N : intindex) (stencil_width : FinIndInt stencil_N).

  -- Inspect the input data
  case boxed @(shape t) (get_shape @a inp) of boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
    @(Mlo M Nlo N : intindex)
    (inp_ymin : IndInt Mlo)
    (inp_height : IndInt M)
    (inp_xmin : IndInt Nlo)
    (inp_width : IndInt N).
    let f_inp_height : FinIndInt M = fromIndInt @M inp_height in
    let f_inp_width : FinIndInt N = fromIndInt @N inp_width in
    case fromIndInt @Mlo inp_ymin of
      finIndInt @Mlo (inp_ymin_i : int).
    case fromIndInt @Nlo inp_xmin of
      finIndInt @Nlo (inp_xmin_i : int).
    case f_inp_height of
      finIndInt @M (inp_height_i : int).
    case f_inp_width of
      finIndInt @N (inp_width_i : int).

    let inp_ymax_i : int =
          AdditiveDict_int_sub (AdditiveDict_int_add inp_ymin_i inp_height_i) 1 in
    let inp_xmax_i : int =
          AdditiveDict_int_sub (AdditiveDict_int_add inp_xmin_i inp_width_i) 1 in

    let row_repr : Repr (arr N b) = repr_arr @N @b (fromIndInt @N inp_width) repr_b in

    letfun {
      -- Read from the input array2 view.  Ensure that accesses do not go
      -- outside array bounds.
      safe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
        -> Writer a =
        -- Read one element from the input for a stencil at point (pty, ptx).
        -- The coordinate to read is (pty + yoff, ptx + xoff).
        -- The image is padded at the edges.
        let yindex : int = AdditiveDict_int_add pty yoff in
        let xindex : int = AdditiveDict_int_add ptx xoff in
        let bounded_yindex : int =
              max_int inp_ymin_i (min_int yindex inp_ymax_i) in
        let bounded_xindex : int =
              max_int inp_xmin_i (min_int xindex inp_xmax_i) in
	case boxed @(index dim2)
	     (pyonTuple2 @(Stored int) @(Stored int)
	      (stored @int bounded_yindex) (stored @int bounded_xindex)) of
	  boxed @(index dim2) (ix : index dim2).
        at_point @a repr_a inp (coerce @(index dim2) @(index (shape t)) ix);

      -- Read from the input array2 view.  Assume that the given
      -- offsets do not produce out-of-bounds array accesses.
      unsafe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
        -> Writer a =
        -- Read one element from the input for a stencil at point (pty, ptx).
        -- The coordinate to read is (pty + yoff, ptx + xoff).
        -- The image is padded at the edges.
        let yindex : int = AdditiveDict_int_add pty yoff in
        let xindex : int = AdditiveDict_int_add ptx xoff in
	case boxed @(index dim2)
	     (pyonTuple2 @(Stored int) @(Stored int)
	      (stored @int yindex) (stored @int xindex)) of
	  boxed @(index dim2) (ix : index dim2).
        at_point @a repr_a inp (coerce @(index dim2) @(index (shape t)) ix);

      -- Initialize a region of the output array.
      -- The region is given as an origin (y, x) and
      -- extent (delta y, delta x).
      initialize_array
        (origin_y : int) (origin_x : int) (delta_y : int) (delta_x : int)
        (getter : int -> int -> int -> int -> Writer a)
        (ret : OutPtr (arr M (arr N b)))
        -> IEffect (arr M (arr N b)) =
        case defineIntIndex delta_y of
          someIndInt @(Minit : intindex) (rgn_height : FinIndInt Minit).
        case defineIntIndex delta_x of
          someIndInt @(Ninit : intindex) (rgn_width : FinIndInt Ninit).

        -- Loop over region
        doall @Minit @(arr M (arr N b)) @(arr N b) rgn_height
        (\ (loop_y : int) -> IEffect (arr N b).
          doall @Ninit @(arr N b) @b rgn_width
          (\ (loop_x : int) -> IEffect b.
             let y : int = AdditiveDict_int_add origin_y loop_y in
             let x : int = AdditiveDict_int_add origin_x loop_x in
             case boxed @(view2 a)
                  (mk_view2 @a
                   @stencil_Mlo @stencil_M @stencil_Nlo @stencil_N
                   stencil_ymin stencil_height stencil_xmin stencil_width
                   (getter y x))
             of boxed @(view2 a) (mv : view2 a).
             -- Pass the array2 view to the stencil function
             stencilfn mv (subscript_out @N @b repr_b
                           (subscript_out @M @(arr N b)
                            row_repr ret y) x)))
    } in

    -- Bounds checking is needed around the edges of the array, but not in
    -- the interior.  Compute the size of the edges and the interior.
    let left_boundary_size : int =
          max_int 0 (AdditiveDict_int_negate xmin) in
    let right_boundary_size : int =
          max_int 0 xmax in
    let top_boundary_size : int =
          max_int 0 (AdditiveDict_int_negate ymin) in
    let bottom_boundary_size : int =
          max_int 0 ymax in
    let center_width : int =
          AdditiveDict_int_sub inp_width_i
          (AdditiveDict_int_add left_boundary_size right_boundary_size) in
    let center_height : int =
          AdditiveDict_int_sub inp_height_i
          (AdditiveDict_int_add top_boundary_size bottom_boundary_size) in

    -- Origin of center, left, and right regions
    let center_origin_y : int = top_boundary_size in

    -- Origin of center region
    let center_origin_x : int = left_boundary_size in

    let right_origin_x : int =
          AdditiveDict_int_sub inp_width_i right_boundary_size in

    let bottom_origin_y : int =
          AdditiveDict_int_sub inp_height_i bottom_boundary_size in

    -- Create return value
    mk_array2 @b @M @N f_inp_height f_inp_width
    (referenced @(arr M (arr N b))
     (if or (OrdDict_int_lt center_width 1) (OrdDict_int_lt center_height 1)
     then
       -- Input array2 is smaller than stencil.  Use one loop for the
       -- entire output array.
       initialize_array 0 0 inp_height_i inp_width_i safe_get
     else
       -- Use one loop each for the left, right, top, bottom, and center of
       -- the output.  The corners of the output array are part of the top
       -- and bottom strips.
       (\ (ret_array : OutPtr (arr M (arr N b)))
          -> IEffect (arr M (arr N b)).
          fromEffTok @(arr M (arr N b))
          (seqEffTok
           (seqEffTok
            (toEffTok @(arr M (arr N b)) -- Top strip
             (initialize_array 0 0 top_boundary_size inp_width_i safe_get ret_array))
            (toEffTok @(arr M (arr N b)) -- Bottom strip
             (initialize_array bottom_origin_y 0 bottom_boundary_size inp_width_i safe_get ret_array)))
           (seqEffTok
            (seqEffTok
             (toEffTok @(arr M (arr N b)) -- Left strip
              (initialize_array center_origin_y 0 center_height left_boundary_size safe_get ret_array))
             (toEffTok @(arr M (arr N b)) -- Right strip
              (initialize_array center_origin_y right_origin_x center_height right_boundary_size safe_get ret_array)))
            (toEffTok @(arr M (arr N b)) -- Center region
             (initialize_array center_origin_y center_origin_x center_height center_width unsafe_get ret_array)))))));

-------------------------------------------------------------------------------
-- List container class functions

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : bare) (repr : Repr a) (ls : list a)
  -> Stream dim1 a =
  case ls of make_list @a @(N : intindex)
                       (size : FinIndInt N) (aref : Referenced (arr N a)).
  case aref of referenced @(arr N a) (ay : arr N a).
  LinStream_flatten @(arr_shape N dim0) @a
  (array_traverse @N @a repr size ay);


IndexableDict_list_at_point @(a : bare)
  (repr : Repr a) (ls : list a) (ix : Stored int) (ret : OutPtr a)
  -> IEffect a =

  -- Deconstruct data structures
  case ls of make_list @a @(N : intindex)
             (size : FinIndInt N) (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).
  case size of finIndInt @N (size_int : int).
  case ix of stored @int (ix_u : int).

  copy @a repr (subscript @N @a repr ay ix_u) ret;


IndexableDict_list_at_slice @(a : bare)
  (repr : Repr a) (ls : list a)
  (slice : PyonTuple3 (Stored int) (Stored int) (Stored int))
  (ret : OutPtr (view1 a)) -> IEffect (view1 a) =

  case slice of pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
       	     	(start_s : Stored int) (delta_s : Stored int) (stride_s : Stored int).
  case start_s of stored @int (start : int).
  case delta_s of stored @int (delta : int).
  case stride_s of stored @int (stride : int).

  case ls of make_list @a @(N : intindex)
       	     (list_size : FinIndInt N) (ayref : Referenced (arr N a)).
  case list_size of finIndInt @N (list_size_i : int).
  case ayref of referenced @(arr N a) (ay : arr N a).

  let count : int =
        -- Ceiling division
	let interval_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta stride) 1 in
	RemainderDict_int_floordiv interval_rounded stride in
  case defineIntIndex count of someIndInt @(L : intindex) (count_i : FinIndInt L).
  mk_view1 @a @0 @L (finIndInt @0 0) count_i
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     let index : int =
           AdditiveDict_int_add start (MultiplicativeDict_int_mul i stride) in
     copy @a repr (subscript @N @a repr ay index) ret)
  ret;


IndexableDict_list_get_shape @(a : bare)
  (ls : list a) (ret : OutPtr dim1) -> IEffect dim1 =

  case ls of make_list @a @(N : intindex)
       	     (length : FinIndInt N)
	     (aptr : Referenced (arr N a)).

  mk_dim1 @0 @N (indInt @0 (finIndInt @0 0)) (indInt @N length) ret;


-------------------------------------------------------------------------------
-- view1 container class functions

TraversableDict_view1_traverse @(a : bare)
  (repr : Repr a) (ls : view1 a) -> Stream dim1 a =
  case ls of mk_view1 @a @(Nlo N : intindex)
       	     (xmin : FinIndInt Nlo) (size : FinIndInt N) (f : int -> Writer a).
  LinStream_flatten @(arr_shape N dim0) @a
  (generate @N @a (indInt @N size) repr f);


TraversableDict_view1_build @(a : bare)
  (repr : Repr a) (s : Stream dim1 a) (ret : OutPtr (view1 a))
  -> IEffect (view1 a) =

  -- Build a list, then create a list view from it
  case boxed @(list a) (TraversableDict_list_build @a repr s) of boxed @(list a) (ls : list a).
  case ls of make_list @a @(N : intindex) (list_size : FinIndInt N) (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).

  mk_view1 @a @0 @N  (finIndInt @0 0) list_size
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
    copy @a repr (subscript @N @a repr ay i) ret)
  ret;


IndexableDict_ListView_at_point @(a : bare)
  (repr : Repr a) (ls : view1 a) (ix : int) (ret : OutPtr a) -> IEffect a =

  case ls of mk_view1 @a @(Nlo N : intindex)
             (xmin : FinIndInt Nlo) (size : FinIndInt N) (generator : int -> Writer a).
  case xmin of finIndInt @Nlo (xmin_i : int).
  case size of finIndInt @N (size_int : int).
  let xmax_i : int =
        AdditiveDict_int_sub (AdditiveDict_int_add xmin_i size_int) 1 in

  if or (OrdDict_int_lt ix xmin_i) (OrdDict_int_gt ix xmax_i)
  then except @(IEffect a)
  else generator ix ret;


IndexableDict_ListView_at_slice @(a : bare)
  (repr : Repr a) (ls : view1 a)
  (start : int) (delta : int) (stride : int)
  (ret : OutPtr (view1 a)) -> IEffect (view1 a) =

  case ls of mk_view1 @a @(Nlo N : intindex)
       	     (xmin : FinIndInt Nlo)
	     (list_size : FinIndInt N)
	     (generator : int -> Writer a).
  case xmin of finIndInt @Nlo (xmin_i : int).
  case list_size of finIndInt @N (list_size_i : int).
  let xmax_i : int =
        AdditiveDict_int_sub (AdditiveDict_int_add xmin_i list_size_i) 1 in
  
  let count : int =
        -- Ceiling division
	let interval_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta stride) 1 in
	RemainderDict_int_floordiv interval_rounded stride in
  case defineIntIndex count of someIndInt @(L : intindex) (count_i : FinIndInt L).
  mk_view1 @a @0 @L  (finIndInt @0 0) count_i
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     let index : int =
           AdditiveDict_int_add start (MultiplicativeDict_int_mul i stride) in
     generator index ret)
  ret;

-------------------------------------------------------------------------------
-- Stream Traversable functions

TraversableDict_Stream_build @(sh : bare) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a = s;

TraversableDict_Stream_traverse @(sh : bare) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a = s;


-------------------------------------------------------------------------------
-- List-specific stream functions

fun_asList_Stream @(sh a : bare)
  (shape_dict : ShapeDict sh) (src : Stream sh a) -> Stream dim1 a =
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  shape_flatten @a src;


range (n : int) -> Stream dim1 (Stored int) =
  case defineIntIndex n of someIndInt @(ix : intindex) (val : FinIndInt ix).
    LinStream_flatten @(arr_shape ix dim0) @(Stored int)
    (rangeIndexed @ix (indInt @ix val));


rangeIndexed @(N : intindex) (count : IndInt N)
  -> Stream (arr_shape N dim0) (Stored int) =
  generate @N @(Stored int) count repr_int
  (\ (i : int) -> Writer (Stored int). stored @int i);


oper_GUARD @(a : bare) (repr : Repr a) (arg : bool) (s : Stream dim1 a)
  -> Stream dim1 a =
  if arg then s else oper_EMPTY @a repr;


oper_EMPTY @(a : bare) (repr : Repr a) -> Stream dim1 a
  attribute(inline_final) =
  linStream @dim1 @a @(Boxed (Stored NoneType))
  (boxed @(Stored NoneType) (stored @NoneType None))
  (\ (state : Boxed (Stored NoneType)) -> StreamNext (Boxed (Stored NoneType)) (BoxedType a).
    streamEmpty @(Boxed (Stored NoneType)) @(BoxedType a));


generate @(N : intindex) @(a : bare)
         (count : IndInt N) (repr : Repr a) (f : int -> Writer a)
 -> Stream (arr_shape N dim0) a
  attribute(inline_final) =

  case count of {
    indInt @N (fin : FinIndInt N).
      -- Finite case
      case fin of finIndInt @N (bound : int).
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

	  -- End of loop?
          if EqDict_int_eq i bound
          then streamEmpty @(Boxed (Stored int)) @(BoxedType a)
	  else let retval : BoxedType a =
                    convertToBoxed @a repr (f i) in

               -- Apply the generator function
               streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in linStream @(arr_shape N dim0) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next;

    indOmega @N (pf : Pf (eqZ N pos_infty)).
      -- Infinite case
      letfun
        next (st : Boxed (Stored int))
	  -> StreamNext (Boxed (Stored int)) (BoxedType a) =

          -- Get the integer value from the state
          case st of boxed @(Stored int) (stored_i : Stored int).
          case stored_i of stored @int (i : int).

          let new_st : Boxed (Stored int) =
                boxed @(Stored int) (stored @int (AdditiveDict_int_add i 1)) in

          let retval : BoxedType a =
                convertToBoxed @a repr (f i) in

          -- Apply the generator function
          streamValue @(Boxed (Stored int)) @(BoxedType a) new_st retval

      in linStream @(arr_shape N dim0) @a @(Boxed (Stored int))
         (boxed @(Stored int) (stored @int 0)) next
  };

-------------------------------------------------------------------------------
-- Matrix-specific stream methods

fun_from_MatrixView_Stream @(a : bare)
  (s : Stream dim2 a) -> Stream dim2 a = s;

fun_asMatrix_Stream @(M N : intindex) @(a : bare)
  (size_y : IndInt M)
  (size_x : IndInt N)
  (src : Stream (arr_shape M (arr_shape N dim0)) a)
  -> Stream dim2 a =
  matrixStream @a @M @N size_y size_x src;


chunk_id @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size : IndInt N)
  (s : Stream (arr_shape M (arr_shape N dim0)) a)
  -> Stream (arr_shape M dim0) (StoredBox (Stream (arr_shape N dim0) a)) =

  chunk @M @N @a @(StoredBox (Stream (arr_shape N dim0) a))
  repr
  (repr_Box @(Stream (arr_shape N dim0) a))
  size
  s
  (\ (x : (Stream (arr_shape N dim0) a))
     -> Writer (StoredBox (Stream (arr_shape N dim0) a)).
     storedBox @(Stream (arr_shape N dim0) a) x);

-------------------------------------------------------------------------------
-- Matrix container class functions

TraversableDict_array2_traverse @(a : bare)
  (repr : Repr a) (m : array2 a) -> Stream dim2 a =
  case m of mk_array2 @a @(M : intindex) @(N : intindex)
            (size_y : FinIndInt M) (size_x : FinIndInt N)
	    (ayref : Referenced (arr M (arr N a))).
  case ayref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).

  matrixStream @a @M @N (indInt @M size_y) (indInt @N size_x)
  (bind @M @(arr_shape N dim0) @(arr N a) @a
   (repr_arr @N @a size_x repr)
   repr
   (array_traverse @M @(arr N a) (repr_arr @N @a size_x repr) size_y ay)
   (array_traverse @N @a repr size_x));


TraversableDict_array2_build @(a : bare)
  (repr : Repr a) (s : Stream dim2 a) (ret : OutPtr (array2 a))
  -> IEffect (array2 a) =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	    (size_y : IndInt M) (size_x : IndInt N)
	    (ls : LinStream (arr_shape M (arr_shape N dim0)) a).

  case size_y of {
    indInt @M (fsize_y : FinIndInt M).
      case size_x of {
        indInt @N (fsize_x : FinIndInt N).
          mk_array2 @a @M @N fsize_y fsize_x
          (referenced @(arr M (arr N a))
           (array_build @M @(arr N a) (repr_arr @N @a fsize_x repr) fsize_y
            (chunk @M @N @a @(arr N a) repr (repr_arr @N @a fsize_x repr)
	     size_x ls
             (array_build @N @a repr fsize_x)))) ret;

        indOmega @N (pf : Pf (eqZ N pos_infty)).
	  except @(IEffect (array2 a))
      };

    indOmega @M (pf : Pf (eqZ M pos_infty)).
      except @(IEffect (array2 a))
  };


IndexableDict_matrix_at_point @(a : bare)
  (repr : Repr a)
  (mat : array2 a)
  (ix : PyonTuple2 (Stored int) (Stored int))
  (ret : OutPtr a)
  -> IEffect a =
  case mat of mk_array2 @a @(M : intindex) @(N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (ayptr : Referenced (arr M (arr N a))).
  case ayptr of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).
  case ix of pyonTuple2 @(Stored int) @(Stored int) (y_s : Stored int) (x_s : Stored int).
  case y_s of stored @int (y : int).
  case x_s of stored @int (x : int).

  let array_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  let value : a =
        subscript @N @a repr (subscript @M @(arr N a) array_repr ay y) x in
  copy @a repr value ret;


IndexableDict_matrix_at_slice @(a : bare)
  (repr : Repr a)
  (mat : array2 a)
  (slice_value : slice dim2)
  (ret : OutPtr (view2 a))
  -> IEffect (view2 a) =

  case mat of mk_array2 @a @(M : intindex) @(N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (ayptr : Referenced (arr M (arr N a))).
  case ayptr of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).

  case slice_value of pyonTuple2
       		      @(PyonTuple3 (Stored int) (Stored int) (Stored int))
       		      @(PyonTuple3 (Stored int) (Stored int) (Stored int))
		      (y_slice : PyonTuple3 (Stored int) (Stored int) (Stored int))
		      (x_slice : PyonTuple3 (Stored int) (Stored int) (Stored int)).
  case y_slice of pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
       	          (start_y_s : Stored int) (delta_y_s : Stored int) (stride_y_s : Stored int).
  case start_y_s of stored @int (start_y : int).
  case delta_y_s of stored @int (delta_y : int).
  case stride_y_s of stored @int (stride_y : int).

  case x_slice of pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
       	          (start_x_s : Stored int) (delta_x_s : Stored int) (stride_x_s : Stored int).
  case start_x_s of stored @int (start_x : int).
  case delta_x_s of stored @int (delta_x : int).
  case stride_x_s of stored @int (stride_x : int).

  let count_y : int =
        -- Ceiling division
	let interval_y_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta_y stride_y) 1 in
	RemainderDict_int_floordiv interval_y_rounded stride_y in
  case defineIntIndex count_y of someIndInt @(K : intindex) (count_y_i : FinIndInt K).

  let count_x : int =
        -- Ceiling division
	let interval_x_rounded : int =
	      AdditiveDict_int_sub (AdditiveDict_int_add delta_x stride_x) 1 in
	RemainderDict_int_floordiv interval_x_rounded stride_x in
  case defineIntIndex count_x of someIndInt @(L : intindex) (count_x_i : FinIndInt L).

  mk_view2 @a @0 @K @0 @L
  (finIndInt @0 0)
  count_y_i
  (finIndInt @0 0)
  count_x_i
  (\ (j : int) (i : int) (ret : OutPtr a) -> IEffect a.
     let y : int =
           AdditiveDict_int_add start_y (MultiplicativeDict_int_mul j stride_y) in
     let x : int =
           AdditiveDict_int_add start_x (MultiplicativeDict_int_mul i stride_x) in
     let array_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
     let value : a =
           subscript @N @a repr (subscript @M @(arr N a) array_repr ay y) x in
     copy @a repr value ret) ret;


IndexableDict_matrix_get_shape @(a : bare)
  (mat : array2 a)
  (ret : OutPtr dim2)
  -> IEffect dim2 =
  case mat of mk_array2 @a @(M N : intindex)
       	      (size_y : FinIndInt M) (size_x : FinIndInt N)
	      (ayptr : Referenced (arr M (arr N a))).
  mk_dim2 @0 @M @0 @N
  (indInt @0 (finIndInt @0 0)) (indInt @M size_y)
  (indInt @0 (finIndInt @0 0)) (indInt @N size_x) ret;

-------------------------------------------------------------------------------
-- view2 container class functions

TraversableDict_view2_traverse @(a : bare)
  (repr : Repr a) (mat : view2 a) -> Stream dim2 a =

  case mat of mk_view2 @a @(Mlo M Nlo N : intindex)
       	      (ymin : FinIndInt Mlo)
	      (size_y : FinIndInt M)
	      (xmin : FinIndInt Nlo)
	      (size_x : FinIndInt N)
	      (f : int -> int -> Writer a).
  matrixStream @a @M @N (indInt @M size_y) (indInt @N size_x)
  (bind @M @(arr_shape N dim0) @(Stored int) @a repr_int repr
   (generate @M @(Stored int) (indInt @M size_y) repr_int (stored @int))
   (\ (y_stored : Stored int) -> Stream (arr_shape N dim0) a.
      case y_stored of stored @int (y : int).
      generate @N @a (indInt @N size_x) repr
      (\ (x : int) -> Writer a. f y x)));

IndexableDict_MatrixView_at_point @(a : bare)
  (repr : Repr a)
  (mat : view2 a)
  (ix : index dim2)
  (ret : OutPtr a)
  -> IEffect a =
  case mat of mk_view2 @a @(Mlo M Nlo N : intindex)
       	      (ymin : FinIndInt Mlo) (height : FinIndInt M)
       	      (xmin : FinIndInt Nlo) (width : FinIndInt N)
	      (get : int -> int -> Writer a).
  case ix of pyonTuple2 @(Stored int) @(Stored int) (y_s : Stored int) (x_s : Stored int).
  case y_s of stored @int (y : int).
  case x_s of stored @int (x : int).
  get y x ret;

IndexableDict_MatrixView_get_shape @(a : bare)
  (mat : view2 a)
  (ret : OutPtr dim2)
  -> IEffect dim2 =
  case mat of mk_view2 @a @(Mlo M Nlo N : intindex)
       	      (ymin : FinIndInt Mlo) (height : FinIndInt M)
       	      (xmin : FinIndInt Nlo) (width : FinIndInt N)
	      (get : int -> int -> Writer a).
  mk_dim2 @Mlo @M @Nlo @N
  (indInt @Mlo ymin) (indInt @M height) (indInt @Nlo xmin) (indInt @N width)
  ret;

-------------------------------------------------------------------------------
-- Generic container methods

len @(t : bare -> bare) @(a : bare)
  (is_linear : coerce @box (BoxedType (shape t)) (Boxed dim1))
  (indexable : IndexableDict t)
  (x : t a) -> int =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @(shape t) (get_shape @a x) of boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim1 shp of
    mk_dim1 @(Nlo N : intindex)
    	          (minix : IndInt Nlo)
	          (fii : IndInt N).
  case fromIndInt @N fii of finIndInt @N (x : int).
  x;


safeIndex @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (ix : index (shape t))
  (ret : OutPtr a)
  -> IEffect a =
  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).
  case shape_dict of shapeDict @(shape t)
    (index_repr : Repr (index (shape t)))
    (slice_repr : Repr (slice (shape t)))
    (shape_flatten : (a : bare) -> Stream (shape t) a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream (shape t) a -> Stream (shape t) b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream (shape t) a -> Stream (shape t) b -> Stream (shape t) c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream (shape t) a -> Stream (shape t) b -> Stream (shape t) c -> Stream (shape t) d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream (shape t) a -> Stream (shape t) b -> Stream (shape t) c -> Stream (shape t) d -> Stream (shape t) e)
    (shape_in_range : shape t -> index (shape t) -> bool)
    (shape_coerce_slice : shape t -> slice (shape t) -> Writer (Maybe (slice (shape t)))).

  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (container_shape : shape t).

  if shape_in_range container_shape ix
  then at_point @a repr container ix ret
  else except @(IEffect a);


safeSlice @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (slice_value : slice (shape t))
  (ret : OutPtr (view (shape t) a))
  -> IEffect (view (shape t) a) =

  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case shape_dict of shapeDict @(shape t)
    (index_repr : Repr (index (shape t)))
    (slice_repr : Repr (slice (shape t)))
    (shape_flatten : (a : bare) -> Stream (shape t) a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream (shape t) a -> Stream (shape t) b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream (shape t) a -> Stream (shape t) b -> Stream (shape t) c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream (shape t) a -> Stream (shape t) b -> Stream (shape t) c -> Stream (shape t) d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream (shape t) a -> Stream (shape t) b -> Stream (shape t) c -> Stream (shape t) d -> Stream (shape t) e)
    (shape_in_range : shape t -> index (shape t) -> bool)
    (shape_coerce_slice : shape t -> slice (shape t) -> Writer (Maybe (slice (shape t)))).

  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).

  case boxed @(Maybe (slice (shape t))) (shape_coerce_slice shp slice_value) of
    boxed @(Maybe (slice (shape t))) (m_co_slice : Maybe (slice (shape t))).
  
  case m_co_slice of {
    Just @(slice (shape t)) (co_slice : slice (shape t)).
      at_slice @a repr container co_slice ret;

    Nothing @(slice (shape t)).
      except @(IEffect (view (shape t) a))
  };


width @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (indexable : IndexableDict t)
  (container : t a)
  -> int =

  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
    @(Mlo M Nlo N : intindex)
    (inp_ymin : IndInt Mlo)
    (inp_height : IndInt M)
    (inp_xmin : IndInt Nlo)
    (inp_width : IndInt N).

  case fromIndInt @N inp_width of finIndInt @N (w : int). w;


height @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (BoxedType (shape t)) (Boxed dim2))
  (indexable : IndexableDict t)
  (container : t a)
  -> int =

  case indexable of
    indexableDict @t
    (at_point : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> slice (shape t) -> Writer (view (shape t) a))
    (get_shape : (a : bare) -> t a -> Writer (shape t)).

  case boxed @(shape t) (get_shape @a container) of
    boxed @(shape t) (shp : shape t).
  case coerce @(shape t) @dim2 shp of
    mk_dim2
    @(Mlo M Nlo N : intindex)
    (inp_ymin : IndInt Mlo)
    (inp_height : IndInt M)
    (inp_xmin : IndInt Nlo)
    (inp_width : IndInt N).

  case fromIndInt @M inp_height of finIndInt @M (h : int). h;

{-
safeIndex2 @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (repr : Repr a)
  (container : t a) (yix : int) (xix : int) -> Writer a =
  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (view2 a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).
  letfun
    get_member @(Mlo M Nlo N : intindex)
      (miny : FinIndInt Mlo) (ysize : FinIndInt M)
      (minx : FinIndInt Nlo) (xsize : FinIndInt N)
      (ret : OutPtr a) -> IEffect a =
      case miny of finIndInt @Mlo (pf : Pf (neZ Mlo pos_infty)) (miny_i : int).
      case minx of finIndInt @Nlo (pf : Pf (neZ Nlo pos_infty)) (minx_i : int).
      case ysize of finIndInt @M (pf : Pf (neZ M pos_infty)) (ysize_i : int).
      case xsize of finIndInt @N (pf : Pf (neZ N pos_infty)) (xsize_i : int).
      let maxy_i : int =
           AdditiveDict_int_sub (AdditiveDict_int_add miny_i ysize_i) 1 in
      let maxx_i : int =
           AdditiveDict_int_sub (AdditiveDict_int_add minx_i xsize_i) 1 in

      -- Bounds checking
      if or (or (OrdDict_int_lt xix minx_i) (OrdDict_int_gt xix maxx_i))
       	    (or (OrdDict_int_lt yix miny_i) (OrdDict_int_gt yix maxy_i))
      then except @(IEffect a)
      else at_point @a repr container yix xix ret

  in with_shape @a @a container (matrixShapeEliminator @a get_member);


safeSlice2 @(t : bare -> bare) @(a : bare)
  (indexable : Indexable2Dict t) (repr : Repr a)
  (container : t a)
  (start_y : int) (stop_y : int) (stride_y : int)
  (start_x : int) (stop_x : int) (stride_x : int)
   -> Writer (view2 a) =
  case indexable of
    indexable2Dict @t
    (at_point : (a : bare) -> Repr a -> t a -> int -> int -> Writer a)
    (at_slice : (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int -> Writer (view2 a))
    (with_shape : (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b).
  letfun
    get_slice @(Mlo M Nlo N : intindex)
      (miny : FinIndInt Mlo) (ysize : FinIndInt M)
      (minx : FinIndInt Nlo) (xsize : FinIndInt N)
      (ret : OutPtr (view2 a))
      -> IEffect (view2 a) =

      case miny of finIndInt @Mlo (pf : Pf (neZ Mlo pos_infty)) (miny_i : int).
      case minx of finIndInt @Nlo (pf : Pf (neZ Nlo pos_infty)) (minx_i : int).
      case ysize of finIndInt @M (pf : Pf (neZ M pos_infty)) (ysize_i : int).
      case xsize of finIndInt @N (pf : Pf (neZ N pos_infty)) (xsize_i : int).

      -- Slice does not include endpoint.  So the endpoint can be up to
      -- 1 + end of list.
      let endy : int = AdditiveDict_int_add miny_i ysize_i in
      let endx : int = AdditiveDict_int_add minx_i xsize_i in

      -- If slice is out of bounds, coerce to bounds
      let real_start_y : int = max_int start_y miny_i in
      let real_end_y : int = min_int stop_y endy in
      let real_start_x : int = max_int start_x minx_i in
      let real_end_x : int = min_int stop_x endx in

      -- Stride must be positive
      if OrdDict_int_le stride_y 0 then except @(IEffect (view2 a)) else
      if OrdDict_int_le stride_x 0 then except @(IEffect (view2 a)) else

      -- Compute interval spanned by slice.  If negative, coerce to zero.
      let delta_y : int =
            let iv : int = AdditiveDict_int_sub real_end_y real_start_y
            in max_int iv 0 in
      let delta_x : int =
            let iv : int = AdditiveDict_int_sub real_end_x real_start_x
            in max_int iv 0 in

      -- Get the slice
      at_slice @a repr container real_start_y delta_y stride_y real_start_x delta_x stride_x ret

  in with_shape @a @(view2 a) container
     (matrixShapeEliminator @(view2 a) get_slice);
-}

fun_reduce @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (init : a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  fun_reduce_Stream @(shape t) @a shape_dict
  repr reducer init (traverse @a repr input) ret;


fun_reduce1 @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  fun_reduce1_Stream @(shape t) @a shape_dict
  repr reducer (traverse @a repr input) ret;


fun_map @(t : bare -> bare) @(a : bare) @(b : bare)
        (traversable : TraversableDict t)
	(shape_dict : ShapeDict (shape t))
        (reprA : Repr a) (reprB : Repr b)
        (transformer : a -> Writer b)
        (input : t a)
        (ret : OutPtr (t b))
  -> IEffect (t b) =
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (build : (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a)).
  build @b reprB (fun_map_Stream @(shape t) @a @b shape_dict
                  reprA reprB transformer
                  (traverse @a reprA input)) ret;

fun_zip @(t1 t2 : bare -> bare) @(a : bare) @(b : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (equal12 : coerce @box (BoxedType (shape t1)) (BoxedType (shape t2)))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b)
        (inputA : t1 a) (inputB : t2 b)
  -> Stream (shape t1) (PyonTuple2 a b) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  fun_zip_Stream @(shape t1) @a @b shape_dict reprA reprB stream1 stream2;

fun_zip3 @(t1 t2 t3 : bare -> bare) @(a b c : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (equal12 : coerce @box (BoxedType (shape t1)) (BoxedType (shape t2)))
        (equal23 : coerce @box (BoxedType (shape t2)) (BoxedType (shape t3)))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c)
  -> Stream (shape t1) (PyonTuple3 a b c) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Writer (t3 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in
  fun_zip3_Stream @(shape t1) @a @b @c shape_dict reprA reprB reprC
  stream1 stream2 stream3;


fun_zip4 @(t1 t2 t3 t4 : bare -> bare) @(a b c d : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (traversable4 : TraversableDict t4)
        (equal12 : coerce @box (BoxedType (shape t1)) (BoxedType (shape t2)))
        (equal23 : coerce @box (BoxedType (shape t2)) (BoxedType (shape t3)))
        (equal34 : coerce @box (BoxedType (shape t3)) (BoxedType (shape t4)))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c) (reprD : Repr d)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c) (inputD : t4 d)
  -> Stream (shape t1) (PyonTuple4 a b c d) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Writer (t3 a)).
  case traversable4
  of traversableDict @t4
       (traverse4 : (a : bare) -> Repr a -> t4 a -> Stream (shape t4) a)
       (build4 : (a : bare) -> Repr a -> Stream (shape t4) a -> Writer (t4 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in
  let stream4 : Stream (shape t1) d =
        coerce @(Stream (shape t4) d) @(Stream (shape t1) d)
	(traverse4 @d reprD inputD) in
  fun_zip4_Stream @(shape t1) @a @b @c @d shape_dict reprA reprB reprC reprD
  stream1 stream2 stream3 stream4;

-------------------------------------------------------------------------------
-- Generic stream methods

fun_reduce_Stream @(sh a : bare) (shape_dict : ShapeDict sh) (repr_a : Repr a)
  (f : a -> a -> Writer a) (init : a) (s : Stream sh a) (ret : OutPtr a)
  -> IEffect a =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  LinStream_reduce @dim1 @a repr_a f init (shape_flatten @a s) ret;


-- reduce1 extracts the first value from the stream, then calls 'fold'
-- for the remaining values
fun_reduce1_Stream @(sh a : bare)
  (shape_dict : ShapeDict sh)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : Stream sh a)
  (ret : OutPtr a)
  -> IEffect a =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  LinStream_reduce1 @dim1 @a repr f (shape_flatten @a s) ret;


fun_map_Stream @(sh a b : bare)
  (shape_dict : ShapeDict sh) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : Stream sh a)
  -> Stream sh b =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  shape_map @a @b repr_a repr_b f src;


fun_zip_Stream @(sh a b : bare) (shape_dict : ShapeDict sh)
  (repr_a : Repr a) (repr_b : Repr b)
  (src_a : Stream sh a) (src_b : Stream sh b) -> Stream sh (PyonTuple2 a b) =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  shape_zipWith @a @b @(PyonTuple2 a b)
  repr_a repr_b (repr_PyonTuple2 @a @b repr_a repr_b)
  (\ (x : a) (y : b) -> Writer (PyonTuple2 a b).
    pyonTuple2 @a @b (copy @a repr_a x) (copy @b repr_b y))
  src_a src_b;


fun_zip3_Stream @(sh a b c : bare) (shape_dict : ShapeDict sh)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (src_a : Stream sh a) (src_b : Stream sh b) (src_c : Stream sh c)
  -> Stream sh (PyonTuple3 a b c) =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  shape_zipWith3 @a @b @c @(PyonTuple3 a b c)
  repr_a repr_b repr_c (repr_PyonTuple3 @a @b @c repr_a repr_b repr_c)
  (\ (x : a) (y : b) (z : c) -> Writer (PyonTuple3 a b c).
    pyonTuple3 @a @b @c (copy @a repr_a x) (copy @b repr_b y) (copy @c repr_c z))
  src_a src_b src_c;


fun_zip4_Stream @(sh a b c d : bare) (shape_dict : ShapeDict sh)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (src_a : Stream sh a) (src_b : Stream sh b) (src_c : Stream sh c) (src_d : Stream sh d)
  -> Stream sh (PyonTuple4 a b c d) =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_coerce_slice : sh -> slice sh -> Writer (Maybe (slice sh))).
  shape_zipWith4 @a @b @c @d @(PyonTuple4 a b c d)
  repr_a repr_b repr_c repr_d (repr_PyonTuple4 @a @b @c @d repr_a repr_b repr_c repr_d)
  (\ (x : a) (y : b) (z : c) (w : d) -> Writer (PyonTuple4 a b c d).
    pyonTuple4 @a @b @c @d (copy @a repr_a x) (copy @b repr_b y) (copy @c repr_c z) (copy @d repr_d w))
  src_a src_b src_c src_d;

-------------------------------------------------------------------------------
-- Other shape methods

ShapeDict_matrix_flatten @(a : bare) (s : Stream dim2 a)
  -> Stream dim1 a =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	                 (size_y : IndInt M) (size_x : IndInt N)
			 (ls : LinStream (arr_shape M (arr_shape N dim0)) a).
  LinStream_flatten @(arr_shape M (arr_shape N dim0)) @a ls;


ShapeDict_matrix_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (s : Stream dim2 a) -> Stream dim2 b =
  case s of matrixStream @a @(M : intindex) @(N : intindex)
       	                 (size_y : IndInt M) (size_x : IndInt N)
			 (ls : LinStream (arr_shape M (arr_shape N dim0)) a).
  matrixStream @b @M @N size_y size_x
  (LinStream_map @(arr_shape M (arr_shape N dim0)) @a @b repr_a repr_b f ls);


ShapeDict_matrix_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : Stream dim2 a) (src_b : Stream dim2 b)
  -> Stream dim2 c =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IndInt Ma) (size_a_x : IndInt Na)
    (ls_a : LinStream (arr_shape Ma (arr_shape Na dim0)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IndInt Mb) (size_b_x : IndInt Nb)
    (ls_b : LinStream (arr_shape Mb (arr_shape Nb dim0)) b).

  let size_y : IndInt (min_i Ma Mb) = min_ii @Ma @Mb size_a_y size_b_y in
  let size_x : IndInt (min_i Na Nb) = min_ii @Na @Nb size_a_x size_b_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @c @(min_i Ma Mb) @(min_i Na Nb) size_y size_x
  (bind
   @(min_i Ma Mb)
   @(arr_shape (min_i Na Nb) dim0)
   @(StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c))
   @c
   (repr_Box @(LinStream (arr_shape (min_i Na Nb) dim0) c))
   repr_c

   -- Zip in Y dimension
   (LinStream_zipWith_array
    @(StoredBox (LinStream (arr_shape Na dim0) a))
    @(StoredBox (LinStream (arr_shape Nb dim0) b))
    @(StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c))
    @Ma
    @Mb
    (repr_Box @(LinStream (arr_shape Na dim0) a))
    (repr_Box @(LinStream (arr_shape Nb dim0) b))
    (repr_Box @(LinStream (arr_shape (min_i Na Nb) dim0) c))
    (\ (inner_stream_a : StoredBox (LinStream (arr_shape Na dim0) a))
       (inner_stream_b : StoredBox (LinStream (arr_shape Nb dim0) b))
       -> Writer (StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c)).
       case inner_stream_a of
         storedBox @(LinStream (arr_shape Na dim0) a)
 	(sa : LinStream (arr_shape Na dim0) a).
       case inner_stream_b of
         storedBox @(LinStream (arr_shape Nb dim0) b)
 	(sb : LinStream (arr_shape Nb dim0) b).
       storedBox @(LinStream (arr_shape (min_i Na Nb) dim0) c)

         -- Zip in X dimension
         (LinStream_zipWith_array @a @b @c @Na @Nb repr_a repr_b repr_c f sa sb))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b))

   (\ (x : StoredBox (LinStream (arr_shape (min_i Na Nb) dim0) c))
      -> LinStream (arr_shape (min_i Na Nb) dim0) c.
      case x of storedBox @(LinStream (arr_shape (min_i Na Nb) dim0) c)
      	        (y : LinStream (arr_shape (min_i Na Nb) dim0) c).
      y));

    
ShapeDict_matrix_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : Stream dim2 a) (src_b : Stream dim2 b)
  (src_c : Stream dim2 c)
  -> Stream dim2 d =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IndInt Ma) (size_a_x : IndInt Na)
    (ls_a : LinStream (arr_shape Ma (arr_shape Na dim0)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IndInt Mb) (size_b_x : IndInt Nb)
    (ls_b : LinStream (arr_shape Mb (arr_shape Nb dim0)) b).

  case src_c of
    matrixStream @c @(Mc : intindex) @(Nc : intindex)
    (size_c_y : IndInt Mc) (size_c_x : IndInt Nc)
    (ls_c : LinStream (arr_shape Mc (arr_shape Nc dim0)) c).

  let size_y : IndInt (min_i (min_i Ma Mb) Mc) =
        min_ii @(min_i Ma Mb) @Mc (min_ii @Ma @Mb size_a_y size_b_y) size_c_y in
  let size_x : IndInt (min_i (min_i Na Nb) Nc) =
        min_ii @(min_i Na Nb) @Nc (min_ii @Na @Nb size_a_x size_b_x) size_c_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @d @(min_i (min_i Ma Mb) Mc) @(min_i (min_i Na Nb) Nc) size_y size_x
  (bind
   @(min_i (min_i Ma Mb) Mc)
   @(arr_shape (min_i (min_i Na Nb) Nc) dim0)
   @(StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
   @d
   (repr_Box @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
   repr_d

   -- Zip in Y dimension
   (LinStream_zipWith3_array
    @(StoredBox (LinStream (arr_shape Na dim0) a))
    @(StoredBox (LinStream (arr_shape Nb dim0) b))
    @(StoredBox (LinStream (arr_shape Nc dim0) c))
    @(StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
    @Ma
    @Mb
    @Mc
    (repr_Box @(LinStream (arr_shape Na dim0) a))
    (repr_Box @(LinStream (arr_shape Nb dim0) b))
    (repr_Box @(LinStream (arr_shape Nc dim0) c))
    (repr_Box @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
    (\ (inner_stream_a : StoredBox (LinStream (arr_shape Na dim0) a))
       (inner_stream_b : StoredBox (LinStream (arr_shape Nb dim0) b))
       (inner_stream_c : StoredBox (LinStream (arr_shape Nc dim0) c))
       -> Writer (StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d)).
       case inner_stream_a of
         storedBox @(LinStream (arr_shape Na dim0) a)
 	(sa : LinStream (arr_shape Na dim0) a).
       case inner_stream_b of
         storedBox @(LinStream (arr_shape Nb dim0) b)
 	(sb : LinStream (arr_shape Nb dim0) b).
       case inner_stream_c of
         storedBox @(LinStream (arr_shape Nc dim0) c)
 	(sc : LinStream (arr_shape Nc dim0) c).
       storedBox @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d)

         -- Zip in X dimension
         (LinStream_zipWith3_array @a @b @c @d @Na @Nb @Nc repr_a repr_b repr_c repr_d f sa sb sc))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b)
    (chunk_id @Mc @Nc @c repr_c size_c_x ls_c))

   (\ (x : StoredBox (LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d))
      -> LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d.
      case x of storedBox @(LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d)
      	        (y : LinStream (arr_shape (min_i (min_i Na Nb) Nc) dim0) d).
      y));


ShapeDict_matrix_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : Stream dim2 a) (src_b : Stream dim2 b)
  (src_c : Stream dim2 c) (src_d : Stream dim2 d)
  -> Stream dim2 e =
  case src_a of
    matrixStream @a @(Ma : intindex) @(Na : intindex)
    (size_a_y : IndInt Ma) (size_a_x : IndInt Na)
    (ls_a : LinStream (arr_shape Ma (arr_shape Na dim0)) a).

  case src_b of
    matrixStream @b @(Mb : intindex) @(Nb : intindex)
    (size_b_y : IndInt Mb) (size_b_x : IndInt Nb)
    (ls_b : LinStream (arr_shape Mb (arr_shape Nb dim0)) b).

  case src_c of
    matrixStream @c @(Mc : intindex) @(Nc : intindex)
    (size_c_y : IndInt Mc) (size_c_x : IndInt Nc)
    (ls_c : LinStream (arr_shape Mc (arr_shape Nc dim0)) c).

  case src_d of
    matrixStream @d @(Md : intindex) @(Nd : intindex)
    (size_d_y : IndInt Md) (size_d_x : IndInt Nd)
    (ls_d : LinStream (arr_shape Md (arr_shape Nd dim0)) d).

  let size_y : IndInt (min_i (min_i (min_i Ma Mb) Mc) Md) =
        min_ii @(min_i (min_i Ma Mb) Mc) @Md
	(min_ii @(min_i Ma Mb) @Mc
	 (min_ii @Ma @Mb size_a_y size_b_y) size_c_y) size_d_y in
  let size_x : IndInt (min_i (min_i (min_i Na Nb) Nc) Nd) =
        min_ii @(min_i (min_i Na Nb) Nc) @Nd
	(min_ii @(min_i Na Nb) @Nc
	 (min_ii @Na @Nb size_a_x size_b_x) size_c_x) size_d_x in

  -- Chunk the streams, zip them in each dimension, then flatten
  matrixStream @e @(min_i (min_i (min_i Ma Mb) Mc) Md) @(min_i (min_i (min_i Na Nb) Nc) Nd) size_y size_x
  (bind
   @(min_i (min_i (min_i Ma Mb) Mc) Md)
   @(arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0)
   @(StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
   @e
   (repr_Box @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
   repr_e

   -- Zip in Y dimension
   (LinStream_zipWith4_array
    @(StoredBox (LinStream (arr_shape Na dim0) a))
    @(StoredBox (LinStream (arr_shape Nb dim0) b))
    @(StoredBox (LinStream (arr_shape Nc dim0) c))
    @(StoredBox (LinStream (arr_shape Nd dim0) d))
    @(StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
    @Ma
    @Mb
    @Mc
    @Md
    (repr_Box @(LinStream (arr_shape Na dim0) a))
    (repr_Box @(LinStream (arr_shape Nb dim0) b))
    (repr_Box @(LinStream (arr_shape Nc dim0) c))
    (repr_Box @(LinStream (arr_shape Nd dim0) d))
    (repr_Box @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
    (\ (inner_stream_a : StoredBox (LinStream (arr_shape Na dim0) a))
       (inner_stream_b : StoredBox (LinStream (arr_shape Nb dim0) b))
       (inner_stream_c : StoredBox (LinStream (arr_shape Nc dim0) c))
       (inner_stream_d : StoredBox (LinStream (arr_shape Nd dim0) d))
       -> Writer (StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e)).
       case inner_stream_a of
         storedBox @(LinStream (arr_shape Na dim0) a)
 	(sa : LinStream (arr_shape Na dim0) a).
       case inner_stream_b of
         storedBox @(LinStream (arr_shape Nb dim0) b)
 	(sb : LinStream (arr_shape Nb dim0) b).
       case inner_stream_c of
         storedBox @(LinStream (arr_shape Nc dim0) c)
 	(sc : LinStream (arr_shape Nc dim0) c).
       case inner_stream_d of
         storedBox @(LinStream (arr_shape Nd dim0) d)
 	(sd : LinStream (arr_shape Nd dim0) d).
       storedBox @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e)

         -- Zip in X dimension
         (LinStream_zipWith4_array @a @b @c @d @e @Na @Nb @Nc @Nd repr_a repr_b repr_c repr_d repr_e f sa sb sc sd))

    (chunk_id @Ma @Na @a repr_a size_a_x ls_a)
    (chunk_id @Mb @Nb @b repr_b size_b_x ls_b)
    (chunk_id @Mc @Nc @c repr_c size_c_x ls_c)
    (chunk_id @Md @Nd @d repr_d size_d_x ls_d))

   (\ (x : StoredBox (LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e))
      -> LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e.
      case x of storedBox @(LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e)
      	        (y : LinStream (arr_shape (min_i (min_i (min_i Na Nb) Nc) Nd) dim0) e).
      y));

ShapeDict_matrix_inRange
  (shape_value : dim2)
  (ix : index dim2)
  -> bool =
  case shape_value of
    mk_dim2 @(Mlo : intindex) @(M : intindex) @(Nlo : intindex) @(N : intindex)
    (ymin : IndInt Mlo)
    (height : IndInt M)
    (xmin : IndInt Nlo)
    (width : IndInt N).
  case ix of
    pyonTuple2 @(Stored int) @(Stored int)
    (y_s : Stored int) (x_s : Stored int).
  case y_s of stored @int (y : int).
  case x_s of stored @int (x : int).

  -- Check Y part of range
  if case ymin of {
       indInt @Mlo (fymin : FinIndInt Mlo).
         case fymin of finIndInt @Mlo (ymin_i : int).
         case height of {
           indInt @M (fheight : FinIndInt M).
             -- Compare against lower and upper bounds
             case fheight of finIndInt @M (height_i : int).

             let maxy_plus_one : int = AdditiveDict_int_add ymin_i height_i in
             and (OrdDict_int_ge y ymin_i) (OrdDict_int_lt y maxy_plus_one);

           indOmega @M (pf : Pf (eqZ M pos_infty)).
   	  -- Compare against lower bound only
   	  OrdDict_int_ge y ymin_i
         };

       indOmega @Mlo (pf : Pf (eqZ Mlo pos_infty)). False
     }
   then -- Check X part of range
        case xmin of {
        indInt @Nlo (fxmin : FinIndInt Nlo).
          case fxmin of finIndInt @Nlo (xmin_i : int).
          case width of {
            indInt @N (fwidth : FinIndInt N).
              -- Compare against lower and upper bounds
              case fwidth of finIndInt @N (width_i : int).

              let maxx_plus_one : int = AdditiveDict_int_add xmin_i width_i in
              and (OrdDict_int_ge x xmin_i) (OrdDict_int_lt x maxx_plus_one);

            indOmega @N (pf : Pf (eqZ N pos_infty)).
          -- Compare against lower bound only
          OrdDict_int_ge x xmin_i
          };

        indOmega @Nlo (pf : Pf (eqZ Nlo pos_infty)). False
      }

   else False;


ShapeDict_matrix_coerceSlice
  (shape_value : dim2)
  (slice_value : slice dim2)
  (ret : OutPtr (Maybe (slice dim2)))
  -> IEffect (Maybe (slice dim2)) =

  case shape_value of
    mk_dim2 @(Mlo : intindex) @(M : intindex) @(Nlo : intindex) @(N : intindex)
    (ymin : IndInt Mlo)
    (height : IndInt M)
    (xmin : IndInt Nlo)
    (width : IndInt N).

  case slice_value of pyonTuple2
       		      @(PyonTuple3 (Stored int) (Stored int) (Stored int))
       		      @(PyonTuple3 (Stored int) (Stored int) (Stored int))
		      (y_slice : PyonTuple3 (Stored int) (Stored int) (Stored int))
		      (x_slice : PyonTuple3 (Stored int) (Stored int) (Stored int)).

  letfun
    -- Coercion in one dimension  
    coerce_slice
      @(Klo K : intindex)
      (kmin : IndInt Klo)
      (extent : IndInt K)
      (slice_1d : PyonTuple3 (Stored int) (Stored int) (Stored int))
      (continuation : int -> int -> int -> Writer (Maybe (slice dim2)))
      (ret : OutPtr (Maybe (slice dim2)))
      -> IEffect (Maybe (slice dim2)) =

      case slice_1d of
        pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
        (start_s : Stored int) (stop_s : Stored int) (stride_s : Stored int).
      case start_s of stored @int (start_i : int).
      case stop_s of stored @int (stop_i : int).
      case stride_s of stored @int (stride_i : int).

      case kmin of {
        indInt @Klo (kmin_f : FinIndInt Klo).
          case kmin_f of finIndInt @Klo (kmin_i : int).

	  -- Start cannot be less than the minimum boundary
	  let real_start : int = max_int start_i kmin_i in

	  -- End cannot be greater than than minimum boundary + extent
	  let real_end : int =
	        case extent of {
		  indInt @K (extent_f : FinIndInt K).
		    case extent_f of finIndInt @K (extent_i : int).
		      let limit : int = AdditiveDict_int_add kmin_i extent_i in
		      min_int stop_i limit;
		  indOmega @K (pf : Pf (eqZ K pos_infty)).
		    stop_i
                } in

	  -- Stride must be positive
          if OrdDict_int_le stride_i 0 then Nothing @(slice dim2) ret else

          -- Compute interval spanned by slice.  If negative, coerce to zero.
          let delta : int =
                let iv : int = AdditiveDict_int_sub real_end real_start
                in max_int iv 0 in

	  continuation real_start delta stride_i ret;

	indOmega @Klo (pf : Pf (eqZ Klo pos_infty)).
	  Nothing @(slice dim2) ret
      }
  in

  coerce_slice @Mlo @M ymin height y_slice
  (\ (y_start : int) (y_delta : int) (y_stride : int)
     (ret : OutPtr (Maybe (slice dim2)))
     -> IEffect (Maybe (slice dim2)).
    coerce_slice @Nlo @N xmin width x_slice
    (\ (x_start : int) (x_delta : int) (x_stride : int)
     (ret : OutPtr (Maybe (slice dim2)))
     -> IEffect (Maybe (slice dim2)).
     Just @(slice dim2)
       (pyonTuple2
        @(PyonTuple3 (Stored int) (Stored int) (Stored int))
	@(PyonTuple3 (Stored int) (Stored int) (Stored int))
	(pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
	 (stored @int y_start) (stored @int y_delta) (stored @int y_stride))
	(pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
	 (stored @int x_start) (stored @int x_delta) (stored @int x_stride)))
       ret)
    ret)
  ret;

{-
ShapeDict_Stream_flatten @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a : bare) -> Stream sh a -> Stream dim1 a =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_flatten;


ShapeDict_Stream_map @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b : bare) -> Repr a -> Repr b -> (a -> Writer b) -> Stream sh a -> Stream sh b =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_map;


ShapeDict_Stream_zipWith @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c : bare) -> Repr a -> Repr b -> Repr c ->
     (a -> b -> Writer c) ->
     Stream sh a -> Stream sh b -> Stream sh c =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith;


ShapeDict_Stream_zipWith3 @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c d : bare) -> Repr a -> Repr b -> Repr c -> Repr d ->
     (a -> b -> c -> Writer d) ->
     Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith3;


ShapeDict_Stream_zipWith4 @(sh : bare) (shape_dict : ShapeDict sh)
  -> (a b c d e : bare) -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
     (a -> b -> c -> d -> Writer e) ->
     Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e =
  case shape_dict of shapeDict @sh 
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_flatten : (a : bare) -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e).
  shape_zipWith4;
-}

-------------------------------------------------------------------------------
-- List shape methods

ShapeDict_list_flatten @(a : bare) (s : Stream dim1 a)
  -> Stream dim1 a =
  s;


ShapeDict_list_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : Stream dim1 a) -> Stream dim1 b =
  LinStream_map @dim1 @a @b repr_a repr_b f src;


ShapeDict_list_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : Stream dim1 a) (src_b : Stream dim1 b)
  -> Stream dim1 c =
  LinStream_zipWith @dim1 @a @b @c repr_a repr_b repr_c f src_a src_b;


ShapeDict_list_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : Stream dim1 a) (src_b : Stream dim1 b) (src_c : Stream dim1 c)
  -> Stream dim1 d =
  LinStream_zipWith3 @dim1 @a @b @c @d repr_a repr_b repr_c repr_d
  f src_a src_b src_c;


ShapeDict_list_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : Stream dim1 a) (src_b : Stream dim1 b) (src_c : Stream dim1 c) (src_d : Stream dim1 d)
  -> Stream dim1 e =
  LinStream_zipWith4 @dim1 @a @b @c @d @e repr_a repr_b repr_c repr_d repr_e
  f src_a src_b src_c src_d;


ShapeDict_list_inRange (shp : dim1) (ix : Stored int) -> bool =
  case shp of mk_dim1 @(Nlo N : intindex)
       	      (lo : IndInt Nlo)
	      (len : IndInt N).
  case ix of stored @int (ix_i : int).

  case lo of {
    indInt @Nlo (flo : FinIndInt Nlo).
      case flo of finIndInt @Nlo (lo_i : int).
      case len of {
        indInt @N (flen : FinIndInt N).
	  -- Compare against lower and upper bounds
          case flen of finIndInt @N (len_i : int).

          let maxindex_plus_one : int = AdditiveDict_int_add lo_i len_i in
	  and (OrdDict_int_ge ix_i lo_i) (OrdDict_int_lt ix_i maxindex_plus_one);

        indOmega @N (pf : Pf (eqZ N pos_infty)).
	  -- Compare against lower bound only
	  OrdDict_int_ge ix_i lo_i
      };

    indOmega @Nlo (pf : Pf (eqZ Nlo pos_infty)). False
  };


ShapeDict_list_coerceSlice
  (shape_value : dim1)
  (slice_value : slice dim1)
  (ret : OutPtr (Maybe (slice dim1)))
  -> IEffect (Maybe (slice dim1)) =

  case shape_value of
    mk_dim1 @(Nlo N : intindex) (lo : IndInt Nlo) (len : IndInt N).
  case slice_value of
    pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
               (start_s : Stored int) (stop_s : Stored int) (stride_s : Stored int).
  case start_s of stored @int (start_i : int).
  case stop_s of stored @int (stop_i : int).
  case stride_s of stored @int (stride_i : int).

  case lo of {
    indInt @Nlo (flo : FinIndInt Nlo).
      case flo of finIndInt @Nlo (lo_i : int).

      -- Start cannot be less than the minimum boundary
      let real_start : int = max_int start_i lo_i in

      -- End cannot be greater than than minimum boundary + extent
      let real_end : int =
            case len of {
	      indInt @N (flen : FinIndInt N).
	        case flen of finIndInt @N (len_i : int).
                let limit : int = AdditiveDict_int_add lo_i len_i in
		min_int stop_i limit;
	      indOmega @N (pf : Pf (eqZ N pos_infty)).
	        stop_i
              } in

      -- Stride must be positive
      if OrdDict_int_le stride_i 0 then Nothing @(slice dim1) ret else

      -- Compute interval spanned by slice.  If negative, coerce to zero.
      let delta : int =
            let iv : int = AdditiveDict_int_sub real_end real_start
            in max_int iv 0 in

      Just @(slice dim1)
        (pyonTuple3 @(Stored int) @(Stored int) @(Stored int)
	 (stored @int real_start)
	 (stored @int delta)
	 (stored @int stride_i))
        ret;

    indOmega @Nlo (pf : Pf (eqZ Nlo pos_infty)).
      Nothing @(slice dim1) ret
  };


-------------------------------------------------------------------------------
-- Linear stream methods

LinStream_flatten @(sh a : bare) (s : LinStream sh a)
  -> LinStream dim1 a
  attribute(inline_final) =
  case s of linStream @sh @a @(st : box)
                       (state : st) (next : st -> StreamNext st (BoxedType a)).
  linStream @dim1 @a @st state next;


LinStream_map @(sh a b : bare) (repr_a : Repr a) (repr_b : Repr b)
  (f : a -> Writer b)
  (src : LinStream sh a) -> LinStream sh b
  attribute(inline_final) =
  case src
  of linStream @sh @a @(src_st : box)
     (st : src_st) (next : src_st -> StreamNext src_st (BoxedType a)).

  letfun
    go (state : src_st) -> StreamNext src_st (BoxedType b) =
      case next state of {

        streamValue @src_st @(BoxedType a)
          (next_state : src_st) (value : BoxedType a).
          let output_value : BoxedType b =
                case boxed @a (convertToBare @a repr_a value) of boxed @a (x : a).
		convertToBoxed @b repr_b (f x)
          in streamValue @src_st @(BoxedType b) next_state output_value;

        streamEmpty @src_st @(BoxedType a).
          streamEmpty @src_st @(BoxedType b)
      }
  in linStream @sh @b @src_st st go;


LinStream_zipWith @(sh a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (f : a -> b -> Writer c)
  (src_a : LinStream sh a) (src_b : LinStream sh b)
  -> LinStream sh c
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b)))
      -> StreamNext (Boxed (Stored (st_a, st_b))) (BoxedType c) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b)) (u_state : Stored (st_a, st_b)).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

	      -- Create output value
	      let value : BoxedType c =
	            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
		    convertToBoxed @c repr_c (f x y) in
	      let next_state : Boxed (Stored (st_a, st_b)) =
	            boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed (Stored (st_a, st_b))) @(BoxedType c) next_state value;

	    streamEmpty @st_b @(BoxedType b).
	      streamEmpty @(Boxed (Stored (st_a, st_b))) @(BoxedType c)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b))) @(BoxedType c)
      }
  in linStream @sh @c @(Boxed (Stored (st_a, st_b)))
       (boxed @(Stored (st_a, st_b)) (stored @(st_a, st_b) (state_a, state_b)))
       go;


LinStream_zipWith3 @(sh a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (f : a -> b -> c -> Writer d)
  (src_a : LinStream sh a) (src_b : LinStream sh b) (src_c : LinStream sh c)
  -> LinStream sh d
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of linStream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  
  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c))) (BoxedType d) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c)) (u_state : Stored (st_a, st_b, st_c)).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Create output value
                  let value : BoxedType d =
                        case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                        convertToBoxed @d repr_d (f x y z) in
                  let next_state : Boxed (Stored (st_a, st_b, st_c)) =
                        boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d) next_state value;

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c))) @(BoxedType d)
      }
  in linStream @sh @d @(Boxed (Stored (st_a, st_b, st_c)))
       (boxed @(Stored (st_a, st_b, st_c)) (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;


LinStream_zipWith4 @(sh a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (f : a -> b -> c -> d -> Writer e)
  (src_a : LinStream sh a) (src_b : LinStream sh b) (src_c : LinStream sh c) (src_d : LinStream sh d)
  -> LinStream sh e
  attribute(inline_final) =

  case src_a
  of linStream @sh @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a (BoxedType a)).
  case src_b
  of linStream @sh @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b (BoxedType b)).
  case src_c
  of linStream @sh @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c (BoxedType c)).
  case src_d
  of linStream @sh @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d (BoxedType d)).

  letfun
    go (state : Boxed (Stored (st_a, st_b, st_c, st_d)))
      -> StreamNext (Boxed (Stored (st_a, st_b, st_c, st_d))) (BoxedType e) =
      -- Unpack the state
      case state of boxed @(Stored (st_a, st_b, st_c, st_d)) (u_state : Stored (st_a, st_b, st_c, st_d)).
      case u_state of stored @(st_a, st_b, st_c, st_d) (i_state : (st_a, st_b, st_c, st_d)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @(BoxedType a)
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @(BoxedType b)
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @(BoxedType c)
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @(BoxedType d)
                      (next_state_d : st_d) (value_d : BoxedType d).

                      -- Create output value
                      let value : BoxedType e =
                            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (convertToBare @d repr_d value_d) of boxed @d (w : d).
                            convertToBoxed @e repr_e (f x y z w) in
                      let next_state : Boxed (Stored (st_a, st_b, st_c, st_d)) =
                            boxed @(Stored (st_a, st_b, st_c, st_d)) (stored @(st_a, st_b, st_c, st_d) (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e) next_state value;

                    streamEmpty @st_d @(BoxedType d).
                      streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
                  };

                streamEmpty @st_c @(BoxedType c).
                  streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
              };

            streamEmpty @st_b @(BoxedType b).
              streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
          };

	streamEmpty @st_a @(BoxedType a).
	  streamEmpty @(Boxed (Stored (st_a, st_b, st_c, st_d))) @(BoxedType e)
      }
  in linStream @sh @e @(Boxed (Stored (st_a, st_b, st_c, st_d)))
       (boxed @(Stored (st_a, st_b, st_c, st_d)) (stored @(st_a, st_b, st_c, st_d) (state_a, state_b, state_c, state_d)))
       go;

-------------------------------------------------------------------------------
-- Other rewritable functions

LinStream_reduce @(sh a : bare) (repr_a : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (s : LinStream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  LinStream_fold @sh @a @a repr_a repr_a f init s ret;


LinStream_reduce1 @(sh a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : LinStream sh a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline_final) =
  -- Use the stream's first element as the initial value
  case s of linStream @sh @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case stream_next stream_state of {
    streamValue @st @(BoxedType a) (next_state : st) (init : BoxedType a).
      case boxed @a (convertToBare @a repr init) of boxed @a (u_init : a).
      let new_stream : Stream dim1 a =
            linStream @dim1 @a @st next_state stream_next in
      LinStream_fold @dim1 @a @a repr repr f u_init new_stream ret;

    streamEmpty @st @(BoxedType a).
      except @(IEffect a)
  };


LinStream_fold @(sh a acc : bare) (repr_a : Repr a) (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (s : LinStream sh a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline_final) =
  case s of linStream @sh @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  letfun
    go (state : st) (accumulator : BoxedType acc) (ret : OutPtr acc)
      -> IEffect acc =
      case stream_next state of {

        -- Obtain value from stream
        streamValue @st @(BoxedType a) (next_state : st) (result : BoxedType a).
          -- Compute the new value
          let new_accumulator : BoxedType acc =
                case boxed @a (convertToBare @a repr_a result)
                of boxed @a (y : a).
                case boxed @acc (convertToBare @acc repr_acc accumulator)
                of boxed @acc (x : acc).
                convertToBoxed @acc repr_acc (f x y)

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty @st @(BoxedType a).
	  convertToBare @acc repr_acc accumulator ret
      }
  in go stream_state (convertToBoxed @acc repr_acc (copy @acc repr_acc init)) ret;

-------------------------------------------------------------------------------
-- Loops

for @(N : intindex) @(acc : bare)
  (repr : Repr acc) (count : IndInt N) (init : acc)
  (f : int -> acc -> Writer acc) (ret : OutPtr acc)
  -> IEffect acc =

  -- Unpack the indexed int
  case count of {
    indInt @N (fin : FinIndInt N).
      case fin of finIndInt @N (bound : int).

      -- Main loop
      letfun
        loop (i : int) (x : acc) (r : OutPtr acc) -> IEffect acc =
          if EqDict_int_eq i bound
          then copy @acc repr x r
          else case boxed @acc (f i x) of boxed @acc (y : acc).
               loop (AdditiveDict_int_add i 1) y r
      in loop 0 init ret;

    -- An infinite loop will fail
    indOmega @N (pf : Pf (eqZ N pos_infty)).
      except @(IEffect acc)
  };
