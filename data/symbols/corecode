
-------------------------------------------------------------------------------
-- Integer index arithmetic

plus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (plus_i m n) attribute(inline) =
  let type sum_t = plus_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (plus_fii @m @n fa fb)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty @n. iNegInfty @sum_t
      }
  };


minus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (minus_i m n) attribute(inline) =
  let type sum_t = minus_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (minus_fii @m @n fa fb)
      ; iPosInfty @n. iNegInfty @sum_t
      ; iNegInfty @n. iPosInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty @n. iPosInfty @sum_t
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty @n. iNegInfty @sum_t
      ; iNegInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  };


min_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (min_i m n) attribute(inline) =
  let type sum_t = min_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (min_fii @m @n fa fb)
      ; iPosInfty @n.
          case fa of fiInt @m (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n).
	  case fb of fiInt @n (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iNegInfty @m.
      iNegInfty @sum_t
  };


max_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (max_i m n) attribute(inline) =
  let type sum_t = max_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (max_fii @m @n fa fb)
      ; iNegInfty @n.
          case fa of fiInt @m (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iPosInfty @n. iPosInfty @sum_t
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n).
	  case fb of fiInt @n (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      iPosInfty @sum_t
  };


-- Operations on finite indexed ints aren't inlined until near the end,
-- because they don't enable other optimizations.  By delaying inlining,
-- code doesn't expand as much.

plus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	 -> FIInt (plus_i m n)
	 attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(plus_i m n) (x_i +# y_i);


minus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	  -> FIInt (minus_i m n)
	  attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(minus_i m n) (x_i -# y_i);


min_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (min_i m n)
	attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(min_i m n) (min_int x_i y_i);


max_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (max_i m n)
	attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(max_i m n) (max_int x_i y_i);


-- Determine if there are integers that are greater than or equal to @x@,
-- but less than @y@.
-- The result is False if @x == y@.
range_nonempty_ii @(m n : intindex) (x : IInt m) (y : IInt n) -> bool
  attribute(inline) =
  case x of {
    iInt @m (fx : FIInt m).
      case fx of fiInt @m (x_i : int).
      case y of {
        iInt @n (fy : FIInt n).
          case fy of fiInt @n (y_i : int).
          x_i <# y_i
      ; iPosInfty @n. True
      ; iNegInfty @n. False
      }
  ; iNegInfty @m.
      case y of {
        iNegInfty @n. False
      ; iInt @n (fy : FIInt n). True
      ; iPosInfty @n. True
      }
  ; iPosInfty @m. False
  };

fromIndInt @(N : intindex) (ii : IInt N) -> FIInt N attribute(inline) =
  case ii of {
    iInt @N (fii : FIInt N). fii;
    iPosInfty @N. except @(FIInt N);
    iNegInfty @N. except @(FIInt N)
  };


-- Test whether an interval is empty.
isEmptyInterval (iv : Interval) -> bool =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).
  case l of {
    justVal @int (ll : int).
      case u of {
        justVal @int (uu : int). ll ==# uu
      ; nothingVal @int. False
    }
  ; nothingVal @int. False
  };


-- Decide whether 'i' is in the interval.
inInterval (i : int) (iv : Interval) -> bool =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).

  -- Is 'i' within the lower bound?
  if case l of {
       nothingVal @int. True
     ; justVal @int (ll : int). i >=# ll
     }
  then -- Is 'i' within the upper bound?
       case u of {
         nothingVal @int. True
       ; justVal @int (uu : int). i <# uu
       }
  else False;


-- Compute the intersection of two intervals.
intersectInterval (iv1 : Interval) (iv2 : Interval) -> Interval =
  case iv1 of interval (l1 : MaybeVal int) (u1 : MaybeVal int).
  case iv2 of interval (l2 : MaybeVal int) (u2 : MaybeVal int).

  -- Lower bound is the maximum of the two bounds
  let l3 : MaybeVal int =
        case l1 of {
          nothingVal @int.
            l2
        ; justVal @int (ll1 : int).
            case l2 of {
              nothingVal @int.
                l1
            ; justVal @int (ll2 : int).
                justVal @int (max_int ll1 ll2)
            }
        } in

  -- Upper bound is the minimum of the two bounds
  let u3 : MaybeVal int =
        case u1 of {
          nothingVal @int.
            u2
        ; justVal @int (uu1 : int).
            case u2 of {
              nothingVal @int.
                u1
            ; justVal @int (uu2 : int).
                justVal @int (max_int uu1 uu2)
            }
        } in
  case l3 of {
    justVal @int (x : int).
      case u3 of {
        justVal @int (y : int).
          if x ># y
          then interval (justVal @int 0) (justVal @int 0) -- Empty interval
          else interval l3 u3
      ; nothingVal @int.
          interval l3 u3
      }
  ; nothingVal @int.
      interval l3 u3
  };


-- Decide whether 'i' is a member of the linear map's range.
inLM (i : int) (m : LinearMap) -> bool =
  case m of linearMap (s : int) (a : int). (i %# s) ==# (a %# s);
  

-- Evaluate a linear map at 'i'. 
evalLM (i : int) (m : LinearMap) -> int =
  case m of linearMap (s : int) (a : int). s *# i +# a;


-- Evaluate the inverse of a linear map at 'i'.
-- The result is undefined if 'i' is not in the range of the map.
invEvalLM (i : int) (m : LinearMap) -> int =
  case m of linearMap (s : int) (a : int). (i -# a) //# s;


-- Compute the intersection of two linear maps.
-- If the intersection is empty, 'Nothing' is returned.
intersectLM (m1 : LinearMap) (m2 : LinearMap) -> MaybeVal LinearMap =
  case m1 of linearMap (s1 : int) (a1 : int).
  case m2 of linearMap (s2 : int) (a2 : int).

  -- Special case handling when stride is 1
  if s1 ==# 1 then justVal @LinearMap m2 else
  if s2 ==# 1 then justVal @LinearMap m1 else

  let g : int = gcd s1 s2 in
  let align_remainder : int = (a2 -# a1) %# g in
  let align_quot : int = (a2 -# a1) //# g in

  -- Check if intersection is empty
  if align_remainder /=# 0 then nothingVal @LinearMap else

  let s1p : int = s1 //# g in
  let s2p : int = s2 //# g in
  let s3 : int = s1p *# s2 in
  let yp : int = extgcd_x s1p s2p in
  let y : int = align_quot *# yp in
  let a3 : int = (s1 *# y +# a1) %# s3 in
  justVal @LinearMap (linearMap s3 a3);


trimInterval (iv : Interval) (m : LinearMap) -> Interval =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).
  case m of linearMap (s : int) (a : int).

  let l2 : MaybeVal int =
        case l of {
          nothingVal @int. nothingVal @int
        ; justVal @int (n : int). justVal @int (n +# (a -# n) %# s) 
        } in
  let u2 : MaybeVal int =
        case u of {
          nothingVal @int. nothingVal @int
        ; justVal @int (n : int). justVal @int (n +# (a -# n) %# s) 
        } in
  interval l2 u2;


-- Convert fields of an array object to a domain.
-- The domain's linear map is the actual map from real to logical index.
arrayDescToDim1 @(N : intindex) (lb : int) (stride : int) (size : FIInt N)
  -> dim1 attribute(inline) =
  case size of fiInt @N (size_i : int).

  let ub : int = lb +# stride *# size_i in
  mk_dim1 (interval (justVal @int lb) (justVal @int ub)) (linearMap stride lb);


-- Convert a domain to fields of an array object
dim1ToArrayDesc @(a : bare)
  (shp : dim1)
  (k : (N : intindex) -> int -> int -> FIInt N -> Writer a)
  (ret : OutPtr a)
  -> IEffect a attribute(inline) =

  case shp of mk_dim1 (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal @int (lb_i : int).
      case ub of {
        justVal @int (ub_i : int).
          case m of linearMap (stride : int) (alignment : int).
          let size_i : int = (ub_i -# lb_i) //# stride in
          case defineIntIndex size_i of
            someIInt @(N : intindex) (size : FIInt N).
          k @N lb_i stride size ret
      ; nothingVal @int.
          except @(IEffect a)
      }
  ; nothingVal @int.
      except @(IEffect a)
  };


internalApplyListSlice (slice_obj : SliceObject) (dom : list_dim)
  -> (list_dim, LinearMap) =
  case slice_obj of
    sliceObject (m_slice_lo : MaybeVal int)
                (m_slice_hi : MaybeVal int)
                (m_m_stride : MaybeVal (MaybeVal int)).
  case dom of mk_list_dim (list_size : MaybeVal int).
  let stride : int =
        case m_m_stride of {
          nothingVal @(MaybeVal int). 1
        ; justVal @(MaybeVal int) (m_stride : MaybeVal int).
            case m_stride of {
              nothingVal @int. 1
            ; justVal @int (stride : int). stride
            }
        } in
  if stride ==# 0 then except @(list_dim, LinearMap) else
  let counting_up : bool = stride ># 0 in

  -- Get the slice's inclusive lower bound.
  -- There must be a lower bound, determined either by the slice or the
  -- list domain.
  let slice_lo : int =
        if counting_up
        then case m_slice_lo of {
               nothingVal @int. 0
             ; justVal @int (l : int). max_int 0 l
             }
        else case m_slice_lo of {
               justVal @int (h : int).
                 case list_size of {
                   justVal @int (n : int). min_int h (n -# 1)
                 ; nothingVal @int. h
                 }
             ; nothingVal @int.
                 case list_size of {
                   justVal @int (n : int). n -# 1
                 ; nothingVal @int. except @int
                 }
             } in

  -- Get the slice's exclusive upper bound.
  let slice_hi : MaybeVal int =
        if counting_up
        then case m_slice_hi of {
               nothingVal @int.
                 list_size
             ; justVal @int (h : int).
                 case list_size of {
                   nothingVal @int. justVal @int h
                 ; justVal @int (n : int). justVal @int (min_int h n)
                 }
             }
        else case m_slice_hi of {
               nothingVal @int. justVal @int -1
             ; justVal @int (h : int). justVal @int (max_int h -1)
             } in

  -- If the slice is nonempty, this is the map from slice member to list member
  let linear_map : LinearMap = linearMap stride slice_lo in

  -- Compute the new list size, which may be unbounded
  let size : MaybeVal int =
        case slice_hi of {
          nothingVal @int. nothingVal @int
        ; justVal @int (h : int).
            let abs_stride : int = if counting_up
                                   then stride
                                   else AdditiveDict_int_negate stride in

            let abs_delta : int =
                  let delta : int = h -# slice_lo in
                  if delta <# 0
                  then AdditiveDict_int_negate delta
                  else delta in

            justVal @int ((abs_delta +# abs_stride -# 1) //# abs_stride)
        } in
  case size of {
    justVal @int (n : int).
      if n <# 0
      then (mk_list_dim (justVal @int 0), linearMap 0 0)
      else (mk_list_dim size, linear_map)
  ; nothingVal @int. (mk_list_dim size, linear_map)
  };


sliceToDomain (slice_obj : SliceObject) -> dim1 =
  case slice_obj of
    sliceObject (m_slice_lo : MaybeVal int)
                (m_slice_hi : MaybeVal int)
                (m_m_stride : MaybeVal (MaybeVal int)).
  let stride : int =
        case m_m_stride of {
          nothingVal @(MaybeVal int). 1
        ; justVal @(MaybeVal int) (m_stride : MaybeVal int).
            case m_stride of {
              nothingVal @int. 1
            ; justVal @int (stride : int). stride
            }
        } in
  let alignment : int =
        case m_slice_lo of {
          nothingVal @int. 0
        ; justVal @int (n : int). n %# stride
        } in

  -- Stride must be positive
  if stride <=# 0 then except @dim1 else

  let map : LinearMap = linearMap stride alignment in
  let iv : Interval = trimInterval (interval m_slice_lo m_slice_hi) map in
  mk_dim1 iv map;


internalApplyArraySlice (slice_obj : SliceObject) (dom : dim1) -> dim1 =
  let slice_dom : dim1 = sliceToDomain slice_obj in
  ShapeDict_dim1_intersect slice_dom dom;

-------------------------------------------------------------------------------
-- Cartesian methods

CartesianDict_dim0_loBound (dom : dim0) -> Writer (Maybe (index dim0))
  attribute(inline) =
  just @(Stored NoneType) (stored @NoneType None);


CartesianDict_dim0_hiBound (dom : dim0) -> Writer (Maybe (index dim0))
  attribute(inline) =
  just @(Stored NoneType) (stored @NoneType None);


CartesianDict_dim0_arrayRange (lo : index dim0) (hi : index dim0) -> dim0
  attribute(inline) =
  mk_dim0;


CartesianDict_dim1_loBound (dom : dim1) (ret : OutPtr (Maybe (index dim1)))
  -> IEffect (Maybe (index dim1))
  attribute(inline) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal @int (x : int).  just @(Stored int) (stored @int x) ret
  ; nothingVal @int. nothing @(Stored int) ret
  };


CartesianDict_dim1_hiBound (dom : dim1) (ret : OutPtr (Maybe (index dim1)))
  -> IEffect (Maybe (index dim1))
  attribute(inline) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case ub of {
    justVal @int (x : int).  just @(Stored int) (stored @int x) ret
  ; nothingVal @int. nothing @(Stored int) ret
  };


CartesianDict_dim1_arrayRange (lo : index dim1) (hi : index dim1) -> dim1
  attribute(inline) =
  case lo of stored @int (lo_i : int).
  case hi of stored @int (hi_i : int).
  mk_dim1 (interval (justVal @int lo_i) (justVal @int hi_i))
          (linearMap 1 0);


CartesianDict_dim2_loBound (dom : dim2) (ret : OutPtr (Maybe (index dim2)))
  -> IEffect (Maybe (index dim2))
  attribute(inline) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dom_y of mk_dim1 (iv_y : Interval) (lm : LinearMap).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lb_y of {
    justVal @int (y : int).
      case dom_x of mk_dim1 (iv_x : Interval) (lm : LinearMap).
      case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
      case lb_x of {
        justVal @int (x : int).
          just @(PyonTuple2 (Stored int) (Stored int))
               (pyonTuple2 @(Stored int) @(Stored int)
                (stored @int y) (stored @int x)) ret
      ; nothingVal @int.
          nothing @(PyonTuple2 (Stored int) (Stored int)) ret
      }
  ; nothingVal @int.
      nothing @(PyonTuple2 (Stored int) (Stored int)) ret
  };
  

CartesianDict_dim2_hiBound (dom : dim2) (ret : OutPtr (Maybe (index dim2)))
  -> IEffect (Maybe (index dim2))
  attribute(inline) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dom_y of mk_dim1 (iv_y : Interval) (lm : LinearMap).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case ub_y of {
    justVal @int (y : int).
      case dom_x of mk_dim1 (iv_x : Interval) (lm : LinearMap).
      case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
      case ub_x of {
        justVal @int (x : int).
          just @(PyonTuple2 (Stored int) (Stored int))
               (pyonTuple2 @(Stored int) @(Stored int)
               (stored @int y) (stored @int x)) ret
      ; nothingVal @int.
          nothing @(PyonTuple2 (Stored int) (Stored int)) ret
      }
  ; nothingVal @int.
      nothing @(PyonTuple2 (Stored int) (Stored int)) ret
  };


CartesianDict_dim2_arrayRange (lo : index dim2) (hi : index dim2) -> dim2
  attribute(inline) =
  case lo of
    pyonTuple2 @(Stored int) @(Stored int)
               (lo_y : Stored int) (lo_x : Stored int).
  case lo_y of stored @int (lo_y_i : int).
  case lo_x of stored @int (lo_x_i : int).
  case hi of
    pyonTuple2 @(Stored int) @(Stored int)
               (hi_y : Stored int) (hi_x : Stored int).
  case hi_y of stored @int (hi_y_i : int).
  case hi_x of stored @int (hi_x_i : int).
  mk_dim2 (mk_dim1 (interval (justVal @int lo_y_i) (justVal @int hi_y_i))
                   (linearMap 1 0))
          (mk_dim1 (interval (justVal @int lo_x_i) (justVal @int hi_x_i))
                   (linearMap 1 0));

-------------------------------------------------------------------------------
-- Imperative computation

intUpdateInPlace (dummy : NoneType)
              -> UpdateInPlace (Stored int) (Stored NoneType) int
              attribute(inline, inline_final) =
  updateInPlace @(Stored int) @(Stored NoneType) @int
  intUpdateInPlace_initializer
  (\ (modify : int -> int) (ret : OutPtr (Stored int)) (ix : Stored NoneType)
     (tok_in : EffTok) -> EffTok.
     intUpdateInPlace_updater modify ret tok_in);


floatUpdateInPlace (dummy : NoneType)
              -> UpdateInPlace (Stored float) (Stored NoneType) float
              attribute(inline, inline_final) =
  updateInPlace @(Stored float) @(Stored NoneType) @float
  floatUpdateInPlace_initializer
  (\ (modify : float -> float) (ret : OutPtr (Stored float))
     (ix : Stored NoneType) (tok_in : EffTok) -> EffTok.
     floatUpdateInPlace_updater modify ret tok_in);


arrUpdateInPlace @(N : intindex) @(s i : bare) @(a : val)
  (size : FIInt N)
  (repr : Repr s)
  (elem_updater : UpdateInPlace s i a)
  -> UpdateInPlace (arr N s) (PyonTuple2 (Stored int) i) a
  attribute(inline, inline_final) =

  case size of fiInt @N (u_size : int).

  case elem_updater of
    updateInPlace @s @i @a
    (elem_init : (NoneType -> a) -> OutPtr s -> EffTok)
    (elem_modify : (a -> a) -> OutPtr s -> i -> EffTok -> EffTok).

  -- Initialize the array by running the initializer on every array element
  letfun
    initialize_array
      (get_init : NoneType -> a) (ret : OutPtr (arr N s)) -> EffTok =
      toEffTok @(arr N s)
      (doall @N @(arr N s) @s size
       (\ (i : int) -> IEffect s.
          let array_element : OutPtr s =
            subscript_out @N @s repr ret i in
          fromEffTok @s (elem_init get_init array_element)))
  in

  -- Update the array by updating one array element.  If out of bounds,
  -- then do nothing.
  letfun
    modify_array
      (modify_value : a -> a)
      (ret : OutPtr (arr N s))
      (ix : PyonTuple2 (Stored int) i)
      (token_in : EffTok)
      -> EffTok =

      -- Choose the array index
      case ix of pyonTuple2 @(Stored int) @i (s_ix : Stored int) (ix2 : i).
      case s_ix of stored @int (u_ix : int).

      -- If out of bounds, do nothing.  Otherwise, modify an array element.
      if or (u_ix <# 0) (u_ix >=# u_size)
      then token_in
      else let array_element : OutPtr s =
             subscript_out @N @s repr ret u_ix in
           elem_modify modify_value array_element ix2 token_in
  in
      
  updateInPlace @(arr N s) @(PyonTuple2 (Stored int) i) @a
  initialize_array modify_array;

-------------------------------------------------------------------------------
-- Traversable methods

TraversableDict_Stream_build @(sh : box) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_Stream_traverse @(sh : box) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_view_list_dim_build
  @(a : bare) (repr : Repr a) (s : Stream list_dim a) -> view list_dim a
  attribute(inline) =
  case s of {
    viewStream @a (vw : view list_dim a). vw
  ; sequenceStream @a (sq : Sequence a). sequenceToView @a repr sq
  };


TraversableDict_view_list_dim_traverse
  @(a : bare) (repr : Repr a) (vw : view list_dim a) -> Stream list_dim a
  attribute(inline) =
  viewStream @a vw;


TraversableDict_view_dim0_build
  @(a : bare) (repr : Repr a) (s : Stream dim0 a) -> view dim0 a
  attribute(inline) =
  s;


TraversableDict_view_dim0_traverse
  @(a : bare) (repr : Repr a) (vw : view dim0 a) -> Stream dim0 a
  attribute(inline) =
  vw;


TraversableDict_view_dim1_build
  @(a : bare) (repr : Repr a) (s : Stream dim1 a) -> view dim1 a
  attribute(inline) =
  s;


TraversableDict_view_dim1_traverse
  @(a : bare) (repr : Repr a) (vw : view dim1 a) -> Stream dim1 a
  attribute(inline) =
  vw;


TraversableDict_view_dim2_build
  @(a : bare) (repr : Repr a) (s : Stream dim2 a) -> view dim2 a
  attribute(inline) =
  s;


TraversableDict_view_dim2_traverse
  @(a : bare) (repr : Repr a) (vw : view dim2 a) -> Stream dim2 a
  attribute(inline) =
  vw;


TraversableDict_list_build @(a : bare)
  (repr : Repr a) (s : Stream list_dim a) (ret : OutPtr (list a))
  -> IEffect (list a) attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      Sequence_build_list @a repr sq ret
  ; viewStream @a (vw : view list_dim a).
      build_list_dim_list @a repr vw ret
  };

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : bare) (repr : Repr a) (ls : list a)
  -> Stream list_dim a attribute(inline) =
  case ls of make_list @a @(N : intindex)
                       (size : FIInt N) (aref : Referenced (arr N a)).
  case aref of referenced @(arr N a) (ay : arr N a).
  case size of fiInt @N (size_i : int).

  let shp : list_dim = mk_list_dim (justVal @int size_i) in

  viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a repr shp
   (\ (si : Stored int) (ret : OutPtr a) -> IEffect a.
     case si of stored @int (i : int).
     copy @a repr (subscript @N @a repr ay i) ret));


TraversableDict_array0_traverse
  @(a : bare) (repr : Repr a) (ay : array0 a) -> view dim0 a attribute(inline) =
  case ay of mk_array0 @a (x : a).
  view_generate @dim0 ShapeDict_dim0 @a
  repr mk_dim0
  (\ (dummy_index : Stored NoneType) -> Writer a. copy @a repr x);


TraversableDict_array0_build
  @(a : bare) (repr : Repr a) (vw : view dim0 a) (ret : OutPtr (array0 a))
  -> IEffect (array0 a) attribute(inline) =

  case vw of mk_view @dim0 @a (dom : dim0) (f : Stored NoneType -> Writer a).
  case boxed @(Stored NoneType) (stored @NoneType None) of
    boxed @(Stored NoneType) (dummy_index : Stored NoneType).
  mk_array0 @a (f dummy_index) ret;


TraversableDict_array1_traverse
  @(a : bare) (repr : Repr a) (ar : array1 a)
  -> view dim1 a attribute(inline) =
  case ar of
    mk_array1 @a @(N : intindex)
    (lo : int) (stride : int) (size : FIInt N)
    (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).
  
  let linear_map : LinearMap = linearMap stride lo in

  view_generate @dim1 ShapeDict_dim1 @a repr
  (arrayDescToDim1 @N lo stride size)
  (\ (ix : Stored int) (ret : OutPtr a) -> IEffect a.
    case ix of stored @int (ix_i : int).

    let real_ix : int = invEvalLM ix_i linear_map in
    copy @a repr (subscript @N @a repr ay real_ix) ret);


TraversableDict_array1_build
  @(a : bare) (repr : Repr a) (s : view dim1 a) (ret : OutPtr (array1 a))
  -> IEffect (array1 a) attribute(inline, inline_dimensionality) =
  build_dim1_array @a repr s ret;


TraversableDict_array2_traverse
  @(a : bare) (repr : Repr a) (ar : array2 a)
  -> view dim2 a attribute(inline) =
  case ar of
    mk_array2 @a @(M N : intindex)
    (lo_y : int) (stride_y : int) (size_y : FIInt M)
    (lo_x : int) (stride_x : int) (size_x : FIInt N)
    (ayref : Referenced (arr M (arr N a))).
  case ayref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).

  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_x of fiInt @N (width : int).
  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  let type Sint = Stored int in

  view_generate @dim2 ShapeDict_dim2 @a repr
  (mk_dim2 (arrayDescToDim1 @M lo_y stride_y size_y)
           (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : PyonTuple2 Sint Sint) (ret : OutPtr a) -> IEffect a.
     case ix of pyonTuple2 @Sint @Sint (ix_y : Sint) (ix_x : Sint).
     case ix_y of stored @int (ix_y_i : int).
     case ix_x of stored @int (ix_x_i : int).
     let real_ix_y : int = invEvalLM ix_y_i linear_map_y in
     let real_ix_x : int = invEvalLM ix_x_i linear_map_x in
     copy @a repr 
     (subscript @N @a repr
      (subscript @M @(arr N a) row_repr ay real_ix_y) real_ix_x)
     ret);


TraversableDict_array2_build
  @(a : bare) (repr : Repr a) (s : view dim2 a) (ret : OutPtr (array2 a))
  -> IEffect (array2 a) attribute(inline, inline_dimensionality) =
  
  case s of mk_view @dim2 @a (dom : dim2) (f : index dim2 -> Writer a).
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).

  -- Compute array parameters
  dim1ToArrayDesc @(array2 a) dom_y
  (\ @(M : intindex)
     (lb_y : int) (stride_y : int) (size_y : FIInt M) (ret : OutPtr (array2 a))
     -> IEffect (array2 a).
     dim1ToArrayDesc @(array2 a) dom_x
     (\ @(N : intindex)
        (lb_x : int) (stride_x : int) (size_x : FIInt N) (ret : OutPtr (array2 a))
        -> IEffect (array2 a).

        let linear_map_y : LinearMap = linearMap stride_y lb_y in
        let linear_map_x : LinearMap = linearMap stride_x lb_x in
        let type out_arr = arr M (arr N a) in
        let type Sint = Stored int in

        mk_array2 @a @M @N lb_y stride_y size_y lb_x stride_x size_x
        (referenced @out_arr
         (arr2D_build @M @N @a repr size_y size_x
          (\ (y : int) (x : int) (ret : OutPtr a) -> IEffect a.
             let logical_y : int = evalLM y linear_map_y in
             let logical_x : int = evalLM x linear_map_x in
             case boxed @(PyonTuple2 Sint Sint)
                  (pyonTuple2 @Sint @Sint
                   (stored @int logical_y) (stored @int logical_x)) of
               boxed @(PyonTuple2 Sint Sint) (ix : PyonTuple2 Sint Sint).

             -- Evaluate the function
             f ix ret)))
         ret)
     ret)
  ret;

-------------------------------------------------------------------------------
-- Shape dictionary methods

ShapeDict_dim0_member (d : dim0) (i : index dim0) -> bool attribute(inline) =
  True;

ShapeDict_dim0_intersect (d : dim0) (x : dim0) -> dim0 attribute(inline) =
  d;

ShapeDict_dim0_generate @(a : bare)
  (repr : Repr a) (d : dim0) (f : Stored NoneType -> Writer a)
  -> Stream dim0 a attribute(inline) =
  mk_view @dim0 @a mk_dim0 f;

ShapeDict_dim0_flatten @(a : bare) (repr : Repr a) (s : Stream dim0 a)
  -> Stream list_dim a attribute(inline) =
  case s of mk_view @dim0 @a (d : dim0) (f : Stored NoneType -> Writer a).

  let d : list_dim = mk_list_dim (justVal @int 1) in

  ShapeDict_list_dim_generate @a repr d
  (\ (i : Stored int) -> Writer a.
    case boxed @(Stored NoneType) (stored @NoneType None) of
      boxed @(Stored NoneType) (x : Stored NoneType).
    f x);


ShapeDict_dim0_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (s : Stream dim0 a)
  -> Stream dim0 b attribute(inline) =
  case s of mk_view @dim0 @a (d : dim0) (f : Stored NoneType -> Writer a).
  mk_view @dim0 @b d
  (\ (i : Stored NoneType) -> Writer b.
    case boxed @a (f i) of boxed @a (x : a). transformer x);


ShapeDict_dim0_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  -> Stream dim0 c attribute(inline) =
  case sA of mk_view @dim0 @a (dA : dim0) (fA : Stored NoneType -> Writer a).
  case sB of mk_view @dim0 @b (dB : dim0) (fB : Stored NoneType -> Writer b).
  mk_view @dim0 @c dA
  (\ (i : Stored NoneType) -> Writer c.
    case boxed @a (fA i) of boxed @a (x : a).
    case boxed @b (fB i) of boxed @b (y : b).
    transformer x y);


ShapeDict_dim0_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  (sC : Stream dim0 c)
  -> Stream dim0 d attribute(inline) =
  case sA of mk_view @dim0 @a (dA : dim0) (fA : Stored NoneType -> Writer a).
  case sB of mk_view @dim0 @b (dB : dim0) (fB : Stored NoneType -> Writer b).
  case sC of mk_view @dim0 @c (dC : dim0) (fC : Stored NoneType -> Writer c).
  mk_view @dim0 @d dA
  (\ (i : Stored NoneType) -> Writer d.
    case boxed @a (fA i) of boxed @a (x : a).
    case boxed @b (fB i) of boxed @b (y : b).
    case boxed @c (fC i) of boxed @c (z : c).
    transformer x y z);


ShapeDict_dim0_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  (sC : Stream dim0 c)
  (sD : Stream dim0 d)
  -> Stream dim0 e attribute(inline) =
  case sA of mk_view @dim0 @a (dA : dim0) (fA : Stored NoneType -> Writer a).
  case sB of mk_view @dim0 @b (dB : dim0) (fB : Stored NoneType -> Writer b).
  case sC of mk_view @dim0 @c (dC : dim0) (fC : Stored NoneType -> Writer c).
  case sD of mk_view @dim0 @d (dD : dim0) (fD : Stored NoneType -> Writer d).
  mk_view @dim0 @e dA
  (\ (i : Stored NoneType) -> Writer e.
    case boxed @a (fA i) of boxed @a (x : a).
    case boxed @b (fB i) of boxed @b (y : b).
    case boxed @c (fC i) of boxed @c (z : c).
    case boxed @d (fD i) of boxed @d (w : d).
    transformer x y z w);

ShapeDict_dim0_slice @(t : bare -> bare) @(a : bare)
  (has_shape : coerce @box (shape t) dim0)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (sl : slice dim0)
  -> view dim0 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  mk_view @dim0 @a mk_dim0
  (\ (ix : Stored NoneType) -> Writer a.
    at_index @a repr container (coerce @(index dim0) @(index (shape t)) ix));


ShapeDict_list_dim_member
  (sh : list_dim) (ix : Stored int) -> bool =
  case ix of stored @int (ix_i : int).
  case sh of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    nothingVal @int. ix_i >=# 0
  ; justVal @int (size_i : int). and (ix_i >=# 0) (ix_i <# size_i)
  };


ShapeDict_list_dim_intersect (d1 : list_dim) (d2 : list_dim) -> list_dim =
  case d1 of mk_list_dim (m_size1 : MaybeVal int).
  case d2 of mk_list_dim (m_size2 : MaybeVal int).
  mk_list_dim
  (case m_size1 of {
     justVal @int (size1 : int).
       case m_size2 of {
         justVal @int (size2 : int).
           justVal @int (min_int size1 size2)
       ; nothingVal @int.
           justVal @int size1
       }
   ; nothingVal @int.
       m_size2
   });


ShapeDict_list_dim_flatten @(a : bare) (repr : Repr a) (s : Stream list_dim a)
  -> Stream list_dim a attribute(inline) = s;


ShapeDict_list_dim_generate @(a : bare)
  (repr : Repr a) (d : list_dim) (f : Stored int -> Writer a)
  -> Stream list_dim a =
  viewStream @a (view_generate @list_dim
  ShapeDict_list_dim @a repr d f);


ShapeDict_list_dim_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (s : Stream list_dim a)
  -> Stream list_dim b attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      sequenceStream @b (Sequence_map @a @b repr_a repr_b transformer sq)
  ; viewStream @a (vw : view list_dim a).
      viewStream @b
      (view_map @list_dim
       ShapeDict_list_dim @a @b repr_a repr_b transformer vw)
  };


ShapeDict_list_dim_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sA : Stream list_dim a)
  (sB : Stream list_dim b)
  -> Stream list_dim c attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view list_dim b). viewToSequence @b repr_b vwB
            } in
      sequenceStream @c
      (Sequence_zipWith @a @b @c repr_a repr_b repr_c transformer sqA sqB)

  ; viewStream @a (vwA : view list_dim a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          sequenceStream @c
          (Sequence_zipWith @a @b @c repr_a repr_b repr_c transformer
           (viewToSequence @a repr_a vwA) sqB)
      ; viewStream @b (vwB : view list_dim b).
          viewStream @c
          (view_zipWith @list_dim
           ShapeDict_list_dim
           @a @b @c repr_a repr_b repr_c transformer vwA vwB)
    }
  };

ShapeDict_list_dim_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sA : Stream list_dim a)
  (sB : Stream list_dim b)
  (sC : Stream list_dim c)
  -> Stream list_dim d attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view list_dim b). viewToSequence @b repr_b vwB
            } in
      let sqC : Sequence c =
            case sC of {
              sequenceStream @c (sqC : Sequence c). sqC
            ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
            } in
      sequenceStream @d
      (Sequence_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d
       transformer sqA sqB sqC)

  ; viewStream @a (vwA : view list_dim a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          let sqC : Sequence c =
                case sC of {
                  sequenceStream @c (sqC : Sequence c). sqC
                ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
                } in
          sequenceStream @d
          (Sequence_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d transformer
           (viewToSequence @a repr_a vwA) sqB sqC)

      ; viewStream @b (vwB : view list_dim b).
          case sC of {
            sequenceStream @c (sqC : Sequence c).
              sequenceStream @d
              (Sequence_zipWith3 @a @b @c @d
               repr_a repr_b repr_c repr_d transformer
               (viewToSequence @a repr_a vwA)
               (viewToSequence @b repr_b vwB)
               sqC)

          ; viewStream @c (vwC : view list_dim c).
              viewStream @d
              (view_zipWith3 @list_dim
               ShapeDict_list_dim
               @a @b @c @d repr_a repr_b repr_c repr_d
               transformer vwA vwB vwC)
          }
      }
  };


ShapeDict_list_dim_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sA : Stream list_dim a)
  (sB : Stream list_dim b)
  (sC : Stream list_dim c)
  (sD : Stream list_dim d)
  -> Stream list_dim e attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view list_dim b). viewToSequence @b repr_b vwB
            } in
      let sqC : Sequence c =
            case sC of {
              sequenceStream @c (sqC : Sequence c). sqC
            ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
            } in
      let sqD : Sequence d =
            case sD of {
              sequenceStream @d (sqD : Sequence d). sqD
            ; viewStream @d (vwD : view list_dim d). viewToSequence @d repr_d vwD
            } in
      sequenceStream @e
      (Sequence_zipWith4 @a @b @c @d @e repr_a repr_b repr_c repr_d repr_e
       transformer sqA sqB sqC sqD)

  ; viewStream @a (vwA : view list_dim a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          let sqC : Sequence c =
                case sC of {
                  sequenceStream @c (sqC : Sequence c). sqC
                ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
                } in
          let sqD : Sequence d =
                case sD of {
                  sequenceStream @d (sqD : Sequence d). sqD
                ; viewStream @d (vwD : view list_dim d). viewToSequence @d repr_d vwD
                } in
          sequenceStream @e
          (Sequence_zipWith4 @a @b @c @d @e
           repr_a repr_b repr_c repr_d repr_e transformer
           (viewToSequence @a repr_a vwA) sqB sqC sqD)

      ; viewStream @b (vwB : view list_dim b).
          case sC of {
            sequenceStream @c (sqC : Sequence c).
              let sqD : Sequence d =
                    case sD of {
                      sequenceStream @d (sqD : Sequence d).
                        sqD
                    ; viewStream @d (vwD : view list_dim d).
                        viewToSequence @d repr_d vwD
                    } in
              sequenceStream @e
              (Sequence_zipWith4 @a @b @c @d @e
               repr_a repr_b repr_c repr_d repr_e transformer
               (viewToSequence @a repr_a vwA)
               (viewToSequence @b repr_b vwB)
               sqC sqD)

          ; viewStream @c (vwC : view list_dim c).
              case sD of {
                sequenceStream @d (sqD : Sequence d).
                  sequenceStream @e
                  (Sequence_zipWith4 @a @b @c @d @e
                   repr_a repr_b repr_c repr_d repr_e transformer
                   (viewToSequence @a repr_a vwA)
                   (viewToSequence @b repr_b vwB)
                   (viewToSequence @c repr_c vwC)
                   sqD)
              ; viewStream @d (vwD : view list_dim d).
                  viewStream @e
                  (view_zipWith4 @list_dim
                   ShapeDict_list_dim @a @b @c @d @e
                   repr_a repr_b repr_c repr_d repr_e
                   transformer vwA vwB vwC vwD)
              }
          }
      }
  };


ShapeDict_list_dim_slice @(t : bare -> bare) @(a : bare)
  (is_dim1 : coerce @box (shape t) list_dim)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice list_dim)
  -> view list_dim a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute parameters of the sliced list
  case internalApplyListSlice slice_argument
       (coerce @(shape t) @list_dim (get_shape @a container)) of
    (view_domain : list_dim, view_map : LinearMap).

  view_generate @list_dim
  ShapeDict_list_dim @a repr view_domain
  (\ (i : Stored int) (ret : OutPtr a) -> IEffect a.

    -- Compute the index in the original object that holds the value at 'i'
    let source_index : int =
          case i of stored @int (u_i : int). evalLM u_i view_map in
    case boxed @(Stored int) (stored @int source_index) of
      boxed @(Stored int) (source_s_index : Stored int).
    let s_index : index (shape t) =
          coerce @(index list_dim) @(index (shape t)) source_s_index in

    -- Retrieve the value
    at_index @a repr container s_index ret);


ShapeDict_dim1_member (dom : dim1) (ix : Stored int)
  -> bool attribute(inline) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case ix of stored @int (ix_i : int).

  -- Point must be in the interval and in the linear map
  if inInterval ix_i iv
  then inLM ix_i lm
  else False;


ShapeDict_dim1_intersect (d : dim1) (e : dim1) -> dim1 =
  case d of mk_dim1 (iv1 : Interval) (m1 : LinearMap).
  case e of mk_dim1 (iv2 : Interval) (m2 : LinearMap).
  case intersectLM m1 m2 of {
    justVal @LinearMap (m3 : LinearMap).
      let iv3 : Interval = trimInterval (intersectInterval iv1 iv2) m3 in
      mk_dim1 iv3 m3
  ; nothingVal @LinearMap.
      mk_dim1 (interval (justVal @int 0) (justVal @int 0)) (linearMap 1 0)
  };


ShapeDict_dim1_flatten @(a : bare)
  (repr : Repr a) (s : Stream dim1 a) -> Stream list_dim a
  attribute(inline, inline_sequential) =
  case s of mk_view @dim1 @a (dom : dim1) (f : Stored int -> Writer a).

  -- Compute the size of the list
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case lm of linearMap (stride : int) (alignment : int).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case case lb of {
         justVal @int (lb_i : int).
           case ub of {
             justVal @int (ub_i : int).
               -- Bounded list
               (justVal @int ((ub_i -# lb_i) //# stride),
                linearMap stride lb_i)
           ; nothingVal @int.
               -- Unbounded list
               (nothingVal @int,
                linearMap stride lb_i)
         }
       ; nothingVal @int. except @(MaybeVal int, LinearMap)
       } of
    (list_size : MaybeVal int, list_map : LinearMap).

  viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a
   repr (mk_list_dim list_size)
   (\ (ix : Stored int) -> Writer a.
      case ix of stored @int (ix_u : int).
      case boxed @(Stored int) (stored @int (evalLM ix_u list_map)) of
        boxed @(Stored int) (ix2 : Stored int).
      f ix2));


ShapeDict_dim1_generate @(a : bare)
  (repr : Repr a) (dom : dim1) (f : index dim1 -> Writer a)
  -> Stream dim1 a attribute(inline) =
  view_generate @dim1
  ShapeDict_dim1 @a repr dom f;


ShapeDict_dim1_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (s : Stream dim1 a)
  -> Stream dim1 b attribute(inline) =
  view_map @dim1
  ShapeDict_dim1 @a @b repr_a repr_b transformer s;


ShapeDict_dim1_slice @(t : bare -> bare) @(a : bare)
  (is_dim1 : coerce @box (shape t) dim1)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice dim1)
  -> view dim1 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute the slice's domain
  let dom : dim1 = coerce @(shape t) @dim1 (get_shape @a container) in
  let slice_dom : dim1 = internalApplyArraySlice slice_argument dom in

  view_generate @dim1
  ShapeDict_dim1 @a repr slice_dom
  (\ (i : index dim1) (ret : OutPtr a) -> IEffect a.
    at_index @a repr container (coerce @(index dim1) @(index (shape t)) i) ret);


ShapeDict_dim2_member (dom : dim2) (ix : index dim2) -> bool =
  -- Take the conjunction of x and y membership conditions
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case ix of pyonTuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
  if ShapeDict_dim1_member dom_y ix_y
  then ShapeDict_dim1_member dom_x ix_x
  else False;


ShapeDict_dim2_intersect (domA : dim2) (domB : dim2) -> dim2 =
  -- Take the intersection in each dimension
  case domA of mk_dim2 (domA_y : dim1) (domA_x : dim1).
  case domB of mk_dim2 (domB_y : dim1) (domB_x : dim1).
  mk_dim2 (ShapeDict_dim1_intersect domA_y domB_y)
          (ShapeDict_dim1_intersect domA_x domB_x);


ShapeDict_dim2_generate @(a : bare)
  (repr : Repr a) (dom : dim2) (f : index dim2 -> Writer a)
  -> Stream dim2 a attribute(inline) =
  view_generate @dim2 ShapeDict_dim2 @a repr dom f;


ShapeDict_dim2_flatten @(a : bare)
  (repr : Repr a) (s : Stream dim2 a) -> Stream list_dim a
  attribute(inline, inline_dimensionality) =
  case s of mk_view @dim2 @a (dom : dim2) (f : index dim2 -> Writer a).
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dom_x of mk_dim1 (iv_x : Interval) (lm_x : LinearMap).
  case dom_y of mk_dim1 (iv_y : Interval) (lm_y : LinearMap).
  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lm_x of linearMap (stride_x : int) (alignment_x : int).
  case lm_y of linearMap (stride_y : int) (alignment_y : int).

  -- Lower bound must be finite
  case lb_x of {
    justVal @int (lb_x_i : int).
      case ub_x of {
        justVal @int (ub_x_i : int).
          -- Domain has finite x extent
          let count_x : int = (ub_x_i -# lb_x_i) //# stride_x in

          case lb_y of {
            justVal @int (lb_y_i : int).

              -- Compute the number of points in the domain
              let list_size : MaybeVal int =
                    case ub_y of {
                      justVal @int (ub_y_i : int).
                        -- Domain is bounded on all sides
                        let count_y : int = (ub_y_i -# lb_y_i) //# stride_y in
                        justVal @int (count_x *# count_y)
                    ; nothingVal @int.

                        -- Domain is unbounded in the y-dimensino
                        nothingVal @int
                    } in

              viewStream @a
              (mk_view @list_dim @a (mk_list_dim list_size)
               (\ (si : Stored int) -> Writer a.
                  -- Linearize the index
                  case si of stored @int (i : int).
                  let i_y : int = i //# count_x in
                  let i_x : int = i %# count_x in

                  -- Apply the stride to get an index in the domain
                  let dim2_i_y : int = lb_y_i +# i_y *# stride_y in 
                  let dim2_i_x : int = lb_x_i +# i_x *# stride_x in 
                  case boxed @(PyonTuple2 (Stored int) (Stored int))
                       (pyonTuple2 @(Stored int) @(Stored int)
                        (stored @int dim2_i_y) (stored @int dim2_i_x))
                  of boxed @(PyonTuple2 (Stored int) (Stored int))
                     (index_2d : PyonTuple2 (Stored int) (Stored int)).
                  f index_2d))

          ; nothingVal @int.
              except @(Stream list_dim a)
          }

      ; nothingVal @int.
          -- Domain has infinite x extent
          case lb_y of {
            justVal @int (lb_y_i : int).
              viewStream @a
              (mk_view @list_dim @a (mk_list_dim (nothingVal @int))
               (\ (si : Stored int) -> Writer a.
                  case si of stored @int (i : int).
                  let dim2_i_x : int = lb_x_i +# i *# stride_x in
                  case boxed @(PyonTuple2 (Stored int) (Stored int))
                       (pyonTuple2 @(Stored int) @(Stored int)
                        (stored @int lb_y_i) (stored @int dim2_i_x))
                  of boxed @(PyonTuple2 (Stored int) (Stored int))
                     (index_2d : PyonTuple2 (Stored int) (Stored int)).
                  f index_2d))
          ; nothingVal @int.
              except @(Stream list_dim a)
          }
      }

  ; nothingVal @int.
      except @(Stream list_dim a)
  };


ShapeDict_dim2_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (s : Stream dim2 a)
  -> Stream dim2 b attribute(inline) =
  view_map @dim2
  ShapeDict_dim2 @a @b repr_a repr_b transformer s;


ShapeDict_dim2_slice @(t : bare -> bare) @(a : bare)
  (is_dim2 : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice dim2)
  -> view dim2 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute the slice's domain
  case slice_argument of
    pyonTuple2 @SliceObject @SliceObject
    (slice_y : SliceObject) (slice_x : SliceObject).

  let dom : dim2 = coerce @(shape t) @dim2 (get_shape @a container) in
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  let slice_dom : dim2 =
        mk_dim2 (internalApplyArraySlice slice_y dom_y)
                (internalApplyArraySlice slice_x dom_x) in

  view_generate @dim2
  ShapeDict_dim2 @a repr slice_dom
  (\ (i : index dim2) (ret : OutPtr a) -> IEffect a.
    at_index @a repr container (coerce @(index dim2) @(index (shape t)) i) ret);

-------------------------------------------------------------------------------
-- Indexable dictionary functions

IndexableDict_list_at_point @(a : bare)
  (repr : Repr a) (ls : list a) (ix : Stored int) (ret : OutPtr a) -> IEffect a
  attribute(inline) =
  case ls of make_list @a @(N : intindex)
             (n : FIInt N) (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).
  case ix of stored @int (ix_i : int).
  copy @a repr (subscript @N @a repr ay ix_i) ret;


IndexableDict_list_get_shape @(a : bare) (ls : list a) -> list_dim
  attribute(inline) =
  case ls of make_list @a @(N : intindex)
             (n : FIInt N) (ayref : Referenced (arr N a)).
  case n of fiInt @N (size : int).
  mk_list_dim (justVal @int size);


IndexableDict_view_at_point @(sh : box) (dict : ShapeDict sh) ->
  (a : bare) -> Repr a -> view sh a -> index sh -> Writer a =
  \ @(a : bare)
    (repr : Repr a) (vw : view sh a) (ix : index sh) -> Writer a.
    case vw of mk_view @sh @a (dom : sh) (f : index sh -> Writer a).
    f ix;


IndexableDict_view_get_shape @(sh : box) (dict : ShapeDict sh) ->
  (a : bare) -> view sh a -> sh =
  \ @(a : bare) (vw : view sh a) -> sh.
    case vw of mk_view @sh @a (dom : sh) (f : index sh -> Writer a).
    dom;


IndexableDict_array0_at_point @(a : bare)
  (repr : Repr a) (ay : array0 a) (ix : Stored NoneType) (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case ay of mk_array0 @a (x : a). copy @a repr x ret;


IndexableDict_array0_get_shape @(a : bare)
  (ay : array0 a) -> dim0
  attribute(inline) =
  mk_dim0;


IndexableDict_array1_at_point @(a : bare)
  (repr : Repr a) (ay : array1 a) (ix : Stored int) (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case ay of mk_array1 @a @(N : intindex)
             (lb : int) (stride : int) (size : FIInt N)
             (ayref : Referenced (arr N a)).
  case ayref of referenced @(arr N a) (ay : arr N a).

  -- Compute real array index
  case ix of stored @int (ix_i : int).
  let real_index : int = (ix_i -# lb) //# stride in
  copy @a repr (subscript @N @a repr ay real_index) ret;


IndexableDict_array1_get_shape @(a : bare)
  (ay : array1 a) -> dim1
  attribute(inline) =
  case ay of mk_array1 @a @(N : intindex)
             (lb : int) (stride : int) (size : FIInt N)
             (ayref : Referenced (arr N a)).
  arrayDescToDim1 @N lb stride size;


IndexableDict_array2_at_point @(a : bare)
  (repr : Repr a)
  (ay : array2 a)
  (ix : PyonTuple2 (Stored int) (Stored int))
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case ay of mk_array2 @a @(M N : intindex)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : Referenced (arr M (arr N a))).
  case ayref of referenced @(arr M (arr N a)) (ay : arr M (arr N a)).
  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in

  -- Compute real array indices
  case ix of pyonTuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
  case ix_y of stored @int (ix_y_i : int).
  let real_index_y : int = (ix_y_i -# lb_y) //# stride_y in
  case ix_x of stored @int (ix_x_i : int).
  let real_index_x : int = (ix_x_i -# lb_x) //# stride_x in

  -- Copy the desired element
  copy @a repr
  (subscript @N @a repr (subscript @M @(arr N a) row_repr ay real_index_y)
   real_index_x) ret;


IndexableDict_array2_get_shape @(a : bare)
  (ay : array2 a) -> dim2
  attribute(inline) =
  case ay of mk_array2 @a @(M N : intindex)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : Referenced (arr M (arr N a))).
  mk_dim2 (arrayDescToDim1 @M lb_y stride_y size_y)
          (arrayDescToDim1 @N lb_x stride_x size_x);

-------------------------------------------------------------------------------
-- High-level overloaded functions

fun_reduce @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (init : a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  let type sh = shape t in

  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Writer (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let s : Stream1 a = shape_flatten @a repr (traverse @a repr input) in
  case s of {
    viewStream @a (vw : view list_dim a).
      reduce_list_dim @a repr reducer init vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce @a repr reducer init sq ret
  };


fun_reduce1 @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Writer a)
  (input : t a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  let type sh = shape t in

  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Writer (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let s : Stream1 a = shape_flatten @a repr (traverse @a repr input) in
  case s of {
    viewStream @a (vw : view list_dim a).
      reduce1_list_dim @a repr reducer vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce1 @a repr reducer sq ret
  };


fun_map @(t : bare -> bare)
        @(a b : bare)
        (traversable : TraversableDict t)
        (shape_dict : ShapeDict (shape t))
        (repr_a : Repr a)
        (repr_b : Repr b)
        (transformer : a -> Writer b)
        (container : t a)
	(ret : OutPtr (t b))
        -> IEffect (t b)
 	attribute(inline) =
  let type sh = shape t in

  case traversable of
    traversableDict @t
    (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
    (build : (a : bare) -> Repr a -> Stream sh a -> Writer (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  build @b repr_b
  (shape_map @a @b repr_a repr_b transformer
   (traverse @a repr_a container))
  ret;


fun_zip @(t1 t2 : bare -> bare) @(a : bare) @(b : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (equal12 : coerce @box (shape t1) (shape t2))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b)
        (inputA : t1 a) (inputB : t2 b)
  -> Stream (shape t1) (PyonTuple2 a b)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (ret : OutPtr (PyonTuple2 a b))
    		-> IEffect (PyonTuple2 a b) =
      pyonTuple2 @a @b (copy @a reprA x) (copy @b reprB y) ret
  in

  shape_zipWith @a @b @(PyonTuple2 a b)
  reprA reprB (repr_PyonTuple2 @a @b reprA reprB)
  transformer stream1 stream2;

fun_zip3 @(t1 t2 t3 : bare -> bare) @(a b c : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (equal12 : coerce @box (shape t1) (shape t2))
        (equal23 : coerce @box (shape t2) (shape t3))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c)
  -> Stream (shape t1) (PyonTuple3 a b c)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Writer (t3 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (z : c) (ret : OutPtr (PyonTuple3 a b c))
    		-> IEffect (PyonTuple3 a b c) =
      pyonTuple3 @a @b @c (copy @a reprA x) (copy @b reprB y) (copy @c reprC z) ret
  in

  shape_zipWith3 @a @b @c @(PyonTuple3 a b c)
  reprA reprB reprC (repr_PyonTuple3 @a @b @c reprA reprB reprC)
  transformer stream1 stream2 stream3;


fun_zip4 @(t1 t2 t3 t4 : bare -> bare) @(a b c d : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (traversable4 : TraversableDict t4)
        (equal12 : coerce @box (shape t1) (shape t2))
        (equal23 : coerce @box (shape t2) (shape t3))
        (equal34 : coerce @box (shape t3) (shape t4))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c) (reprD : Repr d)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c) (inputD : t4 d)
  -> Stream (shape t1) (PyonTuple4 a b c d)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Writer (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Writer (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Writer (t3 a)).
  case traversable4
  of traversableDict @t4
       (traverse4 : (a : bare) -> Repr a -> t4 a -> Stream (shape t4) a)
       (build4 : (a : bare) -> Repr a -> Stream (shape t4) a -> Writer (t4 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in
  let stream4 : Stream (shape t1) d =
        coerce @(Stream (shape t4) d) @(Stream (shape t1) d)
	(traverse4 @d reprD inputD) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (z : c) (w : d) (ret : OutPtr (PyonTuple4 a b c d))
    		-> IEffect (PyonTuple4 a b c d) =
      pyonTuple4 @a @b @c @d (copy @a reprA x) (copy @b reprB y) (copy @c reprC z) (copy @d reprD w) ret
  in

  shape_zipWith4 @a @b @c @d @(PyonTuple4 a b c d)
  reprA reprB reprC reprD (repr_PyonTuple4 @a @b @c @d reprA reprB reprC reprD)
  transformer stream1 stream2 stream3 stream4;


rows @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (shape t) dim2)
  (repr : Repr a)
  (container : t a)
  -> view dim1 (StoredBox (view dim1 a))
  attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).
  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 (shape_y : dim1) (shape_x : dim1).

  view_generate @dim1
  ShapeDict_dim1 @(StoredBox (view dim1 a))
  (repr_Box @(view dim1 a)) shape_y
  (\ (s_y : Stored int) -> Writer (StoredBox (view dim1 a)).
    storedBox @(view dim1 a)
    (view_generate @dim1 ShapeDict_dim1
     @a repr shape_x
     (\ (s_x : Stored int) (ret : OutPtr a) -> IEffect a.
       case boxed @(index dim2)
            (pyonTuple2 @(Stored int) @(Stored int)
             (copy @(Stored int) repr_int s_y)
             (copy @(Stored int) repr_int s_x)) of
         boxed @(index dim2) (ix : index dim2).
       at_index @a repr container
       (coerce @(index dim2) @(index (shape t)) ix)
       ret)));
  

cols @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (shape t) dim2)
  (repr : Repr a)
  (container : t a)
  -> view dim1 (StoredBox (view dim1 a))
  attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).
  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 (shape_y : dim1) (shape_x : dim1).

  view_generate @dim1
  ShapeDict_dim1 @(StoredBox (view dim1 a))
  (repr_Box @(view dim1 a)) shape_x
  (\ (s_x : Stored int) -> Writer (StoredBox (view dim1 a)).
    storedBox @(view dim1 a)
    (view_generate @dim1
     ShapeDict_dim1 @a repr shape_y
     (\ (s_y : Stored int) (ret : OutPtr a) -> IEffect a.
       case boxed @(index dim2)
            (pyonTuple2 @(Stored int) @(Stored int)
             (copy @(Stored int) repr_int s_y)
             (copy @(Stored int) repr_int s_x)) of
         boxed @(index dim2) (ix : index dim2).
       at_index @a repr container
       (coerce @(index dim2) @(index (shape t)) ix)
       ret)));


outerproduct @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim2 (PyonTuple2 a b)
  attribute(inline, inline_dimensionality) =

  case sa of mk_view @dim1 @a (domA : dim1) (fA : Stored int -> Writer a).
  case sb of mk_view @dim1 @b (domB : dim1) (fB : Stored int -> Writer b).

  let type Sint = Stored int in
  let type out_type = PyonTuple2 a b in

  view_generate @dim2 ShapeDict_dim2 @out_type
  (repr_PyonTuple2 @a @b repr_a repr_b)
  (mk_dim2 domA domB)
  (\ (ix : PyonTuple2 Sint Sint) (ret : OutPtr out_type) -> IEffect out_type.

    -- Index each view with one component of the index
    case ix of pyonTuple2 @Sint @Sint (ix_y : Sint) (ix_x : Sint).
    pyonTuple2 @a @b (fA ix_y) (fB ix_x) ret);


-------------------------------------------------------------------------------
-- API functions

range (length : int) -> Stream list_dim (Stored int)
  attribute(inline) =
  viewStream @(Stored int)
  (view_generate @list_dim ShapeDict_list_dim @(Stored int) repr_int
   (mk_list_dim (justVal @int length))
   (\ (i : Stored int) -> Writer (Stored int).
      copy @(Stored int) repr_int i));


-------------------------------------------------------------------------------
-- High-level list comprehension functions

Stream1_empty @(a : bare) (repr : Repr a) -> Stream1 a attribute(inline) =
  sequenceStream @a (Sequence_empty @a repr);


Stream1_return @(a : bare) (repr : Repr a) (w : Writer a) -> Stream1 a
  attribute(inline) =
  sequenceStream @a (Sequence_return @a repr w);


Stream1_guard @(a : bare) (repr : Repr a) (condition : bool) (s : Stream1 a)
  -> Stream1 a
  attribute(inline) =
  let sq : Sequence a =
        case s of {
	  viewStream @a (vw : view list_dim a). viewToSequence @a repr vw
	; sequenceStream @a (sq : Sequence a). sq
	} in
  sequenceStream @a (Sequence_guard @a repr condition sq);


Stream1_bind @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (s : Stream1 a)
  (t : a -> Stream1 b)
  -> Stream1 b
  attribute(inline) =
  let sq : Sequence a =
        case s of {
	  viewStream @a (vw : view list_dim a). viewToSequence @a repr_a vw
	; sequenceStream @a (sq : Sequence a). sq
	} in
  letfun
    sq_t (x : a) -> Sequence b =
      case t x of {
	  viewStream @b (vw : view list_dim b). viewToSequence @b repr_b vw
	; sequenceStream @b (sq : Sequence b). sq
      } in
  
  sequenceStream @b (Sequence_bind @a @b repr_a sq sq_t);


viewToSequence @(a : bare) (repr : Repr a) (vw : view list_dim a)
  -> Sequence a attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (f : Stored int -> Writer a).
      Sequence_generate @a repr dom f;


sequenceToView @(a : bare) (repr : Repr a) (sq : Sequence a)
  -> view list_dim a attribute(inline, inline_dimensionality) =
  -- Write the entire sequence to a list
  case boxed @(list a) (Sequence_list_build @a repr sq)
  of boxed @(list a) (ls : list a).

  -- Then traverse the list
  case ls of make_list @a @(N : intindex)
                       (size : FIInt N) (aref : Referenced (arr N a)).
  case aref of referenced @(arr N a) (ay : arr N a).

  case size of fiInt @N (size_i : int).
  let dom : list_dim = mk_list_dim (justVal @int size_i) in
  view_generate @list_dim ShapeDict_list_dim @a repr dom
  (\ (si : Stored int) (ret : OutPtr a) -> IEffect a.
     case si of stored @int (i : int).
     copy @a repr (subscript @N @a repr ay i) ret);


-------------------------------------------------------------------------------
-- ShapeDict-like internal functions

view_generate @(sh : box) (shape_dict : ShapeDict sh)
  -> (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> view sh a
  attribute(inline, inline_dimensionality) =

  \ @(a : bare) (repr : Repr a) (dom : sh) (f : index sh -> Writer a)
    -> view sh a.
    mk_view @sh @a dom f;


view_map @(sh : box) (shape_dict : ShapeDict sh)
  -> (a b : bare) -> Repr a -> Repr b -> (a -> Writer b) -> view sh a -> view sh b
  attribute(inline, inline_dimensionality) =

  \ @(a b : bare) (repr_a : Repr a) (repr_a : Repr b) (t : a -> Writer b)
    (s1 : view sh a) -> view sh b.

    case s1 of mk_view @sh @a (d : sh) (f : index sh -> Writer a).
    mk_view @sh @b d
    (\ (ix : index sh) (ret : OutPtr b) -> IEffect b.
       case boxed @a (f ix) of boxed @a (x : a).
       t x ret);


view_zipWith @(sh : box)
  (shape_dict : ShapeDict sh)
  -> (a b c : bare) -> Repr a -> Repr b -> Repr c ->
     (a -> b -> Writer c) ->
     view sh a ->
     view sh b ->
     view sh c
  attribute(inline, inline_dimensionality) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  \ @(a b c : bare) (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
     (t : a -> b -> Writer c)
     (sa : view sh a)
     (sb : view sh b)
     -> view sh c.
    case sa of mk_view @sh @a (dA : sh) (fA : index sh -> Writer a).
    case sb of mk_view @sh @b (dB : sh) (fB : index sh -> Writer b).
    let dC : sh = shape_intersect dA dB in
    mk_view @sh @c dC
    (\ (ix : index sh) (ret : OutPtr c) -> IEffect c.
      case boxed @a (fA ix) of boxed @a (x : a).
      case boxed @b (fB ix) of boxed @b (y : b).
      t x y ret);


view_zipWith3 @(sh : box)
  (shape_dict : ShapeDict sh)
  -> (a b c d : bare) -> Repr a -> Repr b -> Repr c -> Repr d ->
     (a -> b -> c -> Writer d) ->
     view sh a ->
     view sh b ->
     view sh c ->
     view sh d
  attribute(inline, inline_dimensionality) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  \ @(a b c d : bare) (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
     (t : a -> b -> c -> Writer d)
     (sa : view sh a)
     (sb : view sh b)
     (sc : view sh c)
     -> view sh d.
    case sa of mk_view @sh @a (dA : sh) (fA : index sh -> Writer a).
    case sb of mk_view @sh @b (dB : sh) (fB : index sh -> Writer b).
    case sc of mk_view @sh @c (dC : sh) (fC : index sh -> Writer c).
    let dD : sh = shape_intersect (shape_intersect dA dB) dC in
    mk_view @sh @d dD
    (\ (ix : index sh) (ret : OutPtr d) -> IEffect d.
      case boxed @a (fA ix) of boxed @a (x : a).
      case boxed @b (fB ix) of boxed @b (y : b).
      case boxed @c (fC ix) of boxed @c (z : c).
      t x y z ret);


view_zipWith4 @(sh : box)
  (shape_dict : ShapeDict sh)
  -> (a b c d e : bare) -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
     (a -> b -> c -> d -> Writer e) ->
     view sh a ->
     view sh b ->
     view sh c ->
     view sh d ->
     view sh e
  attribute(inline, inline_dimensionality) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Writer a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  \ @(a b c d e : bare)
     (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
     (t : a -> b -> c -> d -> Writer e)
     (sa : view sh a)
     (sb : view sh b)
     (sc : view sh c)
     (sd : view sh d)
     -> view sh e.
    case sa of mk_view @sh @a (dA : sh) (fA : index sh -> Writer a).
    case sb of mk_view @sh @b (dB : sh) (fB : index sh -> Writer b).
    case sc of mk_view @sh @c (dC : sh) (fC : index sh -> Writer c).
    case sd of mk_view @sh @d (dD : sh) (fD : index sh -> Writer d).
    let dE : sh =
          shape_intersect (shape_intersect (shape_intersect dA dB) dC) dD in
    mk_view @sh @e dE
    (\ (ix : index sh) (ret : OutPtr e) -> IEffect e.
      case boxed @a (fA ix) of boxed @a (x : a).
      case boxed @b (fB ix) of boxed @b (y : b).
      case boxed @c (fC ix) of boxed @c (z : c).
      case boxed @d (fD ix) of boxed @d (w : d).
      t x y z w ret);


Sequence_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
          (transformer : a -> Writer b) (sq : Sequence a) -> Sequence b
  attribute(inline, inline_final) =
  case sq of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  letfun
    go (state : st) -> StreamNext st b =
      case next state of {
        streamValue @st @a (next_state : st) (value : BoxedType a).
          let output_value : BoxedType b =
                case boxed @a (convertToBare @a repr_a value) of boxed @a (x : a).
		convertToBoxed @b repr_b (transformer x)
          in streamValue @st @b next_state output_value;

        streamEmpty @st @a.
          streamEmpty @st @b
      }
  in sequence @b @st state go;


Sequence_zipWith
  @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sqA : Sequence a)
  (sqB : Sequence b)
  -> Sequence c
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).

  let type st_c = Stored (st_a, st_b) in
  
  letfun
    go (state : Boxed st_c) -> StreamNext (Boxed st_c) c =
      -- Unpack the state
      case state of boxed @st_c (u_state : st_c).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : BoxedType a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : BoxedType b).

	      -- Create output value
	      let value : BoxedType c =
	            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
		    convertToBoxed @c repr_c (transformer x y) in
	      let next_state : Boxed st_c =
	            boxed @st_c (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed st_c) @c next_state value;

	    streamEmpty @st_b @b.
	      streamEmpty @(Boxed st_c) @c
          };

	streamEmpty @st_a @a.
	  streamEmpty @(Boxed st_c) @c
      }
  in sequence @c @(Boxed st_c)
       (boxed @st_c (stored @(st_a, st_b) (state_a, state_b)))
       go;


Sequence_zipWith3
  @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sqA : Sequence a)
  (sqB : Sequence b)
  (sqC : Sequence c)
  -> Sequence d
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).
  case sqC
  of sequence @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c c).

  let type st_d = Stored (st_a, st_b, st_c) in
  
  letfun
    go (state : Boxed st_d) -> StreamNext (Boxed st_d) d =
      -- Unpack the state
      case state of boxed @st_d (u_state : st_d).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : BoxedType a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @c
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Create output value
                  let value : BoxedType d =
                        case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                        convertToBoxed @d repr_d (transformer x y z) in
                  let next_state : Boxed st_d =
                        boxed @st_d (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed st_d) @d next_state value;

                  streamEmpty @st_c @c.
                    streamEmpty @(Boxed st_d) @d
                };

              streamEmpty @st_b @b.
                streamEmpty @(Boxed st_d) @d
            };

        streamEmpty @st_a @a.
          streamEmpty @(Boxed st_d) @d
      }
  in sequence @d @(Boxed st_d)
       (boxed @st_d (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;


Sequence_zipWith4
  @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sqA : Sequence a)
  (sqB : Sequence b)
  (sqC : Sequence c)
  (sqD : Sequence d)
  -> Sequence e
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).
  case sqC
  of sequence @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c c).
  case sqD
  of sequence @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d d).

  let type st_e = Stored (st_a, st_b, st_c, st_d) in
  
  letfun
    go (state : Boxed st_e) -> StreamNext (Boxed st_e) e =
      -- Unpack the state
      case state of boxed @st_e (u_state : st_e).
      case u_state of stored @(st_a, st_b, st_c, st_d) (i_state : (st_a, st_b, st_c, st_d)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : BoxedType a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : BoxedType b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @c
                  (next_state_c : st_c) (value_c : BoxedType c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @d
                      (next_state_d : st_d) (value_d : BoxedType d).

                      -- Create output value
                      let value : BoxedType e =
                            case boxed @a (convertToBare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (convertToBare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (convertToBare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (convertToBare @d repr_d value_d) of boxed @d (w : d).
                            convertToBoxed @e repr_e (transformer x y z w) in
                      let next_state : Boxed st_e =
                            boxed @st_e (stored @(st_a, st_b, st_c, st_d) (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @(Boxed st_e) @e next_state value;

                      streamEmpty @st_d @d.
                        streamEmpty @(Boxed st_e) @e
                    };

                  streamEmpty @st_c @c.
                    streamEmpty @(Boxed st_e) @e
                };

              streamEmpty @st_b @b.
                streamEmpty @(Boxed st_e) @e
            };

        streamEmpty @st_a @a.
          streamEmpty @(Boxed st_e) @e
      }
  in sequence @e @(Boxed st_e)
       (boxed @st_e (stored @(st_a, st_b, st_c, st_d) (state_a, state_b, state_c, state_d)))
       go;



-------------------------------------------------------------------------------
-- View layer stream consumers

build_list_dim_list @(a : bare)
  (repr : Repr a) (vw : view list_dim a) (ret : OutPtr (list a))
  -> IEffect (list a)
  attribute(inline, inline_sequential) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (f : Stored int -> Writer a).
  case dom of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    justVal @int (size : int).
      -- Finite view
      case defineIntIndex size of someIInt @(N : intindex) (sz : FIInt N).
      make_list @a @N sz
      (referenced @(arr N a)
       (arr1D_build @N @a repr sz
        (\ (i : int) (ret : OutPtr a) -> IEffect a.
           case boxed @(Stored int) (stored @int i) of
             boxed @(Stored int) (s_i : Stored int).
           f s_i ret)))
      ret

  ; nothingVal @int.
      -- Infinte views can't be turned into lists
      except @(IEffect (list a))
  };


build_dim1_array @(a : bare)
  (repr : Repr a) (vw : view dim1 a)
  (ret : OutPtr (array1 a))
  -> IEffect (array1 a)
  attribute(inline, inline_sequential) =

  case vw of mk_view @dim1 @a (dom : dim1) (f : Stored int -> Writer a).
  dim1ToArrayDesc @(array1 a) dom
  (\ @(N : intindex)
     (lb : int) (stride : int) (size : FIInt N) (ret : OutPtr (array1 a))
     -> IEffect (array1 a).

     let linear_map : LinearMap = linearMap stride lb in

     mk_array1 @a @N lb stride size
     (referenced @(arr N a)
      (arr1D_build @N @a repr size
       (\ (i : int) (ret : OutPtr a) -> IEffect a.
           -- Compute the logical index corresponding to array index 'i'
           let logical_i : int = evalLM i linear_map in
           case boxed @(Stored int) (stored @int logical_i) of
             boxed @(Stored int) (s_i : Stored int).
           f s_i ret)))
      ret)
  ret;


reduce_list_dim @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (vw : view list_dim a)
  -> Writer a
  attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (gen : Stored int -> Writer a).

  primitive_list_dim_reduce @a repr dom gen f init;


reduce1_list_dim @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (vw : view list_dim a)
  -> Writer a
  attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (gen : Stored int -> Writer a).

  primitive_list_dim_reduce1 @a repr dom gen f;


-------------------------------------------------------------------------------
-- Sequence layer

Sequence_guard @(a : bare)
  (repr : Repr a) (condition : bool) (s : Sequence a) -> Sequence a
  attribute(inline) =
  if condition then s else Sequence_empty @a repr;


Sequence_empty @(a : bare) (repr : Repr a) -> Sequence a
  attribute(inline, inline_final) =
  let type st = Boxed (Stored NoneType) in
  sequence @a @st
  (boxed @(Stored NoneType) (stored @NoneType None))
  (\ (x : st) -> StreamNext st a. streamEmpty @st @a);


Sequence_return @(a : bare)
  (repr : Repr a)
  (ret : Writer a)
  -> Sequence a
  attribute(inline, inline_final) =
  let type st = Boxed (Stored bool) in
  sequence @a @st
  (boxed @(Stored bool) (stored @bool False))
  (\ (depleted : st) -> StreamNext st a.
     case depleted of boxed @(Stored bool) (depleted_s : Stored bool).
     case depleted_s of stored @bool (depleted_u : bool).
     if depleted_u
     then streamEmpty @st @a
     else streamValue @st @a
     	  (boxed @(Stored bool) (stored @bool True))
	  (convertToBoxed @a repr ret));


Sequence_reduce @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (sq : Sequence a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  Sequence_fold @a @a repr repr f init sq ret;


Sequence_reduce1 @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Writer a)
  (sq : Sequence a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  -- Use the stream's first element as the initial value
  case sq of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  case next state of {
    streamValue @st @a (next_state : st) (init : BoxedType a).
      case boxed @a (convertToBare @a repr init) of boxed @a (u_init : a).
      let new_sequence : Sequence a =
            sequence @a @st next_state next in
      Sequence_fold @a @a repr repr f u_init new_sequence ret;

    streamEmpty @st @a.
      except @(IEffect a)
  };


Sequence_fold @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : Sequence a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =
  case src of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  letfun
    go (state : st) (accumulator : BoxedType acc) (ret : OutPtr acc)
      -> IEffect acc =
      case next state of {

        -- Obtain value from stream
        streamValue @st @a (next_state : st) (result : BoxedType a).
          -- Compute the new value
          let new_accumulator : BoxedType acc =
                case boxed @a (convertToBare @a repr_a result)
                of boxed @a (y : a).
                case boxed @acc (convertToBare @acc repr_acc accumulator)
                of boxed @acc (x : acc).
                convertToBoxed @acc repr_acc (f x y)

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty @st @a.
	  convertToBare @acc repr_acc accumulator ret
      }
  in go state (convertToBoxed @acc repr_acc (copy @acc repr_acc init)) ret;


Sequence_generate @(a : bare)
  (repr : Repr a) (size : list_dim) (f : index list_dim -> Writer a)
  -> Sequence a
  attribute(inline, inline_final) =

  let type Sint = Stored int in
  let type st = Boxed Sint in
  case size of mk_list_dim (m_list_size : MaybeVal int).
  case m_list_size of {
    justVal @int (list_size : int).
      -- Finite stream
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @Sint (state_s : Sint).
	  case state_s of stored @int (state_u : int).
	  if state_u <# list_size
	  then let next_value : BoxedType a =
	             convertToBoxed @a repr (f state_s) in
	       let next_state : st =
	             boxed @Sint (stored @int (state_u +# 1)) in
	       streamValue @st @a next_state next_value
	  else streamEmpty @st @a
      in
      sequence @a @st (boxed @Sint (stored @int 0)) next

  ; nothingVal @int.
      -- Infinite stream
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @Sint (state_s : Stored int).
	  case state_s of stored @int (state_u : int).
	  let next_value : BoxedType a =
	        convertToBoxed @a repr (f state_s) in
	  let next_state : st =
	        boxed @Sint (stored @int (state_u +# 1)) in
	  streamValue @st @a next_state next_value
      in
      sequence @a @st (boxed @Sint (stored @int 0)) next
  };


Sequence_bind @(a b : bare)
  (repr : Repr a)
  (src : Sequence a)
  (trans : a -> Sequence b)
  -> Sequence b
  attribute(inline, inline_final) =
  case src of
    sequence @a @(src_st : box)
    (src_state : src_st)
    (src_next : src_st -> StreamNext src_st a).

  let type bind_state = BindState src_st a b in

  letfun {
    next_from_source (src_state : src_st) -> StreamNext bind_state b =
      case src_next src_state of {
        streamValue @src_st @a (src_next_state : src_st) (src_value : BoxedType a).
          case boxed @a (convertToBare @a repr src_value) of boxed @a (x : a).
	  case trans x of
	    sequence @b @(trans_st : box)
	    (trans_state : trans_st)
	    (trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_next_state trans_state trans_next
      ; streamEmpty @src_st @a.
	  streamEmpty @bind_state @b
      };

    next_from_trans @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st b)
      -> StreamNext bind_state b =
      case trans_next trans_state of {
        streamValue @trans_st @b (trans_next_state : trans_st) (trans_value : BoxedType b).
          let next_state : bind_state =
	        bindFromTrans @src_st @a @b @trans_st
		src_state trans_next_state trans_next in
          streamValue @bind_state @b next_state trans_value
      ; streamEmpty @trans_st @b.
	  next_from_source src_state
      };

    next (state : bind_state) -> StreamNext bind_state b =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state
      ; bindFromTrans @src_st @a @b @(trans_st : box)
      	(src_state : src_st)
	(trans_state : trans_st)
	(trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_state trans_state trans_next
      }
  } in

  sequence @b @bind_state (bindFromSource @src_st @a @b src_state) next;


Sequence_generate_bind @(a : bare)
  (shp : list_dim) (transformer : Stored int -> Sequence a)
  -> Sequence a
  attribute(inline, inline_final) =
  Sequence_bind @(Stored int) @a repr_int
  (Sequence_generate @(Stored int) repr_int shp (copy @(Stored int) repr_int))
  transformer;


Sequence_parallel_reduce @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (f : a -> a -> Writer a)
  (init : a)
  (g : Stored int -> Sequence a)
  (ret : OutPtr a)
  -> IEffect a =
  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type b = BoxedType a in
      letfun
        combiner (x : b) (y : b) -> b =
          case boxed @a (convertToBare @a repr x) of boxed @a (bx : a).
          case boxed @a (convertToBare @a repr y) of boxed @a (by : a).
          convertToBoxed @a repr (f bx by)
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =

          -- Reduce over the sequence [lb, lb + count)
          case boxed @a (convertToBare @a repr acc_in) of boxed @a (acc : a).
          case count of fiInt @range_N (count_i : int).
          convertToBoxed @a repr
          (Sequence_reduce @a repr f acc
           (Sequence_generate_bind @a (mk_list_dim (justVal @int count_i))
            (\ (si : Stored int) -> Sequence a.
               -- Add 'lb' to the index
               case si of stored @int (i : int).
               case boxed @(Stored int) (stored @int (lb +# i)) of
                 boxed @(Stored int) (real_si : Stored int).
               g real_si)))
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = convertToBoxed @a repr (copy @a repr init) in
      convertToBare @a repr
      (blocked_1d_reduce @N @b count combiner boxed_init reducer)
      ret

  ; nothingVal @int.
      except @(IEffect a)
  };

-------------------------------------------------------------------------------
-- Helper functions over the basic loop layer

arr1D_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N) (f : int -> Writer a)
  (arr_ptr : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline) =

  doall @N @(arr N a) @a size
  (\ (i : int) -> IEffect a.
     f i (subscript_out @N @a repr arr_ptr i));


arr2D_build @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size_y : FIInt M) (size_x : FIInt N) (f : int -> int -> Writer a)
  (arr_ptr : OutPtr (arr M (arr N a)))
  -> IEffect (arr M (arr N a))
  attribute(inline) =

  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  doall @M @(arr M (arr N a)) @(arr N a) size_y
  (\ (y : int) -> IEffect (arr N a).
     doall @N @(arr N a) @a size_x
     (\ (x : int) -> IEffect a.
        f y x
        (subscript_out @N @a repr
         (subscript_out @M @(arr N a) row_repr arr_ptr y) x)));

-------------------------------------------------------------------------------
-- Domain loops (sequential)

primitive_list_dim_reduce @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (generator : Stored int -> Writer a)
  (reducer : a -> a -> Writer a)
  (init : a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case dom of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    justVal @int (size : int).
      case defineIntIndex size of someIInt @(N : intindex) (sz : FIInt N).

      for @N @a repr sz init
      (\ (i : int) (x : a) (loop_ret : OutPtr a) -> IEffect a.
         case boxed @(Stored int) (stored @int i) of
           boxed @(Stored int) (s_i : Stored int).
         case boxed @a (generator s_i) of boxed @a (y : a).
         reducer x y loop_ret)
      ret

  ; nothingVal @int.
      -- Can't evaluate on an infinite domain
      except @(IEffect a)
  };


primitive_list_dim_reduce1 @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (generator : Stored int -> Writer a)
  (reducer : a -> a -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case dom of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    justVal @int (size : int).
      -- Can't reduce on empty range
      if size ==# 0 then except @(IEffect a) else

      -- Evaluate at index 0 to get initial value
      case boxed @(Stored int) (stored @int 0) of
        boxed @(Stored int) (s_zero : Stored int).
      case boxed @a (generator s_zero) of
        boxed @a (init : a).

      -- Reduce remaining values
      case defineIntIndex (size -# 1) of
        someIInt @(N : intindex) (sz : FIInt N).

      for @N @a repr sz init
      (\ (i : int) (x : a) (loop_ret : OutPtr a) -> IEffect a.
         case boxed @(Stored int) (stored @int (i +# 1)) of
           boxed @(Stored int) (s_i : Stored int).
         case boxed @a (generator s_i) of boxed @a (y : a).
         reducer x y loop_ret)
      ret

  ; nothingVal @int.
      -- Can't evaluate on an infinite domain
      except @(IEffect a)
  };


primitive_list_dim_fold @(acc : bare)
  (repr : Repr acc)
  (d : list_dim)
  (f : index list_dim -> acc -> Writer acc)
  (init : acc)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline) =

  case d of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      
      for @N @acc repr count init
      (\ (i : int) (loop_acc : acc) (ret : OutPtr acc) -> IEffect acc.
         case boxed @(Stored int) (stored @int i) of
           boxed @(Stored int) (real_index : Stored int).

         -- Accumulate value
         f real_index loop_acc ret)
      ret

  ; nothingVal @int.
      except @(IEffect acc)
  };


primitive_dim1_reduce @(a : bare)
  (repr : Repr a)
  (dom : dim1)
  (generator : Stored int -> Writer a)
  (reducer : a -> a -> Writer a)
  (init : a)
  -> Writer a
  attribute(inline, inline_final) =

  dim1ToArrayDesc @a dom
  (\ @(N : intindex)
     (lb : int) (stride : int) (size : FIInt N) (ret : OutPtr a)
     -> IEffect a.

     let linear_map : LinearMap = linearMap stride lb in

     for @N @a repr size init
     (\ (i : int) (x : a) (loop_ret : OutPtr a) -> IEffect a.
        let logical_i : int = evalLM i linear_map in
        case boxed @(Stored int) (stored @int logical_i) of
           boxed @(Stored int) (s_i : Stored int).
         case boxed @a (generator s_i) of boxed @a (y : a).
         reducer x y loop_ret)
     ret);


primitive_dim1_fold @(acc : bare)
  (repr : Repr acc)
  (d : dim1)
  (f : index dim1 -> acc -> Writer acc)
  (init : acc)
  -> Writer acc
  attribute(inline) =

  -- Loop over the domain
  dim1ToArrayDesc @acc d
  (\ @(N : intindex)
     (lb : int) (stride : int) (count : FIInt N) (ret : OutPtr acc)
     -> IEffect acc.

     for @N @acc repr count init
     (\ (i : int) (loop_acc : acc) (ret : OutPtr acc) -> IEffect acc.

        -- Compute the real index in this loop iteration
        case boxed @(Stored int) (stored @int (lb +# i *# stride)) of
          boxed @(Stored int) (real_index : Stored int).

        -- Accumulate value
        f real_index loop_acc ret)
     ret);

-------------------------------------------------------------------------------
-- Domain loops (parallel)

parallel_list_dim_reduce @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (g : Stored int -> Writer a)
  (f : a -> a -> Writer a)
  (init : a)
  (ret : OutPtr a)
  -> IEffect a =

  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type b = BoxedType a in
      letfun
        combiner (x : b) (y : b) -> b =
          case boxed @a (convertToBare @a repr x) of boxed @a (bx : a).
          case boxed @a (convertToBare @a repr y) of boxed @a (by : a).
          convertToBoxed @a repr (f bx by)
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
          for_box @range_N @b count acc_in
          (\ (i : int) (acc_loop : b) -> b.
            -- Add the lower bound to get the real index
            case boxed @(Stored int) (stored @int (i +# lb)) of
              boxed @(Stored int) (real_index : Stored int).

            -- Call 'g' to compute a value, and 'f' to combine it
            case boxed @a (convertToBare @a repr acc_loop) of
              boxed @a (x : a).
            case boxed @a (g real_index) of boxed @a (y : a).
            convertToBoxed @a repr (f x y))
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = convertToBoxed @a repr (copy @a repr init) in
      convertToBare @a repr
      (blocked_1d_reduce @N @b count combiner boxed_init reducer)
      ret

  ; nothingVal @int.
      except @(IEffect a)
  };


parallel_dim1_reduce @(a : bare)
  (repr : Repr a)
  (dom : dim1)
  (g : Stored int -> Writer a)
  (f : a -> a -> Writer a)
  (init : a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =

  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case lm of linearMap (stride : int) (alignemnt : int).
  case iv of
    interval (lower_bound : MaybeVal int) (upper_bound : MaybeVal int).
  case lower_bound of {
    justVal @int (lb : int).
      case upper_bound of {
        justVal @int (ub : int).          
          -- Create combiner and reducer functions using 'f' and 'g'
          let type b = BoxedType a in
          letfun
            combiner (x : b) (y : b) -> b =
              case boxed @a (convertToBare @a repr x) of boxed @a (bx : a).
              case boxed @a (convertToBare @a repr y) of boxed @a (by : a).
              convertToBoxed @a repr (f bx by)
          in
          letfun
            reducer @(range_N : intindex)
              (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
              for_box @range_N @b count acc_in
              (\ (i : int) (acc_loop : b) -> b.
                -- Compute the real index from iteration 'i'
                let real_index_u : int = lb +# i *# stride in
                case boxed @(Stored int) (stored @int real_index_u) of
                  boxed @(Stored int) (real_index : Stored int).

                -- Call 'g' to compute a value, and 'f' to combine it
                case boxed @a (convertToBare @a repr acc_loop) of
                  boxed @a (x : a).
                case boxed @a (g real_index) of boxed @a (y : a).
                convertToBoxed @a repr (f x y))
          in
          let size : int = (ub -# lb) //# stride in
          case defineIntIndex size of
            someIInt @(N : intindex) (count : FIInt N).
          let boxed_init : b = convertToBoxed @a repr (copy @a repr init) in
          convertToBare @a repr
          (blocked_1d_reduce @N @b count combiner boxed_init reducer)
          ret

      ; nothingVal @int.
          except @(IEffect a)
      }
  ; nothingVal @int.
      except @(IEffect a)
  };


parallel_list_dim_reduce1 @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (g : Stored int -> Writer a)
  (f : a -> a -> Writer a)
  (ret : OutPtr a)
  -> IEffect a =

  let mrepr : Repr (Maybe a) = repr_Maybe @a repr in
  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type ma = Maybe a in
      let type b = BoxedType ma in
      letfun
        combiner (x : b) (y : b) -> b =
          -- Combine 'Maybe' values.  Use 'f' if both values are 'Just'.
          case boxed @ma (convertToBare @ma mrepr x) of
            boxed @ma (maybe_x : ma).
          case maybe_x of {
            just @a (bx : a).
              case boxed @ma (convertToBare @ma mrepr y) of
                boxed @ma (maybe_y : ma).
              case maybe_y of {
                just @a (by : a). convertToBoxed @ma mrepr (just @a (f bx by))
              ; nothing @a. x
            }
          ; nothing @a. y
          }
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
          case boxed @ma (convertToBare @ma mrepr acc_in) of
            boxed @ma (m_acc_in : ma).

          letfun
            reduce_with_initial_value @(subrange_N : intindex)
              (subrange_lb : int)
              (subrange_count : FIInt subrange_N)
              (subrange_acc : a)
              -> b =
            convertToBoxed @ma mrepr
            (just @a
             (for @subrange_N @a repr subrange_count subrange_acc
              (\ (i : int) (x : a) (ret : OutPtr a) -> IEffect a.
                 -- Add the lower bound to get the real index
                 case boxed @(Stored int) (stored @int (i +# subrange_lb)) of
                   boxed @(Stored int) (real_index : Stored int).
               
                 -- Call 'g' to compute a value, and 'f' to combine it
                 case boxed @a (g real_index) of boxed @a (y : a).
                 f x y ret)))
          in
          -- Get an initial value.  The value comes from either
          -- the given accumulator or the beginning of the range.
          -- We know the range is nonempty.
          case m_acc_in of {
            just @a (b_acc_in : a).
              reduce_with_initial_value @range_N lb count b_acc_in
          ; nothing @a.
              case boxed @(Stored int) (stored @int lb) of
                boxed @(Stored int) (first_index : Stored int).
              case boxed @a (g first_index) of boxed @a (b_acc_in : a).

              reduce_with_initial_value @(minus_i range_N 1)
              (lb +# 1)
              (minus_fii @range_N @1 count one_fii)
              b_acc_in
          }
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = convertToBoxed @ma mrepr (nothing @a) in
      case boxed @ma
           (convertToBare @ma mrepr
            (blocked_1d_reduce @N @b count combiner boxed_init reducer)) of
        boxed @ma (m_result : Maybe a).
      case m_result of {
        just @a (result : a). copy @a repr result ret
      ; nothing @a. except @(IEffect a)
      }

  ; nothingVal @int.
      except @(IEffect a)
  };


-------------------------------------------------------------------------------
-- Sequential loops

for @(N : intindex) @(acc : bare)
  (repr : Repr acc) (count : FIInt N) (init : acc)
  (f : int -> acc -> Writer acc) (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of fiInt @N (bound : int).

  -- Main loop
  letfun
    loop (i : int) (x : acc) (r : OutPtr acc) -> IEffect acc =
      if EqDict_int_eq i bound
      then copy @acc repr x r
      else case boxed @acc (f i x) of boxed @acc (y : acc).
           loop (AdditiveDict_int_add i 1) y r
  in loop 0 init ret;


for_box @(N : intindex) @(acc : box)
  (count : FIInt N)
  (init : acc)
  (f : int -> acc -> acc)
  -> acc
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of fiInt @N (bound : int).

  -- Main loop
  letfun
    loop (i : int) (x : acc) -> acc =
      if EqDict_int_eq i bound
      then x
      else loop (AdditiveDict_int_add i 1) (f i x)
  in loop 0 init;

-------------------------------------------------------------------------------
-- Parallel loops

parallel_doall @(N : intindex) @(a b : bare)
  (count : FIInt N)
  (f : int -> IEffect b)
  -> IEffect a
  attribute(inline, inline_sequential) =

  letfun
    do_range @(M : intindex)
      (lb : int) (range_count : FIInt M)
      -> IEffect b =
    doall @M @b @b range_count
    (\ (range_i : int) -> IEffect b. f (range_i +# lb))
  in
  blocked_doall @N @a @b count do_range;


-------------------------------------------------------------------------------
-- Data structure functions

fun_just @(a : bare) (repr : Repr a) (x : Writer a)
  -> Writer (Maybe a) attribute(inline) =
  just @a x;


fun_nothing @(a : bare) (repr : Repr a)
  -> Writer (Maybe a) attribute(inline) =
  nothing @a;


fun_isNothing @(a : bare) (repr : Repr a) (x : Maybe a)
  -> bool attribute(inline) =
  case x of {
    just @a (value : a). False
  ; nothing @a. True
  };


fun_isJust @(a : bare) (repr : Repr a) (x : Maybe a)
  -> bool attribute(inline) =
  case x of {
    just @a (value : a). True
  ; nothing @a. False
  };
  

fun_fromJust @(a : bare) (repr : Repr a) (x : Maybe a) (ret : OutPtr a)
  -> IEffect a attribute(inline) =
  case x of {
    just @a (value : a). copy @a repr value ret
  ; nothing @a. except @(IEffect a)
  };


{-



safeIndex @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (ix : index (shape t))
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =

  let type sh = shape t in

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_indices : sh -> Stream sh (index sh))
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).
  
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index sh -> Writer a)
    (get_shape : (a : bare) -> t a -> sh).

  -- Check bounds, then return a value
  if shape_in_range (get_shape @a container) ix
  then at_index @a repr container ix ret
  else except @(IEffect a);


safeSlice @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (sl : slice (shape t))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_indices : sh -> Stream sh (index sh))
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_in_range : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  shape_slice @t @a
  (unsafeMakeCoercion @sh @sh)
  indexable repr container sl;

-------------------------------------------------------------------------------
-- Conversions

view1ToDarr1 @(a b : bare)
  (vw : view1 a)
  (elim : (N : intindex) -> FIInt N -> darr1 N a -> Writer b)
  (elim_empty : Writer b)
  (ret : OutPtr b)
  -> IEffect b attribute(inline, inline_dimensionality) =
  case vw of {
    mk_view1 @a @(lo hi : intindex)
             (ilo : IInt lo) (ihi : IInt hi) (f : int -> Writer a).
      let flo : FIInt lo = fromIndInt @lo ilo in
      let fhi : FIInt hi = fromIndInt @hi ihi in

      let type N = minus_i hi lo in
      let delta : FIInt N = minus_fii @hi @lo fhi flo in
      case flo of fiInt @lo (lo_i : int).

      -- The darr is zero-indexed; subtract the offset
      letfun
        f2 (i : int) -> Writer a = f (AdditiveDict_int_sub i lo_i)
      in

      elim @N delta (mk_darr1 @N @a f2) ret;

    empty_view1 @a.
      elim_empty ret
  };


darr1ToView1 @(N : intindex) @(a : bare)
  (size : FIInt N)
  (darr : darr1 N a)
  -> view1 a attribute(inline, inline_dimensionality) =
  case darr of mk_darr1 @N @a (f : int -> Writer a).
  mk_view1 @a @0 @N zero_ii (iInt @N size) f;


-------------------------------------------------------------------------------
-- Traversable methods

arr1D_traverse @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N) (ay : arr N a)
  -> darr1 N a attribute(inline) =
  mk_darr1 @N @a
  (\ (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr (subscript @N @a repr ay i) ret);

arr1D_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (s : darr1 N a)
  (ret : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline, inline_final) =

  case s of mk_darr1 @N @a (f : int -> Writer a).

  primitive_darr1_generate @N @a repr size f ret;


arr2D_traverse @(M N : intindex) @(a : bare)
  (repr : Repr a) (height : FIInt M) (width : FIInt N) (ay : arr M (arr N a))
  -> darr2 M N a attribute(inline) =
  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in

  mk_darr2 @M @N @a
  (\ (j : int) (i : int) (ret : OutPtr a) -> IEffect a.
     copy @a repr
     (subscript @N @a repr (subscript @M @(arr N a) row_repr ay j) i)
     ret);

arr2D_build @(M N : intindex) @(a : bare)
  (repr : Repr a) (height : FIInt M) (width : FIInt N)
  (s : darr2 M N a)
  (ret : OutPtr (arr M (arr N a)))
  -> IEffect (arr M (arr N a))
  attribute(inline, inline_final) =

  case s of mk_darr2 @M @N @a (f : int -> int -> Writer a).
  primitive_darr2_generate @M @N @a repr height width f ret;

{-
Old array builder function, using a stream to write the array
  case s of linStream @(arr_shape N dim0) @a @(st : box)
    (stream_state : st) (stream_next : st -> StreamNext st (BoxedType a)).

  case size of fiInt @N (bound : int).

  letfun
    go (i : int) (state : st) -> EffTok =
      if EqDict_int_eq i bound
      then emptyEffTok
      else case stream_next state of {

             -- Obtain value from stream
             streamValue @st @(BoxedType a)
	       (next_state : st) (result : BoxedType a).
               -- Write into the array
	       seqEffTok (toEffTok @a (convertToBare @a repr result
	       		               (subscript_out @N @a repr ret i)))
                         (go (AdditiveDict_int_add i 1) next_state);

             streamEmpty @st @(BoxedType a).
	       except @EffTok
	   }
  in fromEffTok @(arr N a) (go 0 stream_state);
-}

-------------------------------------------------------------------------------
-- Indexable methods

ShapeDict_dim2_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Writer b)
  (input_stream : Stream dim2 a)
  -> Stream dim2 b attribute(inline, inline_dimensionality) =
  case input_stream of {
    mk_view2 @a @(Mlo Mhi Nlo Nhi : intindex)
    (imlo : IInt Mlo) (imhi : IInt Mhi)
    (inlo : IInt Nlo) (inhi : IInt Nhi)
    (f : int -> int -> Writer a).
      mk_view2 @b @Mlo @Mhi @Nlo @Nhi imlo imhi inlo inhi
      (\ (j : int) (i : int) -> Writer b.
        case boxed @a (f j i) of boxed @a (x : a). transformer x)

  ; empty_view2 @a.
      empty_view2 @b
  };


ShapeDict_dim2_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Writer c)
  (sA : Stream dim2 a)
  (sB : Stream dim2 b)
  -> Stream dim2 c attribute(inline, inline_dimensionality) =
  case sA of {
    mk_view2 @a @(MloA MhiA NloA NhiA : intindex)
    (imloA : IInt MloA) (imhiA : IInt MhiA)
    (inloA : IInt NloA) (inhiA : IInt NhiA)
    (fA : int -> int -> Writer a).
      case sB of {
        mk_view2 @b @(MloB MhiB NloB NhiB : intindex)
        (imloB : IInt MloB) (imhiB : IInt MhiB)
        (inloB : IInt NloB) (inhiB : IInt NhiB)
        (fB : int -> int -> Writer b).

          -- Find the intersection of the two regions
          let type MloC = max_i MloA MloB in
          let type MhiC = min_i MhiA MhiB in
          let type NloC = max_i NloA NloB in
          let type NhiC = min_i NhiA NhiB in
          let imloC : IInt MloC = max_ii @MloA @MloB imloA imloB in
          let imhiC : IInt MhiC = min_ii @MhiA @MhiB imhiA imhiB in
          let inloC : IInt NloC = max_ii @NloA @NloB inloA inloB in
          let inhiC : IInt NhiC = min_ii @NhiA @NhiB inhiA inhiB in

          -- Is the intersection nonempty?
          if and (range_nonempty_ii @MloC @MhiC imloC imhiC)
                 (range_nonempty_ii @NloC @NhiC inloC inhiC)
          then mk_view2 @c @MloC @MhiC @NloC @NhiC imloC imhiC inloC inhiC
               (\ (j : int) (i : int) -> Writer c.
                 case boxed @a (fA j i) of boxed @a (x : a).
                 case boxed @b (fB j i) of boxed @b (y : b).
                 transformer x y)
          else empty_view2 @c
      ; empty_view2 @b.
          empty_view2 @c
      }
  ; empty_view2 @a.
      empty_view2 @c
  };


ShapeDict_dim2_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Writer d)
  (sA : Stream dim2 a)
  (sB : Stream dim2 b)
  (sC : Stream dim2 c)
  -> Stream dim2 d attribute(inline, inline_dimensionality) =
  case sA of {
    mk_view2 @a @(MloA MhiA NloA NhiA : intindex)
    (imloA : IInt MloA) (imhiA : IInt MhiA)
    (inloA : IInt NloA) (inhiA : IInt NhiA)
    (fA : int -> int -> Writer a).
      case sB of {
        mk_view2 @b @(MloB MhiB NloB NhiB : intindex)
        (imloB : IInt MloB) (imhiB : IInt MhiB)
        (inloB : IInt NloB) (inhiB : IInt NhiB)
        (fB : int -> int -> Writer b).
          case sC of {
            mk_view2 @c @(MloC MhiC NloC NhiC : intindex)
            (imloC : IInt MloC) (imhiC : IInt MhiC)
            (inloC : IInt NloC) (inhiC : IInt NhiC)
            (fC : int -> int -> Writer c).

              -- Find the intersection of the two regions
              let type MloD = max_i (max_i MloA MloB) MloC in
              let type MhiD = min_i (min_i MhiA MhiB) MhiC in
              let type NloD = max_i (max_i NloA NloB) NloC in
              let type NhiD = min_i (min_i NhiA NhiB) NhiC in
              let imloD : IInt MloD = max_ii @(max_i MloA MloB) @MloC
                                      (max_ii @MloA @MloB imloA imloB) imloC in
              let imhiD : IInt MhiD = min_ii @(min_i MhiA MhiB) @MhiC
                                      (min_ii @MhiA @MhiB imhiA imhiB) imhiC in
              let inloD : IInt NloD = max_ii @(max_i NloA NloB) @NloC
                                      (max_ii @NloA @NloB inloA inloB) inloC in
              let inhiD : IInt NhiD = min_ii @(min_i NhiA NhiB) @NhiC
                                      (min_ii @NhiA @NhiB inhiA inhiB) inhiC in

              -- Is the intersection nonempty?
              if and (range_nonempty_ii @MloD @MhiD imloD imhiD)
                     (range_nonempty_ii @NloD @NhiD inloD inhiD)
              then mk_view2 @d @MloD @MhiD @NloD @NhiD imloD imhiD inloD inhiD
                   (\ (j : int) (i : int) -> Writer d.
                     case boxed @a (fA j i) of boxed @a (x : a).
                     case boxed @b (fB j i) of boxed @b (y : b).
                     case boxed @c (fC j i) of boxed @c (z : c).
                     transformer x y z)
              else empty_view2 @d

          ; empty_view2 @c.
              empty_view2 @d
          }

      ; empty_view2 @b.
          empty_view2 @d
      }

  ; empty_view2 @a.
      empty_view2 @d
  };


ShapeDict_dim2_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Writer e)
  (sA : Stream dim2 a)
  (sB : Stream dim2 b)
  (sC : Stream dim2 c)
  (sD : Stream dim2 d)
  -> Stream dim2 e attribute(inline, inline_dimensionality) =
  case sA of {
    mk_view2 @a @(MloA MhiA NloA NhiA : intindex)
    (imloA : IInt MloA) (imhiA : IInt MhiA)
    (inloA : IInt NloA) (inhiA : IInt NhiA)
    (fA : int -> int -> Writer a).
      case sB of {
        mk_view2 @b @(MloB MhiB NloB NhiB : intindex)
        (imloB : IInt MloB) (imhiB : IInt MhiB)
        (inloB : IInt NloB) (inhiB : IInt NhiB)
        (fB : int -> int -> Writer b).
          case sC of {
            mk_view2 @c @(MloC MhiC NloC NhiC : intindex)
            (imloC : IInt MloC) (imhiC : IInt MhiC)
            (inloC : IInt NloC) (inhiC : IInt NhiC)
            (fC : int -> int -> Writer c).
              case sD of {
                mk_view2 @d @(MloD MhiD NloD NhiD : intindex)
                (imloD : IInt MloD) (imhiD : IInt MhiD)
                (inloD : IInt NloD) (inhiD : IInt NhiD)
                (fD : int -> int -> Writer d).

                  -- Find the intersection of the two regions
                  let type MloE = max_i (max_i (max_i MloA MloB) MloC) MloD in
                  let type MhiE = min_i (min_i (min_i MhiA MhiB) MhiC) MhiD in
                  let type NloE = max_i (max_i (max_i NloA NloB) NloC) NloD in
                  let type NhiE = min_i (min_i (min_i NhiA NhiB) NhiC) NhiD in
                  let imloE : IInt MloE = max_ii @(max_i (max_i MloA MloB) MloC) @MloD
                                          (max_ii @(max_i MloA MloB) @MloC
                                           (max_ii @MloA @MloB imloA imloB) imloC) imloD in
                  let imhiE : IInt MhiE = min_ii @(min_i (min_i MhiA MhiB) MhiC) @MhiD
                                          (min_ii @(min_i MhiA MhiB) @MhiC
                                           (min_ii @MhiA @MhiB imhiA imhiB) imhiC) imhiD in
                  let inloE : IInt NloE = max_ii @(max_i (max_i NloA NloB) NloC) @NloD
                                          (max_ii @(max_i NloA NloB) @NloC
                                           (max_ii @NloA @NloB inloA inloB) inloC) inloD in
                  let inhiE : IInt NhiE = min_ii @(min_i (min_i NhiA NhiB) NhiC) @NhiD
                                          (min_ii @(min_i NhiA NhiB) @NhiC
                                           (min_ii @NhiA @NhiB inhiA inhiB) inhiC) inhiD in

                  -- Is the intersection nonempty?
                  if and (range_nonempty_ii @MloE @MhiE imloE imhiE)
                         (range_nonempty_ii @NloE @NhiE inloE inhiE)
                  then mk_view2 @e @MloE @MhiE @NloE @NhiE imloE imhiE inloE inhiE
                       (\ (j : int) (i : int) -> Writer e.
                         case boxed @a (fA j i) of boxed @a (x : a).
                         case boxed @b (fB j i) of boxed @b (y : b).
                         case boxed @c (fC j i) of boxed @c (z : c).
                         case boxed @d (fD j i) of boxed @d (w : d).
                         transformer x y z w)
                  else empty_view2 @e

              ; empty_view2 @d.
                  empty_view2 @e
              }
          ; empty_view2 @c.
              empty_view2 @e
          }
      ; empty_view2 @b.
          empty_view2 @e
      }
  ; empty_view2 @a.
      empty_view2 @e
  };

ShapeDict_dim2_inRange (dim : dim2) (ix : index dim2) -> bool
  attribute(inline) =
  let type Sint = Stored int in
  case ix of pyonTuple2 @Sint @Sint (y_s : Sint) (x_s : Sint).
  case y_s of stored @int (y : int).
  case x_s of stored @int (x : int).

  case dim of
    mk_dim2 @(Mlo Mhi Nlo Nhi : intindex)
    (iMlo : IInt Mlo)
    (iMhi : IInt Mhi)
    (iNlo : IInt Nlo)
    (iNhi : IInt Nhi).

  let in_range_Mlo : bool =
        case iMlo of {
          iInt @Mlo (flo : FIInt Mlo). 
            case flo of fiInt @Mlo (lo_i : int). y >=# lo_i
        ; iNegInfty @Mlo.
            True
        ; iPosInfty @Mlo.
            except @bool
        } in
  let in_range_Mhi : bool =
        case iMhi of {
          iInt @Mhi (fhi : FIInt Mhi).
            case fhi of fiInt @Mhi (hi_i : int). y <# hi_i
        ; iPosInfty @Mhi.
            True
        ; iNegInfty @Mhi.
            except @bool
        } in
  let in_range_Nlo : bool =
        case iNlo of {
          iInt @Nlo (flo : FIInt Nlo). 
            case flo of fiInt @Nlo (lo_i : int). x >=# lo_i
        ; iNegInfty @Nlo.
            True
        ; iPosInfty @Nlo.
            except @bool
        } in
  let in_range_Nhi : bool =
        case iNhi of {
          iInt @Nhi (fhi : FIInt Nhi).
            case fhi of fiInt @Nhi (hi_i : int). x <# hi_i
        ; iPosInfty @Nhi.
            True
        ; iNegInfty @Nhi.
            except @bool
        } in
  and (and in_range_Mlo in_range_Mhi) (and in_range_Nlo in_range_Nhi);

ShapeDict_dim2_slice @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (sl : slice dim2)
  -> view2 a
  attribute(inline) =

  -- Get the container's shape
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 @(Mlo Mhi Nlo Nhi : intindex)
    (iMlo : IInt Mlo)
    (iMhi : IInt Mhi)
    (iNlo : IInt Nlo)
    (iNhi : IInt Nhi).

  -- Get the slice components
  case sl of pyonTuple2 @SliceObject @SliceObject
       	     (slice_y : SliceObject) (slice_x : SliceObject).

  -- Compute the intersection of the container and slice.
  -- Each dimension is computed independently.
  case intersectSliceWithRange @Mlo @Mhi iMlo iMhi slice_y of {
    internalSlice @(sliceMlo sliceMhi : intindex)
    (slice_iMlo : IInt sliceMlo)
    (slice_iMhi : IInt sliceMhi)
    (slice_ystride : int)
    (slice_yoffset : int).

      case intersectSliceWithRange @Nlo @Nhi iNlo iNhi slice_x of {
        internalSlice @(sliceNlo sliceNhi : intindex)
        (slice_iNlo : IInt sliceNlo)
        (slice_iNhi : IInt sliceNhi)
        (slice_xstride : int)
        (slice_xoffset : int).

          -- Create a view
          mk_view2 @a @sliceMlo @sliceMhi @sliceNlo @sliceNhi
          slice_iMlo slice_iMhi slice_iNlo slice_iNhi
          (\ (y : int) (x : int) -> Writer a.
             let index_y : int = y *# slice_ystride +# slice_yoffset in
             let index_x : int = x *# slice_xstride +# slice_xoffset in
             let type Sint = Stored int in
             case boxed @(PyonTuple2 Sint Sint)
             	  (pyonTuple2 @Sint @Sint
                   (stored @int index_y)
                   (stored @int index_x)) of
               boxed @(PyonTuple2 Sint Sint) (ix : PyonTuple2 Sint Sint).
             let co_index : index (shape t) =
               coerce @(index dim2) @(index (shape t)) ix in
             at_index @a repr container co_index)
      ; emptySlice.
          empty_view2 @a
      }
  ; emptySlice.
      empty_view2 @a
  };

-------------------------------------------------------------------------------
-- Internal constructor-like methods

create_view2 @(a : bare)
  (repr : Repr a)
  (lo_bound : index dim2)
  (hi_bound : index dim2)
  (generator : index dim2 -> Writer a)
  -> view2 a
  attribute(inline) =

  let type Sint = Stored int in

  case lo_bound of pyonTuple2 @Sint @Sint (s_lb_y : Sint) (s_lb_x : Sint).
  case s_lb_y of stored @int (lb_y : int).
  case s_lb_x of stored @int (lb_x : int).
  case hi_bound of pyonTuple2 @Sint @Sint (s_hb_y : Sint) (s_hb_x : Sint).
  case s_hb_y of stored @int (hb_y : int).
  case s_hb_x of stored @int (hb_x : int).

  if or (lb_y ># hb_y) (lb_x ># hb_x)
  then empty_view2 @a
  else case defineIntIndex lb_y of
         someIInt @(Mlo : intindex) (mlo_i : FIInt Mlo).
       case defineIntIndex lb_x of
         someIInt @(Nlo : intindex) (nlo_i : FIInt Nlo).
       case defineIntIndex hb_y of
         someIInt @(Mhi : intindex) (mhi_i : FIInt Mhi).
       case defineIntIndex hb_x of
         someIInt @(Nhi : intindex) (nhi_i : FIInt Nhi).
       mk_view2 @a @Mlo @Mhi @Nlo @Nhi (iInt @Mlo mlo_i) (iInt @Mhi mhi_i)
       (iInt @Nlo nlo_i) (iInt @Nhi nhi_i)
       (\ (y : int) (x : int) (ret : OutPtr a) -> IEffect a.
         case boxed @(PyonTuple2 Sint Sint)
              (pyonTuple2 @Sint @Sint (stored @int y) (stored @int x)) of
           boxed @(PyonTuple2 Sint Sint) (ix : index dim2).
         generator ix ret);

-------------------------------------------------------------------------------
-- Fold-like internal methods

fun_reduce_Stream @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (s : Stream dim1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case s of {
    viewStream @a (vw : view1 a).
      reduce_list_dim @a repr f init vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce @a repr f init sq ret
  };


fun_reduce1_Stream @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (s : Stream dim1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  case s of {
    viewStream @a (vw : view1 a).
      reduce1_list_dim @a repr f vw ret

  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce1 @a repr f sq ret
  };


fun_fold_Stream @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : Stream dim1 a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline) =
  case src of {
    viewStream @a (vw : view1 a).
      view1_fold @a @acc repr_a repr_acc f init vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_fold @a @acc repr_a repr_acc f init sq ret
  };


histogram @(sh : box)
  (shape_dict : ShapeDict sh)
  (lo_bound : int)
  (hi_bound : int)
  (input : Stream sh (Stored int))
  (ret : OutPtr (array1 (Stored int)))
  -> IEffect (array1 (Stored int))
  attribute(inline) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_indices : sh -> Stream sh (index sh))
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream dim1 a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Writer b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Writer c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Writer d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Writer e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_at_index : sh -> index sh -> bool)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  case defineIntIndex lo_bound of someIInt @(L : intindex) (lb : FIInt L).
  case defineIntIndex hi_bound of someIInt @(H : intindex) (hb : FIInt H).

  let type N = minus_i H L in
  let size : FIInt N = minus_fii @H @L hb lb in

  mk_array1 @(Stored int) @L @H lb hb 
  (referenced @(arr N (Stored int))
   (histogramArray @N size lo_bound hi_bound
    (shape_flatten @(Stored int) repr_int input)))
  ret;


histogramArray @(N : intindex)
  (size : FIInt N)
  (lo_bound : int)
  (hi_bound : int)
  (input : Stream dim1 (Stored int))
  (ret : OutPtr (arr N (Stored int)))
  -> IEffect (arr N (Stored int))
  attribute(inline, inline_dimensionality) =
  let type Sint = Stored int in
  let type SNoneType = Stored NoneType in
  let type index_type = PyonTuple2 Sint SNoneType in
  let type s = arr N Sint in

  let repr_index : Repr index_type =
    repr_PyonTuple2 @Sint @SNoneType repr_int repr_NoneType in

  let uip : UpdateInPlace s index_type int =
    arrUpdateInPlace @N @Sint @SNoneType @int
    size repr_int (intUpdateInPlace None) in

  -- Put data into the format expected by 'accumulate_Stream_int'.
  -- Shift the histogram index by 'lo_bound', because the underlying array
  -- is zero-indexed.
  let input2 : Stream dim1 (PyonTuple2 index_type SNoneType) =
    ShapeDict_dim1_map @Sint @(PyonTuple2 index_type SNoneType)
    repr_int (repr_PyonTuple2 @index_type @SNoneType repr_index repr_NoneType)
    (\ (x : Sint) (ret : OutPtr (PyonTuple2 index_type SNoneType))
      -> IEffect (PyonTuple2 index_type SNoneType).
      case x of stored @int (ux : int).
      pyonTuple2 @index_type @SNoneType
      (pyonTuple2 @Sint @SNoneType
       (stored @int (ux -# lo_bound)) -- Convert to zero-indexed value
       (stored @NoneType None))
      (stored @NoneType None) ret)
    input in

  -- Create the histogram array
  accumulate_Stream_int @s @(PyonTuple2 Sint SNoneType) @SNoneType
  (repr_PyonTuple2 @Sint @SNoneType repr_int repr_NoneType)
  repr_NoneType
  uip
  0
  (\ (dummy : SNoneType) (ix : PyonTuple2 Sint SNoneType) (n : int) -> int.
     n +# 1)
  input2
  ret;


accumulate_Stream_int @(s i b : bare)
  (repr_i : Repr i)
  (repr_b : Repr b)
  (uip : UpdateInPlace s i int)
  (init : int)
  (modifier : b -> i -> (int -> int))
  (src : Stream dim1 (PyonTuple2 i b))
  (ret : OutPtr s)
  -> IEffect s
  attribute(inline) =

  let type SEffTok = Stored EffTok in
  case uip of
    updateInPlace @s @i @int
    (initialize : (NoneType -> int) -> OutPtr s -> EffTok)
    (update : (int -> int) -> OutPtr s -> i -> EffTok -> EffTok).

  -- First, initialize the output
  let initialized_tok : EffTok =
    initialize (\ (dummy : NoneType) -> int. init) ret in
  case boxed @SEffTok (stored @EffTok initialized_tok) of
    boxed @SEffTok (s_tok : SEffTok). 

  -- Then accumulate updates
  case boxed @SEffTok
       (fun_fold_Stream @(PyonTuple2 i b) @SEffTok
        (repr_PyonTuple2 @i @b repr_i repr_b) repr_EffTok

        -- The accumulating function calls 'update'
        (\ (s_input_tok : SEffTok) (input : PyonTuple2 i b)
           (output_ptr : OutPtr SEffTok)
           -> IEffect SEffTok.
           case s_input_tok of stored @EffTok (input_tok : EffTok).
           case input of pyonTuple2 @i @b (ix : i) (arg : b).
           stored @EffTok (update (modifier arg ix) ret ix input_tok)
           output_ptr)
        s_tok
        src)
    of boxed @SEffTok (s_final_tok : SEffTok).
  case s_final_tok of stored @EffTok (final_tok : EffTok).
  fromEffTok @s final_tok;


dim1_fold @(acc : bare)
  (repr : Repr acc)
  (d : dim1)
  (f : index dim1 -> acc -> Writer acc)
  (init : acc)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline) =

  -- Compute size of loop
  case d of
    mk_dim1 @(L : intindex) @(H : intindex) (ilo : IInt L) (ihi : IInt H).

  let flo : FIInt L = fromIndInt @L ilo in
  let fhi : FIInt H = fromIndInt @H ihi in

  let type N = minus_i H L in
  let delta : FIInt N = minus_fii @H @L fhi flo in
  case flo of fiInt @L (lo_i : int).

  -- Execute a for loop
  for @N @acc repr (iInt @N delta) init
  (\ (i : int) (x : acc) (ret : OutPtr acc) -> IEffect acc.
    case boxed @(Stored int) (stored @int i) of
      boxed @(Stored int) (si : Stored int).
    f si x ret) ret;


primitive_darr1_reduce @(N : intindex) @(a : bare)
  (repr : Repr a) (count : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (g : int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  for @N @a repr (iInt @N count) init
  (\ (i : int) (acc : a) (ret : OutPtr a) -> IEffect a.
    case boxed @a (g i) of boxed @a (x : a).
    f acc x ret)
  ret;


primitive_darr1_reduce1 @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (f : a -> a -> Writer a)
  (g : int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  
  case size of fiInt @N (count : int).
  if count <=# 0
  then except @(IEffect a)
  else -- Get the initial value from index 0
       case boxed @a (g 0) of boxed @a (init : a).

       -- Iterate over the remaining elements
       let size_minus_1 : FIInt (minus_i N 1) =
       	     minus_fii @N @1 size one_fii in

       for @(minus_i N 1) @a repr (iInt @(minus_i N 1) size_minus_1) init
       (\ (i : int) (x : a) (next_x : OutPtr a) -> IEffect a.
          case boxed @a (g (i +# 1)) of boxed @a (y : a).
          f x y next_x)
       ret;


primitive_darr1_generate @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (f : int -> Writer a)
  (ret : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline, inline_sequential) =
  doall @N @(arr N a) @a size
  (\ (i : int) -> IEffect a. f i (subscript_out @N @a repr ret i));


darr1_reduce @(N : intindex) @(a : bare)
  (repr : Repr a)
  (size : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (src : darr1 N a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case src of mk_darr1 @N @a (g : int -> Writer a).
  primitive_darr1_reduce @N @a repr size f init g ret;


darr1_reduce1 @(N : intindex) @(a : bare)
  (repr : Repr a)
  (size : FIInt N)
  (f : a -> a -> Writer a)
  (src : darr1 N a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case src of mk_darr1 @N @a (g : int -> Writer a).
  primitive_darr1_reduce1 @N @a repr size f g ret;


darr1_fold @(N : intindex) @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (size : FIInt N)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : darr1 N a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =
  case src of mk_darr1 @N @a (g : int -> Writer a).

  for @N @acc repr_acc (iInt @N size) init
  (\ (i : int) (x : acc) (next_x : OutPtr acc) -> IEffect acc.
     case boxed @a (g i) of boxed @a (y : a).
     f x y next_x)
  ret;


view1_list_build @(a : bare)
  (repr : Repr a) (vw : view1 a) (ret : OutPtr (list a))
  -> IEffect (list a)
  attribute(inline, inline_dimensionality) =
  view1ToDarr1 @a @(list a) vw
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a)
    -> Writer (list a).
     make_list @a @N size (referenced @(arr N a) (arr1D_build @N @a repr size darr)))
  (\ (ret : OutPtr (list a)) -> IEffect (list a).
    make_list @a @0 zero_fii (referenced @(arr 0 a) (\ (ret : OutPtr (arr 0 a)) -> IEffect (arr 0 a). fromEffTok @(arr 0 a) emptyEffTok)) ret)
  ret;


view1_array1_build @(a : bare)
  (repr : Repr a) (v : view1 a) (ret : OutPtr (array1 a))
  -> IEffect (array1 a)
  attribute(inline, inline_dimensionality) =
  case v of {
    mk_view1 @a @(lo hi : intindex)
    (ilo : IInt lo) (ihi : IInt hi) (f : int -> Writer a).
      let flo : FIInt lo = fromIndInt @lo ilo in
      let fhi : FIInt hi = fromIndInt @hi ihi in

      let type N = minus_i hi lo in
      let delta : FIInt N = minus_fii @hi @lo fhi flo in
      case flo of fiInt @lo (lo_i : int).

      -- The loop is zero-indexed, but the loop body is not.
      -- Add the offset.
      letfun
        f2 (i : int) -> Writer a = f (i +# lo_i)
      in

      mk_array1 @a @lo @hi flo fhi
      (referenced @(arr N a)
       (arr1D_build @N @a repr delta (mk_darr1 @N @a f2)))
      ret

  ; empty_view1 @a.
      let type N0 = minus_i 0 0 in
      mk_array1 @a @0 @0 zero_fii zero_fii
      (referenced @(arr N0 a)
       (\ (ret : OutPtr (arr N0 a)) -> IEffect (arr N0 a).
          fromEffTok @(arr N0 a) emptyEffTok))
      ret
  };

view1_reduce1 @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (vw : view1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  view1ToDarr1 @a @a vw
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a) (ret : OutPtr a)
      -> IEffect a.
     darr1_reduce1 @N @a repr size f darr ret)
  (\ (ret : OutPtr a) -> IEffect a.
    -- Error to call 'reduce1' on an empty stream
    except @(IEffect a))
  ret;


view1_reduce @(a : bare) (repr : Repr a)
  (f : a -> a -> Writer a)
  (init : a)
  (vw : view1 a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  view1ToDarr1 @a @a vw
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a) (ret : OutPtr a)
    -> IEffect a.
    darr1_reduce @N @a repr size f init darr ret)
  (\ (ret : OutPtr a) -> IEffect a. copy @a repr init ret)
  ret;


view1_fold @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Writer acc)
  (init : acc)
  (src : view1 a)
  (ret : OutPtr acc)
  -> IEffect acc
  attribute(inline, inline_final) =
  view1ToDarr1 @a @acc src
  (\ @(N : intindex) (size : FIInt N) (darr : darr1 N a) (ret : OutPtr acc)
    -> IEffect acc.
    darr1_fold @N @a @acc repr_a repr_acc size f init darr ret)
  (\ (ret : OutPtr acc) -> IEffect acc. copy @acc repr_acc init ret)
  ret;





darr2_flatten @(M N MN : intindex) @(a : bare)
  (size_m : FIInt M)
  (size_n : FIInt N)
  (darr : darr2 M N a)
  -> darr1 MN a
  attribute(inline, inline_final) =
  case darr of mk_darr2 @M @N @a (f : int -> int -> Writer a).
  case size_n of fiInt @N (width : int).

  mk_darr1 @MN @a (primitive_darr2_flatten @M @N @a size_n f);


darr2_reduce @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size_y : FIInt M)
  (size_x : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (src : darr2 M N a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_final) =
  case src of mk_darr2 @M @N @a (g : int -> int -> Writer a).
  primitive_darr2_reduce @M @N @a repr size_y size_x f init g ret;


primitive_darr2_flatten @(M N : intindex) @(a : bare)
  (size_n : FIInt N)
  (f : int -> int -> Writer a)
  (i : int)
  -> Writer a
  attribute(conlike, inline, inline_final) =

  -- Compute Y and X indices from the linearized index
  case size_n of fiInt @N (size_n_i : int).
  let y : int = i //# size_n_i in
  let x : int = i %# size_n_i in
  f y x;


primitive_darr2_reduce @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size_y : FIInt M)
  (size_x : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (g : int -> int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_sequential) =

  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in

  for @M @a repr (iInt @M size_y) init
  (\ (j : int) (acc : a) (ret : OutPtr a) -> IEffect a.
   for @N @a repr (iInt @N size_x) acc
   (\ (i : int) (acc : a) (ret : OutPtr a) -> IEffect a.
    case boxed @a (g j i) of boxed @a (x : a).
    f acc x ret)
   ret)
  ret;


primitive_darr2_generate @(M N : intindex) @(a : bare)
  (repr : Repr a) (height : FIInt M) (width : FIInt N)
  (f : int -> int -> Writer a)
  (ret : OutPtr (arr M (arr N a)))
  -> IEffect (arr M (arr N a))
  attribute(inline, inline_sequential) =

  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in
  doall @M @(arr M (arr N a)) @(arr N a) height
  (\ (j : int) -> IEffect (arr N a).
     doall @N @(arr N a) @a width
     (\ (i : int) -> IEffect a.
        f j i (subscript_out @N @a repr (subscript_out @M @(arr N a) row_repr ret j) i)));

-------------------------------------------------------------------------------
-- Methods specifically for 1D streams

view1_normalize @(a : bare) (vw : view1 a) -> view1 a
  attribute(inline, inline_dimensionality) =
  -- Shift the indices so that the first index is 0
  case vw of {
    mk_view1 @a @(lo hi : intindex)
             (Nlo : IInt lo) (Nhi : IInt hi) (f : int -> Writer a).
      let fNlo : FIInt lo = fromIndInt @lo Nlo in
      case fNlo of fiInt @lo (lo_i : int).
      let size : IInt (minus_i hi lo) = minus_ii @hi @lo Nhi Nlo in

      mk_view1 @a @0 @(minus_i hi lo) zero_ii size
       (\ (i : int) -> Writer a. f (i -# lo_i));

    empty_view1 @a.
      -- Don't reuse the view value here because the extra use interferes with
      -- optimization
      empty_view1 @a
  };


range (n : int) -> Stream dim1 (Stored int)
  attribute(inline) =
  let vw : view1 (Stored int) =
        if n <# 0
        then view1_empty @(Stored int) repr_int
	else case defineIntIndex n of someIInt @(N : intindex) (fin : FIInt N).
             let shp : dim1 = mk_dim1 @0 @N zero_ii (iInt @N fin) in

             view1_generate @(Stored int) repr_int shp
             (\ (si : Stored int) (ret : OutPtr (Stored int))
               -> IEffect (Stored int).
               copy @(Stored int) repr_int si ret) in
  viewStream @(Stored int) vw;


Sequence_generate @(a : bare)
  (repr : Repr a) (size : dim1) (f : index dim1 -> Writer a) -> Sequence a
  attribute(inline, inline_final) =
  case size of
    mk_dim1 @(lo : intindex) @(hi : intindex) (ilo : IInt lo) (ihi : IInt hi).
  case ilo of {
    iInt @lo (flo : FIInt lo).
      case flo of fiInt @lo (lo_i : int).

      generate @(minus_i hi lo) @a (minus_ii @hi @lo ihi ilo) repr
      (\ (i : int) (ret : OutPtr a) -> IEffect a.
        -- The 'generate' loop starts from 0.  Add 'lo_i' to get the real
        -- starting offset.
        case boxed @(Stored int) (stored @int (i +# lo_i)) of
          boxed @(Stored int) (real_ix : Stored int).
        f real_ix ret)
  ; iPosInfty @lo.
      except @(Sequence a)
  ; iNegInfty @lo.
      except @(Sequence a)
  };


Sequence_bind @(a b : bare)
  (repr : Repr a)
  (src : Sequence a)
  (trans : a -> Sequence b)
  -> Sequence b
  attribute(inline, inline_final) =
  case src of
    sequence @a @(src_st : box)
    (src_state : src_st)
    (src_next : src_st -> StreamNext src_st a).

  let type bind_state = BindState src_st a b in

  letfun {
    next_from_source (src_state : src_st) -> StreamNext bind_state b =
      case src_next src_state of {
        streamValue @src_st @a (src_next_state : src_st) (src_value : BoxedType a).
          case boxed @a (convertToBare @a repr src_value) of boxed @a (x : a).
	  case trans x of
	    sequence @b @(trans_st : box)
	    (trans_state : trans_st)
	    (trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_next_state trans_state trans_next
      ; streamEmpty @src_st @a.
	  streamEmpty @bind_state @b
      };

    next_from_trans @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st b)
      -> StreamNext bind_state b =
      case trans_next trans_state of {
        streamValue @trans_st @b (trans_next_state : trans_st) (trans_value : BoxedType b).
          let next_state : bind_state =
	        bindFromTrans @src_st @a @b @trans_st
		src_state trans_next_state trans_next in
          streamValue @bind_state @b next_state trans_value
      ; streamEmpty @trans_st @b.
	  next_from_source src_state
      };

    next (state : bind_state) -> StreamNext bind_state b =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state
      ; bindFromTrans @src_st @a @b @(trans_st : box)
      	(src_state : src_st)
	(trans_state : trans_st)
	(trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_state trans_state trans_next
      }
  } in

  sequence @b @bind_state (bindFromSource @src_st @a @b src_state) next;


Sequence_generate_bind @(a : bare)
  (shp : dim1) (transformer : Stored int -> Sequence a)
  -> Sequence a
  attribute(inline, inline_final) =
  Sequence_bind @(Stored int) @a repr_int
  (Sequence_generate @(Stored int) repr_int shp (copy @(Stored int) repr_int))
  transformer;


generate @(N : intindex) @(a : bare)
  (size : IInt N) (repr : Repr a) (f : int -> Writer a)
  -> Sequence a attribute(inline, inline_final) =
  case size of {
    iInt @N (fin_size : FIInt N).
      case fin_size of fiInt @N (bound : int).
      -- Finite stream
      let type st = Boxed (Stored int) in
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @(Stored int) (state_s : Stored int).
	  case state_s of stored @int (state_u : int).
	  if state_u <# bound
	  then let next_value : BoxedType a =
	             convertToBoxed @a repr (f state_u) in
	       let next_state : st =
	             boxed @(Stored int) (stored @int (state_u +# 1)) in
	       streamValue @st @a next_state next_value
	  else streamEmpty @st @a
      in
      sequence @a @st (boxed @(Stored int) (stored @int 0)) next
      
  ; iPosInfty @N.
      -- Infinite stream
      let type st = Boxed (Stored int) in
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @(Stored int) (state_s : Stored int).
	  case state_s of stored @int (state_u : int).
	  let next_value : BoxedType a =
	        convertToBoxed @a repr (f state_u) in
	  let next_state : st =
	        boxed @(Stored int) (stored @int (state_u +# 1)) in
	  streamValue @st @a next_state next_value
      in
      sequence @a @st (boxed @(Stored int) (stored @int 0)) next

  ; iNegInfty @N.
      -- Error
      except @(Sequence a)
  };


len @(t : bare -> bare) @(a : bare)
  (is_linear : coerce @box (shape t) dim1)
  (indexable : IndexableDict t)
  (container : t a)
  -> int
  attribute(inline) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  let sh : dim1 = coerce @(shape t) @dim1 (get_shape @a container) in
  case sh of mk_dim1 @(Nlo Nhi : intindex) (ilo : IInt Nlo) (ihi : IInt Nhi).
  case fromIndInt @Nlo ilo of fiInt @Nlo (lo : int).
  case fromIndInt @Nhi ihi of fiInt @Nhi (hi : int).
  hi -# lo;


width @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (container : t a)
  -> int attribute(inline) =

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  let shp : dim2 = coerce @(shape t) @dim2 (get_shape @a container) in
  case shp of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).

  case fromIndInt @Nlo inp_xmin of fiInt @Nlo (lo : int).
  case fromIndInt @Nhi inp_xend of fiInt @Nhi (hi : int).
  hi -# lo;


height @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (container : t a)
  -> int attribute(inline) =

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  let shp : dim2 = coerce @(shape t) @dim2 (get_shape @a container) in
  case shp of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).

  case fromIndInt @Mlo inp_ymin of fiInt @Mlo (lo : int).
  case fromIndInt @Mhi inp_yend of fiInt @Mhi (hi : int).
  hi -# lo;

-------------------------------------------------------------------------------
-- Methods specifically for 2D streams

stencil2D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_matrix : coerce @box (shape t) dim2)
  (repr_a : Repr a) (repr_b : Repr b)
  (ymin : int) (ymax : int) (xmin : int) (xmax : int)
  (stencilfn : view2 a -> Writer b)
  (inp : t a)
  -> Writer (array2 b)
  attribute(inline, inline_sequential) =

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Stencil must span at least one element
  let yend : int = ymax +# 1 in
  let xend : int = xmax +# 1 in
  let stencil_size_y : int = yend -# ymin in
  let stencil_size_x : int = xend -# xmin in
  if or (stencil_size_y <=# 0) (stencil_size_x <=# 0)
  then except @(Writer (array2 b)) else

  -- Create stencil dimensions
  case defineIntIndex ymin of
    someIInt @(stencil_Mlo : intindex) (stencil_ymin : FIInt stencil_Mlo).
  case defineIntIndex xmin of
    someIInt @(stencil_Nlo : intindex) (stencil_xmin : FIInt stencil_Nlo).
  case defineIntIndex yend of
    someIInt @(stencil_Mhi : intindex) (stencil_yend : FIInt stencil_Mhi).
  case defineIntIndex xend of
    someIInt @(stencil_Nhi : intindex) (stencil_xend : FIInt stencil_Nhi).

  -- Inspect the input data
  case coerce @(shape t) @dim2 (get_shape @a inp) of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).
    case fromIndInt @Mlo inp_ymin of
      fiInt @Mlo (inp_ymin_i : int).
    case fromIndInt @Nlo inp_xmin of
      fiInt @Nlo (inp_xmin_i : int).
    case fromIndInt @Mhi inp_yend of
      fiInt @Mhi (inp_yend_i : int).
    case fromIndInt @Nhi inp_xend of
      fiInt @Nhi (inp_xend_i : int).

    -- Compute dimensions of input
    let type M = minus_i Mhi Mlo in
    let type N = minus_i Nhi Nlo in
    let inp_height : FIInt M =
    	  minus_fii @Mhi @Mlo (fromIndInt @Mhi inp_yend) (fromIndInt @Mlo inp_ymin) in
    case inp_height of fiInt @M (inp_height_i : int).
    let inp_width : FIInt N =
    	  minus_fii @Nhi @Nlo (fromIndInt @Nhi inp_xend) (fromIndInt @Nlo inp_xmin) in
    case inp_width of fiInt @N (inp_width_i : int).

    -- Compute dimensions of output
    let type Mout = minus_i M 0 in
    let type Nout = minus_i N 0 in
    let type out_array = arr Mout (arr Nout b) in

    let row_repr : Repr (arr Nout b) =
    	  repr_arr @Nout @b (minus_fii @N @0 inp_width zero_fii) repr_b in

    letfun {
      -- Read from the input array2 view.  Ensure that accesses do not go
      -- outside array bounds.
      safe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
        -> Writer a =
        -- Read one element from the input for a stencil at point (pty, ptx).
        -- The coordinate to read is (pty + yoff, ptx + xoff).
        -- The image is padded at the edges.
        let yindex : int = pty +# yoff in
        let xindex : int = ptx +# xoff in
        let bounded_yindex : int =
              max_int inp_ymin_i (min_int yindex (inp_yend_i -# 1)) in
        let bounded_xindex : int =
              max_int inp_xmin_i (min_int xindex (inp_xend_i -# 1)) in
	case boxed @(index dim2)
	     (pyonTuple2 @(Stored int) @(Stored int)
	      (stored @int bounded_yindex) (stored @int bounded_xindex)) of
	  boxed @(index dim2) (ix : index dim2).
        at_index @a repr_a inp (coerce @(index dim2) @(index (shape t)) ix);

      -- Read from the input array2 view.  Assume that the given
      -- offsets do not produce out-of-bounds array accesses.
      unsafe_get (pty : int) (ptx : int) (yoff : int) (xoff : int)
        -> Writer a =
        -- Read one element from the input for a stencil at point (pty, ptx).
        -- The coordinate to read is (pty + yoff, ptx + xoff).
        -- The image is padded at the edges.
        let yindex : int = pty +# yoff in
        let xindex : int = ptx +# xoff in
	case boxed @(index dim2)
	     (pyonTuple2 @(Stored int) @(Stored int)
	      (stored @int yindex) (stored @int xindex)) of
	  boxed @(index dim2) (ix : index dim2).
        at_index @a repr_a inp (coerce @(index dim2) @(index (shape t)) ix);

      -- Initialize a region of the output array.
      -- The region is given as an origin (y, x) and
      -- extent (delta y, delta x).
      init_array
        (origin_y : int) (origin_x : int) (delta_y : int) (delta_x : int)
        (getter : int -> int -> int -> int -> Writer a)
        (ret : OutPtr out_array)
        -> IEffect out_array =
        case defineIntIndex delta_y of
          someIInt @(Minit : intindex) (rgn_height : FIInt Minit).
        case defineIntIndex delta_x of
          someIInt @(Ninit : intindex) (rgn_width : FIInt Ninit).

        -- Loop over region
        doall @Minit @out_array @(arr Nout b) rgn_height
        (\ (loop_y : int) -> IEffect (arr Nout b).
          doall @Ninit @(arr Nout b) @b rgn_width
          (\ (loop_x : int) -> IEffect b.
             let y : int = origin_y +# loop_y in
             let x : int = origin_x +# loop_x in
             let mv : view2 a =
                   mk_view2 @a
                   @stencil_Mlo @stencil_Mhi @stencil_Nlo @stencil_Nhi
                   (iInt @stencil_Mlo stencil_ymin)
                   (iInt @stencil_Mhi stencil_yend)
                   (iInt @stencil_Nlo stencil_xmin)
                   (iInt @stencil_Nhi stencil_xend)
                   (getter y x) in
             -- Pass the array2 view to the stencil function
             stencilfn mv (subscript_out @Nout @b repr_b
                           (subscript_out @Mout @(arr Nout b)
                            row_repr ret y) x)))
    } in

    -- Bounds checking is needed around the edges of the array, but not in
    -- the interior.  Compute the size of the edges and the interior.
    let left_boundary_size : int =
          max_int 0 (AdditiveDict_int_negate xmin) in
    let right_boundary_size : int =
          max_int 0 xmax in
    let top_boundary_size : int =
          max_int 0 (AdditiveDict_int_negate ymin) in
    let bottom_boundary_size : int =
          max_int 0 ymax in
    let center_width : int =
     	  inp_width_i -# (left_boundary_size +# right_boundary_size) in
    let center_height : int =
          inp_height_i -# (top_boundary_size +# bottom_boundary_size) in

    -- Origin of center, left, and right regions
    let center_origin_y : int = top_boundary_size in

    -- Origin of center region
    let center_origin_x : int = left_boundary_size in
    let right_origin_x : int = inp_width_i -# right_boundary_size in
    let bottom_origin_y : int = inp_height_i -# bottom_boundary_size in

    -- Create return value
    mk_array2 @b @0 @M @0 @N zero_fii inp_height zero_fii inp_width
    (referenced @(arr (minus_i M 0) (arr (minus_i N 0) b))
     (if or (center_width <# 1) (center_height <# 1)
     then
       -- Input array2 is smaller than stencil.  Use one loop for the
       -- entire output array.
       init_array 0 0 inp_height_i inp_width_i safe_get
     else
       -- Use one loop each for the left, right, top, bottom, and center of
       -- the output.  The corners of the output array are part of the top
       -- and bottom strips.
       (\ (ret_array : OutPtr out_array)
          -> IEffect out_array.
          fromEffTok @out_array
          (seqEffTok
           (seqEffTok
            (toEffTok @out_array -- Top strip
             (init_array 0 0 top_boundary_size inp_width_i safe_get ret_array))
            (toEffTok @out_array -- Bottom strip
             (init_array bottom_origin_y 0 bottom_boundary_size inp_width_i safe_get ret_array)))
           (seqEffTok
            (seqEffTok
             (toEffTok @out_array -- Left strip
              (init_array center_origin_y 0 center_height left_boundary_size safe_get ret_array))
             (toEffTok @out_array -- Right strip
              (init_array center_origin_y right_origin_x center_height right_boundary_size safe_get ret_array)))
            (toEffTok @out_array -- Center region
             (init_array center_origin_y center_origin_x center_height center_width unsafe_get ret_array)))))));


extend2D @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr : Repr a)
  (low_bound : index (shape t))
  (hi_bound : index (shape t))
  (inp : t a)
  -> view2 a =

  let type Sint = Stored int in

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).
  
  -- Get the bounds of the output data
  case coerce @(index (shape t)) @(index dim2) low_bound of
    pyonTuple2 @Sint @Sint (s_ylo : Sint) (s_xlo : Sint).
  case s_ylo of stored @int (ylo : int).
  case s_xlo of stored @int (xlo : int).

  case coerce @(index (shape t)) @(index dim2) low_bound of
    pyonTuple2 @Sint @Sint (s_yhi : Sint) (s_xhi : Sint).
  case s_yhi of stored @int (yhi : int).
  case s_xhi of stored @int (xhi : int).

  -- Lower bound must be less than upper bound
  if or (ylo ># yhi) (xlo ># xhi)
  then except @(view2 a)
  else

  -- Inspect the input data
  case coerce @(shape t) @dim2 (get_shape @a inp) of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).
    case fromIndInt @Mlo inp_ymin of
      fiInt @Mlo (inp_ymin_i : int).
    case fromIndInt @Nlo inp_xmin of
      fiInt @Nlo (inp_xmin_i : int).
    case fromIndInt @Mhi inp_yend of
      fiInt @Mhi (inp_yend_i : int).
    case fromIndInt @Nhi inp_xend of
      fiInt @Nhi (inp_xend_i : int).

  -- Input must be nonempty
  if or (inp_ymin_i >=# inp_yend_i) (inp_xmin_i >=# inp_xend_i)
  then except @(view2 a)
  else

  -- Create the output view
  case defineIntIndex ylo of someIInt @(Mlo : intindex) (f_ylo : FIInt Mlo).
  case defineIntIndex yhi of someIInt @(Mhi : intindex) (f_yhi : FIInt Mhi).
  case defineIntIndex xlo of someIInt @(Nlo : intindex) (f_xlo : FIInt Nlo).
  case defineIntIndex xhi of someIInt @(Nhi : intindex) (f_xhi : FIInt Nhi).
  mk_view2 @a @Mlo @Mhi @Nlo @Nhi (iInt @Mlo f_ylo) (iInt @Mhi f_yhi)
  (iInt @Nlo f_xlo) (iInt @Nhi f_xhi)
  (\ (y : int) (x : int) (ret : OutPtr a) -> IEffect a.
     -- Coerce indices to the nearest in-range part of the input object
     let real_y : int =
           if y <# inp_ymin_i then inp_ymin_i else
           if y >=# inp_yend_i then inp_yend_i -# 1 else
           y in
     let real_x : int =
           if x <# inp_xmin_i then inp_xmin_i else
           if x >=# inp_xend_i then inp_xend_i -# 1 else
           x in

     -- Create an index
     case boxed @(PyonTuple2 Sint Sint)
          (pyonTuple2 @Sint @Sint (stored @int real_y) (stored @int real_x)) of
       boxed @(PyonTuple2 Sint Sint) (ix : index dim2).
     at_index @a repr inp (coerce @(index dim2) @(index (shape t)) ix) ret);


range2D (extent : index dim2) -> Stream dim2 (index dim2)
  attribute(inline) =

  let type Sint = Stored int in
  case extent of pyonTuple2 @Sint @Sint (sy : Sint) (sx : Sint).
  case sy of stored @int (y : int).
  case sx of stored @int (x : int).

  if or (y <# 0) (x <# 0)
  then except @(Stream dim2 (index dim2))
  else case defineIntIndex y of someIInt @(M : intindex) (m : FIInt M).
       case defineIntIndex x of someIInt @(N : intindex) (n : FIInt N).
       mk_view2 @(PyonTuple2 Sint Sint) @0 @0 @M @N zero_ii zero_ii (iInt @M m) (iInt @N n)
       (\ (y : int) (x : int) (ret : OutPtr (PyonTuple2 Sint Sint))
          -> IEffect (PyonTuple2 Sint Sint).
        pyonTuple2 @Sint @Sint (stored @int y) (stored @int x) ret);


shift2D @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr : Repr a)
  (offset : index (shape t))
  (inp : t a)
  -> view2 a =

  let type Sint = Stored int in

  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Writer a)
    (get_shape : (a : bare) -> t a -> shape t).
  
  -- Get the offset to use
  case coerce @(index (shape t)) @(index dim2) offset of
    pyonTuple2 @Sint @Sint (s_y_off : Sint) (s_x_off : Sint).
  case s_y_off of stored @int (y_off : int).
  case s_x_off of stored @int (x_off : int).
  case defineIntIndex y_off of
    someIInt @(Mdelta : intindex) (md : FIInt Mdelta).
  let mdi : IInt Mdelta = iInt @Mdelta md in
  case defineIntIndex x_off of
    someIInt @(Ndelta : intindex) (nd : FIInt Ndelta).
  let ndi : IInt Ndelta = iInt @Ndelta nd in

  -- Inspect the input data
  case coerce @(shape t) @dim2 (get_shape @a inp) of
    mk_dim2
    @(Mlo Mhi Nlo Nhi : intindex)
    (inp_ymin : IInt Mlo)
    (inp_yend : IInt Mhi)
    (inp_xmin : IInt Nlo)
    (inp_xend : IInt Nhi).
    case fromIndInt @Mlo inp_ymin of
      fiInt @Mlo (inp_ymin_i : int).
    case fromIndInt @Nlo inp_xmin of
      fiInt @Nlo (inp_xmin_i : int).
    case fromIndInt @Mhi inp_yend of
      fiInt @Mhi (inp_yend_i : int).
    case fromIndInt @Nhi inp_xend of
      fiInt @Nhi (inp_xend_i : int).

  -- Create the output view
  mk_view2 @a @(plus_i Mlo Mdelta) @(plus_i Mhi Mdelta)
  @(plus_i Nlo Ndelta) @(plus_i Nhi Ndelta)
  (plus_ii @Mlo @Mdelta inp_ymin mdi)
  (plus_ii @Mhi @Mdelta inp_yend mdi)
  (plus_ii @Nlo @Ndelta inp_xmin ndi)
  (plus_ii @Nhi @Ndelta inp_xend ndi)
  (\ (y : int) (x : int) (ret : OutPtr a) -> IEffect a.
     -- Subtract the shift to get the original offset
     let real_y : int = y -# y_off in
     let real_x : int = x -# x_off in

     -- Create an index
     case boxed @(PyonTuple2 Sint Sint)
          (pyonTuple2 @Sint @Sint (stored @int real_y) (stored @int real_x)) of
       boxed @(PyonTuple2 Sint Sint) (ix : index dim2).
     at_index @a repr inp (coerce @(index dim2) @(index (shape t)) ix) ret);

-------------------------------------------------------------------------------
-- Loops

parallel_doall @(N : intindex) @(a b : bare)
  (count : FIInt N)
  (f : int -> IEffect b)
  -> IEffect a
  attribute(inline, inline_sequential) =

  letfun
    do_range @(M : intindex)
      (lb : int) (range_count : FIInt M)
      -> IEffect b =
    doall @M @b @b range_count
    (\ (range_i : int) -> IEffect b. f (range_i +# lb))
  in
  blocked_doall @N @a @b count do_range;


parallel_dim1_reduce @(a : bare)
  (repr : Repr a)
  (shp : dim1)
  (reducer : a -> a -> Writer a)
  (init : a)
  (generator : dim1 -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  -- Parallel reduction over a dim1 domain.
  -- Use blocked_reduce to do the real work.
  case shp of
    mk_dim1 @(L : intindex) @(H : intindex) (il : IInt L) (ih : IInt H).

  -- Compute size of interval.  Size must be finite.
  let type D = minus_i H L in
  let fdelta : FIInt D = fromIndInt @D (minus_ii @H @L ih il) in
  case fromIndInt @L il of fiInt @L (lo_bound : int).

  let type b = BoxedType a in

  -- Wrap the reducer and generator functions
  letfun {
    g @(N : intindex) (lb : int) (count : FIInt N) (acc : b) -> b =

      -- Create a dim1 spanning [lo_bound + lb, lo_bound + lb + count)
      case defineIntIndex (lo_bound +# lb) of
        someIInt @(sub_L : intindex) (sub_lb : FIInt sub_L).
      let type sub_H = plus_i sub_L N in
      let sub_ub : FIInt sub_H = plus_fii @sub_L @N sub_lb count in
      let dim : dim1 =
            mk_dim1 @sub_L @sub_H (iInt @sub_L sub_lb) (iInt @sub_H sub_ub) in

      -- Generate a value and accumulate
      case boxed @a (generator dim) of boxed @a (x : a).
      case boxed @a (convertToBare @a repr acc) of boxed @a (y : a).
      convertToBoxed @a repr (reducer y x)

  ; f (x : b) (y : b) -> b =
      case boxed @a (convertToBare @a repr x) of boxed @a (xb : a).
      case boxed @a (convertToBare @a repr y) of boxed @a (yb : a).
      convertToBoxed @a repr (reducer xb yb)
  } in

  let boxed_init : b = convertToBoxed @a repr (copy @a repr init) in
  convertToBare @a repr (blocked_reduce @D @b fdelta f boxed_init g) ret;

parallel_dim1_reduce1 @(a : bare)
  (repr : Repr a)
  (shp : dim1)
  (reducer : a -> a -> Writer a)
  (generator : dim1 -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline) =
  -- Parallel reduction over a dim1 domain.

  let reprmaybe : Repr (Maybe a) = repr_Maybe @a repr in

  letfun {
    fmaybe (mx : Maybe a) (my : Maybe a) (ret : OutPtr (Maybe a))
      -> IEffect (Maybe a) =
      case mx of {
        just @a (x : a).
          case my of {
            just @a (y : a). just @a (reducer x y) ret
          ; nothing @a.      just @a (copy @a repr x) ret
          }
      ; nothing @a.
          case my of {
            just @a (y : a). just @a (copy @a repr y) ret
          ; nothing @a.      nothing @a ret
          }
      }

  ; gmaybe (range : dim1) (ret : OutPtr (Maybe a)) -> IEffect (Maybe a) =
      just @a (generator range) ret
  } in

  case boxed @(Maybe a) (nothing @a) of boxed @(Maybe a) (init : Maybe a).

  -- Call the regular reduction function here
  case boxed @(Maybe a) (parallel_dim1_reduce @(Maybe a)
                         reprmaybe shp fmaybe init gmaybe) of
    boxed @(Maybe a) (retmaybe : Maybe a).
  case retmaybe of {
    just @a (retval : a). copy @a repr retval ret

    -- If 'nothing' is returned, then the range was empty.  This is an error.
  ; nothing @a. except @(IEffect a) 
  };


parallel_darr1_generate @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N)
  (f : int -> Writer a)
  (ret : OutPtr (arr N a))
  -> IEffect (arr N a)
  attribute(inline) =
  parallel_doall @N @(arr N a) @a size
  (\ (i : int) -> IEffect a. f i (subscript_out @N @a repr ret i));


parallel_darr1_reduce @(N : intindex) @(a : bare)
  (repr : Repr a) (count : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (g : int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_sequential) =

  letfun {
    -- Sequentially reduce on the interval [lb, lb + range_count)
    do_range @(M : intindex)
      (lb : int) (range_count : FIInt M) (acc : BoxedType a) -> BoxedType a =
      case boxed @a (convertToBare @a repr acc) of boxed @a (uacc : a).
      convertToBoxed @a repr
      (primitive_darr1_reduce @M @a repr range_count f uacc
       (\ (i : int) (local_ret : OutPtr a) -> IEffect a.
        g (lb +# i) local_ret))

  ; boxed_f (x : BoxedType a) (y : BoxedType a) -> BoxedType a =
      case boxed @a (convertToBare @a repr x) of boxed @a (ux : a).
      case boxed @a (convertToBare @a repr y) of boxed @a (uy : a).
      convertToBoxed @a repr (f ux uy)
  } in
  let boxed_init : BoxedType a = convertToBoxed @a repr (copy @a repr init) in

  convertToBare @a repr
  (blocked_reduce @N @(BoxedType a) count boxed_f boxed_init do_range) ret;

parallel_darr1_reduce1 @(N : intindex) @(a : bare)
  (repr : Repr a) (count : FIInt N)
  (f : a -> a -> Writer a)
  (g : int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_sequential) =

  let reprmaybe : Repr (Maybe a) = repr_Maybe @a repr in

  -- Parallel reduce1 is defined in terms of parallel reduce.
  -- An 'uninitialized' value is encoded as 'Nothing'.
  letfun {
    fmaybe (mx : Maybe a) (my : Maybe a) (ret : OutPtr (Maybe a))
      -> IEffect (Maybe a) =
      case mx of {
        just @a (x : a).
          case my of {
            just @a (y : a). just @a (f x y) ret
          ; nothing @a.      just @a (copy @a repr x) ret
          }
      ; nothing @a.
          case my of {
            just @a (y : a). just @a (copy @a repr y) ret
          ; nothing @a.      nothing @a ret
          }
      }

  ; gmaybe (i : int) (ret : OutPtr (Maybe a)) -> IEffect (Maybe a) =
      just @a (g i) ret
  } in

  case boxed @(Maybe a) (nothing @a) of boxed @(Maybe a) (init : Maybe a).

  -- Call the regular reduction function here
  case boxed @(Maybe a) (parallel_darr1_reduce @N @(Maybe a)
                         reprmaybe count fmaybe init gmaybe) of
    boxed @(Maybe a) (retmaybe : Maybe a).
  case retmaybe of {
    just @a (retval : a). copy @a repr retval ret

    -- If 'nothing' is returned, then the range was empty.  This is an error.
  ; nothing @a. except @(IEffect a) 
  };


parallel_darr2_reduce @(M N : intindex) @(a : bare)
  (repr : Repr a) (count_y : FIInt M) (count_x : FIInt N)
  (f : a -> a -> Writer a)
  (init : a)
  (g : int -> int -> Writer a)
  (ret : OutPtr a)
  -> IEffect a
  attribute(inline, inline_sequential) =

  letfun {
    -- Sequentially reduce on the interval
    -- [lb_y, lb_y + range_count_y) * [lb_x, lb_x + range_count_x)
    do_range @(M N : intindex)
      (lb_y : int) (range_count_y : FIInt M)
      (lb_x : int) (range_count_x : FIInt N)
      (acc : BoxedType a) -> BoxedType a =

      case boxed @a (convertToBare @a repr acc) of boxed @a (uacc : a).
      convertToBoxed @a repr
      (primitive_darr2_reduce @M @N @a repr range_count_y range_count_x f uacc
       (\ (y : int) (x : int) (local_ret : OutPtr a) -> IEffect a.
        g (lb_y +# y) (lb_x +# x) local_ret))

  ; boxed_f (x : BoxedType a) (y : BoxedType a) -> BoxedType a =
      case boxed @a (convertToBare @a repr x) of boxed @a (ux : a).
      case boxed @a (convertToBare @a repr y) of boxed @a (uy : a).
      convertToBoxed @a repr (f ux uy)
  } in
  let boxed_init : BoxedType a = convertToBoxed @a repr (copy @a repr init) in

  convertToBare @a repr
  (blocked_reduce2 @M @N @(BoxedType a)
   count_y count_x boxed_f boxed_init do_range) ret;


parallel_darr2_generate @(M N : intindex) @(a : bare)
  (repr : Repr a) (height : FIInt M) (width : FIInt N)
  (f : int -> int -> Writer a)
  (ret : OutPtr (arr M (arr N a)))
  -> IEffect (arr M (arr N a))
  attribute(inline, inline_sequential) =

  let row_repr : Repr (arr N a) = repr_arr @N @a width repr in
  parallel_doall2 @M @N @(arr M (arr N a)) @a height width
  (\ (j : int) (i : int) -> IEffect a.
     f j i (subscript_out @N @a repr (subscript_out @M @(arr N a) row_repr ret j) i));


parallel_doall2 @(M N : intindex) @(a b : bare)
  (count_y : FIInt M)
  (count_x : FIInt N)
  (f : int -> int -> IEffect b)
  -> IEffect a
  attribute(inline, inline_sequential) =

  letfun
    do_range @(M N : intindex)
      (lb_m : int) (range_count_m : FIInt M)
      (lb_n : int) (range_count_n : FIInt N)
      -> IEffect b =
    doall @M @b @b range_count_m
    (\ (range_j : int) -> IEffect b.
      doall @N @b @b range_count_n
      (\ (range_i : int) -> IEffect b.
        f (range_j +# lb_m) (range_i +# lb_n)))
  in
  blocked_doall2 @M @N @a @b count_y count_x do_range;



-}