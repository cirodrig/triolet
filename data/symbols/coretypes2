
{- Predefined names
-- These names are predefined.  The definitions are here for reference.

kind val;
kind box;
kind bare;
kind out;
kind write;
kind sideeffect;

-}

-- Data types

data Stored : val -> bare
{
  stored (a : val) () (a);
};

data Ref : box -> bare
{
  ref (a : box) () (a);
};

-- A stuck reference is like a 'Ref' but doesn't get unwrapped
-- by 'convertToBare'.
data StuckRef : box -> bare
{
  stuckRef (a : box) () (a);
};

data Boxed : bare -> box
{
  boxed (a : bare) () (a);
};

-- A stuck box is like a 'boxed' but doesn't get unwrapped
-- by 'convertToBoxed'.
data StuckBox : bare -> box
{
  stuckBox (a : bare) () (a);
};

-- A pointer used for initializing data
data OutPtr : bare -> out
  attribute(abstract, nonalgebraic) {};

-- A dummy value representing the effect of initializing an object
data Store : val
  attribute(abstract)
{
  store () () ();
};

-- Type functions to convert between representations
type BoxedType : bare -> box;
type BareType : box -> bare;

-- Designates an initializer function for a bare object
type Init : bare -> write;

-- Normal data types

data bool : val
{
  True () () ();
  False () () ();
};

data int : val attribute(abstract, nonalgebraic) {};
data uint : val attribute(abstract, nonalgebraic) {};
data float : val attribute(abstract, nonalgebraic) {};

data NoneType : val
{
  None () () ();
};

data Maybe : bare -> bare
{
  just (a : bare) () (a);
  nothing (a : bare) () ();
};

-- A value-form of 'Maybe'.  It must be used with statically known arguments.
data MaybeVal : val -> val
{
  justVal (a : val) () (a);
  nothingVal (a : val) () ();
};

-- An integer interval, given by inclusive lower and exclusive upper bounds.
-- The upper bound must be greater or equal to the lower bound.
-- 'Nothing' means that the interval is unbounded at that end.
data Interval : val
{
  interval () () (MaybeVal int, MaybeVal int);
};

-- | A linear map, representing the function y = s*x + a.
--   The stride 's' must be nonzero.
--
--   Negative strides are valid; however, note that many functions expect
--   linear maps with positive strides.
data LinearMap : val
{
  linearMap () () (int, int);
};

-- A finite indexed integer 
data FIInt : intindex -> val
{
  fiInt (n : intindex) () (int);
};

-- An indexed singleton integer type.
-- Invariant: The type index gives up the integer value.
data IInt : intindex -> val
{
  -- Finite value
  iInt (n : intindex) () (FIInt n);

  -- Positive and negative infinity
  iPosInfty (n : intindex) () ();
  iNegInfty (n : intindex) () ();
};

-- An existential indexed singleton integer type.
-- We can convert int to this type.
data SomeIInt : val
{
  someIInt () (n : intindex) (FIInt n);
};

-- A user-specified slice.
--
-- If the third field is Nothing, the slice specifies a contiguous range.
-- Otherwise it specifies a triple.
data SliceObject : bare
{
  sliceObject () ()
  (MaybeVal int, MaybeVal int, MaybeVal (MaybeVal int));
};

data Complex : bare -> bare
{
  complex (a : bare) () (a, a);
};

data arr : intindex -> bare -> bare
  attribute(abstract, nonalgebraic)
{};


data PyonTuple2 : bare -> bare -> bare
{
  pyonTuple2
  (a : bare, b : bare) () (a, b);
};

data PyonTuple3 : bare -> bare -> bare -> bare
{
  pyonTuple3
  (a : bare, b : bare, c : bare) () (a, b, c);
};

data PyonTuple4 : bare -> bare -> bare -> bare -> bare
{
  pyonTuple4
  (a : bare, b : bare, c : bare, d : bare) () (a, b, c, d);
};

-- Dictionaries

data SizeAlign : bare -> val
{
  sizeAlign (a : bare) () (uint, uint);
};

data SizeAlignVal : val -> val
{
  sizeAlignVal (a : val) () (uint, uint);
};

-- This data declaration is not precisely correct:
-- Size and alignment are not int, but rather unsigned int.
-- The finalize function has a slightly different type.
data Repr : bare -> box
  attribute(abstract)
{
  repr (a : bare) ()
  (SizeAlign a,                 -- Size and alignment
   a -> Init a,		-- Copy
   Init a -> BoxedType a,	-- Convert to boxed
   BoxedType a -> Init a,     -- Convert to bare
   bool);                       -- Pointerlessness
                                -- (True if an 'a' definitely doesn't contain pointers)
};

data EqDict : bare -> box
{
  eqDict
  (a : bare) ()
  (a -> a -> bool, a -> a -> bool);
};

data OrdDict : bare -> box
{
  ordDict
  (a : bare) ()
  (EqDict a, a -> a -> bool, a -> a -> bool, a -> a -> bool, a -> a -> bool);
};

data AdditiveDict : bare -> box
{
  additiveDict
  (a : bare) ()
  (a -> a -> Init a,
   a -> a -> Init a,
   a -> Init a,
   a);
};

data MultiplicativeDict : bare -> box
{
  multiplicativeDict
  (a : bare) ()
  (AdditiveDict a,
   a -> a -> Init a,
   int -> Init a,
   a);
};

data RemainderDict : bare -> box
{
  remainderDict
  (a : bare) ()
  (MultiplicativeDict a,
   a -> a -> int,
   a -> a -> Init a);
};

data FractionalDict : bare -> box
{
  fractionalDict
  (a : bare) ()
  (MultiplicativeDict a, a -> a -> Init a);
};

data FloatingDict : bare -> box
{
  floatingDict
  (a : bare) ()
  (float -> Init a,
   a -> a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a);
};

data VectorDict : bare -> box
{
  vectorDict
  (a : bare) ()
  (AdditiveDict a,
   a -> float -> Init a,
   a -> float,
   a -> a -> float);
};

-- Cartesian domains, indexed by their index type.
--
-- The methods are:
-- 1. Get lower bound of finite range
-- 2. Get upper bound of finite range
-- 3. Get strides
-- 4. Create a finite range
-- 5. Displace a domain by an offset
-- 6. Scale a domain by a scale factor
-- 7. Scale a domain by an inverse scale factor
-- 8. Scale an index by a scale factor
-- 9. Scale an index by an inverse scale factor
-- 10.The largest domain
data CartesianDict : box -> box
{
  cartesianDict
  (sh : box)
  ()
  (coerce @box (cartesianDomain (index sh)) sh,
   sh -> Init (Maybe (index sh)),
   sh -> Init (Maybe (index sh)),
   sh -> Init (index sh),
   index sh -> index sh -> sh,
   sh -> index sh -> sh,
   sh -> index sh -> sh,
   sh -> index sh -> sh,
   index sh -> index sh -> Init (index sh),
   index sh -> index sh -> Init (index sh),
   sh);
};

data TraversableDict : (bare -> bare) -> box
{
  traversableDict (t : bare -> bare) ()
  ((a : bare) -> Repr a -> t a -> Stream (shape t) a,
   (a : bare) -> Repr a -> Stream (shape t) a -> Init (t a));
};

-- Operations related to data domains and traversals over them.
-- The operations are flatten-to-list, generate, map, zipWith{2..4},
-- range checking for integers, and slicing.
data ShapeDict : box -> box
{
  shapeDict (sh : box) ()
  (Repr (index sh),
   Repr (slice sh),

   -- Member
   sh -> index sh -> bool,

   -- Intersect
   sh -> sh -> sh,

   -- Flatten
   (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a,

   -- Generate
   (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a,

   -- Map and zips
   (a b : bare) ->
   Repr a -> Repr b ->
   (a -> Init b) -> Stream sh a -> Stream sh b,

   (a b c : bare) ->
   Repr a -> Repr b -> Repr c ->
   (a -> b -> Init c) -> Stream sh a -> Stream sh b -> Stream sh c,

   (a b c d : bare) ->
   Repr a -> Repr b -> Repr c -> Repr d ->
   (a -> b -> c -> Init d) ->
   Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d,

   (a b c d e : bare) ->
   Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
   (a -> b -> c -> d -> Init e) ->
   Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e,

   -- Slice
   (t : bare -> bare) -> (a : bare) ->
   coerce @box (shape t) sh ->
   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a
   );
};

-- Class methods for one-dimensional, array-like container types
-- that can be indexed into.
-- Methods should not perform bounds checking.
data IndexableDict : (bare -> bare) -> box
{
  indexableDict
  (t : bare -> bare) ()
  ((a : bare) -> Repr a -> t a -> index (shape t) -> Init a,
   (a : bare) -> t a -> shape t);
};

-- The cartesian domain corresponding to an index type
type cartesianDomain : bare -> box;
type index : box -> bare;
type slice : box -> bare;

-------------------------------------------------------------------------------
-- Imperative computation support

-- A dummy token that we use to stand in for dependences due to
-- imperative computation that is inserted by the compiler.
--
-- We take advantage of the fact that EffTok is a unit value, and therefore
-- it is not accessed by load or store instructions when reading or writing it,
-- and therefore we can safely masquerade NULL pointers as EffTok references.
data EffTok : val
  attribute(abstract)
{
  -- We never use the constructor 'effTok' in code, because it could be
  -- optimized away.  We don't want the optimizer to mess with this data type
  -- because it stands in for real dependences.
  -- Instead, use 'emptyEffTok' to produce an EffTok value.
  effTok () () ();
};

-- An empty side effect.
-- This function is translated specially when converting from Core to LowLevel.
emptyEffTok : EffTok;

-- Translate to a side effect.
-- This function is translated specially when converting from Core to LowLevel.
toEffTok : (a : bare) -> Store -> EffTok;

-- Perform two side-effecting operations in sequence.
seqEffTok : EffTok -> EffTok -> EffTok;

fromEffTok : (a : bare) -> EffTok -> Store;

-- The finalizer of an in-place update operation.
-- A finalizer performs a one-time computation to convert the updatable
-- data structure to a read-only data structure.  In some cases, a finalizer
-- is not required, in which case the update is really performed in-place.
data UpdateInPlaceFinalizer : bare -> bare -> box
{
  -- The data can be mutated in place if the mutable and immutable data formats
  -- are the same
  mutateInPlace (mutable immutable : bare) () (coerce @bare mutable immutable);

  -- Data should be mutated out-of-place, then written to the output
  mutateAndCopy (mutable immutable : bare) () (mutable -> Init immutable);
};

-- A scatter-reduce operation.  Reductions are performed with a combination of
-- sequential in-place updates and parallel reduction.
--
-- The type parameters and existential types are:
-- * a return type 'r', which is the result type of a scatter reduction
-- * an index type 'i', which is the type of inputs to a scatter reduction
-- * a state type 's', which is the memory representation that's modified by
--   in-place upate
-- * a scalar type 'a', which is the data type that's loaded and stored
--   (or atomically updated) during an in-place update
--
-- The code is organized such that only function types are parameterized on
-- 'a'.  There are no values of type 'a', because values can only have ground
-- types.  By organizing functions this way, we can generally ensure that the
-- low-level API does not need to perform memory allocation.
--
-- Token passing is used to represent dependences during the in-place part of
-- the reduction.
data Scatter : bare -> bare -> box
{
  mk_scatter (r i : bare) (s : bare, a : val)
  (Repr s,
   (NoneType -> a) -> OutPtr s -> EffTok,       -- Initializer
   (a -> a) -> i -> EffTok -> OutPtr s -> EffTok, -- Updater
   s -> s -> Init s,                          -- Combining function
   UpdateInPlaceFinalizer s r,                  -- Final value constructor
   i -> (a -> a),                               -- Update function
   NoneType -> a                                -- Initial value
  );
};


-- These functions are implemented in low-level code.
intUpdateInPlace_initializer : (NoneType -> int)
                            -> OutPtr (Stored int)
                            -> EffTok;
intUpdateInPlace_updater : (int -> int) -> EffTok
                        -> OutPtr (Stored int)
                        -> EffTok;
floatUpdateInPlace_initializer : (NoneType -> float)
                              -> OutPtr (Stored float)
                              -> EffTok;
floatUpdateInPlace_updater : (float -> float) -> EffTok
                          -> OutPtr (Stored float)
                          -> EffTok;

-- Helper functions for scatter reductions
intUpdateInPlace_combiner : Stored int -> Stored int -> Init (Stored int);
intUpdateInPlace_int_coercion : coerce @bare (Stored int) (Stored int);
intUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored int) (Stored int);

floatUpdateInPlace_combiner : Stored float -> Stored float -> Init (Stored float);
floatUpdateInPlace_float_coercion : coerce @bare (Stored float) (Stored float);
floatUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored float) (Stored float);

-- Scatter reduction algorithms
intSumScatter : Scatter (Stored int) (Stored int);
intSumScatter_updater : (int -> int)
                              -> Stored int -> EffTok -> OutPtr (Stored int)
                              -> EffTok;
intSumScatter_make_update : Stored int -> int -> int;
intSumScatter_make_init : NoneType -> int;

floatSumScatter : Scatter (Stored float) (Stored float);
floatSumScatter_updater : (float -> float)
                              -> Stored float -> EffTok -> OutPtr (Stored float)
                              -> EffTok;
floatSumScatter_make_update : Stored float -> float -> float;
floatSumScatter_make_init : NoneType -> float;

countingScatter : Scatter (Stored int) (Stored NoneType);
countingScatter_updater : (int -> int)
                                -> Stored NoneType -> EffTok -> OutPtr (Stored int)
                                -> EffTok;
countingScatter_make_update : Stored NoneType -> int -> int;
countingScatter_make_init : NoneType -> int;

boxedScatter : (a : box) -> (b : bare) -> Repr b
            -> (b -> a -> a)
            -> (a -> a -> a)
            -> a
            -> Scatter (StuckRef a) b;

boxedScatter_updater : (a : box)
                    -> ((a,) -> (a,))
                    -> EffTok
                    -> OutPtr (StuckRef a)
                    -> EffTok;

arrScatter : (N : intindex)
                   -> (s i : bare)
                   -> Repr i
                   -> Repr s
                   -> FIInt N
                   -> Scatter s i
                   -> Scatter (arr N s) (PyonTuple2 (Stored int) i);

comapScatterIndex :
    (s i1 i2 : bare)
 -> Repr i1
 -> Repr i2
 -> Repr s
 -> (i2 -> Init i1)
 -> Scatter s i1
 -> Scatter s i2;

array1Scatter : (s i : bare)
                      -> Repr i
                      -> Repr s
                      -> dim1
                      -> Scatter s i
                      -> Scatter (array1 s) (PyonTuple2 (Stored int) i);

barray1Scatter : (a i : bare)
              -> Repr i
              -> Repr a
              -> dim1
              -> Scatter (StuckRef (BoxedType a)) i
              -> Scatter (barray1 a) (PyonTuple2 (Stored int) i);

array2Scatter : (s i : bare)
                      -> Repr i
                      -> Repr s
                      -> dim2
                      -> Scatter s i
                      -> Scatter (array2 s) (PyonTuple2 (index dim2) i);

barray2Scatter : (a i : bare)
              -> Repr i
              -> Repr a
              -> dim2
              -> Scatter (StuckRef (BoxedType a)) i
              -> Scatter (barray2 a) (PyonTuple2 (index dim2) i);

array3Scatter : (s i : bare)
                      -> Repr i
                      -> Repr s
                      -> dim3
                      -> Scatter s i
                      -> Scatter (array3 s) (PyonTuple2 (index dim3) i);

barray3Scatter : (a i : bare)
              -> Repr i
              -> Repr a
              -> dim3
              -> Scatter (StuckRef (BoxedType a)) i
              -> Scatter (barray3 a) (PyonTuple2 (index dim3) i);

-------------------------------------------------------------------------------
-- Streams

-- A dynamically computed sequence of values, possibly with run-time
-- shape information.
type Stream : box -> bare -> box;

-- A 1-dimensional stream of values, represented either as a
-- view or as a linear stream.
data Stream1 : bare -> box
{
  sequenceStream (a : bare) () (Sequence a);
  viewStream (a : bare) () (view list_dim a);
};

-- A dynamically computed sequence of values.
data Sequence : bare -> box
{
  -- A stream is a (state, generator) pair.
  sequence (a : bare) (st : box) (st, st -> StreamNext st a);
};

-- The result of attempting to pull a value from a stream.
data StreamNext : box -> bare -> val
{
  streamEmpty (st : box, a : bare) () ();
  streamValue (st : box, a : bare) () (st, BoxedType a);
};

-- The state of the stream 'bind' operator
data BindState : box -> bare -> bare -> box
{
  -- Pull the next value from the source stream
  -- (Also represents a depleted stream)
  bindFromSource (src_st : box, src_elt : bare, trans_elt : bare)
    ()
    (src_st);

  -- Pull the next value from the stream transformer
  bindFromTrans (src_st : box, src_elt : bare, trans_elt : bare)
    (trans_st : box)
    (src_st,
     trans_st,
     trans_st -> StreamNext trans_st trans_elt);
};

-- State of a chained stream
data ChainState : box -> box -> box
{
  chainFromFirst (a b : box) () (a, b);
  chainFromNext (a b : box) () (b);
};



-------------------------------------------------------------------------------
-- Views

--  A view is a container represented by a function
data view : box -> bare -> box
{
  mk_view (sh : box, a : bare) () (sh, index sh -> Init a);
};

-------------------------------------------------------------------------------
-- Storage

data list : bare -> bare
{
  make_list
  (a : bare) (n : intindex)
  (FIInt n, StuckBox (arr n a));
};

-- A list of boxed objects
data blist : bare -> bare
{
  make_blist (a : bare) () (list (StuckRef (BoxedType a)));
};

-- An array type, parameterized over its dimension.
-- The array type contains its bounds.
type array : bare -> bare -> bare;

-- A singleton container
data array0 : bare -> bare
{
  mk_array0 (a : bare) () (a);
};

-- A 1D array.
-- The array's domain is described by a lower bound, stride, and size.
data array1 : bare -> bare
{
  mk_array1 (a : bare) (N : intindex)
  (int, int, FIInt N, StuckBox (arr N a));
};

-- A 2D array.
-- The array's domain is described by a lower bound, stride, and size in
-- the Y dimension, and a lower bound, stride, and size in the X dimension.
data array2 : bare -> bare
{
  mk_array2
  (a : bare) (M N : intindex)
  (int, int, FIInt M, int, int, FIInt N, StuckBox (arr M (arr N a)));
};

-- A 3D array.
-- The array's domain is described by a lower bound, stride, and size in
-- the Z, Y, and X dimensions.
data array3 : bare -> bare
{
  mk_array3
  (a : bare) (L M N : intindex)
  (int, int, FIInt L,
   int, int, FIInt M,
   int, int, FIInt N,
   StuckBox (arr L (arr M (arr N a))));
};

-- A 1D boxed array.
data barray1 : bare -> bare
{
  mk_barray1 (a : bare) () (array1 (StuckRef (BoxedType a)));
};

-- A 2D boxed array.
data barray2 : bare -> bare
{
  mk_barray2 (a : bare) () (array2 (StuckRef (BoxedType a)));
};

-- A 3D boxed array.
data barray3 : bare -> bare
{
  mk_barray3 (a : bare) () (array3 (StuckRef (BoxedType a)));
};

-- Convert the "size" fields of an array to an equivalent dim1.
arrayDescToDim1 : (N : intindex) -> int -> int -> FIInt N -> dim1;

-- Convert a dim1 to the equivalent "size" fields of an array.
dim1ToArrayDesc : (a : bare)
               -> dim1
               -> ((N : intindex) -> int -> int -> FIInt N -> Init a)
               -> Init a;

-------------------------------------------------------------------------------
-- Shapes

-- Get the stream shape corresponding to a container
type shape : (bare -> bare) -> box;

-- The shape of a list stream.
-- 'Nothing' is an infinite stream; otherwise the shape is the length.
data list_dim : box
{
  mk_list_dim () () (MaybeVal int);
};

-- The shape of a singleton stream
data dim0 : box
{
  mk_dim0 () () ();
};

-- A one-dimensional domain.
-- The domain is the intersection of an interval and a linear map's range.
--
-- Invariants:
-- The interval's lower and upper bounds are in the range of the linear map.
-- The linear map's stride is positive.
-- The linear map's alignment may be anything; it's not constrained to be a
-- small positive number.
data dim1 : box
{
  mk_dim1 () () (Interval, LinearMap);
};

-- A two-dimensional domain.  The cross product of two domains.
data dim2 : box
{
  mk_dim2 () () (dim1, dim1);
};

-- A three-dimensional domain.  The cross product of three domains.
data dim3 : box
{
  mk_dim3 () () (dim1, dim1, dim1);
};

-- The shape of an array stream.
-- Array streams are zero-indexed.
data arr_shape : intindex -> box -> box
{
  mk_arr_shape (len : intindex, sh : box) () (sh);
};

shapeIndexRepr : (sh : box) -> ShapeDict sh -> Repr (index sh);
shapeSliceRepr : (sh : box) -> ShapeDict sh -> Repr (slice sh);

-------------------------------------------------------------------------------
-- Representation dictionaries

copy : (a : bare) -> Repr a -> a -> Init a
       attribute(conlike);
convertToBoxed : (a : bare) -> Repr a -> Init a -> BoxedType a;
convertToBare : (a : bare) -> Repr a -> BoxedType a -> Init a;

reprSizeAlign : (a : bare) -> Repr a -> SizeAlign a;

dynamicCopyError : (a : bare) -> a -> Init a;
copyArray : (N : intindex) -> (a : bare) -> Repr a -> IInt N -> arr N a
         -> Init (arr N a);

-- This function is inserted by the simplifier to convert data constructor
-- applications to values
reify : (a : bare) -> Repr a -> Init a -> a;

repr_int : Repr (Stored int);
repr_float : Repr (Stored float);
repr_bool : Repr (Stored bool);
repr_NoneType : Repr (Stored NoneType);
repr_SliceObject : Repr SliceObject;
repr_list_dim : Repr (Ref list_dim);
repr_dim0 : Repr (Ref dim0);
repr_dim1 : Repr (Ref dim1);
repr_dim2 : Repr (Ref dim2);
repr_dim3 : Repr (Ref dim3);

repr_index2 : Repr (PyonTuple2 (Stored int) (Stored int));
repr_slice2 : Repr (PyonTuple2 SliceObject SliceObject);

repr_index3 : Repr (PyonTuple3 (Stored int) (Stored int) (Stored int));
repr_slice3 : Repr (PyonTuple3 SliceObject SliceObject SliceObject);

repr_list : (a : bare) -> Repr a -> Repr (list a);
repr_array0 : (a : bare) -> Repr a -> Repr (array0 a);
repr_array1 : (a : bare) -> Repr a -> Repr (array1 a);
repr_array2 : (a : bare) -> Repr a -> Repr (array2 a);
repr_array3 : (a : bare) -> Repr a -> Repr (array3 a);
repr_blist : (a : bare) -> Repr (blist a);
repr_barray1 : (a : bare) -> Repr (barray1 a);
repr_barray2 : (a : bare) -> Repr (barray2 a);
repr_barray3 : (a : bare) -> Repr (barray3 a);
repr_Complex : (a : bare) -> Repr a -> Repr (Complex a);
repr_Maybe : (a : bare) -> Repr a -> Repr (Maybe a);
repr_MaybeVal_int : Repr (MaybeVal int);
repr_MaybeVal_MaybeVal_int : Repr (MaybeVal (MaybeVal int));

repr_PyonTuple2 :
    (a b : bare) -> Repr a -> Repr b -> Repr (PyonTuple2 a b);

repr_PyonTuple3 :
    (a b c : bare)
 -> Repr a -> Repr b -> Repr c
 -> Repr (PyonTuple3 a b c);

repr_PyonTuple4 :
    (a b c d : bare)
 -> Repr a -> Repr b -> Repr c -> Repr d
 -> Repr (PyonTuple4 a b c d);

-- Representation of any boxed object
repr_Box : (a : box) -> Repr (BareType a);
repr_Ref : (a : box) -> Repr (Ref a);
repr_StuckRef : (a : box) -> Repr (StuckRef a);

repr_Stream : (sh : box) -> (a : bare) -> Repr (BareType (Stream sh a));
repr_view : (sh : box) -> (a : bare) -> Repr (BareType (view sh a));
repr_Scatter : (a b : bare) -> Repr (BareType (Scatter a b));

-- Representation of a referenced object that contains nothing and will
-- never be accessed.  At runtime, the reference will be an arbitrary pointer,
-- possibly NULL.
repr_EmptyReference : (a : bare) -> Repr a;

repr_arr : (n : intindex) -> (e : bare)
        -> FIInt n -> Repr e -> Repr (arr n e);

repr_EffTok : Repr (Stored EffTok);

--getReprSizeAlignTuple : (a : bare) -> Repr a -> (uint, uint);
--getSizeAlignValTuple : (a : val) -> SizeAlignVal a -> (uint, uint);

--productSizeAlign : (uint, uint) -> (uint, uint) -> (uint, uint);
--unionSizeAlign : (uint, uint) -> (uint, uint) -> (uint, uint);

--toSizeAlignVal : (a : val) -> (uint, uint) -> SizeAlignVal a;
--toSizeAlign : (a : bare) -> (uint, uint) -> SizeAlign a;

sizealign_arr : (n : intindex) -> IInt n -> (uint, uint) -> (uint, uint);
repr_arr_2 : (n : intindex) -> (a : bare)
          -> IInt n -> Repr a -> Repr (arr n a);

-------------------------------------------------------------------------------
-- Stream and Traversable dictionaries

TraversableDict_Stream_build :
  (sh : box) -> (a : bare) -> Repr a -> Stream sh a -> Stream sh a;

TraversableDict_Stream_traverse :
  (sh : box) -> (a : bare) -> Repr a -> Stream sh a -> Stream sh a;

TraversableDict_view_list_dim_build :
  (a : bare) -> Repr a -> Stream list_dim a -> view list_dim a;

TraversableDict_view_list_dim_traverse :
  (a : bare) -> Repr a -> view list_dim a -> Stream list_dim a;

TraversableDict_view_dim0_build :
  (a : bare) -> Repr a -> Stream dim0 a -> view dim0 a;

TraversableDict_view_dim0_traverse :
  (a : bare) -> Repr a -> view dim0 a -> Stream dim0 a;

TraversableDict_view_dim1_build :
  (a : bare) -> Repr a -> Stream dim1 a -> view dim1 a;

TraversableDict_view_dim1_traverse :
  (a : bare) -> Repr a -> view dim1 a -> Stream dim1 a;

TraversableDict_view_dim2_build :
  (a : bare) -> Repr a -> Stream dim2 a -> view dim2 a;

TraversableDict_view_dim2_traverse :
  (a : bare) -> Repr a -> view dim2 a -> Stream dim2 a;

TraversableDict_view_dim3_build :
  (a : bare) -> Repr a -> Stream dim3 a -> view dim3 a;

TraversableDict_view_dim3_traverse :
  (a : bare) -> Repr a -> view dim3 a -> Stream dim3 a;

TraversableDict_list_build :
  (a : bare) -> Repr a -> Stream list_dim a -> Init (list a);

TraversableDict_list_traverse :
  (a : bare) -> Repr a -> list a -> Stream list_dim a;

TraversableDict_array0_build :
  (a : bare) -> Repr a -> Stream dim0 a -> Init (array0 a);

TraversableDict_array0_traverse :
  (a : bare) -> Repr a -> array0 a -> Stream dim0 a;

TraversableDict_array1_build :
  (a : bare) -> Repr a -> Stream dim1 a -> Init (array1 a);

TraversableDict_array1_traverse :
  (a : bare) -> Repr a -> array1 a -> Stream dim1 a;

TraversableDict_array2_build :
  (a : bare) -> Repr a -> Stream dim2 a -> Init (array2 a);

TraversableDict_array2_traverse :
  (a : bare) -> Repr a -> array2 a -> Stream dim2 a;

TraversableDict_array3_build :
  (a : bare) -> Repr a -> Stream dim3 a -> Init (array3 a);

TraversableDict_array3_traverse :
  (a : bare) -> Repr a -> array3 a -> Stream dim3 a;

TraversableDict_blist_build :
  (a : bare) -> Repr a -> Stream list_dim a -> Init (blist a);

TraversableDict_blist_traverse :
  (a : bare) -> Repr a -> blist a -> Stream list_dim a;

TraversableDict_barray1_build :
  (a : bare) -> Repr a -> Stream dim1 a -> Init (barray1 a);

TraversableDict_barray1_traverse :
  (a : bare) -> Repr a -> barray1 a -> Stream dim1 a;

TraversableDict_barray2_build :
  (a : bare) -> Repr a -> Stream dim2 a -> Init (barray2 a);

TraversableDict_barray2_traverse :
  (a : bare) -> Repr a -> barray2 a -> Stream dim2 a;

TraversableDict_barray3_build :
  (a : bare) -> Repr a -> Stream dim3 a -> Init (barray3 a);

TraversableDict_barray3_traverse :
  (a : bare) -> Repr a -> barray3 a -> Stream dim3 a;

ShapeDict_list_dim : ShapeDict list_dim;
ShapeDict_dim0 : ShapeDict dim0;
ShapeDict_dim1 : ShapeDict dim1;
ShapeDict_dim2 : ShapeDict dim2;
ShapeDict_dim3 : ShapeDict dim3;

ShapeDict_list_dim_member :
  list_dim -> index list_dim -> bool;

ShapeDict_list_dim_intersect :
  list_dim -> list_dim -> list_dim;

ShapeDict_list_dim_generate :
  (a : bare) -> Repr a -> list_dim -> (index list_dim -> Init a) ->
  Stream list_dim a;

ShapeDict_list_dim_flatten :
  (a : bare) -> Repr a -> Stream list_dim a -> Stream list_dim a;

ShapeDict_list_dim_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Init b) ->
  Stream list_dim a -> Stream list_dim b;

ShapeDict_list_dim_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Init c) ->
  Stream list_dim a -> Stream list_dim b -> Stream list_dim c;

ShapeDict_list_dim_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Init d) ->
  Stream list_dim a -> Stream list_dim b -> Stream list_dim c -> Stream list_dim d;

ShapeDict_list_dim_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Init e) ->
  Stream list_dim a -> Stream list_dim b -> Stream list_dim c -> Stream list_dim d -> Stream list_dim e;

ShapeDict_list_dim_slice :
  (t : bare -> bare) -> (a : bare) ->
  coerce @box (shape t) list_dim ->
  IndexableDict t -> Repr a -> t a -> slice list_dim -> view list_dim a;

ShapeDict_dim0_member :
  dim0 -> index dim0 -> bool;

ShapeDict_dim0_intersect :
  dim0 -> dim0 -> dim0;

ShapeDict_dim0_generate :
  (a : bare) -> Repr a -> dim0 -> (index dim0 -> Init a) -> Stream dim0 a;

ShapeDict_dim0_flatten :
  (a : bare) -> Repr a -> Stream dim0 a -> Stream list_dim a;

ShapeDict_dim0_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Init b) ->
  Stream dim0 a -> Stream dim0 b;

ShapeDict_dim0_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Init c) ->
  Stream dim0 a -> Stream dim0 b -> Stream dim0 c;

ShapeDict_dim0_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Init d) ->
  Stream dim0 a -> Stream dim0 b -> Stream dim0 c -> Stream dim0 d;

ShapeDict_dim0_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Init e) ->
  Stream dim0 a -> Stream dim0 b -> Stream dim0 c -> Stream dim0 d -> Stream dim0 e;

ShapeDict_dim0_slice :
  (t : bare -> bare) -> (a : bare) ->
  coerce @box (shape t) dim0 ->
  IndexableDict t -> Repr a -> t a -> slice dim0 -> view dim0 a;

ShapeDict_dim1_member :
  dim1 -> index dim1 -> bool;

ShapeDict_dim1_intersect :
  dim1 -> dim1 -> dim1;

ShapeDict_dim1_generate :
  (a : bare) -> Repr a -> dim1 -> (index dim1 -> Init a) -> Stream dim1 a;

ShapeDict_dim1_flatten :
  (a : bare) -> Repr a -> Stream dim1 a -> Stream list_dim a;

ShapeDict_dim1_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Init b) ->
  Stream dim1 a -> Stream dim1 b;

ShapeDict_dim1_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Init c) ->
  Stream dim1 a -> Stream dim1 b -> Stream dim1 c;

ShapeDict_dim1_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Init d) ->
  Stream dim1 a -> Stream dim1 b -> Stream dim1 c -> Stream dim1 d;

ShapeDict_dim1_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Init e) ->
  Stream dim1 a -> Stream dim1 b -> Stream dim1 c -> Stream dim1 d -> Stream dim1 e;

ShapeDict_dim1_slice :
  (t : bare -> bare) -> (a : bare) ->
  coerce @box (shape t) dim1 ->
  IndexableDict t -> Repr a -> t a -> slice dim1 -> view dim1 a;

ShapeDict_dim2_member :
  dim2 -> index dim2 -> bool;

ShapeDict_dim2_intersect :
  dim2 -> dim2 -> dim2;

ShapeDict_dim2_generate :
  (a : bare) -> Repr a -> dim2 -> (index dim2 -> Init a) -> Stream dim2 a;

ShapeDict_dim2_flatten_helper : Interval -> Interval -> int -> int
  -> (list_dim, MaybeVal int, int, int);

ShapeDict_dim2_flatten_helper2 : int -> MaybeVal int -> (int, int);

ShapeDict_dim2_flatten :
  (a : bare) -> Repr a -> Stream dim2 a -> Stream list_dim a;

ShapeDict_dim2_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Init b) ->
  Stream dim2 a -> Stream dim2 b;

ShapeDict_dim2_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Init c) ->
  Stream dim2 a -> Stream dim2 b -> Stream dim2 c;

ShapeDict_dim2_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Init d) ->
  Stream dim2 a -> Stream dim2 b -> Stream dim2 c -> Stream dim2 d;

ShapeDict_dim2_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Init e) ->
  Stream dim2 a -> Stream dim2 b -> Stream dim2 c -> Stream dim2 d -> Stream dim2 e;

ShapeDict_dim2_slice :
  (t : bare -> bare) -> (a : bare) ->
  coerce @box (shape t) dim2 ->
  IndexableDict t -> Repr a -> t a -> slice dim2 -> view dim2 a;

ShapeDict_dim3_member :
  dim3 -> index dim3 -> bool;

ShapeDict_dim3_intersect :
  dim3 -> dim3 -> dim3;

ShapeDict_dim3_generate :
  (a : bare) -> Repr a -> dim3 -> (index dim3 -> Init a) -> Stream dim3 a;

ShapeDict_dim3_flatten_helper : Interval -> Interval -> Interval
  -> int -> int -> int
  -> (list_dim, MaybeVal (MaybeVal int, int), int, int, int);

ShapeDict_dim3_flatten_helper2 : int -> MaybeVal (MaybeVal int, int)
                              -> (int, int, int);

ShapeDict_dim3_flatten :
  (a : bare) -> Repr a -> Stream dim3 a -> Stream list_dim a;

ShapeDict_dim3_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Init b) ->
  Stream dim3 a -> Stream dim3 b;

ShapeDict_dim3_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Init c) ->
  Stream dim3 a -> Stream dim3 b -> Stream dim3 c;

ShapeDict_dim3_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Init d) ->
  Stream dim3 a -> Stream dim3 b -> Stream dim3 c -> Stream dim3 d;

ShapeDict_dim3_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Init e) ->
  Stream dim3 a -> Stream dim3 b -> Stream dim3 c -> Stream dim3 d -> Stream dim3 e;

ShapeDict_dim3_slice :
  (t : bare -> bare) -> (a : bare) ->
  coerce @box (shape t) dim3 ->
  IndexableDict t -> Repr a -> t a -> slice dim3 -> view dim3 a;


IndexableDict_list_at_point :
  (a : bare) -> Repr a -> list a -> Stored int -> Init a;

IndexableDict_list_get_shape :
  (a : bare) -> list a -> list_dim;

IndexableDict_view_at_point :
  (sh : box) -> ShapeDict sh ->
  (a : bare) -> Repr a -> view sh a -> index sh -> Init a;

IndexableDict_view_get_shape :
  (sh : box) -> ShapeDict sh ->
  (a : bare) -> view sh a -> sh;

IndexableDict_array0_at_point :
  (a : bare) -> Repr a -> array0 a -> Stored NoneType -> Init a;

IndexableDict_array0_get_shape :
  (a : bare) -> array0 a -> dim0;

IndexableDict_array1_at_point :
  (a : bare) -> Repr a -> array1 a -> Stored int -> Init a;

IndexableDict_array1_get_shape :
  (a : bare) -> array1 a -> dim1;

IndexableDict_array2_at_point :
  (a : bare) -> Repr a -> array2 a -> PyonTuple2 (Stored int) (Stored int)
  -> Init a;

IndexableDict_array2_get_shape :
  (a : bare) -> array2 a -> dim2;

IndexableDict_blist_at_point :
  (a : bare) -> Repr a -> blist a -> Stored int -> Init a;

IndexableDict_blist_get_shape :
  (a : bare) -> blist a -> list_dim;

IndexableDict_barray1_at_point :
  (a : bare) -> Repr a -> barray1 a -> Stored int -> Init a;

IndexableDict_barray1_get_shape :
  (a : bare) -> barray1 a -> dim1;

IndexableDict_barray2_at_point :
  (a : bare) -> Repr a -> barray2 a -> PyonTuple2 (Stored int) (Stored int)
  -> Init a;

IndexableDict_barray2_get_shape :
  (a : bare) -> barray2 a -> dim2;

-------------------------------------------------------------------------------
-- Comparison dictionaries

EqDict_int_eq : int -> int -> bool;
EqDict_int_ne : int -> int -> bool;

EqDict_float_eq : float -> float -> bool;
EqDict_float_ne : float -> float -> bool;

EqDict_Tuple2_eq : (a b : bare) -> EqDict a -> EqDict b
                -> PyonTuple2 a b -> PyonTuple2 a b -> bool;
EqDict_Tuple2_ne : (a b : bare) -> EqDict a -> EqDict b
                -> PyonTuple2 a b -> PyonTuple2 a b -> bool;

OrdDict_int_lt : int -> int -> bool;
OrdDict_int_le : int -> int -> bool;
OrdDict_int_gt : int -> int -> bool;
OrdDict_int_ge : int -> int -> bool;

OrdDict_float_lt : float -> float -> bool;
OrdDict_float_le : float -> float -> bool;
OrdDict_float_gt : float -> float -> bool;
OrdDict_float_ge : float -> float -> bool;

-------------------------------------------------------------------------------
-- Numeric dictionaries

AdditiveDict_int_add : int -> int -> int;
AdditiveDict_int_sub : int -> int -> int;
AdditiveDict_int_negate : int -> int;
AdditiveDict_int_zero : int;

AdditiveDict_uint_add : uint -> uint -> uint;
AdditiveDict_uint_sub : uint -> uint -> uint;
AdditiveDict_uint_negate : uint -> uint;
AdditiveDict_uint_zero : uint;

AdditiveDict_float_add : float -> float -> float;
AdditiveDict_float_sub : float -> float -> float;
AdditiveDict_float_negate : float -> float;
AdditiveDict_float_zero : float;

AdditiveDict_PyonTuple2_add : (a b : bare)
                           -> Repr a
                           -> Repr b
                           -> AdditiveDict a
                           -> AdditiveDict b
                           -> PyonTuple2 a b
                           -> PyonTuple2 a b
                           -> Init (PyonTuple2 a b);
AdditiveDict_PyonTuple2_sub : (a b : bare)
                           -> Repr a
                           -> Repr b
                           -> AdditiveDict a
                           -> AdditiveDict b
                           -> PyonTuple2 a b
                           -> PyonTuple2 a b
                           -> Init (PyonTuple2 a b);
AdditiveDict_PyonTuple2_negate : (a b : bare)
                              -> Repr a
                              -> Repr b
                              -> AdditiveDict a
                              -> AdditiveDict b
                              -> PyonTuple2 a b
                              -> Init (PyonTuple2 a b);
AdditiveDict_PyonTuple2_zero : (a b : bare)
                            -> Repr a
                            -> Repr b
                            -> AdditiveDict a
                            -> AdditiveDict b
                            -> Init (PyonTuple2 a b);

{-AdditiveDict_Complex_add :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
AdditiveDict_Complex_sub :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
AdditiveDict_Complex_negate :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Init (Complex a);
AdditiveDict_Complex_zero :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Init (Complex a);-}


MultiplicativeDict_int_mul : int -> int -> int;
MultiplicativeDict_int_fromInt : int -> int;

MultiplicativeDict_uint_mul : uint -> uint -> uint;
MultiplicativeDict_uint_fromInt : uint -> uint;

MultiplicativeDict_float_mul : float -> float -> float;
MultiplicativeDict_float_fromInt : int -> float;

{-MultiplicativeDict_Complex_mul :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
MultiplicativeDict_Complex_fromInt :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> int
 -> Init (Complex a);
MultiplicativeDict_Complex_one :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> Init (Complex a);-}


RemainderDict_int_floordiv : int -> int -> int;
RemainderDict_int_mod : int -> int -> int;

RemainderDict_uint_floordiv : uint -> uint -> uint;
RemainderDict_uint_mod : uint -> uint -> uint;

RemainderDict_float_floordiv : float -> float -> int;
RemainderDict_float_mod : float -> float -> float;


FractionalDict_float_div : float -> float -> float;

FractionalDict_Complex_div :
    (a : bare)
 -> Repr a
 -> FractionalDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);


FloatingDict_float_fromfloat : float -> float;
FloatingDict_float_power : float -> float -> float;
FloatingDict_float_exp : float -> float;
FloatingDict_float_log : float -> float;
FloatingDict_float_sqrt : float -> float;
FloatingDict_float_sin : float -> float;
FloatingDict_float_cos : float -> float;
FloatingDict_float_tan : float -> float;
FloatingDict_float_pi : float;

FloatingDict_Complex_fromfloat :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> float
 -> Init (Complex a);
FloatingDict_Complex_power :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_exp :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_log :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_sqrt :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_sin :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_cos :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_tan :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_pi :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Init (Complex a);


VectorDict_float_scale : float -> float -> float;
VectorDict_float_magnitude : float -> float;
VectorDict_float_dot : float -> float -> float;

VectorDict_Complex_scale :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> float
 -> Init (Complex a);

VectorDict_Complex_magnitude :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> float;

VectorDict_Complex_dot :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> Complex a
 -> float;

CartesianDict_dim0_loBound :
    dim0 -> Init (Maybe (index dim0));
CartesianDict_dim0_hiBound :
    dim0 -> Init (Maybe (index dim0));
CartesianDict_dim0_stride :
    dim0 -> Init (index dim0);
CartesianDict_dim0_arrayRange :
    index dim0 -> index dim0 -> dim0;
CartesianDict_dim0_displaceDomain :
    dim0 -> index dim0 -> dim0;
CartesianDict_dim0_multiplyDomain :
    dim0 -> index dim0 -> dim0;
CartesianDict_dim0_divideDomain :
    dim0 -> index dim0 -> dim0;
CartesianDict_dim0_multiplyIndex :
    index dim0 -> index dim0 -> Init (index dim0);
CartesianDict_dim0_divideIndex :
    index dim0 -> index dim0 -> Init (index dim0);
CartesianDict_dim0_unbounded :
    dim0;
CartesianDict_dim1_loBound :
    dim1 -> Init (Maybe (index dim1));
CartesianDict_dim1_hiBound :
    dim1 -> Init (Maybe (index dim1));
CartesianDict_dim1_stride :
    dim1 -> Init (index dim1);
CartesianDict_dim1_arrayRange :
    index dim1 -> index dim1 -> dim1;
CartesianDict_dim1_displaceDomain :
    dim1 -> index dim1 -> dim1;
CartesianDict_dim1_multiplyDomain :
    dim1 -> index dim1 -> dim1;
CartesianDict_dim1_divideDomain :
    dim1 -> index dim1 -> dim1;
CartesianDict_dim1_multiplyIndex :
    index dim1 -> index dim1 -> Init (index dim1);
CartesianDict_dim1_divideIndex :
    index dim1 -> index dim1 -> Init (index dim1);
CartesianDict_dim1_unbounded :
    dim1;
CartesianDict_dim2_loBound :
    dim2 -> Init (Maybe (index dim2));
CartesianDict_dim2_hiBound :
    dim2 -> Init (Maybe (index dim2));
CartesianDict_dim2_stride :
    dim2 -> Init (index dim2);
CartesianDict_dim2_arrayRange :
    index dim2 -> index dim2 -> dim2;
CartesianDict_dim2_displaceDomain :
    dim2 -> index dim2 -> dim2;
CartesianDict_dim2_multiplyDomain :
    dim2 -> index dim2 -> dim2;
CartesianDict_dim2_divideDomain :
    dim2 -> index dim2 -> dim2;
CartesianDict_dim2_multiplyIndex :
    index dim2 -> index dim2 -> Init (index dim2);
CartesianDict_dim2_divideIndex :
    index dim2 -> index dim2 -> Init (index dim2);
CartesianDict_dim2_unbounded :
    dim2;
CartesianDict_dim3_loBound :
    dim3 -> Init (Maybe (index dim3));
CartesianDict_dim3_hiBound :
    dim3 -> Init (Maybe (index dim3));
CartesianDict_dim3_stride :
    dim3 -> Init (index dim3);
CartesianDict_dim3_arrayRange :
    index dim3 -> index dim3 -> dim3;
CartesianDict_dim3_displaceDomain :
    dim3 -> index dim3 -> dim3;
CartesianDict_dim3_multiplyDomain :
    dim3 -> index dim3 -> dim3;
CartesianDict_dim3_divideDomain :
    dim3 -> index dim3 -> dim3;
CartesianDict_dim3_multiplyIndex :
    index dim3 -> index dim3 -> Init (index dim3);
CartesianDict_dim3_divideIndex :
    index dim3 -> index dim3 -> Init (index dim3);
CartesianDict_dim3_unbounded :
    dim3;

-------------------------------------------------------------------------------
-- other arithmetic

min_int : int -> int -> int;
max_int : int -> int -> int;

or : bool -> bool -> bool;
and : bool -> bool -> bool;
not : bool -> bool;

-- An internal slice object.
-- The two integers are (in_stride, in_offset).
--
-- The slice produces a view with bounds [lo, hi).
-- Element i of the view maps to element i * in_stride + in_offset.
data InternalSlice : box
{
  internalSlice () (lo hi : intindex) (IInt lo, IInt hi, int, int);
  emptySlice () () ();
};

-------------------------------------------------------------------------------
-- integer index arithmetic

-- Promote an integer to a type index
defineIntIndex : int -> SomeIInt;

type pos_infty : intindex;
type plus_i : intindex -> intindex -> intindex;
type minus_i : intindex -> intindex -> intindex;
type min_i : intindex -> intindex -> intindex;
type max_i : intindex -> intindex -> intindex;

zero_fii : FIInt 0;
one_fii : FIInt 1;
plus_fii : (m n : intindex)
       -> FIInt m
       -> FIInt n
       -> FIInt (plus_i m n);

minus_fii : (m n : intindex)
        -> FIInt m
        -> FIInt n
        -> FIInt (minus_i m n);

min_fii : (m n : intindex)
      -> FIInt m
      -> FIInt n
      -> FIInt (min_i m n);

max_fii : (m n : intindex)
      -> FIInt m
      -> FIInt n
      -> FIInt (max_i m n);

zero_ii : IInt 0;
one_ii : IInt 1;
plus_ii : (m n : intindex)
       -> IInt m
       -> IInt n
       -> IInt (plus_i m n);

minus_ii : (m n : intindex)
        -> IInt m
        -> IInt n
        -> IInt (minus_i m n);

min_ii : (m n : intindex)
      -> IInt m
      -> IInt n
      -> IInt (min_i m n);

max_ii : (m n : intindex)
      -> IInt m
      -> IInt n
      -> IInt (max_i m n);

range_nonempty_ii : (m n : intindex) -> IInt m -> IInt n -> bool;


gcd : int -> int -> int;
extgcd_x : int -> int -> int;
isEmptyInterval : Interval -> bool;
inInterval : int -> Interval -> bool;
intersectInterval : Interval -> Interval -> Interval;
convolveInterval : Interval -> Interval -> Interval;
subsetInterval : Interval -> Interval -> bool;
inLM : int -> LinearMap -> bool;
evalLM : int -> LinearMap -> int;
invEvalLM : int -> LinearMap -> int;
intersectLM : LinearMap -> LinearMap -> MaybeVal LinearMap;
trimInterval : Interval -> LinearMap -> Interval;

internalApplyListSlice : SliceObject -> list_dim -> (list_dim, LinearMap);
internalApplyArraySlice : SliceObject -> dim1 -> dim1;
sliceToDomain : SliceObject -> dim1;

-------------------------------------------------------------------------------
-- propositions

-- Proof objects
data Pf : prop -> val
  attribute(abstract)
{
  pf (p : prop) () ();
};

type eqZ : intindex -> intindex -> prop;
type neZ : intindex -> intindex -> prop;
type trueP : prop;

eqZ_refl : (n : intindex) -> Pf (eqZ n n);

-- Construct an arbitrary proof value.  This function is only called to
-- construct proofs that are never used.  Since the value is not used, it is
-- safe to construct such a value.
deadProof : (p : prop) -> Pf p;

-- Construct an identity coercion.  This function is safe.
idCoercion : (a : box) -> coerce @box a a;
idBareCoercion : (a : bare) -> coerce @bare a a;

-- The type functions 'index' and 'cartesianDomain' are inverses where
-- they are defined.
cartesianIndexCoercion : (sh : box)
                      -> coerce @box (cartesianDomain (index sh)) sh;

-- Construct a coercion.  This function is unsafe.
unsafeMakeCoercion : (a b : box) -> coerce @box a b;

-- Construct a coercion.  This function is unsafe.
unsafeMakeBareCoercion : (a b : bare) -> coerce @bare a b;

-- Construct a coercion.  This function is unsafe.
unsafeMakeViewCoercion : (d : box)
                      -> coerce @(bare -> box) (Stream d) (view d);

-------------------------------------------------------------------------------
-- Domain functions

fun_list_dim : Maybe (Stored int) -> list_dim;

fun_dim1 : Maybe (Stored int) -> Maybe (Stored int) -> int -> int -> dim1;

make_sliceObject : bool -> int -> bool -> int -> bool -> bool -> int
                -> Init SliceObject;

-------------------------------------------------------------------------------
-- Stream consumers

build_list_dim_list : (a : bare)
                   -> Repr a
                   -> view list_dim a
                   -> Init (list a);

build_dim1_array : (a : bare)
                -> Repr a
                -> view dim1 a
                -> Init (array1 a);

reduce_list_dim : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> a
  -> view list_dim a
  -> Init a;

reduce1_list_dim : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> view list_dim a
  -> Init a;

reduce_dim1 : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> a
  -> view dim1 a
  -> Init a;

reduce1_dim1 : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> view dim1 a
  -> Init a;

scatter_list_dim : (i r : bare)
  -> Repr i -> Repr r
  -> Scatter r i
  -> view list_dim i
  -> Init r;

fold_list_dim : (a acc : bare)
  -> Repr a
  -> Repr acc
  -> (acc -> a -> Init acc)
  -> acc
  -> view list_dim a
  -> Init acc;

-------------------------------------------------------------------------------
-- Stream and Traversable dictionary-like internal methods

view_generate :
  (sh : box) -> ShapeDict sh ->
  (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> view sh a;

view_map :
  (sh : box) -> ShapeDict sh ->
  (a b : bare) -> Repr a -> Repr b -> (a -> Init b) -> view sh a -> view sh b;

view_zipWith :
  (sh : box) -> ShapeDict sh ->
  (a b c : bare) -> Repr a -> Repr b -> Repr c ->
  (a -> b -> Init c) ->
  view sh a ->
  view sh b ->
  view sh c;

view_zipWith3 :
  (sh : box) -> ShapeDict sh ->
  (a b c d : bare) -> Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Init d) ->
  view sh a ->
  view sh b ->
  view sh c ->
  view sh d;

view_zipWith4 :
  (sh : box) -> ShapeDict sh ->
  (a b c d e : bare) -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Init e) ->
  view sh a ->
  view sh b ->
  view sh c ->
  view sh d ->
  view sh e;

Sequence_flatten : (a : bare) -> Repr a -> Sequence a -> Stream dim1 a;

Sequence_generate : (a : bare)
                 -> Repr a -> list_dim -> (index list_dim -> Init a) -> Sequence a;

Sequence_map : (a b : bare) -> Repr a -> Repr b
	    -> (a -> Init b) -> Sequence a -> Sequence b;

Sequence_zipWith : (a b c : bare) -> Repr a -> Repr b -> Repr c
		-> (a -> b -> Init c)
		-> Sequence a
		-> Sequence b
		-> Sequence c;

Sequence_zipWith3 : (a b c d : bare)
		 -> Repr a -> Repr b -> Repr c -> Repr d
		 -> (a -> b -> c -> Init d)
		 -> Sequence a
		 -> Sequence b
		 -> Sequence c
                 -> Sequence d;

Sequence_zipWith4 : (a b c d e : bare)
		 -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e
		 -> (a -> b -> c -> d -> Init e)
		 -> Sequence a
		 -> Sequence b
		 -> Sequence c
                 -> Sequence d
                 -> Sequence e;

-------------------------------------------------------------------------------
-- Sequence operations

--view1_fold : (a acc : bare)
--          -> Repr a -> Repr acc
--          -> (acc -> a -> Init acc) -> acc -> view list_dim a
--          -> Init acc;

Sequence_reduce : (a : bare)
		-> Repr a
		-> (a -> a -> Init a)
		-> a
		-> Sequence a
		-> Init a;

Sequence_reduce1 : (a : bare)
		 -> Repr a
		 -> (a -> a -> Init a)
		 -> Sequence a
		 -> Init a;

Sequence_scatter : (i r : bare) -> Repr i -> Repr r
                -> Scatter r i
                -> Sequence i
                -> Init r;

Sequence_fold : (a acc : bare)
	      -> Repr a
	      -> Repr acc
	      -> (acc -> a -> Init acc)
	      -> acc
	      -> Sequence a
	      -> Init acc;

Sequence_build_list : (a : bare) -> Repr a -> Sequence a -> Init (list a);

Sequence_parallel_reduce : (a : bare)
                        -> Repr a
                        -> list_dim
                        -> (a -> a -> Init a)
                        -> a
                        -> (Stored int -> Sequence a)
                        -> Init a;

-------------------------------------------------------------------------------
-- High-level stream and container functions

fun_map : (t : bare -> bare)
       -> (a b : bare)
       -> TraversableDict t
       -> ShapeDict (shape t)
       -> Repr a
       -> Repr b
       -> (a -> Init b)
       -> t a
       -> Init (t b);

fun_filter : (t : bare -> bare)
          -> (a : bare)
          -> TraversableDict t
          -> coerce @box (shape t) list_dim
          -> Repr a
          -> (a -> bool)
          -> t a
          -> Init (t a);

fun_zip : (t1 t2 : bare -> bare)
       -> (a b : bare)
       -> TraversableDict t1
       -> TraversableDict t2
       -> coerce @box (shape t1) (shape t2)
       -> ShapeDict (shape t1)
       -> Repr a
       -> Repr b
       -> t1 a
       -> t2 b
       -> Stream (shape t1) (PyonTuple2 a b);

fun_zip3 : (t1 t2 t3 : bare -> bare)
        -> (a b c : bare)
        -> TraversableDict t1
        -> TraversableDict t2
        -> TraversableDict t3
        -> coerce @box (shape t1) (shape t2)
        -> coerce @box (shape t2) (shape t3)
        -> ShapeDict (shape t1)
        -> Repr a
        -> Repr b
        -> Repr c
        -> t1 a
        -> t2 b
        -> t3 c
        -> Stream (shape t1) (PyonTuple3 a b c);

fun_zip4 : (t1 t2 t3 t4 : bare -> bare)
        -> (a b c d : bare)
        -> TraversableDict t1
        -> TraversableDict t2
        -> TraversableDict t3
        -> TraversableDict t4
        -> coerce @box (shape t1) (shape t2)
        -> coerce @box (shape t2) (shape t3)
        -> coerce @box (shape t3) (shape t4)
        -> ShapeDict (shape t1)
        -> Repr a
        -> Repr b
        -> Repr c
        -> Repr d
        -> t1 a
        -> t2 b
        -> t3 c
        -> t4 d
        -> Stream (shape t1) (PyonTuple4 a b c d);

fun_reduce : (t : bare -> bare)
          -> (a : bare)
          -> TraversableDict t
	  -> ShapeDict (shape t)
          -> Repr a
          -> (a -> a -> Init a)
	  -> a
          -> t a
          -> Init a;

fun_reduce1 : (t : bare -> bare)
           -> (a : bare)
           -> TraversableDict t
	   -> ShapeDict (shape t)
           -> Repr a
           -> (a -> a -> Init a)
           -> t a
           -> Init a;

fun_indices : (sh : box) -> ShapeDict sh -> sh -> Stream sh (index sh);

displaceView : (t : bare -> bare) -> (a : bare)
            -> IndexableDict t
            -> ShapeDict (shape t)
            -> CartesianDict (shape t)
            -> AdditiveDict (index (shape t))
            -> Repr a
            -> t a
            -> index (shape t)
            -> view (shape t) a;

multiplyView : (t : bare -> bare) -> (a : bare)
            -> IndexableDict t
            -> ShapeDict (shape t)
            -> CartesianDict (shape t)
            -> AdditiveDict (index (shape t))
            -> Repr a
            -> t a
            -> index (shape t)
            -> view (shape t) a;

divideView : (t : bare -> bare) -> (a : bare)
          -> IndexableDict t
          -> ShapeDict (shape t)
          -> CartesianDict (shape t)
          -> AdditiveDict (index (shape t))
          -> Repr a
          -> t a
          -> index (shape t)
          -> view (shape t) a;

-------------------------------------------------------------------------------
-- Domain loops

primitive_list_dim_chain : (a : bare)
                        -> Repr a
                        -> view list_dim a
                        -> view list_dim a
                        -> view list_dim a;

primitive_list_dim_reduce : (a : bare)
  -> Repr a
  -> list_dim
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

parallel_list_dim_reduce : (a : bare)
  -> Repr a
  -> list_dim
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

primitive_list_dim_reduce1 : (a : bare)
  -> Repr a
  -> list_dim
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

parallel_list_dim_reduce1 : (a : bare)
  -> Repr a
  -> list_dim
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

primitive_list_dim_fold : (acc : bare)
  -> Repr acc
  -> list_dim
  -> (index list_dim -> acc -> Init acc)
  -> acc
  -> Init acc;

primitive_dim1_reduce : (a : bare)
  -> Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

parallel_dim1_reduce : (a : bare)
  -> Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

primitive_dim1_reduce1 : (a : bare)
  -> Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

parallel_dim1_reduce1 : (a : bare)
  -> Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

primitive_dim1_fold : (acc : bare)
  -> Repr acc
  -> dim1
  -> (index dim1 -> acc -> Init acc)
  -> acc
  -> Init acc;


-------------------------------------------------------------------------------
-- Other functions

fun_undefined : (a : box) -> a;

-- Convert an indexed int to a finite indexed int.  Raise an exception
-- if not finite.
fromIndInt : (N : intindex) -> IInt N -> FIInt N;

-- A dummy boxed object that is used as a placeholder for a dead value.
deadBox : (a : box) -> a;

-- A dummy referenced object that is used as a placeholder for a dead value.
deadRef : (a : bare) -> Init a;

fun_isNothing : (a : bare) -> Repr a -> Maybe a -> bool;
fun_isJust : (a : bare) -> Repr a -> Maybe a -> bool;
fun_fromJust : (a : bare) -> Repr a -> Maybe a -> Init a;

arr1D_build : (N : intindex) -> (a : bare) -> Repr a -> FIInt N
	   -> (int -> Init a) -> Init (arr N a);

arr2D_build : (M N : intindex) -> (a : bare) -> Repr a -> FIInt M -> FIInt N
	   -> (int -> int -> Init a) -> Init (arr M (arr N a));

arr3D_build : (L M N : intindex) -> (a : bare)
           -> Repr a -> FIInt L -> FIInt M -> FIInt N
	   -> (int -> int -> int -> Init a)
           -> Init (arr L (arr M (arr N a)));

empty_list_dim_view : (a : bare) -> Repr a -> view list_dim a;

viewToSequence : (a : bare) -> Repr a -> view list_dim a -> Sequence a;
sequenceToView : (a : bare) -> Repr a -> Sequence a -> view list_dim a;
view_transform : (sh : box) -> (a : bare)
              -> Repr a
              -> (sh -> sh)
              -> (index sh -> Init (index sh))
              -> view sh a
              -> view sh a;

-- An identity function needed in the frontend
fun_from_MatrixView_Stream : (a : bare)
			  -> Stream dim2 a
			  -> Stream dim2 a;

-- Reinterpret an array stream as having array2 shape
fun_asMatrix_Stream : (M N : intindex)
		   -> (a : bare)
		   -> IInt M
		   -> IInt N
		   -> Stream (arr_shape M (arr_shape N dim0)) a
		   -> Stream dim2 a;

-- Reinterpret a array2 stream as having array shape
fun_asArray2_Stream : (a b : bare)
		   -> Stream dim2 a
		   -> ((M N : intindex)
		       -> IInt M -> IInt N
		       -> Stream (arr_shape M (arr_shape N dim0))
		       -> Init b)
		   -> Init b;

fun_map_Stream : (sh a b : bare)
	      -> ShapeDict sh
       	      -> Repr a
       	      -> Repr b
       	      -> (a -> Init b)
       	      -> Stream sh a
       	      -> Stream sh b;



fun_zip_Stream : (sh a b : bare)
	      -> ShapeDict sh
       	      -> Repr a
       	      -> Repr b
       	      -> Stream sh a
       	      -> Stream sh b
       	      -> Stream sh (PyonTuple2 a b);

fun_zip3_Stream : (sh a b c : bare)
	       -> ShapeDict sh
               -> Repr a
               -> Repr b
               -> Repr c
               -> Stream sh a
               -> Stream sh b
               -> Stream sh c
               -> Stream sh (PyonTuple3 a b c);

fun_zip4_Stream : (sh a b c d : bare)
	       -> ShapeDict sh
               -> Repr a
               -> Repr b
               -> Repr c
               -> Repr d
               -> Stream sh a
               -> Stream sh b
               -> Stream sh c
               -> Stream sh d
               -> Stream sh (PyonTuple4 a b c d);

count : Stream list_dim (Stored int);

range : int -> Stream list_dim (Stored int);

singletonIter : (a : bare) -> Repr a -> Init a -> Stream list_dim a;

-- Helper function for 'singletonIter'
singleton_list_dim_view : (a : bare) -> Repr a -> Init a -> view list_dim a;

chain : (a : bare) -> Repr a -> Stream list_dim a -> Stream list_dim a -> Stream list_dim a;

len : (t : bare -> bare) -> (a : bare)
   -> (coerce @box (shape t) list_dim)
   -> IndexableDict t
   -> t a -> int;

safeIndex : (t : bare -> bare) -> (a : bare)
         -> IndexableDict t -> ShapeDict (shape t) -> Repr a
	 -> t a -> index (shape t) -> Init a;

safeSlice : (t : bare -> bare) -> (a : bare)
         -> IndexableDict t -> ShapeDict (shape t) -> Repr a
	 -> t a -> slice (shape t)
	 -> view (shape t) a;

width : (t : bare -> bare) -> (a : bare)
     -> coerce @box (shape t) dim2
     -> IndexableDict t
     -> t a -> int;
height : (t : bare -> bare) -> (a : bare)
     -> coerce @box (shape t) dim2
     -> IndexableDict t
     -> t a -> int;

rows : (t : bare -> bare) -> (a : bare)
    -> IndexableDict t
    -> coerce @box (shape t) dim2
    -> Repr a
    -> t a -> view dim1 (Ref (view dim1 a));

cols : (t : bare -> bare) -> (a : bare)
    -> IndexableDict t
    -> coerce @box (shape t) dim2
    -> Repr a
    -> t a -> view dim1 (Ref (view dim1 a));

outerproduct : (t u : bare -> bare) -> (a b : bare)
            -> TraversableDict t -> TraversableDict u
            -> coerce @box (shape t) dim1
            -> coerce @box (shape u) dim1
            -> Repr a -> Repr b
	    -> t a
	    -> u b
	    -> Stream dim2 (PyonTuple2 a b);

outerproductStream : (a b : bare)
            -> Repr a -> Repr b
	    -> Stream dim1 a
	    -> Stream dim1 b
	    -> Stream dim2 (PyonTuple2 a b);

transpose : (t : bare -> bare) -> (a : bare)
         -> IndexableDict t
	 -> coerce @box (shape t) dim2
	 -> Repr a
	 -> t a -> view dim2 a;

boxedStencil2D : (t : bare -> bare) -> (a b : bare)
	 -> IndexableDict t
	 -> coerce @box (shape t) dim2
	 -> Repr a
         -> Repr b
	 -> dim2
         -> dim2
	 -> (view dim2 a -> Init b)
	 -> t a
	 -> Init (barray2 b);

stencil2D : (t : bare -> bare) -> (a b : bare)
	 -> IndexableDict t
	 -> coerce @box (shape t) dim2
	 -> Repr a
         -> Repr b
	 -> dim2
         -> dim2
	 -> (view dim2 a -> Init b)
	 -> t a
	 -> Init (array2 b);

stencil3D : (t : bare -> bare) -> (a b : bare)
	 -> IndexableDict t
	 -> coerce @box (shape t) dim3
	 -> Repr a
         -> Repr b
	 -> dim3
         -> dim3
	 -> (view dim3 a -> Init b)
	 -> t a
	 -> Init (array3 b);

viewStencil2D : (a b : bare)
	 -> Repr a
         -> Repr b
	 -> dim2
         -> dim2
	 -> (view dim2 a -> Init b)
	 -> view dim2 a
	 -> Init (array2 b);

extend2D : (t : bare -> bare) -> (a : bare)
        -> IndexableDict t
        -> coerce @box (shape t) dim2
        -> Repr a
        -> t a
        -> view dim2 a;

extend3D : (t : bare -> bare) -> (a : bare)
        -> IndexableDict t
        -> coerce @box (shape t) dim3
        -> Repr a
        -> t a
        -> view dim3 a;

create_view2 : (a : bare) -> Repr a
            -> index dim2 -> index dim2 -> (index dim2 -> Init a) -> view dim2 a;

-- A type-indexed version of 'range'
rangeIndexed : (n : intindex)
            -> IInt n
            -> Stream (arr_shape n dim0) (Stored int);

fun_scatter : (t : bare -> bare)
           -> (i r : bare)
           -> ShapeDict (shape t)
           -> TraversableDict t
           -> Repr (t i)
           -> Repr i
           -> Repr r
           -> Scatter r i
           -> t i
           -> Init r;

histogram : (sh : box)
         -> ShapeDict sh
         -> int
         -> int
         -> Stream sh (Stored int)
         -> Init (array1 (Stored int));

histogramArray : (n : intindex)
              -> FIInt n
              -> int
              -> int
              -> Stream dim1 (Stored int)
              -> Init (arr n (Stored int));

generate : (n : intindex)
        -> (a : bare)
        -> IInt n
        -> Repr a
        -> (int -> Init a)
        -> Sequence a;

subscript : (n : intindex)
         -> (a : bare)
         -> SizeAlign a
         -> arr n a
         -> int
         -> a
         attribute(conlike);

-- Like subscript, but modifies an output pointer
subscript_out : (n : intindex)
             -> (a : bare)
             -> SizeAlign a
             -> OutPtr (arr n a)
             -> int
             -> OutPtr a;

-------------------------------------------------------------------------------
-- Other rewritable functions

Stream1_empty : (a : bare) -> Repr a -> Stream1 a;
Stream1_return : (a : bare) -> Repr a -> Init a -> Stream1 a;
Stream1_guard : (a : bare) -> Repr a -> bool -> Stream1 a -> Stream1 a;
Stream1_bind : (a b : bare)
	    -> Repr a -> Repr b -> Stream1 a -> (a -> Stream1 b) -> Stream1 b;

Sequence_empty : (a : bare) -> Repr a -> Sequence a;
Sequence_return : (a : bare) -> Repr a -> Init a -> Sequence a;
Sequence_chain : (a : bare) -> Repr a -> Sequence a -> Sequence a -> Sequence a;
Sequence_guard : (a : bare) -> Repr a -> bool -> Sequence a -> Sequence a;
Sequence_bind : (a b : bare)
	     -> Repr a -> Sequence a -> (a -> Sequence b) -> Sequence b;

-- A fused version of 'bind' and 'generate'.
Sequence_generate_bind : (a : bare)
	              -> list_dim
                      -> (index list_dim -> Sequence a)
                      -> Sequence a;


view_array1_build : (a : bare)
                 -> Repr a
                 -> view dim1 a
                 -> Init (array1 a);

Sequence_list_build : (a : bare)
		   -> Repr a
		   -> Sequence a
		   -> Init (list a);

Sequence_array1_build : (a : bare)
		     -> Repr a
		     -> Sequence a
		     -> Init (array1 a);

-------------------------------------------------------------------------------
-- Loops

-- Parallelizable loop
doall : (n : intindex)
     -> (a b : bare)
     -> FIInt n
     -> (int -> Store)
     -> Store;

-- Sequential loop
for : (n : intindex)
   -> (acc : bare)
   -> Repr acc
   -> FIInt n
   -> acc
   -> (int -> acc -> Init acc)
   -> Init acc;

-- Sequential loop with boxed accumulator
for_box : (n : intindex) -> (acc : box)
       -> FIInt n -> acc -> (int -> acc -> acc) -> acc;

parallel_doall : (n : intindex)
     -> (a b : bare)
     -> FIInt n
     -> (int -> Store)
     -> Store;

parallel_dim1_reduce : (a : bare)
                    -> Repr a
                    -> dim1
                    -> (a -> a -> Init a)
                    -> a
                    -> (dim1 -> Init a)
                    -> Init a;

parallel_dim1_reduce1 : (a : bare)
                     -> Repr a
                     -> dim1
                     -> (a -> a -> Init a)
                     -> (dim1 -> Init a)
                     -> Init a;

parallel_doall2 : (M N : intindex)
     -> (a b : bare)
     -> FIInt M
     -> FIInt N
     -> (int -> int -> Store)
     -> Store;

-- Blocked parallel reduction, implemented in low-level.
blocked_1d_reduce :
    (N : intindex)
 -> (acc : box)
 -> FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> acc			-- Initial value
 -> ((M : intindex) -> int -> FIInt M -> acc -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked 2D parallel reduction
blocked_2d_reduce :
    (M N : intindex)
 -> (acc : box)
 -> FIInt M		-- Size of range
 -> FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> acc			-- Initial value
 -> ((M N : intindex) -> int -> FIInt M -> int -> FIInt N -> acc -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked parallel loop
blocked_doall :
    (N : intindex)
 -> (a b : bare)
 -> FIInt N
 -> ((M : intindex) -> int -> FIInt M -> Store)
 -> Store;

-- Blocked 2D parallel loop
blocked_doall2 :
    (M N : intindex)
 -> (a b : bare)
 -> FIInt M
 -> FIInt N
 -> ((M N : intindex) -> int -> FIInt M -> int -> FIInt N -> Store)
 -> Store;
