
{- Predefined names
-- These names are predefined.  The definitions are here for reference.

kind val;
kind box;
kind bare;
kind out;
kind write;
kind sideeffect;

-}

-- Data types

data Stored : val -> bare
{
  stored (a : val) () (a);
};

data StoredBox : box -> bare
{
  storedBox (a : box) () (a);
};

data Boxed : bare -> box
{
  boxed (a : bare) () (a);
};

data Referenced : bare -> bare
{
  referenced (a : bare) () (a);
};

-- A pointer used for initializing data
data OutPtr : bare -> out
  attribute(abstract) {};

-- A dummy value representing the effect of initializing an object
data IEffect : bare -> sideeffect
  attribute(abstract) {};

-- Type functions to convert between representations
type BoxedType : bare -> box;
type BareType : box -> bare;

-- Designates an initializer function for a bare object
type Writer : bare -> write;

-- Normal data types

data bool : val
{
  True () () ();
  False () () ();
};

data int : val attribute(abstract) {};
data float : val attribute(abstract) {};

data NoneType : val
{
  None () () ();
};

-- A finite indexed integer 
data FinIndInt : intindex -> val
{
  finIndInt (n : intindex) () (Pf (neZ n pos_infty), int);
};

-- An indexed singleton integer type.
-- Invariant: The type index gives up the integer value.
data IndInt : intindex -> val
{
  -- Finite value
  indInt (n : intindex) () (FinIndInt n);

  -- Infinite value
  indOmega (n : intindex) () (Pf (eqZ n pos_infty));
};

-- An existential indexed singleton integer type.
-- We can convert int to this type.
data SomeIndInt : val
{
  someIndInt () (n : intindex) (FinIndInt n);
};

-- A dummy token that we use to stand in for dependences due to
-- imperative computation that is inserted by the compiler.
--
-- We take advantage of the fact that EffTok is a unit value, and therefore
-- it is not accessed by load or store instructions when reading or writing it,
-- and therefore we can safely masquerade NULL pointers as EffTok references.
data EffTok : val
  attribute(abstract)
{
  -- We never use the constructor 'effTok' in code, because it could be
  -- optimized away.  We don't want the optimizer to mess with this data type
  -- because it stands in for real dependences.
  -- Instead, use 'emptyEffTok' to produce an EffTok value.
  effTok () () ();
};

-- An empty side effect.
-- This function is translated specially when converting from Core to LowLevel.
emptyEffTok : EffTok;

-- Translate to a side effect.
-- This function is translated specially when converting from Core to LowLevel.
toEffTok : (a : bare) -> IEffect a -> EffTok;

-- Perform two side-effecting operations in sequence.
seqEffTok : EffTok -> EffTok -> EffTok;

fromEffTok : (a : bare) -> EffTok -> IEffect a;

data Complex : bare -> bare
{
  complex (a : bare) () (a, a);
};

data array : intindex -> bare -> bare
  attribute(abstract)
{};

-- A dynamically computed sequence of values, possibly with run-time
-- shape information.
type Stream : bare -> bare -> box;

-- A dynamically computed sequence of values.
data LinStream : bare -> bare -> box
  attribute(abstract)
{
  -- A stream is a (state, generator) pair.
  linStream (sh : bare, a : bare) (st : box)
    (st, st -> StreamNext st (BoxedType a));
};

data MatrixStream : bare -> box
{
  matrixStream (a : bare) (M : intindex, N : intindex)
    (IndInt M,
     IndInt N,
     LinStream (array_shape M (array_shape N unit_shape)) a);
};

-- The result of attempting to pull a value from a stream.
data StreamNext : box -> box -> val
{
  streamEmpty (st : box, a : box) () ();
  streamValue (st : box, a : box) () (st, a);
};

-- The state of the stream 'bind' operator
data BindState : box -> bare -> bare -> box
{
  -- Pull the next value from the source stream
  -- (Also represents a depleted stream)
  bindFromSource (src_st : box, src_elt : bare, trans_elt : bare)
    ()
    (src_st);

  -- Pull the next value from the stream transformer
  bindFromTrans (src_st : box, src_elt : bare, trans_elt : bare)
    (trans_st : box)
    (src_st,
     trans_st,
     trans_st -> StreamNext trans_st (BoxedType trans_elt));
};

data list : bare -> bare
{
  make_list
  (a : bare) (n : intindex)
  (FinIndInt n, Referenced (array n a));
};

data matrix : bare -> bare
{
  make_matrix
  (a : bare) (m : intindex, n : intindex)
  (FinIndInt m, FinIndInt n, Referenced (array m (array n a)));
};

-- A list-like, indexable object that computes values when they are retrieved
data ListView : bare -> bare
{
  listView
  (a : bare) (n : intindex)
  (FinIndInt n, int -> Writer a);
};

data MatrixView : bare -> bare
{
  matrixView
  (a : bare) (m : intindex, n : intindex)
  (FinIndInt m, FinIndInt n, int -> int -> Writer a);
};

data PyonTuple2 : bare -> bare -> bare
{
  pyonTuple2
  (a : bare, b : bare) () (a, b);
};

data PyonTuple3 : bare -> bare -> bare -> bare
{
  pyonTuple3
  (a : bare, b : bare, c : bare) () (a, b, c);
};

data PyonTuple4 : bare -> bare -> bare -> bare -> bare
{
  pyonTuple4
  (a : bare, b : bare, c : bare, d : bare) () (a, b, c, d);
};

-- Dictionaries

-- This data declaration is not precisely correct:
-- Size and alignment are not int, but rather unsigned int.
-- The finalize function has a slightly different type.
data Repr : bare -> box
  attribute(abstract)
{
  repr (a : bare) ()
  (int, int,			-- Size and alignment
   a -> Writer a,		-- Copy
   Writer a -> BoxedType a,	-- Convert to boxed
   BoxedType a -> Writer a,     -- Convert to bare
   a -> EffTok,			-- Finalize
   bool);
};

data EqDict : bare -> box
{
  eqDict
  (a : bare) ()
  (a -> a -> bool, a -> a -> bool);
};

data OrdDict : bare -> box
{
  ordDict
  (a : bare) ()
  (EqDict a, a -> a -> bool, a -> a -> bool, a -> a -> bool, a -> a -> bool);
};

data AdditiveDict : bare -> box
{
  additiveDict
  (a : bare) ()
  (a -> a -> Writer a,
   a -> a -> Writer a,
   a -> Writer a,
   a);
};

data MultiplicativeDict : bare -> box
{
  multiplicativeDict
  (a : bare) ()
  (AdditiveDict a,
   a -> a -> Writer a,
   int -> Writer a,
   a);
};

data RemainderDict : bare -> box
{
  remainderDict
  (a : bare) ()
  (MultiplicativeDict a,
   a -> a -> int,
   a -> a -> Writer a);
};

data FractionalDict : bare -> box
{
  fractionalDict
  (a : bare) ()
  (MultiplicativeDict a, a -> a -> Writer a);
};

data FloatingDict : bare -> box
{
  floatingDict
  (a : bare) ()
  (float -> Writer a,
   a -> a -> Writer a,
   a -> Writer a,
   a -> Writer a,
   a -> Writer a,
   a -> Writer a,
   a -> Writer a,
   a -> Writer a,
   a);
};

data VectorDict : bare -> box
{
  vectorDict
  (a : bare) ()
  (AdditiveDict a,
   a -> float -> Writer a,
   a -> float,
   a -> a -> float);
};

data TraversableDict : (bare -> bare) -> box
{
  traversableDict (t : bare -> bare) ()
  ((a : bare) -> Repr a -> t a -> Stream (shape t) a,
   (a : bare) -> Repr a -> Stream (shape t) a -> Writer (t a));
};

-- How to perform generalized stream operations that depend on shape.
-- The operations are flatten-to-list, map, and zipWith{2..4}.
data ShapeDict : bare -> box
{
  shapeDict (sh : bare) ()
  ((a : bare) -> Stream sh a -> Stream list_shape a,

   (a b : bare) ->
   Repr a -> Repr b ->
   (a -> Writer b) -> Stream sh a -> Stream sh b,

   (a b c : bare) ->
   Repr a -> Repr b -> Repr c ->
   (a -> b -> Writer c) -> Stream sh a -> Stream sh b -> Stream sh c,

   (a b c d : bare) ->
   Repr a -> Repr b -> Repr c -> Repr d ->
   (a -> b -> c -> Writer d) ->
   Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d,

   (a b c d e : bare) ->
   Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
   (a -> b -> c -> d -> Writer e) ->
   Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e
   );
};

data ListShapeEliminator : bare -> box
{
  listShapeEliminator (a : bare) ()
    ((N : intindex) -> FinIndInt N -> Writer a);
};

-- Class methods for one-dimensional, array-like container types
-- that can be indexed into.
-- Methods should not perform bounds checking.
data IndexableDict : (bare -> bare) -> box
{
  indexableDict
  (t : bare -> bare) ()
  ((a : bare) -> Repr a -> t a -> int -> Writer a,
   (a : bare) -> Repr a -> t a -> int -> int -> int -> Writer (ListView a),
   (a b : bare) -> t a -> ListShapeEliminator b -> Writer b);
};

data MatrixShapeEliminator : bare -> box
{
  matrixShapeEliminator (a : bare) ()
    ((M N : intindex) -> FinIndInt M -> FinIndInt N -> Writer a);
};

-- Class methods for two-dimensional, array-like container types
-- that can be indexed into.
-- Methods should not perform bounds checking.
data Indexable2Dict : (bare -> bare) -> box
{
  indexable2Dict
  (t : bare -> bare) ()
  ((a : bare) -> Repr a -> t a -> int -> int -> Writer a,
   (a : bare) -> Repr a -> t a -> int -> int -> int -> int -> int -> int ->
     Writer (MatrixView a),
   (a b : bare) -> t a -> MatrixShapeEliminator b -> Writer b);
};


-------------------------------------------------------------------------------
-- Shapes

-- Get the stream shape corresponding to a container
type shape : (bare -> bare) -> bare;

-- The shape of a list stream
data list_shape : bare {};

-- The shape of a matrix stream
data matrix_shape : bare {};

-- The shape of a singleton stream
data unit_shape : bare {};

-- The shape of an array stream
data array_shape : intindex -> bare -> bare {};

-------------------------------------------------------------------------------
-- Representation dictionaries

copy : (a : bare) -> Repr a -> a -> Writer a;
convertToBoxed : (a : bare) -> Repr a -> Writer a -> BoxedType a;
convertToBare : (a : bare) -> Repr a -> BoxedType a -> Writer a;

repr_int : Repr (Stored int);
repr_float : Repr (Stored float);
repr_bool : Repr (Stored bool);

repr_list : (a : bare) -> Repr a -> Repr (list a);
repr_matrix : (a : bare) -> Repr a -> Repr (matrix a);
repr_ListView : (a : bare) -> Repr (ListView a);
repr_Complex : (a : bare) -> Repr a -> Repr (Complex a);

repr_PyonTuple2 :
    (a b : bare) -> Repr a -> Repr b -> Repr (PyonTuple2 a b);

repr_PyonTuple3 :
    (a b c : bare)
 -> Repr a -> Repr b -> Repr c
 -> Repr (PyonTuple3 a b c);

repr_PyonTuple4 :
    (a b c d : bare)
 -> Repr a -> Repr b -> Repr c -> Repr d
 -> Repr (PyonTuple4 a b c d);

-- Representation of any boxed object
repr_Box : (a : box) -> Repr (BareType a);

repr_Referenced : (a : bare) -> Repr a -> Repr (Referenced a);
repr_Stream : (sh : bare) -> (a : bare) -> Repr (BareType (Stream sh a));

-- Representation of a referenced object that contains nothing and will
-- never be accessed.  At runtime, the reference will be an arbitrary pointer,
-- possibly NULL.
repr_EmptyReference : (a : bare) -> Repr a;

repr_array : (n : intindex) -> (e : bare)
          -> FinIndInt n -> Repr e -> Repr (array n e);

repr_EffTok : Repr (Stored EffTok);

-------------------------------------------------------------------------------
-- Stream and Traversable dictionaries

TraversableDict_Stream_build :
    (t : bare -> bare) -> (a : bare)
 -> Repr a -> Stream (shape t) a -> Stream (shape t) a;

TraversableDict_Stream_traverse :
    (t : bare -> bare) -> (a : bare)
 -> Repr a -> Stream (shape t) a -> Stream (shape t) a;

TraversableDict_list_build :
  (a : bare) -> Repr a -> Stream list_shape a -> Writer (list a);

TraversableDict_list_traverse :
  (a : bare) -> Repr a -> list a -> Stream list_shape a;

TraversableDict_matrix_build :
  (a : bare) -> Repr a -> Stream matrix_shape a -> Writer (matrix a);

TraversableDict_matrix_traverse :
  (a : bare) -> Repr a -> matrix a -> Stream matrix_shape a;

TraversableDict_ListView_build :
  (a : bare) -> Repr a -> Stream list_shape a -> Writer (ListView a);

TraversableDict_ListView_traverse :
  (a : bare) -> Repr a -> ListView a -> Stream list_shape a;

TraversableDict_MatrixView_build :
  (a : bare) -> Repr a -> Stream matrix_shape a -> Writer (MatrixView a);

TraversableDict_MatrixView_traverse :
  (a : bare) -> Repr a -> MatrixView a -> Stream matrix_shape a;

ShapeDict_list_flatten :
  (a : bare) -> Stream list_shape a -> Stream list_shape a;

ShapeDict_list_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Writer b) ->
  Stream list_shape a -> Stream list_shape b;

ShapeDict_list_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Writer c) ->
  Stream list_shape a -> Stream list_shape b -> Stream list_shape c;

ShapeDict_list_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Writer d) ->
  Stream list_shape a -> Stream list_shape b -> Stream list_shape c -> Stream list_shape d;

ShapeDict_list_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Writer e) ->
  Stream list_shape a -> Stream list_shape b -> Stream list_shape c -> Stream list_shape d -> Stream list_shape e;

ShapeDict_matrix_flatten :
  (a : bare) -> Stream matrix_shape a -> Stream list_shape a;

ShapeDict_matrix_map :
  (a b : bare) ->
  Repr a -> Repr b ->
  (a -> Writer b) ->
  Stream matrix_shape a -> Stream matrix_shape b;

ShapeDict_matrix_zipWith :
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Writer c) ->
  Stream matrix_shape a -> Stream matrix_shape b -> Stream matrix_shape c;

ShapeDict_matrix_zipWith3 :
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Writer d) ->
  Stream matrix_shape a -> Stream matrix_shape b -> Stream matrix_shape c -> Stream matrix_shape d;

ShapeDict_matrix_zipWith4 :
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Writer e) ->
  Stream matrix_shape a -> Stream matrix_shape b -> Stream matrix_shape c -> Stream matrix_shape d -> Stream matrix_shape e;

ShapeDict_Stream_flatten :
  (sh : bare) -> ShapeDict sh ->
  (a : bare) ->
  Stream sh a -> Stream list_shape a;

ShapeDict_Stream_map :
  (sh : bare) -> ShapeDict sh ->
  (a b : bare) ->
  Repr a -> Repr b -> (a -> Writer b) -> Stream sh a -> Stream sh b;

ShapeDict_Stream_zipWith :
  (sh : bare) -> ShapeDict sh ->
  (a b c : bare) ->
  Repr a -> Repr b -> Repr c ->
  (a -> b -> Writer c) ->
  Stream sh a -> Stream sh b -> Stream sh c;

ShapeDict_Stream_zipWith3 :
  (sh : bare) -> ShapeDict sh ->
  (a b c d : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d ->
  (a -> b -> c -> Writer d) ->
  Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d;

ShapeDict_Stream_zipWith4 :
  (sh : bare) -> ShapeDict sh ->
  (a b c d e : bare) ->
  Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
  (a -> b -> c -> d -> Writer e) ->
  Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e;

IndexableDict_list_at_point :
  (a : bare) -> Repr a -> list a -> int -> Writer a;

IndexableDict_list_at_slice :
  (a : bare) -> Repr a -> list a -> int -> int -> int -> Writer (ListView a);

IndexableDict_list_with_shape :
  (a b : bare) -> list a -> ListShapeEliminator b -> Writer b;

IndexableDict_ListView_at_point :
  (a : bare) -> Repr a -> ListView a -> int -> Writer a;

IndexableDict_ListView_at_slice :
  (a : bare) -> Repr a -> ListView a -> int -> int -> int -> Writer (ListView a);

IndexableDict_ListView_with_shape :
  (a b : bare) -> ListView a -> ListShapeEliminator b -> Writer b;

Indexable2Dict_matrix_at_point2 :
  (a : bare) -> Repr a -> matrix a -> int -> int -> Writer a;

Indexable2Dict_matrix_at_slice2 :
  (a : bare) -> Repr a -> matrix a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a);

Indexable2Dict_matrix_with_shape2 :
  (a b : bare) -> matrix a -> MatrixShapeEliminator b -> Writer b;

Indexable2Dict_MatrixView_at_point2 :
  (a : bare) -> Repr a -> MatrixView a -> int -> int -> Writer a;

Indexable2Dict_MatrixView_at_slice2 :
  (a : bare) -> Repr a -> MatrixView a -> int -> int -> int -> int -> int -> int -> Writer (MatrixView a);

Indexable2Dict_MatrixView_with_shape2 :
  (a b : bare) -> MatrixView a -> MatrixShapeEliminator b -> Writer b;

-------------------------------------------------------------------------------
-- Comparison dictionaries

EqDict_int_eq : int -> int -> bool;
EqDict_int_ne : int -> int -> bool;

EqDict_float_eq : float -> float -> bool;
EqDict_float_ne : float -> float -> bool;

OrdDict_int_lt : int -> int -> bool;
OrdDict_int_le : int -> int -> bool;
OrdDict_int_gt : int -> int -> bool;
OrdDict_int_ge : int -> int -> bool;

OrdDict_float_lt : float -> float -> bool;
OrdDict_float_le : float -> float -> bool;
OrdDict_float_gt : float -> float -> bool;
OrdDict_float_ge : float -> float -> bool;

-------------------------------------------------------------------------------
-- Numeric dictionaries

AdditiveDict_int_add : int -> int -> int;
AdditiveDict_int_sub : int -> int -> int;
AdditiveDict_int_negate : int -> int;
AdditiveDict_int_zero : int;

AdditiveDict_float_add : float -> float -> float;
AdditiveDict_float_sub : float -> float -> float;
AdditiveDict_float_negate : float -> float;
AdditiveDict_float_zero : float;

AdditiveDict_Complex_add :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Complex a
 -> Writer (Complex a);
AdditiveDict_Complex_sub :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Complex a
 -> Writer (Complex a);
AdditiveDict_Complex_negate :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Writer (Complex a);
AdditiveDict_Complex_zero :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Writer (Complex a);


MultiplicativeDict_int_mul : int -> int -> int;
MultiplicativeDict_int_fromInt : int -> int;

MultiplicativeDict_float_mul : float -> float -> float;
MultiplicativeDict_float_fromInt : int -> float;

MultiplicativeDict_Complex_mul :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> Complex a
 -> Complex a
 -> Writer (Complex a);
MultiplicativeDict_Complex_fromInt :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> int
 -> Writer (Complex a);
MultiplicativeDict_Complex_one :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> Writer (Complex a);


RemainderDict_int_floordiv : int -> int -> int;
RemainderDict_int_mod : int -> int -> int;

RemainderDict_float_floordiv : float -> float -> int;
RemainderDict_float_mod : float -> float -> float;


FractionalDict_float_div : float -> float -> float;

FractionalDict_Complex_div :
    (a : bare)
 -> Repr a
 -> FractionalDict a
 -> Complex a
 -> Complex a
 -> Writer (Complex a);


FloatingDict_float_fromfloat : float -> float;
FloatingDict_float_power : float -> float -> float;
FloatingDict_float_exp : float -> float;
FloatingDict_float_log : float -> float;
FloatingDict_float_sqrt : float -> float;
FloatingDict_float_sin : float -> float;
FloatingDict_float_cos : float -> float;
FloatingDict_float_tan : float -> float;
FloatingDict_float_pi : float;

FloatingDict_Complex_fromfloat :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> float
 -> Writer (Complex a);
FloatingDict_Complex_power :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_exp :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_log :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_sqrt :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_sin :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_cos :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_tan :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Writer (Complex a);
FloatingDict_Complex_pi :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Writer (Complex a);


VectorDict_float_scale : float -> float -> float;
VectorDict_float_magnitude : float -> float;
VectorDict_float_dot : float -> float -> float;

VectorDict_Complex_scale :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> float
 -> Writer (Complex a);

VectorDict_Complex_magnitude :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> float;

VectorDict_Complex_dot :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> Complex a
 -> float;

-------------------------------------------------------------------------------
-- other arithmetic

or : bool -> bool -> bool;
and : bool -> bool -> bool;

-------------------------------------------------------------------------------
-- integer index arithmetic

-- Promote an integer to a type index
defineIntIndex : int -> SomeIndInt;

type pos_infty : intindex;
type plus_i : intindex -> intindex -> intindex;
type minus_i : intindex -> intindex -> intindex;
type min_i : intindex -> intindex -> intindex;

zero_ii : IndInt 0;
one_ii : IndInt 1;
plus_ii : (m n : intindex)
       -> IndInt m
       -> IndInt n
       -> IndInt (plus_i m n);

minus_ii : (m n : intindex)
        -> IndInt m
        -> IndInt n
        -> IndInt (minus_i m n);

min_ii : (m n : intindex)
      -> IndInt m
      -> IndInt n
      -> IndInt (min_i m n);

-------------------------------------------------------------------------------
-- propositions

-- Proof objects
data Pf : prop -> val
  attribute(abstract)
{
  pf (p : prop) () ();
};

type eqZ : intindex -> intindex -> prop;
type neZ : intindex -> intindex -> prop;
type trueP : prop;

eqZ_refl : (n : intindex) -> Pf (eqZ n n);

-- Construct an arbitrary proof value.  This function is only called to
-- construct proofs that are never used.  Since the value is not used, it is
-- safe to construct such a value.
deadProof : (p : prop) -> Pf p;

-------------------------------------------------------------------------------
-- Other functions

-- A dummy boxed object that is used as a placeholder for a dead value.
deadBox : (a : box) -> a;

-- A dummy referenced object that is used as a placeholder for a dead value.
deadRef : (a : bare) -> Writer a;

array_traverse : (N : intindex) -> (a : bare) -> Repr a -> FinIndInt N
	      -> array N a -> Stream (array_shape N unit_shape) a;

array_build : (N : intindex) -> (a : bare) -> Repr a -> FinIndInt N
	   -> Stream (array_shape N unit_shape) a -> Writer (array N a);

oper_DO : (a : bare) -> Repr a -> Writer a -> Stream list_shape a;

-- Explicit-shape version of oper_DO
return : (a : bare) -> Repr a -> Writer a -> Stream unit_shape a;

oper_GUARD : (a : bare)
          -> Repr a -> bool
	  -> Stream list_shape a
	  -> Stream list_shape a;

-- An empty stream
oper_EMPTY : (a : bare) -> Repr a -> Stream list_shape a;

oper_CAT_MAP :
    (a b : bare) -> Repr a -> Repr b
 -> Stream list_shape a
 -> (a -> Stream list_shape b)
 -> Stream list_shape b;

-- Explicit-shape version of oper_CAT_MAP
bind :
    (n : intindex)
 -> (sh a b : bare)
 -> Repr a
 -> Repr b
 -> Stream (array_shape n unit_shape) a
 -> (a -> Stream sh b)
 -> Stream (array_shape n sh) b;

-- Strip-mine a stream with array shape.  This is, roughly, an
-- eliminator for 'bind'.  Note that the last 2 arguments and return type
-- are similar to those of 'bind', but in a different order.
chunk :
    (M N : intindex)
 -> (a b : bare)
 -> Repr a
 -> Repr b
 -> IndInt N
 -> Stream (array_shape M (array_shape N unit_shape)) a
 -> (Stream (array_shape N unit_shape) a -> Writer b)
 -> Stream (array_shape M unit_shape) b;

chunk_id : 
    (M N : intindex)
 -> (a : bare)
 -> Repr a
 -> IndInt N
 -> Stream (array_shape M (array_shape N unit_shape)) a
 -> Stream (array_shape M unit_shape) (StoredBox (Stream (array_shape N unit_shape) a));

-- Sequential fold over a stream
fun_fold_Stream : (a acc : bare)
               -> Repr a
               -> Repr acc
               -> (acc -> a -> Writer acc)
               -> acc
               -> Stream list_shape a
               -> Writer acc;

-- Reinterpret a stream as having list shape
fun_asList_Stream : (sh a : bare)
                 -> ShapeDict sh
                 -> Stream sh a
                 -> Stream list_shape a;

-- An identity function needed in the frontend
fun_from_MatrixView_Stream : (a : bare)
			  -> Stream matrix_shape a
			  -> Stream matrix_shape a;

-- Reinterpret an array stream as having matrix shape
fun_asMatrix_Stream : (M N : intindex)
		   -> (a : bare)
		   -> IndInt M
		   -> IndInt N
		   -> Stream (array_shape M (array_shape N unit_shape)) a
		   -> Stream matrix_shape a;

-- Reinterpret a matrix stream as having array shape
fun_asArray2_Stream : (a b : bare)
		   -> Stream matrix_shape a
		   -> ((M N : intindex)
		       -> IndInt M -> IndInt N
		       -> Stream (array_shape M (array_shape N unit_shape))
		       -> Writer b)
		   -> Writer b;

fun_map_Stream : (sh a b : bare)
	      -> ShapeDict sh
       	      -> Repr a
       	      -> Repr b
       	      -> (a -> Writer b)
       	      -> Stream sh a
       	      -> Stream sh b;

fun_map : (t : bare -> bare)
       -> (a b : bare)
       -> TraversableDict t
       -> ShapeDict (shape t)
       -> Repr a
       -> Repr b
       -> (a -> Writer b)
       -> t a
       -> Writer (t b);

fun_reduce_Stream : (sh a : bare)
		 -> ShapeDict sh
          	 -> Repr a
          	 -> (a -> a -> Writer a)
	  	 -> a
          	 -> Stream sh a
          	 -> Writer a;

fun_reduce : (t : bare -> bare)
          -> (a : bare)
          -> TraversableDict t
	  -> ShapeDict (shape t)
          -> Repr a
          -> (a -> a -> Writer a)
	  -> a
          -> t a
          -> Writer a;

fun_reduce1_Stream : (sh a : bare)
		 -> ShapeDict sh
          	  -> Repr a
          	  -> (a -> a -> Writer a)
          	  -> Stream sh a
          	  -> Writer a;

fun_reduce1 : (t : bare -> bare)
           -> (a : bare)
           -> TraversableDict t
	   -> ShapeDict (shape t)
           -> Repr a
           -> (a -> a -> Writer a)
           -> t a
           -> Writer a;

fun_zip_Stream : (sh a b : bare)
	      -> ShapeDict sh
       	      -> Repr a
       	      -> Repr b
       	      -> Stream sh a
       	      -> Stream sh b
       	      -> Stream sh (PyonTuple2 a b);

fun_zip3_Stream : (sh a b c : bare)
	       -> ShapeDict sh
               -> Repr a
               -> Repr b
               -> Repr c
               -> Stream sh a
               -> Stream sh b
               -> Stream sh c
               -> Stream sh (PyonTuple3 a b c);

fun_zip4_Stream : (sh a b c d : bare)
	       -> ShapeDict sh
               -> Repr a
               -> Repr b
               -> Repr c
               -> Repr d
               -> Stream sh a
               -> Stream sh b
               -> Stream sh c
               -> Stream sh d
               -> Stream sh (PyonTuple4 a b c d);

LinStream_zipWith_array : (a b c : bare)
		       -> (Na Nb : intindex)
                       -> Repr a
    		       -> Repr b
    		       -> Repr c
		       -> (a -> b -> Writer c)
    	               -> LinStream (array_shape Na unit_shape) a
    	               -> LinStream (array_shape Nb unit_shape) b
    	               -> LinStream (array_shape (min_i Na Nb) unit_shape) c;

LinStream_zipWith3_array : (a b c d : bare)
		       -> (Na Nb Nc : intindex)
                       -> Repr a
    		       -> Repr b
    		       -> Repr c
		       -> Repr d
		       -> (a -> b -> c -> Writer d)
    	               -> LinStream (array_shape Na unit_shape) a
    	               -> LinStream (array_shape Nb unit_shape) b
    	               -> LinStream (array_shape Nc unit_shape) c
    	               -> LinStream (array_shape (min_i (min_i Na Nb) Nc) unit_shape) d;

LinStream_zipWith4_array : (a b c d e : bare)
		       -> (Na Nb Nc Nd : intindex)
                       -> Repr a
    		       -> Repr b
    		       -> Repr c
    		       -> Repr d
		       -> Repr e
		       -> (a -> b -> c -> d -> Writer e)
    	               -> LinStream (array_shape Na unit_shape) a
    	               -> LinStream (array_shape Nb unit_shape) b
    	               -> LinStream (array_shape Nc unit_shape) c
    	               -> LinStream (array_shape Nd unit_shape) d
    	               -> LinStream (array_shape (min_i (min_i (min_i Na Nb) Nc) Nd) unit_shape) e;

fun_zip : (t : bare -> bare)
       -> (a b : bare)
       -> TraversableDict t
       -> ShapeDict (shape t)
       -> Repr a
       -> Repr b
       -> t a
       -> t b
       -> Writer (t (PyonTuple2 a b));

fun_zip3 : (t : bare -> bare)
        -> (a b c : bare)
        -> TraversableDict t
        -> ShapeDict (shape t)
        -> Repr a
        -> Repr b
        -> Repr c
        -> t a
        -> t b
        -> t c
        -> Writer (t (PyonTuple3 a b c));

fun_zip4 : (t : bare -> bare)
        -> (a b c d : bare)
        -> TraversableDict t
        -> ShapeDict (shape t)
        -> Repr a
        -> Repr b
        -> Repr c
        -> Repr d
        -> t a
        -> t b
        -> t c
        -> t d
        -> Writer (t (PyonTuple4 a b c d));

count : Stream list_shape (Stored int);

range : int -> Stream list_shape (Stored int);

len : (t : bare -> bare) -> (a : bare) -> IndexableDict t -> t a -> int;

safeIndex : (t : bare -> bare) -> (a : bare)
         -> IndexableDict t -> Repr a -> t a -> int -> Writer a;

safeSlice : (t : bare -> bare) -> (a : bare)
         -> IndexableDict t -> Repr a
	 -> t a -> int -> int -> int
	 -> Writer (ListView a);

width : (t : bare -> bare) -> (a : bare)
     -> Indexable2Dict t -> t a -> int;
height : (t : bare -> bare) -> (a : bare)
      -> Indexable2Dict t -> t a -> int;

safeIndex2 : (t : bare -> bare) -> (a : bare)
          -> Indexable2Dict t -> Repr a -> t a -> int -> int -> Writer a;

safeSlice2 : (t : bare -> bare) -> (a : bare)
         -> Indexable2Dict t -> Repr a
	 -> t a -> int -> int -> int -> int -> int -> int
	 -> Writer (MatrixView a);

rows : (t : bare -> bare) -> (a : bare)
    -> Indexable2Dict t -> Repr a
    -> t a -> ListView (ListView a);

cols : (t : bare -> bare) -> (a : bare)
    -> Indexable2Dict t -> Repr a
    -> t a -> ListView (ListView a);

transpose : (t : bare -> bare) -> (a : bare)
         -> Indexable2Dict t -> Repr a -> t a -> MatrixView a;

-- A type-indexed version of 'range'
rangeIndexed : (n : intindex)
            -> IndInt n
            -> Stream (array_shape n unit_shape) (Stored int);

histogram : (t : bare -> bare)
         -> int
         -> Stream (shape t) (Stored int)
         -> Writer (list (Stored int));

histogramArray : (sh : bare)
              -> (n : intindex)
              -> FinIndInt n
              -> Stream sh (Stored int)
              -> Writer (array n (Stored int));

-- Low-level function for imperatively initializing an histogram
createHistogram :
    (n : intindex)
 -> FinIndInt n
 -> ((int -> EffTok) -> EffTok -> EffTok)
 -> Writer (array n (Stored int));

generate : (n : intindex)
        -> (a : bare)
        -> IndInt n
        -> Repr a
        -> (int -> Writer a)
        -> Stream (array_shape n unit_shape) a;

subscript : (n : intindex)
         -> (a : bare)
         -> Repr a
         -> array n a
         -> int
         -> a;

-- Like subscript, but modifies an output pointer
subscript_out : (n : intindex)
             -> (a : bare)
             -> Repr a
             -> OutPtr (array n a)
             -> int
             -> OutPtr a;

-------------------------------------------------------------------------------
-- Linear stream methods

LinStream_flatten : (sh a : bare) -> LinStream sh a -> LinStream list_shape a;

LinStream_map : (sh a b : bare)
	     -> Repr a
	     -> Repr b
	     -> (a -> Writer b)
	     -> LinStream sh a
	     -> LinStream sh b;

LinStream_zipWith : (sh a b c : bare)
		 -> Repr a -> Repr b -> Repr c
		 -> (a -> b -> Writer c)
		 -> LinStream sh a -> LinStream sh b
		 -> LinStream sh c;

LinStream_zipWith3 : (sh a b c d : bare)
		 -> Repr a -> Repr b -> Repr c -> Repr d
		 -> (a -> b -> c -> Writer d)
		 -> LinStream sh a -> LinStream sh b -> LinStream sh c
		 -> LinStream sh d;

LinStream_zipWith4 : (sh a b c d e : bare)
		 -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e
		 -> (a -> b -> c -> d -> Writer e)
		 -> LinStream sh a -> LinStream sh b -> LinStream sh c -> LinStream sh d
		 -> LinStream sh e;

-------------------------------------------------------------------------------
-- Other rewritable functions

LinStream_reduce : (sh a : bare)
		-> Repr a
		-> (a -> a -> Writer a)
		-> a
		-> LinStream sh a
		-> Writer a;

LinStream_reduce1 : (sh a : bare)
		 -> Repr a
		 -> (a -> a -> Writer a)
		 -> LinStream sh a
		 -> Writer a;

LinStream_fold : (sh a acc : bare)
	      -> Repr a
	      -> Repr acc
	      -> (acc -> a -> Writer acc)
	      -> acc
	      -> LinStream sh a
	      -> Writer acc;

-------------------------------------------------------------------------------
-- Loops

-- Parallelizable loop
doall : (n : intindex)
     -> (a b : bare)
     -> FinIndInt n
     -> (int -> IEffect b)
     -> IEffect a;

-- Sequential loop
for : (n : intindex)
   -> (acc : bare)
   -> Repr acc
   -> IndInt n
   -> acc
   -> (int -> acc -> Writer acc)
   -> Writer acc;

-- Blocked parallel reduction
blocked_reduce :
    (acc : bare)
 -> (n : intindex)
 -> Repr acc
 -> FinIndInt n		-- Size of range
 -> int	       			-- First member of range
 -> (acc -> acc -> Writer acc) -- Reducer
 -> acc			-- Initial value
 -> ((n : intindex) -> FinIndInt n -> int -> Writer acc)
    -- ^ Generate value given range
 -> Writer acc;

-- Blocked parallel reduction with no neutral element
blocked_reduce1 :
    (acc : bare)
 -> (n : intindex)
 -> Repr acc
 -> FinIndInt n		-- Size of range
 -> int			-- First member of range
 -> (acc -> acc -> Writer acc) -- Reducer
 -> ((n : intindex) -> FinIndInt n -> int -> Writer acc)
    -- ^ Generate value given range
 -> Writer acc;

-- Blocked parallel loop
blocked_doall :
    (n : intindex)
 -> (a b : bare)
 -> FinIndInt n
 -> int
 -> ((n : intindex) -> FinIndInt n -> int -> IEffect b)
 -> IEffect a;
