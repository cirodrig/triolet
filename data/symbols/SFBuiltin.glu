{- System F builtin constructors.
--
-- At this point in compilation, side effects are ignored.  These constructors
-- therefore have no side effects.
-}

{-
-- Integer arithmetic

operator left 45 * = timesZ;
operator left 40 + = plusZ;
operator left 40 - = subtractZ;

let subtractZ (x : Int) (y : Int) -> Int = x + -1 * y;

-- Integer comparison propositions

operator 20 == = equalZ;
operator 20 /= = notEqualZ;
operator 20 >= = greaterOrEqualZ;
operator 20 >  = greaterThanZ;
operator 20 <= = lessOrEqualZ;
operator 20 <  = lessThanZ;

let equalZ          (x : Int) (y : Int) -> Prop = isZeroZ (x - y);
let notEqualZ       (x : Int) (y : Int) -> Prop = x > y || x < y;
let greaterOrEqualZ (x : Int) (y : Int) -> Prop = isNnegZ (x - y);
let greaterThanZ    (x : Int) (y : Int) -> Prop = isNnegZ (x - y + -1);
let lessOrEqualZ    (x : Int) (y : Int) -> Prop = isNnegZ (y - x);
let lessThanZ       (x : Int) (y : Int) -> Prop = isNnegZ (y - x + -1);

-- Logical propositions

operator right 10 || = or;
operator right 15 && = and;

-}



-- Pyon types
data NoneType : Pure where None : NoneType;
constant Any : Pure;
data int : Pure;
data float : Pure;
data complex : Pure -> Pure where
  makeComplex : float -> float -> complex float;
data bool : Pure where True : bool | False : bool;

-- While 'list' is used in System F, 'makeList' is only used after generating
-- Core.  The type of 'makeList' can't be represented in System F.
data list : Pure -> Pure where
  makeList : (a : Pure) -> int -> a -> list a;
constant Stream : Pure -> Pure;

data PyonTuple0 : Pure where
  pyonTuple0 : PyonTuple0;
data PyonTuple1 : Pure -> Pure where
  pyonTuple1 : (a : Pure) -> a -> PyonTuple1 a;
data PyonTuple2 : Pure -> Pure -> Pure where
  pyonTuple2 : (a : Pure) -> (b : Pure) -> a -> b -> PyonTuple2 a b;
data PyonTuple3 : Pure -> Pure -> Pure -> Pure where
  pyonTuple3 : (a : Pure) -> (b : Pure) -> (c : Pure)
            -> a -> b -> c -> PyonTuple3 a b c;
data PyonTuple4 : Pure -> Pure -> Pure -> Pure -> Pure where
  pyonTuple4 : (a : Pure) -> (b : Pure) -> (c : Pure) -> (d : Pure)
            -> a -> b -> c -> d -> PyonTuple4 a b c d;
data PyonTuple5 : Pure -> Pure -> Pure -> Pure -> Pure -> Pure where
  pyonTuple5 : (a : Pure) -> (b : Pure) -> (c : Pure) -> (d : Pure)
            -> (e : Pure)
            -> a -> b -> c -> d -> e -> PyonTuple4 a b c d e;

let comparison (a : Pure) -> Pure = a -> a -> bool;
let binary (a : Pure) -> Pure = a -> a -> a;
let unary (a : Pure) -> Pure = a -> a;
let binary_any -> Pure = (a : Pure) -> PassConv a -> binary a;

-- Parameter-passing conventions.
data PassConv : Pure -> Pure;

constant passConv_int : PassConv int;
constant passConv_float : PassConv float;
constant passConv_bool : PassConv bool;
constant passConv_NoneType : PassConv NoneType;
constant passConv_complex : (t : Pure) -> PassConv t -> PassConv (complex t);
constant passConv_iter : (t : Pure) -> PassConv t -> PassConv (Stream t);
constant passConv_list : (t : Pure) -> PassConv t -> PassConv (list t);
constant passConv_Any : PassConv Any;

-- The parameter-passing convention for any owned reference
constant passConv_owned : (t : Pure) -> PassConv t;

constant passConv_pyonTuple0 : PassConv PyonTuple0;
constant passConv_pyonTuple1 :
    (t : Pure) -> PassConv t -> PassConv (PyonTuple1 t);
constant passConv_pyonTuple2 :
    (t : Pure) -> (u : Pure)
 -> PassConv t -> PassConv u
 -> PassConv (PyonTuple2 t u);
constant passConv_pyonTuple3 :
    (t : Pure) -> (u : Pure) -> (v : Pure)
 -> PassConv t -> PassConv u -> PassConv v
 -> PassConv (PyonTuple3 t u v);
constant passConv_pyonTuple4 :
    (t : Pure) -> (u : Pure) -> (v : Pure) -> (w : Pure)
 -> PassConv t -> PassConv u -> PassConv v -> PassConv w
 -> PassConv (PyonTuple4 t u v w);
constant passConv_pyonTuple5 :
    (t : Pure) -> (u : Pure) -> (v : Pure) -> (w : Pure) -> (x : Pure)
 -> PassConv t -> PassConv u -> PassConv v -> PassConv w -> PassConv x
 -> PassConv (PyonTuple5 t u v w x);

-- Dictionary types for Pyon classes.
data EqDict : Pure -> Pure where
  eqDict : (a : Pure) -> comparison a -> comparison a -> EqDict a;

data OrdDict : Pure -> Pure where
  ordDict : (a : Pure)
         -> EqDict a
         -> comparison a
         -> comparison a
         -> comparison a
         -> comparison a
         -> OrdDict a;

data TraversableDict : (Pure -> Pure) -> Pure where
  traversableDict : (t : Pure -> Pure)
                 -> ((a : Pure) -> PassConv a -> (t a -> Stream a))
                 -> ((a : Pure) -> PassConv a -> (Stream a -> t a))
                 -> TraversableDict t;

-- Opaque traversable dictionary objects.  We need these for effect inference
-- because effect inference can't handle the general case.
constant OpaqueTraversableDict_list : TraversableDict list;

data AdditiveDict : Pure -> Pure where
  additiveDict : (a : Pure) -> PassConv a -> binary a -> binary a -> unary a -> a
              -> AdditiveDict a;

data MultiplicativeDict : Pure -> Pure where
  multiplicativeDict : (a : Pure)
                   -> AdditiveDict a
                   -> (a -> a -> a)
                   -> (int -> a)
                   -> a
                   -> MultiplicativeDict a;

data VectorDict : Pure -> Pure where
  vectorDict : (a : Pure)
            -> AdditiveDict a
            -> (a -> float -> a)
            -> (a -> float)
            -> VectorDict a;

-- Class dictionary members for predefined instances.

constant Eq_EQ_int : comparison int;
constant Eq_NE_int : comparison int;
constant Ord_GT_int : comparison int;
constant Ord_GE_int : comparison int;
constant Ord_LT_int : comparison int;
constant Ord_LE_int : comparison int;

constant Eq_EQ_float : comparison float;
constant Eq_NE_float : comparison float;
constant Ord_GT_float : comparison float;
constant Ord_GE_float : comparison float;
constant Ord_LT_float : comparison float;
constant Ord_LE_float : comparison float;

constant Eq_EQ_Tuple2 : (a : Pure) -> (b : Pure)
                     -> EqDict a -> EqDict b
                     -> (comparison (PyonTuple2 a b));
constant Eq_NE_Tuple2 : (a : Pure) -> (b : Pure)
                     -> EqDict a -> EqDict b
                     -> (comparison (PyonTuple2 a b));
constant Ord_GT_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));
constant Ord_GE_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));
constant Ord_LT_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));
constant Ord_LE_Tuple2 : (a : Pure) -> (b : Pure)
                      -> OrdDict a -> OrdDict b
                      -> (comparison (PyonTuple2 a b));

let Traversable_TRAVERSE_Stream
    (a : Pure)
    (pc : PassConv a)
    (s : Stream a)
 -> Stream a
  = s;

let Traversable_BUILD_Stream
    (a : Pure)
    (pc : PassConv a)
    (s : Stream a)
 -> Stream a
  = s;

constant Traversable_TRAVERSE_list
  : (a : Pure)
 -> PassConv a
 -> list a
 -> Stream a;

constant Traversable_BUILD_list
  : (a : Pure)
 -> PassConv a
 -> Stream a
 -> list a;

constant Additive_ADD_int : binary int;
constant Additive_SUB_int : binary int;
constant Additive_NEGATE_int : unary int;
constant Additive_ZERO_int : int;

constant Additive_ADD_float : binary float;
constant Additive_SUB_float : binary float;
constant Additive_NEGATE_float : unary float;
constant Additive_ZERO_float : float;

constant additiveDict_complex
  : (a : Pure)
 -> AdditiveDict a
 -> AdditiveDict (complex a);

constant add_complex : (a : Pure)
                    -> AdditiveDict a
                    -> binary (complex a);
constant sub_complex : (a : Pure)
                    -> AdditiveDict a
                    -> binary (complex a);
constant negate_complex : (a : Pure)
                       -> AdditiveDict a
                       -> unary (complex a);
constant zero_complex : (a : Pure)
                     -> AdditiveDict a
                     -> complex a;

constant Multiplicative_MUL_int : binary int;
constant Multiplicative_FROMINT_int : int -> int;
constant Multiplicative_ONE_int : int;

constant Multiplicative_MUL_float : binary float;
constant Multiplicative_FROMINT_float : int -> float;
constant Multiplicative_ONE_float : float;

-- Builtin functions
constant oper_DIV : binary_any;
constant oper_MOD : binary int;
constant oper_POWER : binary_any;
constant oper_FLOORDIV : binary_any;
constant oper_BITWISEAND : binary int;
constant oper_BITWISEOR : binary int;
constant oper_BITWISEXOR : binary int;
constant oper_NEGATE : (a : Pure) -> PassConv a -> (a -> a);

constant oper_CAT_MAP : (a : Pure)
                     -> (b : Pure)
                     -> PassConv a
                     -> PassConv b
                     -> (Stream a -> (a -> Stream b) -> Stream b);

constant oper_GUARD : (a : Pure) -> bool -> Stream a -> Stream a;

constant oper_DO : (a : Pure) -> PassConv a -> (a -> Stream a);

constant fun_map : (t : Pure -> Pure) -> (a : Pure) -> (b : Pure)
                -> TraversableDict t
                -> PassConv (t a)
                -> PassConv (t b)
                -> ((a -> b) -> t a -> t b);

constant fun_map_Stream : (a : Pure) -> (b : Pure)
                -> PassConv (Stream a)
                -> PassConv (Stream b)
                -> ((a -> b) -> Stream a -> Stream b);

constant fun_reduce : (t : Pure -> Pure) -> (a : Pure)
                   -> TraversableDict t
                   -> PassConv a
                   -> PassConv (t a)
                   -> ((a -> a -> a) -> a -> t a -> a);

constant fun_reduce_Stream : (a : Pure)
                   -> PassConv a
                   -> PassConv (Stream a)
                   -> ((a -> a -> a) -> a -> Stream a -> a);

constant fun_reduce1 : (t : Pure -> Pure) -> (a : Pure)
                    -> TraversableDict t
                    -> PassConv a
                    -> PassConv (t a)
                    -> ((a -> a -> a) -> t a -> a);

constant fun_reduce1_Stream : (a : Pure)
                           -> PassConv a
			   -> PassConv (Stream a)
                           -> ((a -> a -> a) -> Stream a -> a);

constant fun_zip : (s : Pure -> Pure)
                -> (t : Pure -> Pure)
                -> (a : Pure)
                -> (b : Pure)
                -> TraversableDict s
                -> TraversableDict t
                -> (s a -> t b -> Stream (PyonTuple2 a b));

constant fun_zip_NS : (s : Pure -> Pure)
                -> (a : Pure)
                -> (b : Pure)
                -> TraversableDict s
                -> (s a -> Stream b -> Stream (PyonTuple2 a b));

constant fun_zip_SN : (t : Pure -> Pure)
                -> (a : Pure)
                -> (b : Pure)
                -> TraversableDict t
                -> (Stream a -> t b -> Stream (PyonTuple2 a b));

constant fun_zip_SS :
                   (a : Pure)
                -> (b : Pure)
                -> (Stream a -> Stream b -> Stream (PyonTuple2 a b));

constant fun_iota : NoneType -> Stream int;

constant fun_undefined : (a : Pure) -> a;

constant eqDict_Tuple2 : (a : Pure) -> (b : Pure) -> EqDict a -> EqDict b -> EqDict (PyonTuple2 a b);

constant ordDict_Tuple2 : (a : Pure) -> (b : Pure) -> OrdDict a -> OrdDict b -> OrdDict (PyonTuple2 a b);

{- Constructors inserted after effect inference.  These constructors deal
-- with data at a low level, where the representation becomes visible.
-}

-- Pointer-to-address type
constant Ptr : Addr -> Pure;

-- Owned reference type
constant Own : Pure -> Pure;

-- Undefined/defined state type
constant Def : Pure -> State;
constant Undef : Pure -> State;

-- Stream type after effect inference
constant LazyStream : Effect is(covar) -> Pure is(covar) -> Pure;

-- Effect monad type
constant Action : Effect is(covar) -> Pure is(covar) -> Pure;

-- Inserted during flattening.  The types are not correct.

-- Stream constructor
constant fun_return :
    (e : Effect is(covar))
 -> (a : Pure is(covar))
 -> PassConv a
 -> (NoneType -> a)
 -> LazyStream e a;

constant fun_copy : (a : Pure) -> PassConv a -> a -> a;

constant fun_store_int : int -> int;
constant fun_store_float : float -> float;
constant fun_store_complexFloat : complex float -> complex float;
constant fun_store_bool : bool -> bool;
constant fun_store_NoneType : NoneType -> NoneType;
constant fun_store_boxed : (a : Pure) -> a -> a;

constant fun_load_int : int -> int;
constant fun_load_float : float -> float;
constant fun_load_complexFloat : complex float -> complex float;
constant fun_load_bool : bool -> bool;
constant fun_load_NoneType : NoneType -> NoneType;
constant fun_load_boxed : (a : Pure) -> a -> a;

-- Inserted during core.  The types are not correct.

constant fun_subscript : (a : Pure) -> PassConv a -> a -> a;
constant fun_generate : (a : Pure) -> PassConv a -> int -> (int -> a) -> Stream a;
constant fun_generateList : (a : Pure) -> PassConv a -> int -> (int -> a) -> list a;
constant fun_vectorGenerateList : (a : Pure) -> PassConv a -> int -> (int -> a) -> list a;
