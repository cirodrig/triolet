
-- Data types

data val bool : val pure
{
  True : val bool,
  () () () : val bool;
  False : val bool,
  () () () : val bool;
};

data val int : val pure {};
data val float : val pure {};
data val NoneType : val pure
{
  None : val NoneType,
  () () () : val NoneType;
};

-- An indexed singleton integer type.
-- Invariant: The type index gives up the integer value.
data val IndexedInt : val (val intindex -> val pure)
{
  indexedInt : (val n : intindex) -> val int -> val (IndexedInt n),
  (val n : intindex) () (val int) : val (IndexedInt n);
};

-- An existential indexed singleton integer type.
-- We can convert int to this type.
data val SomeIndexedInt : val pure
{
  someIndexedInt : (val n : intindex) -> val int -> val SomeIndexedInt,
  () (val n : intindex) (val IndexedInt n) : val SomeIndexedInt;
};

-- A dummy token that we use to stand in for dependences due to
-- imperative computation that is inserted by the compiler.
--
-- We take advantage of the fact that EffTok is a unit value, and therefore
-- it is not accessed by load or store instructions when reading or writing it,
-- and therefore we can safely masquerade NULL pointers as EffTok references.
data val EffTok : val pure
{
  -- We never use the constructor 'effTok' in code, because it could be
  -- optimized away.  We don't want the optimizer to mess with this data type
  -- because it stands in for real dependences.
  -- Instead, use 'emptyEffTok' to produce an EffTok value.
  effTok : val EffTok, () () () : val EffTok;
};

emptyEffTok : write EffTok;

-- Translate to a side effect.
-- This function is translated specially when converting from Core to LowLevel.
toEffTok : (val a : pure) -> sideeffect a -> write EffTok;

-- Propagate a side effect.
propagateEffTok : read EffTok -> write EffTok;

-- Perform two side-effecting operations in sequence.
seqEffTok : write EffTok -> write EffTok -> write EffTok;

data ref Complex : val (val pure -> val pure)
{
  complex : (val a : pure) -> write a -> write a -> write Complex a,
  (val a : pure) () (read a, read a) : read Complex a;
};

data ref array : val (val intindex -> val pure -> val pure) {};

data box Repr : val (val pure -> val pure) {};

-- A stream is indexed by a shape and an element type.
-- Container types are punned as shapes.
data box Stream : val (val pure -> val pure -> val pure) {};

data ref list : val (val pure -> val pure)
{
  make_list : (val a : pure)
           -> (val n : intindex)
           -> val IndexedInt n
           -> write Referenced (array n a)
           -> write list a,
  (val a : pure) (val n : intindex)
  (val IndexedInt n,
   read Referenced (array n a)) : read list a;
};

-- This data structure has a special representation
data box Boxed : val (val pure -> val pure)
{
  boxed : (val a : pure) -> write a -> box Boxed a,
  (val a : pure) () (read a) : box Boxed a;
};

-- This data structure has a special representation
data ref Referenced : val (val pure -> val pure)
{
  referenced : (val a : pure) -> write a -> write Referenced a,
  (val a : pure) () (read a) : read Referenced a;
};

data ref PyonTuple2 : val (val pure -> val pure -> val pure)
{
  pyonTuple2 : (val a : pure) -> (val b : pure)
            -> write a -> write b -> write PyonTuple2 a b,
  (val a : pure, val b : pure) () (read a, read b) : read PyonTuple2 a b;
};

data ref PyonTuple3 : val (val pure -> val pure -> val pure -> val pure)
{
  pyonTuple3 : (val a : pure) -> (val b : pure) -> (val c : pure)
            -> write a -> write b -> write c -> write PyonTuple3 a b c,
  (val a : pure, val b : pure, val c : pure) ()
  (read a, read b, read c) : read PyonTuple3 a b c;
};

data ref PyonTuple4 :
  val (val pure -> val pure -> val pure -> val pure -> val pure)
{
  pyonTuple4 : (val a : pure)
            -> (val b : pure)
            -> (val c : pure)
            -> (val d : pure)
            -> write a -> write b -> write c -> write d
            -> write PyonTuple4 a b c d,
  (val a : pure, val b : pure, val c : pure, val d : pure) ()
  (read a, read b, read c, read d) : read PyonTuple4 a b c d;
};

data val UnboxedTuple2 : val (val pure -> val pure -> val pure)
{
  unboxedTuple2 : (val a : pure) -> (val b : pure) -> val a -> val b
               -> val UnboxedTuple2 a b,
  (val a : pure, val b : pure) () (val a, val b) : val UnboxedTuple2 a b;
};

data val UnboxedTuple3 : val (val pure -> val pure -> val pure -> val pure)
{
  unboxedTuple3 : (val a : pure) -> (val b : pure) -> (val c : pure)
               -> val a -> val b -> val c -> val UnboxedTuple3 a b c,
  (val a : pure, val b : pure, val c : pure) ()
  (val a, val b, val c) : val UnboxedTuple3 a b c;
};

data val UnboxedTuple4 :
  val (val pure -> val pure -> val pure -> val pure -> val pure)
{
  unboxedTuple4 : (val a : pure)
               -> (val b : pure)
               -> (val c : pure)
               -> (val d : pure)
               -> val a -> val b -> val c -> val d
            -> val UnboxedTuple4 a b c d,
  (val a : pure, val b : pure, val c : pure, val d : pure) ()
  (val a, val b, val c, val d) : val UnboxedTuple4 a b c d;
};

data val UnboxedTuple5 :
  val (val pure -> val pure -> val pure -> val pure -> val pure -> val pure)
{
  unboxedTuple5 : (val a : pure)
               -> (val b : pure)
               -> (val c : pure)
               -> (val d : pure)
               -> (val e : pure)
               -> val a -> val b -> val c -> val d -> val e
            -> val UnboxedTuple5 a b c d e,
  (val a : pure, val b : pure, val c : pure, val d : pure, val e : pure) ()
  (val a, val b, val c, val d, val e) : val UnboxedTuple5 a b c d e;
};

data val UnboxedTuple6 :
  val (val pure -> val pure -> val pure -> val pure -> val pure -> val pure -> val pure)
{
  unboxedTuple6 : (val a : pure)
               -> (val b : pure)
               -> (val c : pure)
               -> (val d : pure)
               -> (val e : pure)
               -> (val f : pure)
               -> val a -> val b -> val c -> val d -> val e -> val f
            -> val UnboxedTuple6 a b c d e f,
  (val a : pure, val b : pure, val c : pure, val d : pure, val e : pure, val f : pure) ()
  (val a, val b, val c, val d, val e, val f) : val UnboxedTuple6 a b c d e f;
};


data box EqDict : val (val pure -> val pure)
{
  eqDict : (val a : pure)
        -> box (read a -> read a -> val bool)
        -> box (read a -> read a -> val bool)
        -> box EqDict a,
  (val a : pure) ()
  (box (read a -> read a -> val bool),
   box (read a -> read a -> val bool)) : box EqDict a;
};

data box OrdDict : val (val pure -> val pure)
{
  ordDict : (val a : pure)
         -> box EqDict a
         -> box (read a -> read a -> val bool)
         -> box (read a -> read a -> val bool)
         -> box (read a -> read a -> val bool)
         -> box (read a -> read a -> val bool)
         -> box OrdDict a,
  (val a : pure) ()
  (box EqDict a,
   box (read a -> read a -> val bool),
   box (read a -> read a -> val bool),
   box (read a -> read a -> val bool),
   box (read a -> read a -> val bool)) : box OrdDict a;
};

data box AdditiveDict : val (val pure -> val pure)
{
  additiveDict : (val a : pure)
               -> box (read a -> read a -> write a)
              -> box (read a -> read a -> write a)
              -> box (read a -> write a)
              -> write a
              -> box AdditiveDict a,
  (val a : pure) ()
  (box (read a -> read a -> write a),
   box (read a -> read a -> write a),
   box (read a -> write a),
   read a) : box AdditiveDict a;
};

data box MultiplicativeDict : val (val pure -> val pure)
{
  multiplicativeDict : (val a : pure)
                    -> box AdditiveDict a
                    -> box (read a -> read a -> write a)
                    -> box (val int -> write a)
                    -> write a
                    -> box MultiplicativeDict a,
  (val a : pure) ()
  (box AdditiveDict a,
   box (read a -> read a -> write a),
   box (val int -> write a),
   read a) : box MultiplicativeDict a;
};

data box RemainderDict : val (val pure -> val pure)
{
  remainderDict : (val a : pure)
  	       -> box MultiplicativeDict a
	       -> box (read a -> read a -> val int)
	       -> box (read a -> read a -> write a)
	       -> box RemainderDict a,
  (val a : pure) ()
  (box MultiplicativeDict a,
   box (read a -> read a -> val int),
   box (read a -> read a -> write a)) : box RemainderDict a;
};

data box FractionalDict : val (val pure -> val pure)
{
  fractionalDict : (val a : pure)
  	        -> box MultiplicativeDict a
	        -> box (read a -> read a -> write a)
	        -> box FractionalDict a,
  (val a : pure) ()
  (box MultiplicativeDict a,
   box (read a -> read a -> write a)) : box FractionalDict a;
};

data box FloatingDict : val (val pure -> val pure)
{
  floatingDict : (val a : pure)
	      -> box (val float -> write a)
	      -> box (read a -> read a -> write a)
	      -> box (read a -> write a)
	      -> box (read a -> write a)
	      -> box (read a -> write a)
	      -> box (read a -> write a)
	      -> box (read a -> write a)
	      -> box (read a -> write a)
	      -> write a
	      -> box FloatingDict a,
  (val a : pure) ()
  (box (val float -> write a),
   box (read a -> read a -> write a),
   box (read a -> write a),
   box (read a -> write a),
   box (read a -> write a),
   box (read a -> write a),
   box (read a -> write a),
   box (read a -> write a),
   read a) : box FloatingDict a;
};

data box VectorDict : val (val pure -> val pure)
{
  vectorDict : (val a : pure)
            -> box AdditiveDict a
            -> box (read a -> val float -> write a)
            -> box (read a -> val float)
            -> box (read a -> read a -> val float)
            -> box VectorDict a,
  (val a : pure) ()
  (box AdditiveDict a,
   box (read a -> val float -> write a),
   box (read a -> val float),
   box (read a -> read a -> val float)) : box VectorDict a;
};

data box TraversableDict : val (val (val pure -> val pure) -> val pure)
{
  traversableDict :
      (val t : val pure -> val pure)
   -> box ((val a : pure) -> box Repr a -> read t a -> box Stream (shape t) a)
   -> box ((val a : pure) -> box Repr a -> box Stream (shape t) a -> write t a)
   -> box TraversableDict t,
  (val t : val pure -> val pure) ()
  (box ((val a : pure) -> box Repr a -> read t a -> box Stream (shape t) a),
   box ((val a : pure) -> box Repr a -> box Stream (shape t) a -> write t a))
  : box TraversableDict t;
};

-------------------------------------------------------------------------------
-- Shapes

-- Get the stream shape corresponding to a container
shape : val (val (val pure -> val pure) -> val pure);

-- The shape of a list stream
data val list_shape : val pure {};

-- The shape of an array stream
data val array_shape : val (val intindex -> val pure) {};

-------------------------------------------------------------------------------
-- Representation dictionaries

-- Loaded and stored types must be statically known.
-- Code is generated specifically for the type at the callsite.
load : (val a : pure) -> read a -> val a;
store : (val a : pure) -> val a -> write a;
copy : (val a : pure) -> box Repr a -> read a -> write a;

loadBox : (val a : pure) -> read a -> box a;
storeBox : (val a : pure) -> box a -> write a;

-- Cast a read reference to a boxed reference (operationally the id function)
ptrToBox : (val a : pure) -> read a -> box a;

-- Cast a boxed reference to a read reference (operationally the id function)
boxToPtr : (val a : pure) -> box a -> read a;

repr_int : box Repr int;
repr_float : box Repr float;
repr_bool : box Repr bool;

repr_list : (val a : pure) -> box Repr a -> box Repr (list a);
repr_Complex : (val a : pure) -> box Repr a -> box Repr (Complex a);

repr_PyonTuple2 :
    (val a : pure) -> (val b : pure) -> box Repr a -> box Repr b
 -> box Repr (PyonTuple2 a b);

repr_PyonTuple3 :
    (val a : pure) -> (val b : pure) -> (val c : pure)
 -> box Repr a -> box Repr b -> box Repr c
 -> box Repr (PyonTuple3 a b c);

repr_PyonTuple4 :
    (val a : pure) -> (val b : pure) -> (val c : pure) -> (val d : pure)
 -> box Repr a -> box Repr b -> box Repr c -> box Repr d
 -> box Repr (PyonTuple4 a b c d);

-- This always returns the same, global object
repr_Box : (val a : pure) -> box Repr a;

repr_Boxed : (val a : pure) -> box Repr (Boxed a);
repr_Referenced : (val a : pure) -> box Repr a -> box Repr (Referenced a);
repr_Stream : (val sh : pure) -> (val a : pure) -> box Repr (Stream sh a);

-- Representation of a referenced object that contains nothing and will
-- never be accessed.  At runtime, the reference will be an arbitrary pointer,
-- possibly NULL.
repr_EmptyReference : (val a : pure) -> box Repr a;

repr_array : (val n : intindex) -> (val e : pure)
          -> val IndexedInt n -> box Repr e -> box Repr (array n e);

repr_EffTok : box Repr EffTok;

OpaqueTraversableDict_list : box TraversableDict list;

TraversableDict_Stream_build :
    (val t : val pure -> val pure) -> (val a : pure)
 -> box Repr a -> box Stream (shape t) a -> box Stream (shape t) a;

TraversableDict_Stream_traverse :
    (val t : val pure -> val pure) -> (val a : pure)
 -> box Repr a -> box Stream (shape t) a -> box Stream (shape t) a;

TraversableDict_list_build :
  (val a : pure) -> box Repr a -> box Stream list_shape a -> write list a;

TraversableDict_list_traverse :
  (val a : pure) -> box Repr a -> read list a -> box Stream list_shape a;

-------------------------------------------------------------------------------
-- Comparison dictionaries

EqDict_int_eq : val int -> val int -> val bool;
EqDict_int_ne : val int -> val int -> val bool;

EqDict_float_eq : val float -> val float -> val bool;
EqDict_float_ne : val float -> val float -> val bool;

OrdDict_int_lt : val int -> val int -> val bool;
OrdDict_int_le : val int -> val int -> val bool;
OrdDict_int_gt : val int -> val int -> val bool;
OrdDict_int_ge : val int -> val int -> val bool;

OrdDict_float_lt : val float -> val float -> val bool;
OrdDict_float_le : val float -> val float -> val bool;
OrdDict_float_gt : val float -> val float -> val bool;
OrdDict_float_ge : val float -> val float -> val bool;

-------------------------------------------------------------------------------
-- Numeric dictionaries

AdditiveDict_int_add : val int -> val int -> val int;
AdditiveDict_int_sub : val int -> val int -> val int;
AdditiveDict_int_negate : val int -> val int;
AdditiveDict_int_zero : val int;

AdditiveDict_float_add : val float -> val float -> val float;
AdditiveDict_float_sub : val float -> val float -> val float;
AdditiveDict_float_negate : val float -> val float;
AdditiveDict_float_zero : val float;

AdditiveDict_Complex_add :
    (val a : pure)
 -> box Repr a
 -> box AdditiveDict a
 -> read Complex a
 -> read Complex a
 -> write Complex a;
AdditiveDict_Complex_sub :
    (val a : pure)
 -> box Repr a
 -> box AdditiveDict a
 -> read Complex a
 -> read Complex a
 -> write Complex a;
AdditiveDict_Complex_negate :
    (val a : pure)
 -> box Repr a
 -> box AdditiveDict a
 -> read Complex a
 -> write Complex a;
AdditiveDict_Complex_zero :
    (val a : pure)
 -> box Repr a
 -> box AdditiveDict a
 -> write Complex a;


MultiplicativeDict_int_mul : val int -> val int -> val int;
MultiplicativeDict_int_fromInt : val int -> val int;

MultiplicativeDict_float_mul : val float -> val float -> val float;
MultiplicativeDict_float_fromInt : val int -> val float;

MultiplicativeDict_Complex_mul :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> read Complex a
 -> read Complex a
 -> write Complex a;
MultiplicativeDict_Complex_fromInt :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> val int
 -> write Complex a;
MultiplicativeDict_Complex_one :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> write Complex a;


RemainderDict_int_floordiv : val int -> val int -> val int;
RemainderDict_int_mod : val int -> val int -> val int;

RemainderDict_float_floordiv : val float -> val float -> val int;
RemainderDict_float_mod : val float -> val float -> val float;


FractionalDict_float_div : val float -> val float -> val float;

FractionalDict_Complex_div :
    (val a : pure)
 -> box Repr a
 -> box FractionalDict a
 -> read Complex a
 -> read Complex a
 -> write Complex a;


FloatingDict_float_fromfloat : val float -> val float;
FloatingDict_float_power : val float -> val float -> val float;
FloatingDict_float_exp : val float -> val float;
FloatingDict_float_log : val float -> val float;
FloatingDict_float_sqrt : val float -> val float;
FloatingDict_float_sin : val float -> val float;
FloatingDict_float_cos : val float -> val float;
FloatingDict_float_tan : val float -> val float;
FloatingDict_float_pi : val float;

FloatingDict_Complex_fromfloat :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> val float
 -> write Complex a;
FloatingDict_Complex_power :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> read Complex a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_exp :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_log :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_sqrt :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_sin :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_cos :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_tan :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> read Complex a
 -> write Complex a;
FloatingDict_Complex_pi :
    (val a : pure)
 -> box Repr a
 -> box MultiplicativeDict a
 -> box FractionalDict a
 -> box FloatingDict a
 -> write Complex a;


VectorDict_float_scale : val float -> val float -> val float;
VectorDict_float_magnitude : val float -> val float;
VectorDict_float_dot : val float -> val float -> val float;

VectorDict_Complex_scale :
    (val a : pure)
 -> box Repr a
 -> box VectorDict a
 -> read Complex a
 -> val float
 -> write Complex a;

VectorDict_Complex_magnitude :
    (val a : pure)
 -> box Repr a
 -> box VectorDict a
 -> read Complex a
 -> val float;

VectorDict_Complex_dot :
    (val a : pure)
 -> box Repr a
 -> box VectorDict a
 -> read Complex a
 -> read Complex a
 -> write float;

-------------------------------------------------------------------------------
-- other arithmetic

or : val bool -> val bool -> val bool;
and : val bool -> val bool -> val bool;

-------------------------------------------------------------------------------
-- integer index arithmetic

-- Promote an integer to a type index
defineIntIndex : val int -> val SomeIndexedInt;

pos_infty : val intindex;
plus_i : val (val intindex -> val intindex -> val intindex);
minus_i : val (val intindex -> val intindex -> val intindex);
min_i : val (val intindex -> val intindex -> val intindex);

zero_ii : val (IndexedInt 0Z);
one_ii : val (IndexedInt 1Z);
plus_ii : (val m : intindex)
       -> (val n : intindex)
       -> val (IndexedInt m)
       -> val (IndexedInt n)
       -> val (IndexedInt (plus_i m n));

minus_ii : (val m : intindex)
        -> (val n : intindex)
        -> val (IndexedInt m)
        -> val (IndexedInt n)
        -> val (IndexedInt (minus_i m n));

min_ii : (val m : intindex)
      -> (val n : intindex)
      -> val (IndexedInt m)
      -> val (IndexedInt n)
      -> val (IndexedInt (min_i m n));

-------------------------------------------------------------------------------
-- Other functions

-- A dummy boxed object that is used as a placeholder for a dead value.
deadBox : (val a : pure) -> box a;

-- A dummy referenced object that is used as a placeholder for a dead value.
deadRef : (val a : pure) -> read a;

oper_DO : (val a : pure) -> box Repr a -> write a -> box Stream list_shape a;

oper_GUARD : (val a : pure)
          -> box Repr a -> val bool
	  -> box Stream list_shape a
	  -> box Stream list_shape a;

-- An empty stream
oper_EMPTY : (val a : pure) -> box Repr a -> box Stream list_shape a;

oper_CAT_MAP :
    (val a : pure) -> (val b : pure) -> box Repr a -> box Repr b
 -> box Stream list_shape a
 -> box (read a -> box Stream list_shape b)
 -> box Stream list_shape b;

-- Sequential fold over a stream
fun_fold_Stream : (val a : pure)
	       -> (val acc : pure)
               -> box Repr a
               -> box Repr acc
               -> box (read acc -> read a -> write acc)
               -> read acc
               -> box Stream list_shape a
               -> write acc;

-- Reinterpret a stream as having list shape
fun_asList_Stream : (val sh : pure)
                 -> (val a : pure)
                 -> box Stream sh a
                 -> box Stream list_shape a;

fun_map_Stream : (val sh : pure)
              -> (val a : pure)
	      -> (val b : pure)
       	      -> box Repr a
       	      -> box Repr b
       	      -> box (read a -> write b)
       	      -> box Stream sh a
       	      -> box Stream sh b;

fun_map : (val t : val pure -> val pure)
       -> (val a : pure)
       -> (val b : pure)
       -> box TraversableDict t
       -> box Repr a
       -> box Repr b
       -> box (read a -> write b)
       -> read t a
       -> write t b;

fun_reduce_Stream : (val sh : pure)
		 -> (val a : pure)
          	 -> box Repr a
          	 -> box (read a -> read a -> write a)
	  	 -> read a
          	 -> box Stream sh a
          	 -> write a;

fun_reduce : (val t : val pure -> val pure)
          -> (val a : pure)
          -> box TraversableDict t
          -> box Repr a
          -> box (read a -> read a -> write a)
	  -> read a
          -> read t a
          -> write a;

fun_reduce1_Stream : (val sh : pure)
		  -> (val a : pure)
          	  -> box Repr a
          	  -> box (read a -> read a -> write a)
          	  -> box Stream sh a
          	  -> write a;

fun_reduce1 : (val t : val pure -> val pure)
           -> (val a : pure)
           -> box TraversableDict t
           -> box Repr a
           -> box (read a -> read a -> write a)
           -> read t a
           -> write a;

fun_zip_Stream : (val sh : pure)
	      -> (val a : pure)
       	      -> (val b : pure)
       	      -> box Repr a
       	      -> box Repr b
       	      -> box Stream sh a
       	      -> box Stream sh b
       	      -> box Stream sh (PyonTuple2 a b);

fun_zip3_Stream : (val sh : pure)
	       -> (val a : pure)
               -> (val b : pure)
               -> (val c : pure)
               -> box Repr a
               -> box Repr b
               -> box Repr c
               -> box Stream sh a
               -> box Stream sh b
               -> box Stream sh c
               -> box Stream sh (PyonTuple3 a b c);

fun_zip4_Stream : (val sh : pure)
	       -> (val a : pure)
               -> (val b : pure)
               -> (val c : pure)
               -> (val d : pure)
               -> box Repr a
               -> box Repr b
               -> box Repr c
               -> box Repr d
               -> box Stream sh a
               -> box Stream sh b
               -> box Stream sh c
               -> box Stream sh d
               -> box Stream sh (PyonTuple4 a b c d);

zip_StreamArray : (val sizeA : intindex)
	       -> (val sizeB : intindex)
	       -> (val a : pure)
       	       -> (val b : pure)
               -> box Repr a
               -> box Repr b
               -> box Stream (array_shape sizeA) a
               -> box Stream (array_shape sizeB) b
               -> box Stream (array_shape (min_i sizeA sizeB)) (PyonTuple2 a b);

zip3_StreamArray :
    (val sizeA : intindex)
 -> (val sizeB : intindex)
 -> (val sizeC : intindex)
 -> (val a : pure)
 -> (val b : pure)
 -> (val c : pure)
 -> box Repr a
 -> box Repr b
 -> box Repr c
 -> box Stream (array_shape sizeA) a
 -> box Stream (array_shape sizeB) b
 -> box Stream (array_shape sizeC) c
 -> box Stream (array_shape (min_i (min_i sizeA sizeB) sizeC)) (PyonTuple3 a b c);

zip4_StreamArray :
    (val sizeA : intindex)
 -> (val sizeB : intindex)
 -> (val sizeC : intindex)
 -> (val sizeD : intindex)
 -> (val a : pure)
 -> (val b : pure)
 -> (val c : pure)
 -> (val d : pure)
 -> box Repr a
 -> box Repr b
 -> box Repr c
 -> box Repr d
 -> box Stream (array_shape sizeA) a
 -> box Stream (array_shape sizeB) b
 -> box Stream (array_shape sizeC) c
 -> box Stream (array_shape sizeD) d
 -> box Stream (array_shape (min_i (min_i (min_i sizeA sizeB) sizeC) sizeD)) (PyonTuple4 a b c d);

fun_zip : (val t : val pure -> val pure)
       -> (val a : pure)
       -> (val b : pure)
       -> box TraversableDict t
       -> box Repr a
       -> box Repr b
       -> read t a
       -> read t b
       -> write t (PyonTuple2 a b);

fun_zip3 : (val t : val pure -> val pure)
        -> (val a : pure)
        -> (val b : pure)
        -> (val c : pure)
        -> box TraversableDict t
        -> box Repr a
        -> box Repr b
        -> box Repr c
        -> read t a
        -> read t b
        -> read t c
        -> write t (PyonTuple3 a b c);

fun_zip4 : (val t : val pure -> val pure)
        -> (val a : pure)
        -> (val b : pure)
        -> (val c : pure)
        -> (val d : pure)
        -> box TraversableDict t
        -> box Repr a
        -> box Repr b
        -> box Repr c
        -> box Repr d
        -> read t a
        -> read t b
        -> read t c
        -> read t d
        -> write t (PyonTuple4 a b c d);

count : box Stream list_shape int;

range : val int -> box Stream list_shape int;

len : (val a : pure) -> read list a -> val int;

-- A type-indexed version of 'range'
rangeIndexed : (val n : intindex)
            -> val IndexedInt n
            -> box Stream (array_shape n) int;

histogram : (val t : val pure -> val pure)
         -> val int
         -> box Stream (shape t) int
         -> write list int;

histogramArray : (val sh : pure)
              -> (val n : intindex)
              -> val IndexedInt n
              -> box Stream sh int
              -> write array n int;

-- Low-level function for imperatively initializing an histogram
createHistogram :
    (val n : intindex)
 -> val IndexedInt n
 -> box (box (val int -> write EffTok) -> read EffTok -> write EffTok)
 -> write array n int;

generate : (val n : intindex)
        -> (val a : pure)
        -> val IndexedInt n
        -> box Repr a
        -> box (val int -> write a)
        -> box Stream (array_shape n) a;

generate_forever : (val a : pure)
                -> box Repr a
                -> box (val int -> write a)
                -> box Stream (array_shape pos_infty) a;

safeSubscript : (val a : pure)
             -> box Repr a
             -> read list a
             -> val int
             -> write a;

subscript : (val n : intindex)
         -> (val a : pure)
         -> box Repr a
         -> read array n a
         -> val int
         -> read a;

-- Like subscript, but modifies an output pointer
subscript_out : (val n : intindex)
             -> (val a : pure)
             -> box Repr a
             -> out array n a
             -> val int
             -> out a;

-- Parallelizable loop
doall : (val n : intindex)
     -> (val a : pure)
     -> (val b : pure)
     -> val IndexedInt n
     -> box (val int -> sideeffect b)
     -> sideeffect a;

-- Sequential loop
for : (val n : intindex)
   -> (val acc : pure)
   -> box Repr acc
   -> val IndexedInt n
   -> read acc
   -> box (val int -> read acc -> write acc)
   -> write acc;

-- Blocked parallel reduction
blocked_reduce :
    (val acc : pure)
 -> (val n : intindex)
 -> box Repr acc
 -> val IndexedInt n		-- Size of range
 -> val int			-- First member of range
 -> box (read acc -> read acc -> write acc) -- Reducer
 -> read acc			-- Initial value
 -> box ((val n : intindex) -> val IndexedInt n -> val int -> write acc)
    -- ^ Generate value given range
 -> write acc;

-- Blocked parallel reduction with no neutral element
blocked_reduce1 :
    (val acc : pure)
 -> (val n : intindex)
 -> box Repr acc
 -> val IndexedInt n		-- Size of range
 -> val int			-- First member of range
 -> box (read acc -> read acc -> write acc) -- Reducer
 -> box ((val n : intindex) -> val IndexedInt n -> val int -> write acc)
    -- ^ Generate value given range
 -> write acc;

-- Blocked parallel loop
blocked_doall :
    (val n : intindex)
 -> (val a : pure)
 -> (val b : pure)
 -> val IndexedInt n
 -> val int
 -> box ((val n : intindex) -> val IndexedInt n -> val int -> sideeffect b)
 -> sideeffect a;
