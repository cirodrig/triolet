
-- Data types
box makeComplex : val float -> val float -> ref complex float;

-- Load and store functions
box fun_load_int      : ref(r) int      -> [int @ r] val int;
box fun_load_float    : ref(r) float    -> [int @ r] val float;
box fun_load_bool     : ref(r) bool     -> [int @ r] val bool;
box fun_load_NoneType : ref(r) NoneType -> [int @ r] val NoneType;
box fun_load_complexFloat : ref(r) complex float -> [complex float @ r] val complex float;
  
box fun_store_int      : val int      -> ref int;
box fun_store_float    : val float    -> ref float;
box fun_store_bool     : val bool     -> ref bool;
box fun_store_NoneType : val NoneType -> ref NoneType;
box fun_store_complexFloat : val complex float -> ref complex float;

-- PassConv objects
ref(passConv_int_addr) passConv_int : PassConv int;
ref(passConv_float_addr) passConv_float : PassConv float;

-- PassConv-building functions
box passConv_owned : val (a : Pure) -> ref PassConv a;

box passConv_list :
    val (a : Pure)
 -> ref(r1) PassConv a
 -> [PassConv a @ r1] ref PassConv (list a);

box passConv_iter :
    val (a : Pure)
 -> ref(r1) PassConv a
 -> [PassConv a @ r1] ref PassConv (LazyStream EmpE a);

box passConv_pyonTuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(r1) PassConv a
 -> ref(r2) PassConv b
 -> [PassConv a @ r1 ** PassConv b @ r2] ref PassConv (PyonTuple2 a b);

-------------------------------------------------------------------------------
-- Comparison classes

-- Eq dict constructor

box eqDict :
    val (a : Pure)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] val bool)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] val bool)
 -> ref EqDict a;

-- Eq dict instances

-- ref(eqDict_int_addr) eqDict_int : EqDict int;
-- ref(eqDict_float_addr) eqDict_float : EqDict float;

box eqDict_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) EqDict a
 -> ref(rb) EqDict b
 -> [EqDict a @ ra ** EqDict b @ rb] ref EqDict (PyonTuple2 a b);

-- Eq dict members

box Eq_EQ_int : val int -> val int -> val bool;
box Eq_NE_int : val int -> val int -> val bool;

box Eq_EQ_float : val float -> val float -> val bool;
box Eq_NE_float : val float -> val float -> val bool;

box Eq_EQ_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) EqDict a
 -> ref(rb) EqDict b
 -> ref(r1) (PyonTuple2 a b)
 -> ref(r2) (PyonTuple2 a b)
 -> [EqDict a @ ra ** EqDict b @ rb **
     PyonTuple2 a b @ r1 ** PyonTuple2 a b @ r2]
    val bool;

box Eq_NE_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) EqDict a
 -> ref(rb) EqDict b
 -> ref(r1) (PyonTuple2 a b)
 -> ref(r2) (PyonTuple2 a b)
 -> [EqDict a @ ra ** EqDict b @ rb **
     PyonTuple2 a b @ r1 ** PyonTuple2 a b @ r2]
    val bool;

-- Ord dict constructor

box ordDict :
    val (a : Pure)
 -> ref(req) EqDict a
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] val bool)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] val bool)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] val bool)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] val bool)
 -> [EqDict a @ req] ref OrdDict a;

-- Ord dict instances

-- ref(ordDict_int_addr) ordDict_int_ptr : OrdDict int;
-- ref(ordDict_float_addr) ordDict_float_ptr : OrdDict float;

box ordDict_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) OrdDict a
 -> ref(rb) OrdDict b
 -> [OrdDict a @ ra ** OrdDict b @ rb] ref OrdDict (PyonTuple2 a b);

-- Ord dict members

box Ord_GT_int : val int -> val int -> val bool;
box Ord_GE_int : val int -> val int -> val bool;
box Ord_LT_int : val int -> val int -> val bool;
box Ord_LE_int : val int -> val int -> val bool;

box Ord_GT_float : val float -> val float -> val bool;
box Ord_GE_float : val float -> val float -> val bool;
box Ord_LT_float : val float -> val float -> val bool;
box Ord_LE_float : val float -> val float -> val bool;

box Ord_GT_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) OrdDict a
 -> ref(rb) OrdDict b
 -> ref(r1) (PyonTuple2 a b)
 -> ref(r2) (PyonTuple2 a b)
 -> [OrdDict a @ ra ** OrdDict b @ rb **
     PyonTuple2 a b @ r1 ** PyonTuple2 a b @ r2]
    val bool;

box Ord_GE_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) OrdDict a
 -> ref(rb) OrdDict b
 -> ref(r1) (PyonTuple2 a b)
 -> ref(r2) (PyonTuple2 a b)
 -> [OrdDict a @ ra ** OrdDict b @ rb **
     PyonTuple2 a b @ r1 ** PyonTuple2 a b @ r2]
    val bool;

box Ord_LT_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) OrdDict a
 -> ref(rb) OrdDict b
 -> ref(r1) (PyonTuple2 a b)
 -> ref(r2) (PyonTuple2 a b)
 -> [OrdDict a @ ra ** OrdDict b @ rb **
     PyonTuple2 a b @ r1 ** PyonTuple2 a b @ r2]
    val bool;

box Ord_LE_Tuple2 :
    val (a : Pure)
 -> val (b : Pure)
 -> ref(ra) OrdDict a
 -> ref(rb) OrdDict b
 -> ref(r1) (PyonTuple2 a b)
 -> ref(r2) (PyonTuple2 a b)
 -> [OrdDict a @ ra ** OrdDict b @ rb **
     PyonTuple2 a b @ r1 ** PyonTuple2 a b @ r2]
    val bool;

-------------------------------------------------------------------------------

-- Additive dict constructor

box additiveDict :
    val (a : Pure)
 -> ref(r_pc) PassConv a
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] ref a)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] ref a)
 -> box (ref(r) a -> [a @ r] ref a)
 -> ref(rzero) a
 -> [a @ rzero ** PassConv a @ r_pc] ref AdditiveDict a;

-- Additive class instances

-- ref(additiveDict_int_addr) additiveDict_int_ptr : AdditiveDict int;
-- ref(additiveDict_float_addr) additiveDict_float_ptr : AdditiveDict float;

-- Additive class members

box Additive_ADD_int : val int -> val int -> val int;
box Additive_SUB_int : val int -> val int -> val int;
box Additive_NEGATE_int : val int -> val int;

-- This is actually a value, not a reference, so it can't be written here
-- ref(additiveDict_int_zero_addr) Additive_ZERO_int : int;

box Additive_ADD_float : val float -> val float -> val float;
box Additive_SUB_float : val float -> val float -> val float;
box Additive_NEGATE_float : val float -> val float;

-- This is actually a value, not a reference, so it can't be written here
-- ref(additiveDict_float_zero_addr) Additive_ZERO_float : float;

box additiveDict_complex :
    val (a : Pure)
 -> ref(d_addr) AdditiveDict a
 -> [AdditiveDict a @ d_addr] ref AdditiveDict (complex a);

-- Multiplicative dict constructor

box multiplicativeDict :
    val (a : Pure)
 -> ref (r_add) AdditiveDict a
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2] ref a)
 -> box (val int -> ref a)
 -> ref(rzero) a
 -> [a @ rzero ** AdditiveDict a @ r_add] ref MultiplicativeDict a;

box Multiplicative_MUL_int : val int -> val int -> val int;
box Multiplicative_FROMINT_int : val int -> val int;
ref(multiplicativeDict_int_one_addr) Multiplicative_ONE_int : int;

box Multiplicative_MUL_float : val float -> val float -> val float;
box Multiplicative_FROMINT_float : val int -> val float;
ref(multiplicativeDict_float_one_addr) Multiplicative_ONE_float : float;

-- Traversable dictionary members

box traversableDict :
    val (t : val Pure -> val Pure)
 -> box (val (a : Pure) -> ref (pa) PassConv a -> ref (ta) t a ->
         [PassConv a @ pa] box LazyStream (t a @ ta) a)
 -> box (val (e : Effect) -> val (a : Pure) -> ref (pa) PassConv a ->
         box LazyStream e a -> [PassConv a @ pa ** e] ref t a)
 -> ref TraversableDict t;

ref(OpaqueTraversableDict_list_addr) OpaqueTraversableDict_list :
    TraversableDict list;

box Traversable_TRAVERSE_list :
    val (a : Pure)
 -> ref(pc_addr) PassConv a
 -> ref(list_addr) list a
 -> [PassConv a @ pc_addr] box LazyStream (list a @ list_addr) a;

box Traversable_BUILD_list :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(pc_addr) PassConv a
 -> box LazyStream e a
 -> [PassConv a @ pc_addr ** e] ref list a;

box Traversable_TRAVERSE_Stream :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(unused_addr) PassConv a
 -> box LazyStream e a
 -> box LazyStream e a;

box Traversable_BUILD_Stream :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(unused_addr) PassConv a
 -> box LazyStream e a
 -> box LazyStream e a;

-------------------------------------------------------------------------------
-- Other functions

box fun_copy : val (a : Pure) -> ref(a1) PassConv a -> ref(a2) a -> ref a;

-- Return representation is 'read', which we cannot write
-- box fun_subscript

box oper_CAT_MAP :
    val (e : Effect)
 -> val (a : Pure)
 -> val (b : Pure)
 -> ref(pc_a) PassConv a
 -> ref(pc_b) PassConv b
 -> box LazyStream e a
 -> box (ref(x_a) a -> [e] box LazyStream (a @ x_a ** e) b)
 -> [PassConv a @ pc_a ** PassConv b @ pc_b] box LazyStream e b;

box fun_map_Stream :
    val (e : Effect)
 -> val (a : Pure)
 -> val (b : Pure)
 -> ref(pc_a) PassConv a
 -> ref(pc_b) PassConv b
 -> box (ref(addr_a) a -> [a @ addr_a ** e] ref b)
 -> box LazyStream e a
 -> [PassConv a @ pc_a ** PassConv b @ pc_b] box LazyStream e b;

box fun_reduce :
    val (e : Effect)
 -> val (t : val Pure -> val Pure)
 -> val (a : Pure)
 -> ref(td_addr) TraversableDict t
 -> ref(pc1_addr) PassConv a
 -> ref(pc2_addr) PassConv (t a)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2 ** e] ref a)
 -> ref(unit_addr) a
 -> ref(container_addr) t a
 -> [t a @ container_addr ** a @ unit_addr **
     TraversableDict t @ td_addr **
     PassConv a @ pc1_addr ** PassConv (t a) @ pc2_addr **
     e] ref a;

box fun_reduce_Stream :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(pc1_addr) PassConv a
 -> ref(unused_addr) PassConv (LazyStream EmpE a)
 -> box (ref(r1) a -> ref(r2) a -> [a @ r1 ** a @ r2 ** e] ref a)
 -> ref(unit_addr) a
 -> box LazyStream e a
 -> [a @ unit_addr ** PassConv a @ pc1_addr ** e] ref a;

box fun_return :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(pc_addr) PassConv a
 -> box (val NoneType -> [e] ref a)
 -> [PassConv a @ pc_addr] box LazyStream e a;

box fun_generate :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(pc_addr) PassConv a
 -> val int
 -> box (val int -> [e] ref a)
 -> [PassConv a @ pc_addr] box LazyStream e a;

box fun_generateList :
    val (e : Effect)
 -> val (a : Pure)
 -> ref(pc_addr) PassConv a
 -> val int
 -> box (val int -> [e] ref a)
 -> [PassConv a @ pc_addr ** e] ref list a;

