
{- Predefined names
-- These names are predefined.  The definitions are here for reference.

kind val;
kind box;
kind bare;
kind out;
kind write;
kind sideeffect;

-}

{- This data type definition should be caught as an error, because its
   memory layout depends on an existential type parameter.
data ErroneousType : bare
{
  erroneousType (a : bare) (a);
};
-}

-- Data types

data Stored (a : val) : bare
{
  stored () (a);
};

data Ref (a : box) : bare
{
  ref () (a);
};

-- A stuck reference is like a 'Ref' but doesn't get unwrapped
-- by 'asbare'.
data StuckRef (a : box) : bare
{
  stuckRef () (a);
};

data Boxed (a : bare) : box
{
  boxed () (a);
};

-- A stuck box is like a 'boxed' but doesn't get unwrapped
-- by 'asbox'.
data StuckBox (a : bare) : box
{
  stuckBox () (a);
};

-- An unspecified data type
data Any : box
{
};

-- A pointer used for initializing data
data OutPtr (a : bare) : out
  attribute(abstract, nonalgebraic) {};

-- A dummy value representing the effect of initializing an object
data Store : val
  attribute(abstract)
{
  store () ();
};

-- Type functions to convert between representations
type AsBox : bare -> box;
type AsBare : box -> bare;

-- Designates an initializer function for a bare object
type Init : bare -> write;

-- Normal data types

data bool : val
{
  True () ();
  False () ();
};

data int : val attribute(abstract, nonalgebraic) {};
data uint : val attribute(abstract, nonalgebraic) {};
data float : val attribute(abstract, nonalgebraic) {};

data NoneType : val
{
  None () ();
};

data Maybe (a : bare) : bare
{
  just () (a);
  nothing () ();
};

-- A value-form of 'Maybe'.  It must be used with statically known arguments.
data MaybeVal (a : val) : val
{
  justVal () (a);
  nothingVal () ();
};

-- A linked list
data llist (a : bare) : box
{
  cons () (a, llist a);
  nil () ();
};

-- An integer interval, given by inclusive lower and exclusive upper bounds.
-- The upper bound must be greater or equal to the lower bound.
-- 'Nothing' means that the interval is unbounded at that end.
data Interval : val
{
  interval () (MaybeVal int, MaybeVal int);
};

-- | A linear map, representing the function y = s*x + a.
--   The stride 's' must be nonzero.
--
--   Negative strides are valid; however, note that many functions expect
--   linear maps with positive strides.
data LinearMap : val
{
  linearMap () (int, int);
};

-- A finite indexed integer 
data FIInt (n : intindex) : val
{
  fiInt () (int);
};

-- An indexed singleton integer type.
-- Invariant: The type index gives up the integer value.
data IInt (n : intindex) : val
{
  -- Finite value
  iInt () (FIInt n);

  -- Positive and negative infinity
  iPosInfty () ();
  iNegInfty () ();
};

-- An existential indexed singleton integer type.
-- We can convert int to this type.
data SomeIInt : val
{
  someIInt (n : intindex) (FIInt n);
};

-- A user-specified slice.
--
-- If the third field is Nothing, the slice specifies a contiguous range.
-- Otherwise it specifies a triple.
data SliceObject : bare
{
  sliceObject ()
  (MaybeVal int, MaybeVal int, MaybeVal (MaybeVal int));
};

data Complex (a : bare) : bare
{
  complex () (a, a);
};

data arr (n : intindex) (a : bare) : bare
  attribute(abstract, nonalgebraic)
{};

data Tuple0 : bare
{
  tuple0 () ();
};

data Tuple1 (a : bare) : bare
{
  tuple1 () (a);
};


data Tuple2 (a b : bare) : bare
{
  tuple2 () (a, b);
};

data Tuple3 (a b c : bare) : bare
{
  tuple3 () (a, b, c);
};

data Tuple4 (a b c d : bare) : bare
{
  tuple4 () (a, b, c, d);
};

-- Dictionaries

data SizeAlign (a : bare) : val
{
  sizeAlign () (uint, uint);
};

data SizeAlignVal (a : val) : val
{
  sizeAlignVal () (uint, uint);
};

-- This data declaration is not precisely correct:
-- Size and alignment are not int, but rather unsigned int.
-- The finalize function has a slightly different type.
data Repr (a : bare) : box
  attribute(abstract)
{
  repr ()
  (SizeAlign a,                 -- Size and alignment
   a -> Init a,		-- Copy
   Init a -> AsBox a,	-- Convert to boxed
   AsBox a -> Init a,     -- Convert to bare
   bool);                       -- Pointerlessness
                                -- (True if an 'a' definitely doesn't contain pointers)
};

data EqDict (a : box) : box
{
  eqDict ()
  (a -> a -> Boxed (Stored bool), a -> a -> Boxed (Stored bool));
};

data OrdDict (a : bare) : box
{
  ordDict ()
  (EqDict a,
   a -> a -> Boxed (Stored bool),
   a -> a -> Boxed (Stored bool),
   a -> a -> Boxed (Stored bool),
   a -> a -> Boxed (Stored bool));
};

data AdditiveDict (a : bare) : box
{
  additiveDict ()
  (a -> a -> Init a,
   a -> a -> Init a,
   a -> Init a,
   a);
};

data MultiplicativeDict (a : bare) : box
{
  multiplicativeDict ()
  (AdditiveDict a,
   a -> a -> Init a,
   int -> Init a,
   a);
};

data RemainderDict (a : bare) : box
{
  remainderDict ()
  (MultiplicativeDict a,
   a -> a -> int,
   a -> a -> Init a);
};

data FractionalDict (a : bare) : box
{
  fractionalDict ()
  (MultiplicativeDict a, a -> a -> Init a);
};

data FloatingDict (a : bare) : box
{
  floatingDict ()
  (float -> Init a,
   a -> a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a -> Init a,
   a);
};

data VectorDict (a : bare) : box
{
  vectorDict ()
  (AdditiveDict a,
   a -> float -> Init a,
   a -> float,
   a -> a -> float);
};

-- Cartesian domains, indexed by their index type.
--
-- The methods are:
-- 1. Get lower bound of finite range
-- 2. Get upper bound of finite range
-- 3. Get strides
-- 4. Create a finite range
-- 5. Displace a domain by an offset
-- 6. Scale a domain by a scale factor
-- 7. Scale a domain by an inverse scale factor
-- 8. Scale an index by a scale factor
-- 9. Scale an index by an inverse scale factor
-- 10.The largest domain
data CartesianDict (sh : box) : box
{
  cartesianDict ()
  (coerce @box (cartesianDomain (index sh)) sh,
   sh -> Init (Maybe (index sh)),
   sh -> Init (Maybe (index sh)),
   sh -> Init (index sh),
   index sh -> index sh -> sh,
   sh -> index sh -> sh,
   sh -> index sh -> sh,
   sh -> index sh -> sh,
   index sh -> index sh -> Init (index sh),
   index sh -> index sh -> Init (index sh),
   sh);
};

data TraversableDict (t : bare -> bare) : box
{
  traversableDict ()
  ((a : bare) -> Repr a -> t a -> Stream (shape t) a,
   (a : bare) -> Repr a -> Stream (shape t) a -> Init (t a));
};

-- Operations related to data domains and traversals over them.
-- The operations are flatten-to-list, generate, map, zipWith{2..4},
-- range checking for integers, and slicing.
data ShapeDict (sh : box) : box
{
  shapeDict ()
  (Repr (index sh),
   Repr (slice sh),

   -- Member
   sh -> index sh -> bool,

   -- Intersect
   sh -> sh -> sh,

   -- Flatten
   (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a,

   -- Generate
   (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a,

   -- Map and zips
   (a b : bare) ->
   Repr a -> Repr b ->
   (a -> Init b) -> Stream sh a -> Stream sh b,

   (a b c : bare) ->
   Repr a -> Repr b -> Repr c ->
   (a -> b -> Init c) -> Stream sh a -> Stream sh b -> Stream sh c,

   (a b c d : bare) ->
   Repr a -> Repr b -> Repr c -> Repr d ->
   (a -> b -> c -> Init d) ->
   Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d,

   (a b c d e : bare) ->
   Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
   (a -> b -> c -> d -> Init e) ->
   Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e,

   -- Slice
   (t : bare -> bare) -> (a : bare) ->
   coerce @box (shape t) sh ->
   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a
   );
};

-- Class methods for one-dimensional, array-like container types
-- that can be indexed into.
-- Methods should not perform bounds checking.
data IndexableDict (t : bare -> bare) : box
{
  indexableDict ()
  ((a : bare) -> Repr a -> t a -> index (shape t) -> Init a,
   (a : bare) -> t a -> shape t);
};

-- The cartesian domain corresponding to an index type
type cartesianDomain : bare -> box;
type index : box -> bare;
type slice : box -> bare;

-------------------------------------------------------------------------------
-- Imperative computation support

-- A dummy token that we use to stand in for dependences due to
-- imperative computation that is inserted by the compiler.
--
-- We take advantage of the fact that EffTok is a unit value, and therefore
-- it is not accessed by load or store instructions when reading or writing it,
-- and therefore we can safely masquerade NULL pointers as EffTok references.
data EffTok : val
  attribute(abstract)
{
  -- We never use the constructor 'effTok' in code, because it could be
  -- optimized away.  We don't want the optimizer to mess with this data type
  -- because it stands in for real dependences.
  -- Instead, use 'emptyEffTok' to produce an EffTok value.
  effTok () ();
};

-- An empty side effect.
-- This function is translated specially when converting from Core to LowLevel.
emptyEffTok : EffTok;

-- Translate to a side effect.
-- This function is translated specially when converting from Core to LowLevel.
toEffTok : (a : bare) -> Store -> EffTok;

-- Perform two side-effecting operations in sequence.
seqEffTok : EffTok -> EffTok -> EffTok;

fromEffTok : (a : bare) -> EffTok -> Store;

-- An opaque reference to mutable data.
data OpaqueRef : box
  attribute(abstract, nonalgebraic)
{};

-- The state of a list-building computation.
-- This is used when constructing a list from a sequence.
data ListBuilder (a : bare) : val
{
  listBuilder () (int, int, OpaqueRef);
};

-- Primitive function for building a list by appending to it.
-- Defined in low-level.
append_build_list : (a : bare)
                 -> Repr a
                 -> ((Init a -> ListBuilder a -> ListBuilder a) ->
                     ListBuilder a -> ListBuilder a)
                 -> Init (list a);

-- The finalizer of an in-place update operation.
-- A finalizer performs a one-time computation to convert the updatable
-- data structure to a read-only data structure.  In some cases, a finalizer
-- is not required, in which case the update is really performed in-place.
data UpdateInPlaceFinalizer (mutable immutable : bare) : box
{
  -- The data can be mutated in place if the mutable and immutable data formats
  -- are the same
  mutateInPlace () (coerce @bare mutable immutable);

  -- Data should be mutated out-of-place, then written to the output
  mutateAndCopy () (mutable -> Init immutable);
};

-- A scatter-reduce operation.  Reductions are performed with a combination of
-- sequential in-place updates and parallel reduction.
--
-- The type parameters and existential types are:
-- * a return type 'r', which is the result type of a scatter reduction
-- * an index type 'i', which is the type of inputs to a scatter reduction
-- * a state type 's', which is the memory representation that's modified by
--   in-place upate
-- * a scalar type 'a', which is the data type that's loaded and stored
--   (or atomically updated) during an in-place update
--
-- The code is organized such that only function types are parameterized on
-- 'a'.  There are no values of type 'a', because values can only have ground
-- types.  By organizing functions this way, we can generally ensure that the
-- low-level API does not need to perform memory allocation.
--
-- Token passing is used to represent dependences during the in-place part of
-- the reduction.
data Scatter (r i : bare) : box
{
  mk_scatter (s : bare, iniF : box, updF : box)
  (Repr s,
   iniF -> OutPtr s -> EffTok,                -- Initializer
   updF -> i -> EffTok -> OutPtr s -> EffTok, -- Updater
   s -> s -> Init s,                          -- Combining function
   UpdateInPlaceFinalizer s r,                -- Final value constructor
   i -> updF,                                 -- Update function
   iniF                                       -- Initial value
  );
};


-- These functions are implemented in low-level code.
intUpdateInPlace_initializer : (NoneType -> int)
                            -> OutPtr (Stored int)
                            -> EffTok;
intUpdateInPlace_updater : (int -> int) -> EffTok
                        -> OutPtr (Stored int)
                        -> EffTok;
floatUpdateInPlace_initializer : (NoneType -> float)
                              -> OutPtr (Stored float)
                              -> EffTok;
floatUpdateInPlace_updater : (float -> float) -> EffTok
                          -> OutPtr (Stored float)
                          -> EffTok;
boolUpdateInPlace_initializer : (NoneType -> bool)
                              -> OutPtr (Stored bool)
                              -> EffTok;
boolUpdateInPlace_updater : (bool -> bool) -> EffTok
                          -> OutPtr (Stored bool)
                          -> EffTok;

-- Helper functions for scatter reductions

intUpdateInPlace_int_coercion : coerce @bare (Stored int) (Stored int) =
  idBareCoercion @(Stored int);


intUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored int) (Stored int) =
  mutateInPlace @(Stored int) @(Stored int)
  intUpdateInPlace_int_coercion;


intUpdateInPlace_combiner (x : Stored int) (y : Stored int)
  (ret : OutPtr (Stored int))
  -> Store =
  case x of stored @int (ux : int).
  case y of stored @int (uy : int).
  stored @int (ux +# uy) ret;


floatUpdateInPlace_float_coercion : coerce @bare (Stored float) (Stored float) =
  idBareCoercion @(Stored float);


floatUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored float) (Stored float) =
  mutateInPlace @(Stored float) @(Stored float)
  floatUpdateInPlace_float_coercion;


floatUpdateInPlace_combiner (x : Stored float) (y : Stored float)
  (ret : OutPtr (Stored float))
  -> Store =
  case x of stored @float (ux : float).
  case y of stored @float (uy : float).
  stored @float (AdditiveDict_float_add ux uy) ret;


boolUpdateInPlace_bool_coercion : coerce @bare (Stored bool) (Stored bool) =
  idBareCoercion @(Stored bool);


boolUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored bool) (Stored bool) =
  mutateInPlace @(Stored bool) @(Stored bool)
  boolUpdateInPlace_bool_coercion;

-- Scatter reduction algorithms

intScatter : (a : bare)
          -> Repr a
          -> (a -> int -> int)
          -> (int -> int -> int)
          -> int
          -> Scatter (Stored int) a;

floatScatter : (a : bare)
            -> Repr a
            -> (a -> float -> float)
            -> (float -> float -> float)
            -> float
            -> Scatter (Stored float) a;

intScatter @(a : bare) (rep : Repr a)
  (f : a -> int -> int)
  (g : int -> int -> int)
  (init : int)
  -> Scatter (Stored int) a
  attribute(inline) =
  let type Sint = Stored int in
  mk_scatter @Sint @a @Sint @(NoneType -> int) @(int -> int)
  repr_int
  intUpdateInPlace_initializer
  (\ (modify : int -> int) (ix : a)
     (tok_in : EffTok) (ret : OutPtr Sint) -> EffTok.
     intUpdateInPlace_updater modify tok_in ret)
  (\ (x : Sint) (y : Sint) (r : OutPtr (Sint)) -> Store.
    case x of stored @int (ux : int).
    case y of stored @int (uy : int).
    stored @int (g ux uy) r)
  intUpdateInPlace_finalizer
  f
  (\ (dummy : NoneType) -> int. init);


floatScatter @(a : bare) (rep : Repr a)
  (f : a -> float -> float)
  (g : float -> float -> float)
  (init : float)
  -> Scatter (Stored float) a
  attribute(inline) =
  let type Sfloat = Stored float in
  mk_scatter @Sfloat @a @Sfloat @(NoneType -> float) @(float -> float)
  repr_float
  floatUpdateInPlace_initializer
  (\ (modify : float -> float) (ix : a)
     (tok_in : EffTok) (ret : OutPtr Sfloat) -> EffTok.
     floatUpdateInPlace_updater modify tok_in ret)
  (\ (x : Sfloat) (y : Sfloat) (r : OutPtr (Sfloat)) -> Store.
    case x of stored @float (ux : float).
    case y of stored @float (uy : float).
    stored @float (g ux uy) r)
  floatUpdateInPlace_finalizer
  f
  (\ (dummy : NoneType) -> float. init);


boolScatter @(a : bare) (rep : Repr a)
  (f : a -> bool -> bool)
  (g : bool -> bool -> bool)
  (init : bool)
  -> Scatter (Stored bool) a
  attribute(inline) =
  let type Sbool = Stored bool in
  mk_scatter @Sbool @a @Sbool @(NoneType -> bool) @(bool -> bool)
  repr_bool
  boolUpdateInPlace_initializer
  (\ (modify : bool -> bool) (ix : a)
     (tok_in : EffTok) (ret : OutPtr Sbool) -> EffTok.
     boolUpdateInPlace_updater modify tok_in ret)
  (\ (x : Sbool) (y : Sbool) (r : OutPtr (Sbool)) -> Store.
    case x of stored @bool (ux : bool).
    case y of stored @bool (uy : bool).
    stored @bool (g ux uy) r)
  boolUpdateInPlace_finalizer
  f
  (\ (dummy : NoneType) -> bool. init);


intSumScatter : Scatter (Stored int) (Stored int) =
  let type Sint = Stored int in
  mk_scatter @Sint @Sint @Sint @(NoneType -> int) @(int -> int)
  repr_int
  intUpdateInPlace_initializer
  intSumScatter_updater
  intUpdateInPlace_combiner
  intUpdateInPlace_finalizer
  intSumScatter_make_update
  intSumScatter_make_init;


intSumScatter_updater (modify : int -> int) (ix : Stored int)
  (tok_in : EffTok) (ret : OutPtr (Stored int)) -> EffTok =
  intUpdateInPlace_updater modify tok_in ret;


intSumScatter_make_update (i : Stored int) -> int -> int =
  case i of stored @int (ui : int).
  (\ (n : int) -> int. ui +# n);


intSumScatter_make_init (dummy : NoneType) -> int = 0;


floatSumScatter : Scatter (Stored float) (Stored float) =
  let type Sfloat = Stored float in
  mk_scatter @Sfloat @Sfloat @Sfloat @(NoneType -> float) @(float -> float)
  repr_float
  floatUpdateInPlace_initializer
  floatSumScatter_updater
  floatUpdateInPlace_combiner
  floatUpdateInPlace_finalizer
  floatSumScatter_make_update
  floatSumScatter_make_init;


floatSumScatter_updater
  (modify : float -> float) (ix : Stored float)
  (tok_in : EffTok) (ret : OutPtr (Stored float)) -> EffTok =
  floatUpdateInPlace_updater modify tok_in ret;


floatSumScatter_make_update (i : Stored float) -> float -> float =
  case i of stored @float (ui : float).
  (\ (n : float) -> float. AdditiveDict_float_add ui n);


floatSumScatter_make_init (dummy : NoneType) -> float = 0.0;


countingScatter : Scatter (Stored int) (Stored NoneType) =

  mk_scatter @(Stored int) @(Stored NoneType) @(Stored int)
             @(NoneType -> int) @(int -> int)
  repr_int
  intUpdateInPlace_initializer
  countingScatter_updater
  intUpdateInPlace_combiner
  intUpdateInPlace_finalizer
  countingScatter_make_update
  countingScatter_make_init;


countingScatter_updater (modify : int -> int) (ix : Stored NoneType)
  (tok_in : EffTok) (ret : OutPtr (Stored int)) -> EffTok =
  intUpdateInPlace_updater modify tok_in ret;


countingScatter_make_update (i : Stored NoneType) -> int -> int =
  (\ (n : int) -> int. n +# 1);


countingScatter_make_init (dummy : NoneType) -> int = 0;


boxedScatter @(a : box) @(b : bare) (repr : Repr b)
  (f : b -> a -> a)
  (g : a -> a -> a)
  (init : a)
  -> Scatter (StuckRef a) b =
  mk_scatter @(StuckRef a) @b @(StuckRef a) @(NoneType -> a) @(a -> a)
  (repr_StuckRef @a)
  -- Initializer
  (\ (init_f : NoneType -> a) (p : OutPtr (StuckRef a)) -> EffTok.
     toEffTok @(StuckRef a) (stuckRef @a (init_f None) p))
  -- Updater
  (\ (modify : a -> a) (index : b) (eff_in : EffTok)
     (p : OutPtr (StuckRef a)) -> EffTok.
     boxedScatter_updater @a modify eff_in p)
  (\ (x : StuckRef a) (y : StuckRef a) (ret : OutPtr (StuckRef a))
     -> Store.
     case x of stuckRef @a (ux : a).
     case y of stuckRef @a (uy : a).
     stuckRef @a (g ux uy) ret)
  (mutateInPlace @(StuckRef a) @(StuckRef a) (idBareCoercion @(StuckRef a)))
  (\ (x : b) (old : a) -> a. f x old)
  (\ (dummy : NoneType) -> a. init);


boxedScatter_updater : (a : box)
                    -> (a -> a)
                    -> EffTok
                    -> OutPtr (StuckRef a)
                    -> EffTok;


appendScatter @(a : bare) (rep : Repr a)
  -> Scatter (list a) a =
  mk_scatter @(list a) @a @(append_list a)
             @(NoneType -> NoneType)
             @(OutPtr a -> Store)
  (repr_append_list @a rep)
  (appendScatter_initializer @a (reprSizeAlign @a rep))
  (appendScatter_updater @a rep)
  (appendScatter_concatenate @a rep)
  (mutateAndCopy @(append_list a) @(list a)
   (\ (x : append_list a) (ret : OutPtr (list a)) -> Store.

      -- Create a copy of the list that contains no unused array elements.

      -- Inspect the old value
      case x of
        make_append_list @a @(M : intindex)
        (ls_count : FIInt M) (real_length : int) (ls_data : StuckBox (arr M a)).
      case ls_data of stuckBox @(arr M a) (ls_arr : arr M a).

      -- Construct the new list; copy from the old list
      case defineIntIndex real_length of
        someIInt @(N : intindex) (count : FIInt N).
      make_list @a @N count
      (stuckBox @(arr N a)
       (\ (ret : OutPtr (arr N a)) -> Store.
          doall @N @a @a count
          (\ (i : int) -> Store.
             copy @a rep
             (subscript @M @a (reprSizeAlign @a rep) ls_arr i)
             (subscript_out @N @a (reprSizeAlign @a rep) ret i))))
      ret))
  (copy @a rep)
  (\ (dummy : NoneType) -> NoneType. dummy);


appendScatter_updater @(a : bare)
  (rep : Repr a)
  (writer : OutPtr a -> Store)
  (arg : a)
  (tok_in : EffTok)
  (update_list : OutPtr (append_list a))
  -> EffTok =
  appendScatter_update_real @a
  (reprSizeAlign @a rep) writer tok_in update_list;


appendScatter_concatenate @(a : bare)
  (rep : Repr a)
  (l1 : append_list a)
  (l2 : append_list a)
  (ret : OutPtr (append_list a))
  -> Store
  attribute(inline) =

  case l1 of
    make_append_list @a @(N : intindex)
    (s1 : FIInt N) (n1 : int) (data1 : StuckBox (arr N a)).
  case data1 of stuckBox @(arr N a) (arr1 : arr N a).
  case l2 of
    make_append_list @a @(M : intindex)
    (s2 : FIInt M) (n2 : int) (data2 : StuckBox (arr M a)).
  case data2 of stuckBox @(arr M a) (arr2 : arr M a).

  -- Concatenate both lists
  -- TODO: This function may be called repeatedly, but we shouldn't copy
  -- more than once.  Avoid excess copying by building a cord, then
  -- flattening the cord later.
  case defineIntIndex n1 of someIInt @(Np : intindex) (count1 : FIInt Np).
  case defineIntIndex n2 of someIInt @(Mp : intindex) (count2 : FIInt Mp).

  case defineIntIndex (n1 +# n2) of someIInt @(P : intindex) (s3 : FIInt P).
  case s3 of fiInt @P (n3 : int).

  let sizealign : SizeAlign a = reprSizeAlign @a rep in

  make_append_list @a @P s3 n3
  (stuckBox @(arr P a)
   (\ (ret : OutPtr (arr P a)) -> Store.

      -- Copy data from l1 and l2 into the output
      fromEffTok @(arr P a)
      (seqEffTok
       (toEffTok @(arr P a)
        (sequential_doall @Np @a @a count1
         (\ (i : int) -> Store.
            -- Copy l1 into the beginning of the list
            copy @a rep
            (subscript @N @a sizealign arr1 i)
            (subscript_out @P @a sizealign ret i))))
       (toEffTok @(arr P a)
        (sequential_doall @Mp @a @a count2
         (\ (i : int) -> Store.
            -- Copy l2 into the end of the list
            copy @a rep
            (subscript @M @a sizealign arr2 i)
            (subscript_out @P @a sizealign ret (i +# n1))))))))
  ret;


appendScatter_initializer : (a : bare) -> SizeAlign a -> (NoneType -> NoneType)
                         -> OutPtr (append_list a) -> EffTok;

appendScatter_update_real : (a : bare)
                     -> SizeAlign a
                     -> (OutPtr a -> Store)
                     -> EffTok
                     -> OutPtr (append_list a)
                     -> EffTok;


arrScatter @(N : intindex) @(e i : bare)
  (repr_i : Repr i)
  (repr_e : Repr e)
  (count : FIInt N)
  (reduction_op : Scatter e i)
  -> Scatter (arr N e) (Tuple2 (Stored int) i)
  attribute(inline, inline_final) =

  case reduction_op of
    mk_scatter @e @i @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s e)
    (update_f : i -> updF)
    (init_f : iniF).

  let type arr_t = arr N e in
  let type i2 = Tuple2 (Stored int) i in

  case count of fiInt @N (u_count : int).

  case repr_s of
    repr @s
    (sa_s : SizeAlign s)
    (copy_s : s -> Init s)
    (to_boxed_s : Init s -> AsBox s)
    (to_bare_s : AsBox s -> Init s)
    (pointerless_s : bool).

  mk_scatter @arr_t @i2 @(arr N s) @iniF @updF
  (repr_arr @N @s count repr_s)
  (\ (f : iniF) (p : OutPtr (arr N s)) -> EffTok.
     -- Initialize all array elements
     toEffTok @(arr N s)
     (arr1D_build @N @s repr_s count
      (\ (i : int) (ret : OutPtr s) -> Store.
         fromEffTok @s (initializer f ret)) p))
  (\ (f : updF) (index : i2) (in_tok : EffTok) (p : OutPtr (arr N s))
     -> EffTok.
     case index of
       tuple2 @(Stored int) @i (arr_index : Stored int) (elt_index : i).
     case arr_index of stored @int (u_arr_index : int).

     -- If index is out of bounds, do nothing
     if or (u_arr_index <# 0) (u_arr_index >=# u_count)
     then in_tok
     else updater f elt_index in_tok
          (subscript_out @N @s sa_s p u_arr_index))

  -- Combine arrays elementwise
  (\ (x : arr N s) (y : arr N s) (ret : OutPtr (arr N s)) -> Store.
     arr1D_build @N @s repr_s count
     (\ (i : int) (local_ret : OutPtr s) -> Store.
        combiner (subscript @N @s sa_s x i) (subscript @N @s sa_s y i)
        local_ret)
     ret)

  -- Update in place if array elements can be updated in place
  -- Otherwise, make a copy
  (case finalizer of {
     mutateInPlace @s @e (co : coerce @bare s e).
       mutateInPlace @(arr N s) @(arr N e)
       (unsafeMakeBareCoercion @(arr N s) @(arr N e))
   ; mutateAndCopy @s @e (f : s -> Init e).
       mutateAndCopy @(arr N s) @(arr N e)
       (\ (accumulator : arr N s) (ret : OutPtr (arr N e))
          -> Store.
          arr1D_build @N @e repr_e count
          (\ (i : int) (ret : OutPtr e) -> Store.
             f (subscript @N @s sa_s accumulator i) ret)
          ret)
   })
   (\ (index : i2) -> updF.
      case index of
        tuple2 @(Stored int) @i (arr_index : Stored int) (elt_index : i).
      update_f elt_index)
   init_f;


comapScatterIndex @(r i1 i2 : bare)
  (repr_i1 : Repr i1)
  (repr_i2 : Repr i2)
  (repr_r : Repr r)
  (transform : i2 -> Init i1)
  (sr : Scatter r i1)
  -> Scatter r i2
  attribute(inline, inline_final) =

  case sr of
    mk_scatter @r @i1 @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i1 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (update_f : i1 -> updF)
    (init_f : iniF).

  letfun
    updater2 (f : updF) (index : i2) (tok_in : EffTok) (out_ptr : OutPtr s)
      -> EffTok =
      case boxed @i1 (transform index) of boxed @i1 (index1 : i1).
      updater f index1 tok_in out_ptr in

  letfun
    update_f2 (index : i2) -> updF =
      case boxed @i1 (transform index) of boxed @i1 (index1 : i1).
      update_f index1 in

  mk_scatter @r @i2 @s @iniF @updF repr_s initializer
  updater2 combiner finalizer update_f2 init_f;


blistScatter @(a i : bare)
  (repr_i : Repr i)
  (repr_a : Repr a)
  (dom : list_dim)
  (reduction_op : Scatter (StuckRef (AsBox a)) i)
  -> Scatter (blist a) (Tuple2 (Stored int) i) =
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (Stored int) i in

  -- Use listScatter
  case listScatter @boxed_a @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(list boxed_a) @i2 @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (list boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with blist
  let repr_list_a : Repr (list boxed_a) = repr_list @boxed_a in

  let blist_finalizer : UpdateInPlaceFinalizer s (blist a) =
        case finalizer of {
          mutateInPlace @s @(list boxed_a)
          (co : coerce @bare s (list boxed_a)).
            mutateAndCopy @s @(blist a)
            (\ (x : s) -> Init (blist a).
               make_blist @a
               (copy @(list boxed_a) repr_list_a
                (coerce @s @(list boxed_a) x)))
        ; mutateAndCopy @s @(list boxed_a) (f : s -> Init (list boxed_a)).
            mutateAndCopy @s @(blist a)
            (\ (x : s) -> Init (blist a). make_blist @a (f x))
        } in

  mk_scatter @(blist a) @i2 @s @iniF @updF repr_s initializer updater combiner
  blist_finalizer make_updater make_init;


listScatter @(e i : bare)
  (repr_i : Repr i)
  (repr_e : Repr e)
  (dom : list_dim)
  (reduction_op : Scatter e i)
  -> Scatter (list e) (Tuple2 (Stored int) i) =

  let type i2 = (Tuple2 (Stored int) i) in
  let type ret_type = Scatter (list e) i2 in

  case dom of mk_list_dim (mlist_size : MaybeVal int).
  case mlist_size of {
    justVal @int (list_size : int).
      case defineIntIndex list_size of
        someIInt @(N : intindex) (count : FIInt N).

      -- Create a plain array scatter reducer.
      case arrScatter @N @e @i repr_i repr_e count reduction_op of
        mk_scatter @(arr N e) @i2 @(s : bare) @(iniF : box) @(updF : box)
        (repr_s : Repr s)
        (initializer : iniF -> OutPtr s -> EffTok)
        (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
        (combiner : s -> s -> Init s)
        (finalizer : UpdateInPlaceFinalizer s (arr N e))
        (make_updater : i2 -> updF)
        (make_init : iniF).

      -- Create a scatter reducer that wraps it in a list
      let list_finalizer : UpdateInPlaceFinalizer s (list e) =
            mutateAndCopy @s @(list e)
            (\ (accumulator : s) (ret : OutPtr (list e)) -> Store.
               make_list @e @N count
               (stuckBox @(arr N e)
                (case finalizer of {
                   mutateInPlace @s @(arr N e) (co : coerce @bare s (arr N e)).
                     copy @(arr N e) (repr_arr @N @e count repr_e)
                     (coerce @s @(arr N e) accumulator)
                 ; mutateAndCopy @s @(arr N e) (f : s -> Init (arr N e)).
                     f accumulator
                 }))
               ret) in

      mk_scatter @(list e) @i2 @s @iniF @updF
      repr_s
      initializer
      updater
      combiner
      list_finalizer
      make_updater
      make_init

  ; nothingVal @int.
      except @(Scatter (list e) (Tuple2 (Stored int) i))
  };


array1Scatter @(e i : bare)
  (repr_i : Repr i)
  (repr_e : Repr e)
  (dom : dim1)
  (reduction_op : Scatter e i)
  -> Scatter (array1 e) (Tuple2 (Stored int) i) =

  let type i2 = (Tuple2 (Stored int) i) in
  let type ret_type = Scatter (array1 e) i2 in

  -- Compute array size
  case boxed @(Ref ret_type)
       (dim1ToArrayDesc @(Ref ret_type) dom
        (\ @(N : intindex) (lb : int) (stride : int) (count : FIInt N)
           (ret : OutPtr (Ref ret_type))
           -> Store.

           -- Create a plain array scatter reducer.
           case arrScatter @N @e @i repr_i repr_e count reduction_op of
             mk_scatter @(arr N e) @i2 @(s : bare) @(iniF : box) @(updF : box)
             (repr_s : Repr s)
             (initializer : iniF -> OutPtr s -> EffTok)
             (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
             (combiner : s -> s -> Init s)
             (finalizer : UpdateInPlaceFinalizer s (arr N e))
             (make_updater : i2 -> updF)
             (make_init : iniF).

           -- Create a scatter reducer that wraps it in an array
           let array_finalizer : UpdateInPlaceFinalizer s (array1 e) =
                 mutateAndCopy @s @(array1 e)
                 (\ (accumulator : s) (ret : OutPtr (array1 e))
                    -> Store.
                    mk_array1 @e @N lb stride count
                    (stuckBox @(arr N e)
                     (case finalizer of {
                        mutateInPlace @s @(arr N e) (co : coerce @bare s (arr N e)).
                          copy @(arr N e) (repr_arr @N @e count repr_e)
                          (coerce @s @(arr N e) accumulator)
                      ; mutateAndCopy @s @(arr N e) (f : s -> Init (arr N e)).
                          f accumulator
                      }))
                    ret) in

           -- Transform dim1 indices to linear indices
           letfun
             linearized_updater
               (f : updF) (ix : i2) (tok_in : EffTok) (ret : OutPtr s)
               -> EffTok =
               case ix of tuple2 @(Stored int) @i (arr_ix : Stored int) (val : i).
               case arr_ix of stored @int (u_arr_ix : int).

               -- Drop values whose indices are out of bounds due to alignment
               let zeroed_ix : int = u_arr_ix -# lb in
               if zeroed_ix %# stride /=# 0 then tok_in else
               let linearized_ix : int = zeroed_ix //# stride in
               case boxed @i2 (tuple2 @(Stored int) @i
                               (stored @int linearized_ix) (copy @i repr_i val)) of
                 boxed @i2 (new_ix : i2).
               updater f new_ix tok_in ret
           in

           ref @ret_type
           (mk_scatter @(array1 e) @i2 @s @iniF @updF
            repr_s
            initializer
            linearized_updater
            combiner
            array_finalizer
            make_updater
            make_init)
           ret)) of
    boxed @(Ref ret_type) (s_retval : Ref ret_type).
  case s_retval of ref @ret_type (retval : ret_type).
  retval;


barray1Scatter @(a i : bare)
  (repr_i : Repr i)
  (repr_a : Repr a)
  (dom : dim1)
  (reduction_op : Scatter (StuckRef (AsBox a)) i)
  -> Scatter (barray1 a) (Tuple2 (Stored int) i) =
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (Stored int) i in

  -- Use array1Scatter
  case array1Scatter @boxed_a @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(array1 boxed_a) @i2 @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (array1 boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with barray1
  let repr_array_a : Repr (array1 boxed_a) = repr_array1 @boxed_a in

  let barray_finalizer : UpdateInPlaceFinalizer s (barray1 a) =
        case finalizer of {
          mutateInPlace @s @(array1 boxed_a)
          (co : coerce @bare s (array1 boxed_a)).
            mutateAndCopy @s @(barray1 a)
            (\ (x : s) -> Init (barray1 a).
               mk_barray1 @a
               (copy @(array1 boxed_a) repr_array_a
                (coerce @s @(array1 boxed_a) x)))
        ; mutateAndCopy @s @(array1 boxed_a) (f : s -> Init (array1 boxed_a)).
            mutateAndCopy @s @(barray1 a)
            (\ (x : s) -> Init (barray1 a). mk_barray1 @a (f x))
        } in

  mk_scatter @(barray1 a) @i2 @s @iniF @updF repr_s initializer updater combiner
  barray_finalizer make_updater make_init;


array2Scatter @(e i : bare)
  (repr_i : Repr i)
  (repr_e : Repr e)
  (dom : dim2)
  (reduction_op : Scatter e i)
  -> Scatter (array2 e) (Tuple2 (index dim2) i) =

  let type i2 = (Tuple2 (index dim2) i) in
  let type ret_type = Scatter (array2 e) i2 in

  let repr_i2 : Repr i2 =
        repr_Tuple2 @(index dim2) @i repr_index2 repr_i in

  -- Compute array size
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case boxed @(Ref ret_type)
       (dim1ToArrayDesc @(Ref ret_type) dom_y
        (\ @(M : intindex) (lb_y : int) (stride_y : int) (count_y : FIInt M)
           (ret : OutPtr (Ref ret_type))
           -> Store.
           dim1ToArrayDesc @(Ref ret_type) dom_x
           (\ @(N : intindex) (lb_x : int) (stride_x : int) (count_x : FIInt N)
              (ret : OutPtr (Ref ret_type))
              -> Store.

              let type index_1d = Tuple2 (Stored int) i in
              let type index_2d = Tuple2 (Stored int) index_1d in

              let repr_inner_array : Repr (arr N e) =
                    repr_arr @N @e count_x repr_e in
              let repr_array : Repr (arr M (arr N e)) =
                    repr_arr @M @(arr N e) count_y repr_inner_array in
              let repr_inner_index : Repr index_1d =
                    repr_Tuple2 @(Stored int) @i repr_int repr_i in
              let repr_index : Repr index_2d =
                    repr_Tuple2 @(Stored int) @index_1d repr_int repr_inner_index in


              -- Create a plain array scatter reducer using two calls to
              -- 'arrScatter'
              let x_scatter_reduction : Scatter (arr N e) index_1d  =
                    arrScatter @N @e @i repr_i repr_e count_x reduction_op in
              let xy_scatter_reduction : Scatter (arr M (arr N e)) index_2d =
                    arrScatter @M @(arr N e) @index_1d
                    repr_inner_index repr_inner_array count_y x_scatter_reduction in

              -- Change the index to the expected data type
              -- Deconstruct the result.
              let arr_scatter_reduction : Scatter (arr M (arr N e)) i2 =
                   comapScatterIndex @(arr M (arr N e)) @index_2d @i2
                   repr_index repr_i2 repr_array
                   (\ (index_in : i2) (ret : OutPtr index_2d) -> Store.
                      case index_in of
                        tuple2 @(index dim2) @i
                        (yx : index dim2) (z : i).
                      case yx of
                        tuple2 @(Stored int) @(Stored int)
                        (y : Stored int) (x : Stored int).
                      case x of stored @int (u_x : int).
                      case y of stored @int (u_y : int).

                      tuple2 @(Stored int) @index_1d
                      (stored @int u_y)
                      (tuple2 @(Stored int) @i
                       (stored @int u_x) (copy @i repr_i z))
                      ret)
                   xy_scatter_reduction in
              case arr_scatter_reduction of
                mk_scatter @(arr M (arr N e)) @i2 @(s : bare)
                           @(iniF : box) @(updF : box)
                (repr_s : Repr s)
                (initializer : iniF -> OutPtr s -> EffTok)
                (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
                (combiner : s -> s -> Init s)
                (finalizer : UpdateInPlaceFinalizer s (arr M (arr N e)))
                (make_updater : i2 -> updF)
                (make_init : iniF).

              -- Create a scatter reducer that wraps it in an array
              let array_finalizer : UpdateInPlaceFinalizer s (array2 e) =
                    mutateAndCopy @s @(array2 e)
                    (\ (accumulator : s) (ret : OutPtr (array2 e))
                       -> Store.
                       mk_array2 @e @M @N
                       lb_y stride_y count_y lb_x stride_x count_x
                       (stuckBox @(arr M (arr N e))
                        (case finalizer of {
                           mutateInPlace @s @(arr M (arr N e)) (co : coerce @bare s (arr M (arr N e))).
                             copy @(arr M (arr N e)) repr_array
                             (coerce @s @(arr M (arr N e)) accumulator)
                         ; mutateAndCopy @s @(arr M (arr N e)) (f : s -> Init (arr M (arr N e))).
                             f accumulator
                         }))
                       ret) in

              -- Transform dim2 indices to linear indices
              letfun
                linearized_updater
                  (f : updF) (ix : i2) (tok_in : EffTok) (ret : OutPtr s)
                  -> EffTok =
                  case ix of tuple2 @(index dim2) @i
                             (arr_ix : index dim2) (val : i).
                  case arr_ix of tuple2 @(Stored int) @(Stored int)
                                 (ix_y : Stored int) (ix_x : Stored int).
                  case ix_y of stored @int (u_ix_y : int).
                  case ix_x of stored @int (u_ix_x : int).

                  -- Drop values whose indices are out of bounds due to alignment
                  let zeroed_ix_y : int = u_ix_y -# lb_y in
                  let zeroed_ix_x : int = u_ix_x -# lb_x in
                  if zeroed_ix_y %# stride_y /=# 0 then tok_in else
                  if zeroed_ix_x %# stride_x /=# 0 then tok_in else
                  let linearized_ix_y : int = zeroed_ix_y //# stride_y in
                  let linearized_ix_x : int = zeroed_ix_x //# stride_x in
                  case boxed @i2 (tuple2 @(index dim2) @i
                                  (tuple2 @(Stored int) @(Stored int)
                                   (stored @int linearized_ix_y) (stored @int linearized_ix_x))
                                  (copy @i repr_i val)) of
                    boxed @i2 (new_ix : i2).
                  updater f new_ix tok_in ret
              in

              ref @ret_type
              (mk_scatter @(array2 e) @i2 @s @iniF @updF
               repr_s
               initializer
               linearized_updater
               combiner
               array_finalizer
               make_updater
               make_init)
              ret)
           ret)) of
    boxed @(Ref ret_type) (s_retval : Ref ret_type).
  case s_retval of ref @ret_type (retval : ret_type).
  retval;


barray2Scatter @(a i : bare)
  (repr_i : Repr i)
  (repr_a : Repr a)
  (dom : dim2)
  (reduction_op : Scatter (StuckRef (AsBox a)) i)
  -> Scatter (barray2 a) (Tuple2 (index dim2) i) =
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (index dim2) i in

  -- Use array2Scatter
  case array2Scatter @boxed_a @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(array2 boxed_a) @i2 @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (array2 boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with barray2
  let repr_array_a : Repr (array2 boxed_a) = repr_array2 @boxed_a in

  let barray_finalizer : UpdateInPlaceFinalizer s (barray2 a) =
        case finalizer of {
          mutateInPlace @s @(array2 boxed_a)
          (co : coerce @bare s (array2 boxed_a)).
            mutateAndCopy @s @(barray2 a)
            (\ (x : s) -> Init (barray2 a).
               mk_barray2 @a
               (copy @(array2 boxed_a) repr_array_a
                (coerce @s @(array2 boxed_a) x)))
        ; mutateAndCopy @s @(array2 boxed_a) (f : s -> Init (array2 boxed_a)).
            mutateAndCopy @s @(barray2 a)
            (\ (x : s) -> Init (barray2 a). mk_barray2 @a (f x))
        } in

  mk_scatter @(barray2 a) @i2 @s @iniF @updF repr_s initializer updater combiner
  barray_finalizer make_updater make_init;


array3Scatter @(e i : bare)
  (repr_i : Repr i)
  (repr_e : Repr e)
  (dom : dim3)
  (reduction_op : Scatter e i)
  -> Scatter (array3 e) (Tuple2 (index dim3) i) =

  let type i3 = (Tuple2 (index dim3) i) in
  let type ret_type = Scatter (array3 e) i3 in

  let repr_i3 : Repr i3 =
        repr_Tuple2 @(index dim3) @i repr_index3 repr_i in

  -- Compute array size
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case boxed @(Ref ret_type)
       (dim1ToArrayDesc @(Ref ret_type) dom_z
        (\ @(L : intindex) (lb_z : int) (stride_z : int) (count_z : FIInt L)
           (ret : OutPtr (Ref ret_type))
           -> Store.
           dim1ToArrayDesc @(Ref ret_type) dom_y
           (\ @(M : intindex) (lb_y : int) (stride_y : int) (count_y : FIInt M)
              (ret : OutPtr (Ref ret_type))
              -> Store.
              dim1ToArrayDesc @(Ref ret_type) dom_x
              (\ @(N : intindex) (lb_x : int) (stride_x : int) (count_x : FIInt N)
                 (ret : OutPtr (Ref ret_type))
                 -> Store.

                 let type index_1d = Tuple2 (Stored int) i in
                 let type index_2d = Tuple2 (Stored int) index_1d in
                 let type index_3d = Tuple2 (Stored int) index_2d in
                 let type arr1d = arr N e in
                 let type arr2d = arr M arr1d in
                 let type arr3d = arr L arr2d in

                 let repr_inner_array : Repr arr1d =
                       repr_arr @N @e count_x repr_e in
                 let repr_plane : Repr arr2d =
                       repr_arr @M @arr1d count_y repr_inner_array in
                 let repr_array : Repr arr3d =
                       repr_arr @L @arr2d count_z repr_plane in
                 let repr_inner_index : Repr index_1d =
                       repr_Tuple2 @(Stored int) @i repr_int repr_i in
                 let repr_plane_index : Repr index_2d =
                       repr_Tuple2 @(Stored int) @index_1d repr_int repr_inner_index in
                 let repr_index : Repr index_3d =
                       repr_Tuple2 @(Stored int) @index_2d repr_int repr_plane_index in

                 -- Create a plain array scatter reducer using three calls to
                 -- 'arrScatter'
                 let x_scatter_reduction : Scatter arr1d index_1d  =
                       arrScatter @N @e @i repr_i repr_e count_x reduction_op in
                 let xy_scatter_reduction : Scatter arr2d index_2d =
                       arrScatter @M @arr1d @index_1d
                       repr_inner_index repr_inner_array count_y x_scatter_reduction in
                 let xyz_scatter_reduction : Scatter arr3d index_3d =
                       arrScatter @L @arr2d @index_2d
                       repr_plane_index repr_plane count_z xy_scatter_reduction in

                 -- Change the index to the expected data type
                 -- Deconstruct the result.
                 let arr_scatter_reduction : Scatter arr3d i3 =
                      comapScatterIndex @arr3d @index_3d @i3
                      repr_index repr_i3 repr_array
                      (\ (index_in : i3) (ret : OutPtr index_3d) -> Store.
                         case index_in of
                           tuple2 @(index dim3) @i
                           (zyx : index dim3) (val : i).
                         case zyx of
                           tuple3 @(Stored int) @(Stored int) @(Stored int)
                           (z : Stored int) (y : Stored int) (x : Stored int).
                         case z of stored @int (u_z : int).
                         case x of stored @int (u_x : int).
                         case y of stored @int (u_y : int).

                         tuple2 @(Stored int) @index_2d
                         (stored @int u_z)
                         (tuple2 @(Stored int) @index_1d
                          (stored @int u_y)
                          (tuple2 @(Stored int) @i
                           (stored @int u_x) (copy @i repr_i val)))
                         ret)
                      xyz_scatter_reduction in
                 case arr_scatter_reduction of
                   mk_scatter @arr3d @i3 @(s : bare) @(iniF : box) @(updF : box)
                   (repr_s : Repr s)
                   (initializer : iniF -> OutPtr s -> EffTok)
                   (updater : updF -> i3 -> EffTok -> OutPtr s -> EffTok)
                   (combiner : s -> s -> Init s)
                   (finalizer : UpdateInPlaceFinalizer s arr3d)
                   (make_updater : i3 -> updF)
                   (make_init : iniF).

                 -- Create a scatter reducer that wraps it in an array
                 let array_finalizer : UpdateInPlaceFinalizer s (array3 e) =
                       mutateAndCopy @s @(array3 e)
                       (\ (accumulator : s) (ret : OutPtr (array3 e))
                          -> Store.
                          mk_array3 @e @L @M @N
                          lb_z stride_z count_z
                          lb_y stride_y count_y
                          lb_x stride_x count_x
                          (stuckBox @arr3d
                           (case finalizer of {
                              mutateInPlace @s @arr3d (co : coerce @bare s arr3d).
                                copy @arr3d repr_array
                                (coerce @s @arr3d accumulator)
                            ; mutateAndCopy @s @arr3d (f : s -> Init arr3d).
                                f accumulator
                            }))
                          ret) in

                 -- Transform dim3 indices to linear indices
                 letfun
                   linearized_updater
                     (f : updF) (ix : i3) (tok_in : EffTok) (ret : OutPtr s)
                     -> EffTok =
                     case ix of tuple2 @(index dim3) @i
                                (arr_ix : index dim3) (val : i).
                     case arr_ix of tuple3 @(Stored int) @(Stored int) @(Stored int)
                                    (ix_z : Stored int) (ix_y : Stored int) (ix_x : Stored int).
                     case ix_z of stored @int (u_ix_z : int).
                     case ix_y of stored @int (u_ix_y : int).
                     case ix_x of stored @int (u_ix_x : int).

                     -- Drop values whose indices are out of bounds due to alignment
                     let zeroed_ix_z : int = u_ix_z -# lb_z in
                     let zeroed_ix_y : int = u_ix_y -# lb_y in
                     let zeroed_ix_x : int = u_ix_x -# lb_x in
                     if zeroed_ix_z %# stride_z /=# 0 then tok_in else
                     if zeroed_ix_y %# stride_y /=# 0 then tok_in else
                     if zeroed_ix_x %# stride_x /=# 0 then tok_in else
                     let linearized_ix_z : int = zeroed_ix_z //# stride_z in
                     let linearized_ix_y : int = zeroed_ix_y //# stride_y in
                     let linearized_ix_x : int = zeroed_ix_x //# stride_x in
                     case boxed @i3 (tuple2 @(index dim3) @i
                                     (tuple3 @(Stored int) @(Stored int) @(Stored int)
                                      (stored @int linearized_ix_z)
                                      (stored @int linearized_ix_y)
                                      (stored @int linearized_ix_x))
                                     (copy @i repr_i val)) of
                       boxed @i3 (new_ix : i3).
                     updater f new_ix tok_in ret
                 in

                 ref @ret_type
                 (mk_scatter @(array3 e) @i3 @s @iniF @updF
                  repr_s
                  initializer
                  linearized_updater
                  combiner
                  array_finalizer
                  make_updater
                  make_init)
                 ret)
              ret)
            ret)) of
    boxed @(Ref ret_type) (s_retval : Ref ret_type).
  case s_retval of ref @ret_type (retval : ret_type).
  retval;


barray3Scatter @(a i : bare)
  (repr_i : Repr i)
  (repr_a : Repr a)
  (dom : dim3)
  (reduction_op : Scatter (StuckRef (AsBox a)) i)
  -> Scatter (barray3 a) (Tuple2 (index dim3) i) =
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (index dim3) i in

  -- Use array3Scatter
  case array3Scatter @boxed_a @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(array3 boxed_a) @i2 @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (array3 boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with barray3
  let repr_array_a : Repr (array3 boxed_a) = repr_array3 @boxed_a in

  let barray_finalizer : UpdateInPlaceFinalizer s (barray3 a) =
        case finalizer of {
          mutateInPlace @s @(array3 boxed_a)
          (co : coerce @bare s (array3 boxed_a)).
            mutateAndCopy @s @(barray3 a)
            (\ (x : s) -> Init (barray3 a).
               mk_barray3 @a
               (copy @(array3 boxed_a) repr_array_a
                (coerce @s @(array3 boxed_a) x)))
        ; mutateAndCopy @s @(array3 boxed_a) (f : s -> Init (array3 boxed_a)).
            mutateAndCopy @s @(barray3 a)
            (\ (x : s) -> Init (barray3 a). mk_barray3 @a (f x))
        } in

  mk_scatter @(barray3 a) @i2 @s @iniF @updF repr_s initializer updater combiner
  barray_finalizer make_updater make_init;


-- Using the contents of a 'Scatter' object, perform part of a scatter
-- operation sequentially on a list_dim.  Return the scatter state.

Sequence_partial_scatter @(i s : bare) @(iniF updF : box)
  (repr_i : Repr i) (repr_s : Repr s)
  (initializer : iniF -> OutPtr s -> EffTok)
  (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
  (make_updater : i -> updF)
  (make_init : iniF)
  (src : Sequence i)
  (ret : OutPtr s)
  -> Store
  attribute(inline, inline_sequential) =

  let type SEff = Stored EffTok in

   -- Initialize the output
   case boxed @SEff (stored @EffTok (initializer make_init ret)) of
     boxed @SEff (init_eff_tok : SEff).

   case boxed @SEff
        (Sequence_fold @i @SEff
         repr_i repr_EffTok
         (\ (x : SEff) (y : i) (loop_ret : OutPtr SEff) -> Store.
            case x of stored @EffTok (x_u : EffTok).
            stored @EffTok (updater (make_updater y) y x_u ret) loop_ret)
            init_eff_tok
            src) of
     boxed @SEff (s_final_eff_tok : SEff).

   -- Translate to a return value
   case s_final_eff_tok of stored @EffTok (final_eff_tok : EffTok).
   fromEffTok @s final_eff_tok;


-- Using the contents of a 'Scatter' object, perform part of a scatter
-- operation sequentially on a list_dim.  Return the scatter state.

partial_list_dim_scatter @(i s : bare) @(iniF updF : box)
  (repr_i : Repr i) (repr_s : Repr s)
  (initializer : iniF -> OutPtr s -> EffTok)
  (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
  (make_updater : i -> updF)
  (make_init : iniF)
  (dom : list_dim)
  (f : Stored int -> Init i)
  (ret : OutPtr s)
  -> Store
  attribute(inline, inline_sequential) =

  let type SEff = Stored EffTok in

  -- Initialize the output
  case boxed @SEff (stored @EffTok (initializer make_init ret)) of
     boxed @SEff (init_eff_tok : SEff).

   -- Sequential in-place update
   case boxed @SEff
        (primitive_list_dim_fold @SEff
         repr_EffTok dom
         (\ (index : Stored int) (x : SEff) (loop_ret : OutPtr SEff) -> Store.
            case x of stored @EffTok (x_u : EffTok).

            -- Compute a value
            case stuckBox @i (f index) of stuckBox @i (y : i).

            -- Perform an update
            stored @EffTok (updater (make_updater y) y x_u ret) loop_ret)
         init_eff_tok) of
     boxed @SEff (s_final_eff_tok : Stored EffTok).

   -- Translate to a return value
   case s_final_eff_tok of stored @EffTok (final_eff_tok : EffTok).
   fromEffTok @s final_eff_tok;


finish_scatter @(r s : bare) 
  (rep_r : Repr r)
  (rep_s : Repr s)
  (finalizer : UpdateInPlaceFinalizer s r)
  (w : Init s)
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_sequential) =

  case finalizer of {
    mutateInPlace @s @r (co : coerce @bare s r).
      (coerce @(Init s) @(Init r) w) ret

  ; mutateAndCopy @s @r (f : s -> Init r).
      case boxed @s w of boxed @s (tmp : s).
      f tmp ret
  };

-------------------------------------------------------------------------------
-- Sets of integers

-- A set of integers, represented as a hash table.
-- The hash table consists of an array of integers and an array
-- of linked list indices (used for collisions).
data intset : bare
{
  mk_intset (N : intindex) (FIInt N,
                            StuckBox (Tuple2 (arr N (Stored int))
                                             (arr N (Stored uint))));
};

build_intset (ls : list (Stored int)) (ret : OutPtr intset)
  -> Store attribute(inline) =
  case ls of
    make_list @(Stored int) @(N : intindex)
              (list_size : FIInt N) (barr : StuckBox (arr N (Stored int))).
  case barr of stuckBox @(arr N (Stored int)) (a : arr N (Stored int)).

  -- Compute size of hash table
  let table_count : int = compute_hash_table_size @N list_size in

  case defineIntIndex table_count of
    someIInt @(M : intindex) (table_size : FIInt M).

  -- Create hash table
  let type HT = Tuple2 (arr M (Stored int)) (arr M (Stored uint)) in
  let hash_table : StuckBox HT =
   stuckBox @HT (build_hash_table @N @M list_size table_size a) in

  mk_intset @M table_size hash_table ret;


compute_hash_table_size : (N : intindex) -> FIInt N -> int;
build_hash_table : (N M : intindex)
                -> FIInt N -> FIInt M
                -> arr N (Stored int)
                -> Init (Tuple2 (arr M (Stored int)) (arr M (Stored uint)));

intsetLookup (set : intset) (key : int) (ret : OutPtr (Maybe (Stored int)))
  -> Store attribute(inline) =

  case set of
    mk_intset @(N : intindex)
              (size : FIInt N)
              (contents : StuckBox (Tuple2 (arr N (Stored int))
                                           (arr N (Stored uint)))).
  case contents of
    stuckBox @(Tuple2 (arr N (Stored int)) (arr N (Stored uint)))
    (tuple : Tuple2 (arr N (Stored int)) (arr N (Stored uint))).
  case tuple of
    tuple2 @(arr N (Stored int)) @(arr N (Stored uint))
    (keys_array : arr N (Stored int))
    (inds_array : arr N (Stored uint)).

  let index : int = lookup_hash_table @N size keys_array inds_array key in
  if index ==# -1
  then nothing @(Stored int) ret
  else just @(Stored int) (stored @int index) ret;


lookup_hash_table : (N : intindex)
                 -> FIInt N
                 -> arr N (Stored int)
                 -> arr N (Stored uint)
                 -> int
                 -> int;

intsetElements (set : intset) -> Stream1 (Stored int) attribute(inline) =
   case set of
    mk_intset @(N : intindex)
              (size : FIInt N)
              (contents : StuckBox (Tuple2 (arr N (Stored int))
                                           (arr N (Stored uint)))).
  case size of fiInt @N (count : int).
  case contents of
    stuckBox @(Tuple2 (arr N (Stored int)) (arr N (Stored uint)))
    (tuple : Tuple2 (arr N (Stored int)) (arr N (Stored uint))).
  case tuple of
    tuple2 @(arr N (Stored int)) @(arr N (Stored uint))
    (keys_array : arr N (Stored int))
    (inds_array : arr N (Stored uint)).

  -- For each array element
  let dom : list_dim = mk_list_dim (justVal @int count) in

  sequenceStream @(Stored int)
  (Sequence_generate_bind @(Stored int) dom
   (\ (si : Stored int) -> Sequence (Stored int).

     case si of stored @int (i : int).

     -- Check inds_array to determine if the i_th element of keys_array
     -- holds a key
     case subscript @N @(Stored uint)
          (reprSizeAlign @(Stored uint) repr_uint) inds_array i
       of stored @uint (indirection : uint).

     if oper_BITWISEAND (uint_to_int indirection) 1 ==# 1
     then case subscript @N @(Stored int)
          (reprSizeAlign @(Stored int) repr_int) keys_array i
            of stored @int (key : int).
          Sequence_return @(Stored int) repr_int (stored @int key)
     else Sequence_empty @(Stored int) repr_int));

-------------------------------------------------------------------------------
-- Trees of lists

-- Trees of lists.  These are used as temporary data structures
-- when constructing irregular arrays.
--
-- Invariant: 'pbBranch' never contains 'pbEmpty'.
data PBTree (a : bare) : box
{
  -- A branch with two children.
  -- The 'int' is the total number of list elements in its leaves.
  pbBranch () (int, PBTree a, PBTree a);
  pbLeaf () (list a);
  pbEmpty () ();
};


-- Get the number of 'a's in a PBtree 
PBTree_size @(a : bare) (t : PBTree a) -> int =
  case t of {
    pbLeaf @a (l : list a).
      case l of
        make_list @a @(n : intindex) (len : FIInt n) (b : StuckBox (arr n a)).
      case len of fiInt @n (i : int).
      i
  ; pbBranch @a (i : int) (t1 : PBTree a) (t2 : PBTree a).
      i
  ; pbEmpty @a.
      0
  };


-- Create a new branch, computing the number of 'a's in the branch.
-- Do not create a branch if one of the leaves is empty.
PBTree_branch @(a : bare) (ta : PBTree a) (tb : PBTree a) -> PBTree a =
  let tot_sz : int = PBTree_size @a ta +# PBTree_size @a tb in
  letfun both (x : NoneType) -> PBTree a = pbBranch @a tot_sz ta tb in
  letfun
    k1 (empty : NoneType) -> PBTree a =
      case tb of {
        pbEmpty @a. ta
      ; pbLeaf @a (l : list a). both None
      ; pbBranch @a (n : int) (e_ta : PBTree a) (e_tb : PBTree a). both None
      } in
  case ta of {
    pbEmpty @a. tb
  ; pbLeaf @a (l : list a). k1 None
  ; pbBranch @a (n : int) (e_ta : PBTree a) (e_tb : PBTree a). k1 None
  };


-- Flatten a PBTree to a list.  The list contains the elements of the PBTree
-- in the same order.
PBTree_flatten @(a : bare)
  (rep : Repr a) (tree : PBTree a) (ret : OutPtr (list a)) -> Store
  attribute(inline) =
  -- Get the list size
  case defineIntIndex (PBTree_size @a tree) of
    someIInt @(n : intindex) (out_list_dim : FIInt n).

  letfun
    -- Copy the given subtree to the output, at the given offset
    storeTreeVal (new_ind : int) (t : PBTree a) (ret_p : OutPtr (arr n a)) -> Store =
      let ind : int = new_ind in
      case t of {
        pbEmpty @a.
          fromEffTok @a emptyEffTok

      ; pbBranch @a (e_i : int) (ta : PBTree a) (tb : PBTree a).
          let ta_sz : int = PBTree_size @a ta in
          fromEffTok @a
          (seqEffTok (toEffTok @a (storeTreeVal new_ind ta ret_p))
                     (toEffTok @a (storeTreeVal (new_ind +# ta_sz) tb ret_p)))

      ; pbLeaf @a (tree_list : list a).
          case tree_list of make_list @a @(m : intindex) (tree_list_dim : FIInt m) (list_sb : StuckBox (arr m a)).
          case list_sb of stuckBox @(arr m a) (tree_list_array : (arr m a)).
          case rep of
            repr @a
            (sa : SizeAlign a)
            (copy_a : a -> Init a)
            (to_boxed_a : Init a -> AsBox a)
            (to_bare_a : AsBox a -> Init a)
            (pointerless_a : bool).

          doall @m @a @a tree_list_dim
          (\ (i : int) -> Store.
            copy @a rep
            (subscript @m @a sa tree_list_array i)
            (subscript_out @n @a sa ret_p (i +# ind)))
      } in

  -- Create a new list.
  -- In parallel, copy results into the list.
  make_list @a @n out_list_dim
  (stuckBox @(arr n a)
   (\ (ret_p : OutPtr (arr n a)) -> Store.
     blocked_PBTree_doall @a @(list a) tree
     (\ (i : int) (t : PBTree a) -> Store.
     storeTreeVal i t ret_p)))
  ret;
  
  

-------------------------------------------------------------------------------
-- Streams

-- A dynamically computed sequence of values, possibly with run-time
-- shape information.
type Stream : box -> bare -> box;

-- A 1-dimensional stream of values, represented either as a
-- view or as a linear stream.
data Stream1 (a : bare) : box
{
  sequenceStream () (Sequence a);
  viewStream () (view list_dim a);
};

-- A dynamically computed sequence of values.
data Sequence (a : bare) : box
{
  -- A stream is a (state, generator) pair.
  sequence (st : box) (st, st -> StreamNext st a);
};

-- The result of attempting to pull a value from a stream.
data StreamNext (st : box) (a : bare) : val
{
  streamEmpty () ();
  streamValue () (st, AsBox a);
};

-- The state of the stream 'bind' operator
data BindState (src_st : box) (src_elt trans_elt : bare) : box
{
  -- Pull the next value from the source stream
  -- (Also represents a depleted stream)
  bindFromSource () (src_st);

  -- Pull the next value from the stream transformer
  bindFromTrans (trans_st : box)
    (src_st,
     trans_st,
     trans_st -> StreamNext trans_st trans_elt);
};

-- State of a chained stream
data ChainState (a b : box) : box
{
  chainFromFirst () (a, b);
  chainFromNext () (b);
};



-------------------------------------------------------------------------------
-- Views

--  A view is a container represented by a function
data view (sh : box) (a : bare) : box
{
  mk_view () (sh, index sh -> Init a);
};

-------------------------------------------------------------------------------
-- Storage

data list (a : bare) : bare
{
  make_list (n : intindex)
  (FIInt n, StuckBox (arr n a));
};

-- A list of boxed objects
data blist (a : bare): bare
{
  make_blist () (list (StuckRef (AsBox a)));
};

-- A list with extra fields supporting a mutable "append" operation.
-- The 'FIInt n' field is the actual array size.
-- The int field is the number of valid array elements.  Other elements are
-- zeroed.
-- Mutable operations are implemented in low-level code.
data append_list (a : bare) : bare
{
  make_append_list (n : intindex)
  (FIInt n, int, StuckBox (arr n a));
};

-- An array type, parameterized over its dimension.
-- The array type contains its bounds.
type array : bare -> bare -> bare;

-- A singleton container
data array0 (a : bare) : bare
{
  mk_array0 () (StuckBox a);
};

-- A 1D array.
-- The array's domain is described by a lower bound, stride, and size.
data array1 (a : bare) : bare
{
  mk_array1 (N : intindex)
  (int, int, FIInt N, StuckBox (arr N a));
};

-- A 2D array.
-- The array's domain is described by a lower bound, stride, and size in
-- the Y dimension, and a lower bound, stride, and size in the X dimension.
data array2 (a : bare) : bare
{
  mk_array2 (M N : intindex)
  (int, int, FIInt M, int, int, FIInt N, StuckBox (arr M (arr N a)));
};

-- A 3D array.
-- The array's domain is described by a lower bound, stride, and size in
-- the Z, Y, and X dimensions.
data array3 (a : bare) : bare
{
  mk_array3 (L M N : intindex)
  (int, int, FIInt L,
   int, int, FIInt M,
   int, int, FIInt N,
   StuckBox (arr L (arr M (arr N a))));
};

-- A 1D boxed array.
data barray1 (a : bare) : bare
{
  mk_barray1 () (array1 (StuckRef (AsBox a)));
};

-- A 2D boxed array.
data barray2 (a : bare) : bare
{
  mk_barray2 () (array2 (StuckRef (AsBox a)));
};

-- A 3D boxed array.
data barray3 (a : bare) : bare
{
  mk_barray3 () (array3 (StuckRef (AsBox a)));
};

-- Convert the "size" fields of an array to an equivalent dim1.
arrayDescToDim1 @(N : intindex) (lb : int) (stride : int) (size : FIInt N)
  -> dim1 attribute(inline) =
  case size of fiInt @N (size_i : int).

  let ub : int = lb +# stride *# size_i in
  mk_dim1 (interval (justVal @int lb) (justVal @int ub)) (linearMap stride lb);


-- Convert a dim1 to the equivalent "size" fields of an array.
dim1ToArrayDesc @(a : bare)
  (shp : dim1)
  (k : (N : intindex) -> int -> int -> FIInt N -> Init a)
  (ret : OutPtr a)
  -> Store attribute(inline) =

  case shp of mk_dim1 (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal @int (lb_i : int).
      case ub of {
        justVal @int (ub_i : int).
          case m of linearMap (stride : int) (alignment : int).
          let size_i : int = (ub_i -# lb_i) //# stride in
          case defineIntIndex size_i of
            someIInt @(N : intindex) (size : FIInt N).
          k @N lb_i stride size ret
      ; nothingVal @int.
          except @Store
      }
  ; nothingVal @int.
      except @Store
  };


-------------------------------------------------------------------------------
-- Shapes

-- Get the stream shape corresponding to a container
type shape : (bare -> bare) -> box;

-- The shape of a list stream.
-- 'Nothing' is an infinite stream; otherwise the shape is the length.
data list_dim : box
{
  mk_list_dim () (MaybeVal int);
};

-- The shape of a singleton stream
data dim0 : box
{
  mk_dim0 () ();
};

-- A one-dimensional domain.
-- The domain is the intersection of an interval and a linear map's range.
--
-- Invariants:
-- The interval's lower and upper bounds are in the range of the linear map.
-- The linear map's stride is positive.
-- The linear map's alignment may be anything; it's not constrained to be a
-- small positive number.
data dim1 : box
{
  mk_dim1 () (Interval, LinearMap);
};

-- A two-dimensional domain.  The cross product of two domains.
data dim2 : box
{
  mk_dim2 () (dim1, dim1);
};

-- A three-dimensional domain.  The cross product of three domains.
data dim3 : box
{
  mk_dim3 () (dim1, dim1, dim1);
};

-- The shape of an array stream.
-- Array streams are zero-indexed.
data arr_shape (n : intindex) (sh : box) : box
{
  mk_arr_shape () (sh);
};

shapeIndexRepr : (sh : box) -> ShapeDict sh -> Repr (index sh);
shapeSliceRepr : (sh : box) -> ShapeDict sh -> Repr (slice sh);

-------------------------------------------------------------------------------
-- Representation dictionaries

copy @(a : bare) (rep : Repr a) (src : a) (dst : OutPtr a) -> Store
  attribute(conlike, inline, inline_postfinal) =

  case rep of
    repr @a 
    (sa : SizeAlign a)
    (copy_a : a -> Init a)
    (to_boxed_a : Init a -> AsBox a)
    (to_bare_a : AsBox a -> Init a)
    (pointerless_a : bool).

  copy_a src dst;

asbox : (a : bare) -> Repr a -> Init a -> AsBox a;
asbare : (a : bare) -> Repr a -> AsBox a -> Init a;


reprSizeAlign @(a : bare) (rep : Repr a) -> SizeAlign a
  attribute(inline) =

  case rep of
    repr @a
    (sa : SizeAlign a)
    (copy_a : a -> Init a)
    (to_boxed_a : Init a -> AsBox a)
    (to_bare_a : AsBox a -> Init a)
    (pointerless_a : bool).

  sa;


dynamicCopyError @(a : bare) (x : a) (ret : OutPtr a) -> Store
  attribute(inline) =
  except @Store;

-- Copy an array.  Use a loop to copy individual array elements.
copyArray @(N : intindex) @(a : bare)
  (rep : Repr a) (size : IInt N) (src : arr N a) (ret : OutPtr (arr N a))
  -> Store
  attribute(inline) =
  case rep of
    repr @a
    (sa : SizeAlign a)
    (copy_a : a -> Init a)
    (to_boxed_a : Init a -> AsBox a)
    (to_bare_a : AsBox a -> Init a)
    (pointerless_a : bool).

  case size of {
    iInt @N (fsize : FIInt N).
      -- Copy each item in a loop
      doall @N @a @a fsize
      (\ (i : int) -> Store.
        copy @a rep
        (subscript @N @a sa src i)
        (subscript_out @N @a sa ret i))
  ; iPosInfty @N. except @Store
  ; iNegInfty @N. except @Store
  };

-- This function is inserted by the simplifier to convert data constructor
-- applications to values
reify : (a : bare) -> Repr a -> Init a -> a;

sizealign_int : SizeAlign (Stored int);
sizealign_uint : SizeAlign (Stored uint);
sizealign_float : SizeAlign (Stored float);
sizealign_bool : SizeAlign (Stored bool);
sizealign_NoneType : SizeAlign (Stored NoneType);
sizealign_EffTok : SizeAlign (Stored EffTok);
sizealign_Ref : (a : box) -> SizeAlign (Ref a);
sizealign_StuckRef : (a : box) -> SizeAlign (StuckRef a);

copy_int (src : Stored int) (ret : OutPtr (Stored int)) -> Store
  attribute(inline) =
  case src of stored @int (x : int). stored @int x ret;

box_int (x : Init (Stored int)) -> Boxed (Stored int)
  attribute(inline) =
  boxed @(Stored int) x;

unbox_int (x : Boxed (Stored int)) (ret : OutPtr (Stored int)) -> Store
  attribute(inline) =
  case x of boxed @(Stored int) (sf : Stored int).
  case sf of stored @int (x : int). stored @int x ret;

repr_int : Repr (Stored int) attribute(inline, inline_final) =
  repr @(Stored int) sizealign_int copy_int box_int unbox_int True;

copy_uint (src : Stored uint) (ret : OutPtr (Stored uint)) -> Store
  attribute(inline) =
  case src of stored @uint (x : uint). stored @uint x ret;

box_uint (x : Init (Stored uint)) -> Boxed (Stored uint)
  attribute(inline) =
  boxed @(Stored uint) x;

unbox_uint (x : Boxed (Stored uint)) (ret : OutPtr (Stored uint)) -> Store
  attribute(inline) =
  case x of boxed @(Stored uint) (sf : Stored uint).
  case sf of stored @uint (x : uint). stored @uint x ret;

repr_uint : Repr (Stored uint) attribute(inline, inline_final) =
  repr @(Stored uint) sizealign_uint copy_uint box_uint unbox_uint True;

copy_float (src : Stored float) (ret : OutPtr (Stored float)) -> Store
  attribute(inline) =
  case src of stored @float (x : float). stored @float x ret;

box_float (x : Init (Stored float)) -> Boxed (Stored float)
  attribute(inline) =
  boxed @(Stored float) x;

unbox_float (x : Boxed (Stored float)) (ret : OutPtr (Stored float)) -> Store
  attribute(inline) =
  case x of boxed @(Stored float) (sf : Stored float).
  case sf of stored @float (x : float). stored @float x ret;

repr_float : Repr (Stored float) attribute(inline, inline_final) =
  repr @(Stored float) sizealign_float copy_float box_float unbox_float True;

repr_bool : Repr (Stored bool);
repr_NoneType : Repr (Stored NoneType);
repr_FIInt : (n : intindex) -> Repr (Stored (FIInt n));
repr_SliceObject : Repr SliceObject;
repr_list_dim : Repr (Ref list_dim);
repr_dim0 : Repr (Ref dim0);
repr_dim1 : Repr (Ref dim1);
repr_dim2 : Repr (Ref dim2);
repr_dim3 : Repr (Ref dim3);

repr_index2 : Repr (Tuple2 (Stored int) (Stored int)) =
  repr_Tuple2 @(Stored int) @(Stored int) repr_int repr_int;

repr_slice2 : Repr (Tuple2 SliceObject SliceObject) =
  repr_Tuple2 @SliceObject @SliceObject repr_SliceObject repr_SliceObject;

repr_index3 : Repr (Tuple3 (Stored int) (Stored int) (Stored int)) =
  repr_Tuple3 @(Stored int) @(Stored int) @(Stored int)
  repr_int repr_int repr_int;

repr_slice3 : Repr (Tuple3 SliceObject SliceObject SliceObject) =
  repr_Tuple3 @SliceObject @SliceObject @SliceObject
  repr_SliceObject repr_SliceObject repr_SliceObject;

repr_append_list @(a : bare) (rep : Repr a) -> Repr (append_list a)
  attribute(inline, inline_postfinal) =

  letfun
    copy_append_list (src : append_list a) (dst : OutPtr (append_list a)) -> Store =
      case src of
        make_append_list @a @(N : intindex)
        (capacity : FIInt N) (size : int) (arr : StuckBox (arr N a)).

      make_append_list @a @N capacity size arr dst
  in

  repr @(append_list a) (sizealign_append_list @a)
  copy_append_list
  (\ (x : Init (append_list a)) -> Boxed (append_list a).
    boxed @(append_list a) x)
  (\ (x : Boxed (append_list a)) (ret : OutPtr (append_list a)) -> Store.
    case x of boxed @(append_list a) (y : append_list a). copy_append_list y ret)
  False;

copy_ListBuilder @(a : bare)
  (src : Stored (ListBuilder a)) (ret : OutPtr (Stored (ListBuilder a))) -> Store
  attribute(inline) =
  case src of stored @(ListBuilder a) (x : ListBuilder a). stored @(ListBuilder a) x ret;

box_ListBuilder @(a : bare) (x : Init (Stored (ListBuilder a)))
  -> Boxed (Stored (ListBuilder a))
  attribute(inline) =
  boxed @(Stored (ListBuilder a)) x;

unbox_ListBuilder @(a : bare) (x : Boxed (Stored (ListBuilder a)))
  (ret : OutPtr (Stored (ListBuilder a))) -> Store
  attribute(inline) =
  case x of boxed @(Stored (ListBuilder a)) (sf : Stored (ListBuilder a)).
  case sf of stored @(ListBuilder a) (x : ListBuilder a). stored @(ListBuilder a) x ret;

repr_ListBuilder @(a : bare) -> Repr (Stored (ListBuilder a))
  attribute(inline, inline_postfinal) =
  repr @(Stored (ListBuilder a))
  (sizealign_ListBuilder @a)
  (copy_ListBuilder @a)
  (box_ListBuilder @a)
  (unbox_ListBuilder @a)
  False;

repr_array0 @(a : bare) -> Repr (array0 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array0 a) (ret : OutPtr (array0 a)) -> Store =
    case x of
      mk_array0 @a (arr_ref : StuckBox a). mk_array0 @a arr_ref ret
  in

  repr @(array0 a) (sizealign_array0 @a) copy_array
  (\ (x : Init (array0 a)) -> Boxed (array0 a).
    boxed @(array0 a) x)
  (\ (x : Boxed (array0 a)) (ret : OutPtr (array0 a)) -> Store.
     case x of boxed @(array0 a) (ux : array0 a). copy_array ux ret)
  False;


repr_array1 @(a : bare) -> Repr (array1 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array1 a) (ret : OutPtr (array1 a)) -> Store =
     case x of
       mk_array1 @a @(N : intindex)
       (lb : int) (stride : int) (count : FIInt N)
       (arr_ref : StuckBox (arr N a)).

     mk_array1 @a @N lb stride count arr_ref ret
  in

  repr @(array1 a) (sizealign_array1 @a) copy_array
  (\ (x : Init (array1 a)) -> Boxed (array1 a).
    boxed @(array1 a) x)
  (\ (x : Boxed (array1 a)) (ret : OutPtr (array1 a)) -> Store.
     case x of boxed @(array1 a) (ux : array1 a). copy_array ux ret)
  False;


repr_array2 @(a : bare) -> Repr (array2 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array2 a) (ret : OutPtr (array2 a)) -> Store =
     case x of
       mk_array2 @a @(M N : intindex)
       (lb_y : int) (stride_y : int) (count_y : FIInt M)
       (lb_x : int) (stride_x : int) (count_x : FIInt N)
       (arr_ref : StuckBox (arr M (arr N a))).

     mk_array2 @a @M @N lb_y stride_y count_y lb_x stride_x count_x arr_ref ret
  in

  repr @(array2 a) (sizealign_array2 @a) copy_array
  (\ (x : Init (array2 a)) -> Boxed (array2 a).
    boxed @(array2 a) x)
  (\ (x : Boxed (array2 a)) (ret : OutPtr (array2 a)) -> Store.
     case x of boxed @(array2 a) (ux : array2 a). copy_array ux ret)
  False;


repr_array3 @(a : bare) -> Repr (array3 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array3 a) (ret : OutPtr (array3 a)) -> Store =
     case x of
       mk_array3 @a @(L M N : intindex)
       (lb_z : int) (stride_z : int) (count_z : FIInt L)
       (lb_y : int) (stride_y : int) (count_y : FIInt M)
       (lb_x : int) (stride_x : int) (count_x : FIInt N)
       (arr_ref : StuckBox (arr L (arr M (arr N a)))).

     mk_array3 @a @L @M @N lb_z stride_z count_z lb_y stride_y count_y lb_x stride_x count_x arr_ref ret
  in

  repr @(array3 a) (sizealign_array3 @a) copy_array
  (\ (x : Init (array3 a)) -> Boxed (array3 a).
    boxed @(array3 a) x)
  (\ (x : Boxed (array3 a)) (ret : OutPtr (array3 a)) -> Store.
     case x of boxed @(array3 a) (ux : array3 a). copy_array ux ret)
  False;


repr_list @(a : bare) -> Repr (list a)
  attribute(inline, inline_postfinal) =

  letfun copy_list (x : list a) (ret : OutPtr (list a)) -> Store =
     case x of
       make_list @a @(N : intindex)
       (count : FIInt N) (arr_ref : StuckBox (arr N a)).

     make_list @a @N count arr_ref ret
  in

  repr @(list a) (sizealign_list @a) copy_list
  (\ (x : Init (list a)) -> Boxed (list a). boxed @(list a) x)
  (\ (x : Boxed (list a)) (ret : OutPtr (list a)) -> Store.
     case x of boxed @(list a) (ux : list a). copy_list ux ret)
  False;
  

repr_llist : (a : bare) -> Repr (Ref (llist a));


repr_barray1 @(a : bare) -> Repr (barray1 a)
  attribute(inline, inline_postfinal) =

  let type a_ref = StuckRef (AsBox a) in

  letfun copy_array (x : barray1 a) (ret : OutPtr (barray1 a)) -> Store =
     case x of mk_barray1 @a (y : array1 a_ref).
     case y of
       mk_array1 @a_ref @(N : intindex)
        (lb : int) (stride : int) (count : FIInt N)
        (arr_ref : StuckBox (arr N a_ref)).

     mk_barray1 @a (mk_array1 @a_ref @N lb stride count arr_ref) ret
  in

  repr @(barray1 a) (sizealign_barray1 @a) copy_array
  (\ (x : Init (barray1 a)) -> Boxed (barray1 a).
    boxed @(barray1 a) x)
  (\ (x : Boxed (barray1 a)) (ret : OutPtr (barray1 a)) -> Store.
     case x of boxed @(barray1 a) (ux : barray1 a). copy_array ux ret)
  False;


repr_barray2 @(a : bare) -> Repr (barray2 a)
  attribute(inline, inline_postfinal) =

  let type a_ref = StuckRef (AsBox a) in

  letfun copy_barray (x : barray2 a) (ret : OutPtr (barray2 a)) -> Store =
     case x of mk_barray2 @a (y : array2 a_ref).
     case y of
       mk_array2 @a_ref @(M N : intindex)
       (lb_y : int) (stride_y : int) (count_y : FIInt M)
       (lb_x : int) (stride_x : int) (count_x : FIInt N)
       (arr_ref : StuckBox (arr M (arr N a_ref))).

     mk_barray2 @a
     (mk_array2 @a_ref @M @N lb_y stride_y count_y lb_x stride_x count_x arr_ref)
     ret
  in

  repr @(barray2 a) (sizealign_barray2 @a) copy_barray
  (\ (x : Init (barray2 a)) -> Boxed (barray2 a).
    boxed @(barray2 a) x)
  (\ (x : Boxed (barray2 a)) (ret : OutPtr (barray2 a)) -> Store.
     case x of boxed @(barray2 a) (ux : barray2 a). copy_barray ux ret)
  False;


repr_barray3 @(a : bare) -> Repr (barray3 a)
  attribute(inline, inline_postfinal) =

  let type a_ref = StuckRef (AsBox a) in

  letfun copy_barray (x : barray3 a) (ret : OutPtr (barray3 a)) -> Store =
     case x of mk_barray3 @a (y : array3 a_ref).
     case y of
       mk_array3 @a_ref @(L M N : intindex)
       (lb_z : int) (stride_z : int) (count_z : FIInt L)
       (lb_y : int) (stride_y : int) (count_y : FIInt M)
       (lb_x : int) (stride_x : int) (count_x : FIInt N)
       (arr_ref : StuckBox (arr L (arr M (arr N a_ref)))).

     mk_barray3 @a
     (mk_array3 @a_ref @L @M @N lb_z stride_z count_z lb_y stride_y count_y lb_x stride_x count_x arr_ref)
     ret
  in

  repr @(barray3 a) (sizealign_barray3 @a) copy_barray
  (\ (x : Init (barray3 a)) -> Boxed (barray3 a).
    boxed @(barray3 a) x)
  (\ (x : Boxed (barray3 a)) (ret : OutPtr (barray3 a)) -> Store.
     case x of boxed @(barray3 a) (ux : barray3 a). copy_barray ux ret)
  False;


repr_blist @(a : bare) -> Repr (blist a)
  attribute(inline, inline_postfinal) =

  let type ref_a = StuckRef (AsBox a) in

  letfun copy_list (x : blist a) (ret : OutPtr (blist a)) -> Store =
     case x of make_blist @a (l : list ref_a).
     case l of
       make_list @ref_a @(N : intindex)
       (count : FIInt N) (arr_ref : StuckBox (arr N ref_a)).

     make_blist @a (make_list @ref_a @N count arr_ref) ret
  in

  repr @(blist a) (sizealign_blist @a) copy_list
  (\ (x : Init (blist a)) -> Boxed (blist a). boxed @(blist a) x)
  (\ (x : Boxed (blist a)) (ret : OutPtr (blist a)) -> Store.
     case x of boxed @(blist a) (ux : blist a). copy_list ux ret)
  False;


repr_Complex : (a : bare) -> Repr a -> Repr (Complex a);
repr_Maybe : (a : bare) -> Repr a -> Repr (Maybe a);
repr_MaybeVal_int : Repr (MaybeVal int);
repr_MaybeVal_MaybeVal_int : Repr (MaybeVal (MaybeVal int));

-- This is only used for coercions.  Since we don't have
-- kind polymorphism, we cheat a bit on the type.
repr_Coercion : (a : val) -> Repr (Stored a);

repr_Tuple0 : Repr Tuple0;

repr_Tuple1 :
    (a : bare) -> Repr a -> Repr (Tuple1 a);

repr_Tuple2 @(a b : bare) (rep_a : Repr a) (rep_b : Repr b)
  -> Repr (Tuple2 a b)
  attribute(inline, inline_postfinal) =

  case rep_a of
    repr @a (sa_a : SizeAlign a) (copy_a : a -> Init a)
            (tboxed_a : Init a -> AsBox a)
            (fboxed_a : AsBox a -> Init a)
            (pl_a : bool).

  case rep_b of
    repr @b (sa_b : SizeAlign b) (copy_b : b -> Init b)
            (tboxed_b : Init b -> AsBox b)
            (fboxed_b: AsBox b -> Init b)
            (pl_b : bool).

  letfun
    copy_tuple (x : Tuple2 a b) (ret : OutPtr (Tuple2 a b)) -> Store =
      case x of tuple2 @a @b (fa : a) (fb : b).
      tuple2 @a @b (copy @a rep_a fa) (copy @b rep_b fb) ret
  in

  repr @(Tuple2 a b)

  (sizealign_Tuple2 @a @b sa_a sa_b)

  copy_tuple

  (\ (f : Init (Tuple2 a b)) -> Boxed (Tuple2 a b). boxed @(Tuple2 a b) f)

  (\ (i : Boxed (Tuple2 a b)) (ret : OutPtr (Tuple2 a b)) -> Store.
    case i of boxed @(Tuple2 a b) (tup : Tuple2 a b). copy_tuple tup ret)

  (and pl_a pl_b);


repr_Tuple3 @(a b c : bare) (rep_a : Repr a) (rep_b : Repr b) (rep_c : Repr c)
 -> Repr (Tuple3 a b c)
 attribute(inline, inline_postfinal) =

  case rep_a of
    repr @a (sa_a : SizeAlign a) (copy_a : a -> Init a)
            (tboxed_a : Init a -> AsBox a)
            (fboxed_a : AsBox a -> Init a)
            (pl_a : bool).

  case rep_b of
    repr @b (sa_b : SizeAlign b) (copy_b : b -> Init b)
            (tboxed_b : Init b -> AsBox b)
            (fboxed_b: AsBox b -> Init b)
            (pl_b : bool).

  case rep_c of
    repr @c (sa_c : SizeAlign c) (copy_c : c -> Init c)
            (tboxed_c : Init c -> AsBox c)
            (fboxed_c: AsBox c -> Init c)
            (pl_c : bool).

  letfun
    copy_tuple (x : Tuple3 a b c) (ret : OutPtr (Tuple3 a b c)) -> Store =
      case x of tuple3 @a @b @c (fa : a) (fb : b) (fc : c).
      tuple3 @a @b @c (copy @a rep_a fa) (copy @b rep_b fb) (copy @c rep_c fc) ret
  in

  repr @(Tuple3 a b c)

  (sizealign_Tuple3 @a @b @c sa_a sa_b sa_c)

  copy_tuple

  (\ (f : Init (Tuple3 a b c)) -> Boxed (Tuple3 a b c).
    boxed @(Tuple3 a b c) f)

  (\ (i : Boxed (Tuple3 a b c)) (ret : OutPtr (Tuple3 a b c)) -> Store.
    case i of boxed @(Tuple3 a b c) (tup : Tuple3 a b c). copy_tuple tup ret)

  (and pl_a (and pl_b pl_c));


repr_Tuple4 @(a b c d : bare)
  (rep_a : Repr a) (rep_b : Repr b) (rep_c : Repr c) (rep_d : Repr d)
  -> Repr (Tuple4 a b c d)
  attribute(inline, inline_postfinal) =

  case rep_a of
    repr @a (sa_a : SizeAlign a) (copy_a : a -> Init a)
            (tboxed_a : Init a -> AsBox a)
            (fboxed_a : AsBox a -> Init a)
            (pl_a : bool).

  case rep_b of
    repr @b (sa_b : SizeAlign b) (copy_b : b -> Init b)
            (tboxed_b : Init b -> AsBox b)
            (fboxed_b: AsBox b -> Init b)
            (pl_b : bool).

  case rep_c of
    repr @c (sa_c : SizeAlign c) (copy_c : c -> Init c)
            (tboxed_c : Init c -> AsBox c)
            (fboxed_c: AsBox c -> Init c)
            (pl_c : bool).

  case rep_d of
    repr @d (sa_d : SizeAlign d) (copy_d : d -> Init d)
            (tboxed_d : Init d -> AsBox d)
            (fboxed_d : AsBox d -> Init d)
            (pl_d : bool).

  letfun
    copy_tuple (x : Tuple4 a b c d) (ret : OutPtr (Tuple4 a b c d)) -> Store =
      case x of tuple4 @a @b @c @d (fa : a) (fb : b) (fc : c) (fd : d).
      tuple4 @a @b @c @d (copy @a rep_a fa) (copy @b rep_b fb) (copy @c rep_c fc) (copy @d rep_d fd) ret
  in

  repr @(Tuple4 a b c d)

  (sizealign_Tuple4 @a @b @c @d sa_a sa_b sa_c sa_d)

  copy_tuple

  (\ (f : Init (Tuple4 a b c d)) -> Boxed (Tuple4 a b c d).
    boxed @(Tuple4 a b c d) f)

  (\ (i : Boxed (Tuple4 a b c d)) (ret : OutPtr (Tuple4 a b c d)) -> Store.
    case i of boxed @(Tuple4 a b c d) (tup : Tuple4 a b c d). copy_tuple tup ret)

  (and pl_a (and pl_b (and pl_c pl_d)));


repr_intset : Repr intset;

-- Representation of any boxed object
repr_Box : (a : box) -> Repr (AsBare a);

repr_Ref @(a : box) -> Repr (Ref a)
  attribute(inline, inline_postfinal) =

  repr @(Ref a) (sizealign_Ref @a)
  (\ (x : Ref a) (r : OutPtr (Ref a)) -> Store.
    case x of ref @a (bx : a). ref @a bx r)
  (\ (x : Init (Ref a)) -> a.
    case stuckBox @(Ref a) x of stuckBox @(Ref a) (ref_x : Ref a).
    case ref_x of ref @a (bx :a). bx)
  (\ (x : a) (r : OutPtr (Ref a)) -> Store. ref @a x r)
  False;

copy_StuckRef @(a : box) (x : StuckRef a) (r : OutPtr (StuckRef a)) -> Store =
  case x of stuckRef @a (bx : a). stuckRef @a bx r;

repr_StuckRef @(a : box) -> Repr (StuckRef a)
  attribute(inline, inline_postfinal) =

  repr @(StuckRef a) (sizealign_StuckRef @a) (copy_StuckRef @a)
  (\ (x : Init (StuckRef a)) -> Boxed (StuckRef a). boxed @(StuckRef a) x)
  (\ (x : Boxed (StuckRef a)) (r : OutPtr (StuckRef a)) -> Store.
    case x of boxed @(StuckRef a) (rx : StuckRef a).
    copy_StuckRef @a rx r)
  False;

repr_Any : Repr (AsBare Any);
repr_Stream : (sh : box) -> (a : bare) -> Repr (AsBare (Stream sh a));
repr_view : (sh : box) -> (a : bare) -> Repr (AsBare (view sh a));
repr_Scatter : (a b : bare) -> Repr (AsBare (Scatter a b));

-- Representation of a referenced object that contains nothing and will
-- never be accessed.  At runtime, the reference will be an arbitrary pointer,
-- possibly NULL.
repr_EmptyReference : (a : bare) -> Repr a;

repr_arr @(n : intindex) @(e : bare)
  (size : FIInt n) (repr_e : Repr e) -> Repr (arr n e)
  attribute(inline, inline_postfinal) =

  case repr_e of
    repr @e
    (sa : SizeAlign e)
    (copy_e : e -> Init e)
    (to_boxed_e : Init e -> AsBox e)
    (to_bare_e : AsBox e -> Init e)
    (pointerless_e : bool).

  letfun
    copy_arr (a : arr n e) (ret : OutPtr (arr n e)) -> Store =

    doall @n @(arr n e) @(arr n e) size
    (\ (i : int) -> Store.
       copy @e repr_e (subscript @n @e sa a i) (subscript_out @n @e sa ret i))
  in

  repr @(arr n e) (sizealign_arr @n @e size sa)
  copy_arr
  (\ (x : Init (arr n e)) -> Boxed (arr n e). boxed @(arr n e) x)
  (\ (x : Boxed (arr n e)) (ret : OutPtr (arr n e)) -> Store.
     case x of boxed @(arr n e) (ux : arr n e). copy_arr ux ret)
  pointerless_e;


copy_EffTok (x : Stored EffTok) (ret : OutPtr (Stored EffTok)) -> Store
  attribute(inline) =
  case x of stored @EffTok (t : EffTok). stored @EffTok t ret;

box_EffTok (f : Init (Stored EffTok)) -> Boxed (Stored EffTok)
  attribute(inline) =
  boxed @(Stored EffTok) f;

unbox_EffTok (x : Boxed (Stored EffTok)) (ret : OutPtr (Stored EffTok))
  -> Store attribute(inline) =
  case x of boxed @(Stored EffTok) (sx : Stored EffTok).
  case sx of stored @EffTok (t : EffTok).
  stored @EffTok t ret;

repr_EffTok : Repr (Stored EffTok) attribute(inline, inline_postfinal) =

  repr @(Stored EffTok)
  sizealign_EffTok copy_EffTok box_EffTok unbox_EffTok True;

--getReprSizeAlignTuple : (a : bare) -> Repr a -> (uint, uint);
--getSizeAlignValTuple : (a : val) -> SizeAlignVal a -> (uint, uint);

--productSizeAlign : (uint, uint) -> (uint, uint) -> (uint, uint);
--unionSizeAlign : (uint, uint) -> (uint, uint) -> (uint, uint);

--toSizeAlignVal : (a : val) -> (uint, uint) -> SizeAlignVal a;
--toSizeAlign : (a : bare) -> (uint, uint) -> SizeAlign a;

sizealign_append_list : (a : bare) -> SizeAlign (append_list a);

sizealign_ListBuilder : (a : bare) -> SizeAlign (Stored (ListBuilder a));

sizealign_Tuple2 : (a b : bare)
                -> SizeAlign a -> SizeAlign b
                -> SizeAlign (Tuple2 a b);
sizealign_Tuple3 : (a b c : bare)
                -> SizeAlign a -> SizeAlign b -> SizeAlign c
                -> SizeAlign (Tuple3 a b c);
sizealign_Tuple4 : (a b c d : bare)
                -> SizeAlign a -> SizeAlign b -> SizeAlign c -> SizeAlign d
                -> SizeAlign (Tuple4 a b c d);

sizealign_arr : (n : intindex) -> (e : bare)
             -> FIInt n -> SizeAlign e -> SizeAlign (arr n e);

sizealign_list : (a : bare) -> SizeAlign (list a);
sizealign_array0 : (a : bare) -> SizeAlign (array0 a);
sizealign_array1 : (a : bare) -> SizeAlign (array1 a);
sizealign_array2 : (a : bare) -> SizeAlign (array2 a);
sizealign_array3 : (a : bare) -> SizeAlign (array3 a);
sizealign_blist : (a : bare) -> SizeAlign (blist a);
sizealign_barray1 : (a : bare) -> SizeAlign (barray1 a);
sizealign_barray2 : (a : bare) -> SizeAlign (barray2 a);
sizealign_barray3 : (a : bare) -> SizeAlign (barray3 a);

-------------------------------------------------------------------------------
-- Stream and Traversable dictionaries

TraversableDict_Stream_build @(sh : box) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_Stream_traverse @(sh : box) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_llist_build : (a : bare)
  -> Repr a -> Stream list_dim a -> llist a;


TraversableDict_llist_traverse @(a : bare)
  (repr : Repr a) (l : llist a) -> Stream list_dim a
  attribute(inline) =

  sequenceStream @a (Sequence_from_llist @a repr l);


TraversableDict_Stream_traverse @(sh : box) @(a : bare)
  (repr : Repr a) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_view_list_dim_build
  @(a : bare) (repr : Repr a) (s : Stream list_dim a) -> view list_dim a
  attribute(inline) =
  case s of {
    viewStream @a (vw : view list_dim a). vw
  ; sequenceStream @a (sq : Sequence a). sequenceToView @a repr sq
  };


TraversableDict_view_list_dim_traverse
  @(a : bare) (repr : Repr a) (vw : view list_dim a) -> Stream list_dim a
  attribute(inline) =
  viewStream @a vw;


TraversableDict_view_dim0_build
  @(a : bare) (repr : Repr a) (s : Stream dim0 a) -> view dim0 a
  attribute(inline) =
  s;


TraversableDict_view_dim0_traverse
  @(a : bare) (repr : Repr a) (vw : view dim0 a) -> Stream dim0 a
  attribute(inline) =
  vw;


TraversableDict_view_dim1_build
  @(a : bare) (repr : Repr a) (s : Stream dim1 a) -> view dim1 a
  attribute(inline) =
  s;


TraversableDict_view_dim1_traverse
  @(a : bare) (repr : Repr a) (vw : view dim1 a) -> Stream dim1 a
  attribute(inline) =
  vw;


TraversableDict_view_dim2_build
  @(a : bare) (repr : Repr a) (s : Stream dim2 a) -> view dim2 a
  attribute(inline) =
  s;


TraversableDict_view_dim2_traverse
  @(a : bare) (repr : Repr a) (vw : view dim2 a) -> Stream dim2 a
  attribute(inline) =
  vw;


TraversableDict_view_dim3_build
  @(a : bare) (repr : Repr a) (s : Stream dim3 a) -> view dim3 a
  attribute(inline) =
  s;


TraversableDict_view_dim3_traverse
  @(a : bare) (repr : Repr a) (vw : view dim3 a) -> Stream dim3 a
  attribute(inline) =
  vw;


TraversableDict_list_build @(a : bare)
  (repr : Repr a) (s : Stream list_dim a) (ret : OutPtr (list a))
  -> Store attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      Sequence_list_build @a repr sq ret
  ; viewStream @a (vw : view list_dim a).
      build_list_dim_list @a repr vw ret
  };

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : bare) (rep : Repr a) (ls : list a)
  -> Stream list_dim a attribute(inline) =
  case ls of make_list @a @(N : intindex)
                       (size : FIInt N) (aref : StuckBox (arr N a)).
  case aref of stuckBox @(arr N a) (ay : arr N a).
  case size of fiInt @N (size_i : int).

  let shp : list_dim = mk_list_dim (justVal @int size_i) in

  case rep of
    repr @a
    (sa : SizeAlign a)
    (copy_a : a -> Init a)
    (to_boxed_a : Init a -> AsBox a)
    (to_bare_a : AsBox a -> Init a)
    (pointerless_a : bool).

  viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a rep shp
   (\ (si : Stored int) (ret : OutPtr a) -> Store.
     case si of stored @int (i : int).
     copy @a rep (subscript @N @a sa ay i) ret));


TraversableDict_array0_build
  @(a : bare) (repr : Repr a) (vw : view dim0 a) (ret : OutPtr (array0 a))
  -> Store attribute(inline) =

  case vw of mk_view @dim0 @a (dom : dim0) (f : Stored NoneType -> Init a).
  case boxed @(Stored NoneType) (stored @NoneType None) of
    boxed @(Stored NoneType) (dummy_index : Stored NoneType).
  mk_array0 @a (stuckBox @a (f dummy_index)) ret;


TraversableDict_array0_traverse
  @(a : bare) (repr : Repr a) (ay : array0 a) -> view dim0 a attribute(inline) =
  case ay of mk_array0 @a (x : StuckBox a).
  view_generate @dim0 ShapeDict_dim0 @a
  repr mk_dim0
  (\ (dummy_index : Stored NoneType) (ret : OutPtr a) -> Store.
    case x of stuckBox @a (ux : a). copy @a repr ux ret);


TraversableDict_array1_build
  @(a : bare) (repr : Repr a) (s : view dim1 a) (ret : OutPtr (array1 a))
  -> Store attribute(inline, inline_dimensionality) =
  build_dim1_array @a repr s ret;


TraversableDict_array1_traverse
  @(a : bare) (rep : Repr a) (ar : array1 a)
  -> view dim1 a attribute(inline) =
  case ar of
    mk_array1 @a @(N : intindex)
    (lo : int) (stride : int) (size : FIInt N)
    (ayref : StuckBox (arr N a)).
  case ayref of stuckBox @(arr N a) (ay : arr N a).
  
  let linear_map : LinearMap = linearMap stride lo in

  case rep of
    repr @a
    (sa : SizeAlign a)
    (copy_a : a -> Init a)
    (to_boxed_a : Init a -> AsBox a)
    (to_bare_a : AsBox a -> Init a)
    (pointerless_a : bool).

  view_generate @dim1 ShapeDict_dim1 @a rep
  (arrayDescToDim1 @N lo stride size)
  (\ (ix : Stored int) (ret : OutPtr a) -> Store.
    case ix of stored @int (ix_i : int).

    let real_ix : int = invEvalLM ix_i linear_map in
    copy @a rep (subscript @N @a sa ay real_ix) ret);


TraversableDict_array2_build
  @(a : bare) (repr : Repr a) (s : view dim2 a) (ret : OutPtr (array2 a))
  -> Store attribute(inline, inline_dimensionality) =
  
  case s of mk_view @dim2 @a (dom : dim2) (f : index dim2 -> Init a).
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).

  -- Compute array parameters
  dim1ToArrayDesc @(array2 a) dom_y
  (\ @(M : intindex)
     (lb_y : int) (stride_y : int) (size_y : FIInt M) (ret : OutPtr (array2 a))
     -> Store.
     dim1ToArrayDesc @(array2 a) dom_x
     (\ @(N : intindex)
        (lb_x : int) (stride_x : int) (size_x : FIInt N) (ret : OutPtr (array2 a))
        -> Store.

        let linear_map_y : LinearMap = linearMap stride_y lb_y in
        let linear_map_x : LinearMap = linearMap stride_x lb_x in
        let type out_arr = arr M (arr N a) in
        let type Sint = Stored int in

        mk_array2 @a @M @N lb_y stride_y size_y lb_x stride_x size_x
        (stuckBox @out_arr
         (arr2D_build @M @N @a repr size_y size_x
          (\ (y : int) (x : int) (ret : OutPtr a) -> Store.
             let logical_y : int = evalLM y linear_map_y in
             let logical_x : int = evalLM x linear_map_x in
             case boxed @(Tuple2 Sint Sint)
                  (tuple2 @Sint @Sint
                   (stored @int logical_y) (stored @int logical_x)) of
               boxed @(Tuple2 Sint Sint) (ix : Tuple2 Sint Sint).

             -- Evaluate the function
             f ix ret)))
         ret)
     ret)
  ret;


TraversableDict_array2_traverse
  @(a : bare) (rep : Repr a) (ar : array2 a)
  -> view dim2 a attribute(inline) =
  case ar of
    mk_array2 @a @(M N : intindex)
    (lo_y : int) (stride_y : int) (size_y : FIInt M)
    (lo_x : int) (stride_x : int) (size_x : FIInt N)
    (ayref : StuckBox (arr M (arr N a))).
  case ayref of stuckBox @(arr M (arr N a)) (ay : arr M (arr N a)).

  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_x of fiInt @N (width : int).
  let row_repr : Repr (arr N a) = repr_arr @N @a size_x rep in
  let type Sint = Stored int in

  view_generate @dim2 ShapeDict_dim2 @a rep
  (mk_dim2 (arrayDescToDim1 @M lo_y stride_y size_y)
           (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Tuple2 Sint Sint) (ret : OutPtr a) -> Store.
     case ix of tuple2 @Sint @Sint (ix_y : Sint) (ix_x : Sint).
     case ix_y of stored @int (ix_y_i : int).
     case ix_x of stored @int (ix_x_i : int).
     let real_ix_y : int = invEvalLM ix_y_i linear_map_y in
     let real_ix_x : int = invEvalLM ix_x_i linear_map_x in
     copy @a rep 
     (subscript @N @a (reprSizeAlign @a rep)
      (subscript @M @(arr N a) (reprSizeAlign @(arr N a) row_repr) ay real_ix_y) real_ix_x)
     ret);


TraversableDict_array3_build
  @(a : bare) (repr : Repr a) (s : view dim3 a) (ret : OutPtr (array3 a))
  -> Store attribute(inline, inline_dimensionality) =

  case s of mk_view @dim3 @a (dom : dim3) (f : index dim3 -> Init a).
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).

  -- Compute array parameters
  dim1ToArrayDesc @(array3 a) dom_z
  (\ @(L : intindex)
     (lb_z : int) (stride_z : int) (size_z : FIInt L) (ret : OutPtr (array3 a))
     -> Store.
     dim1ToArrayDesc @(array3 a) dom_y
     (\ @(M : intindex)
        (lb_y : int) (stride_y : int) (size_y : FIInt M) (ret : OutPtr (array3 a))
        -> Store.
        dim1ToArrayDesc @(array3 a) dom_x
        (\ @(N : intindex)
           (lb_x : int) (stride_x : int) (size_x : FIInt N) (ret : OutPtr (array3 a))
           -> Store.

           let linear_map_z : LinearMap = linearMap stride_z lb_z in
           let linear_map_y : LinearMap = linearMap stride_y lb_y in
           let linear_map_x : LinearMap = linearMap stride_x lb_x in
           let type out_arr = arr L (arr M (arr N a)) in
           let type Sint = Stored int in

           mk_array3 @a @L @M @N lb_z stride_z size_z
                                 lb_y stride_y size_y
                                 lb_x stride_x size_x
           (stuckBox @out_arr
            (arr3D_build @L @M @N @a repr size_z size_y size_x
             (\ (z : int) (y : int) (x : int) (ret : OutPtr a) -> Store.
                let logical_z : int = evalLM z linear_map_z in
                let logical_y : int = evalLM y linear_map_y in
                let logical_x : int = evalLM x linear_map_x in
                case boxed @(Tuple3 Sint Sint Sint)
                     (tuple3 @Sint @Sint @Sint
                      (stored @int logical_z)
                      (stored @int logical_y) (stored @int logical_x)) of
                  boxed @(Tuple3 Sint Sint Sint)
                        (ix : Tuple3 Sint Sint Sint).

                -- Evaluate the function
                f ix ret)))
            ret)
        ret)
     ret)
  ret;


TraversableDict_array3_traverse
  @(a : bare) (repr : Repr a) (ar : array3 a)
  -> view dim3 a attribute(inline) =
  case ar of
    mk_array3 @a @(L M N : intindex)
    (lo_z : int) (stride_z : int) (size_z : FIInt L)
    (lo_y : int) (stride_y : int) (size_y : FIInt M)
    (lo_x : int) (stride_x : int) (size_x : FIInt N)
    (ayref : StuckBox (arr L (arr M (arr N a)))).
  let type arr3d = arr L (arr M (arr N a)) in

  case ayref of stuckBox @arr3d (ay : arr3d).

  let linear_map_z : LinearMap = linearMap stride_z lo_z in
  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_y of fiInt @M (height : int).
  case size_x of fiInt @N (width : int).
  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  let plane_repr : Repr (arr M (arr N a)) =
        repr_arr @M @(arr N a) size_y row_repr in
  let type Sint = Stored int in

  view_generate @dim3 ShapeDict_dim3 @a repr
  (mk_dim3 (arrayDescToDim1 @L lo_z stride_z size_z)
           (arrayDescToDim1 @M lo_y stride_y size_y)
           (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Tuple3 Sint Sint Sint) (ret : OutPtr a) -> Store.
     case ix of tuple3 @Sint @Sint @Sint
                (ix_z : Sint) (ix_y : Sint) (ix_x : Sint).
     case ix_z of stored @int (ix_z_i : int).
     case ix_y of stored @int (ix_y_i : int).
     case ix_x of stored @int (ix_x_i : int).
     let real_ix_z : int = invEvalLM ix_z_i linear_map_z in
     let real_ix_y : int = invEvalLM ix_y_i linear_map_y in
     let real_ix_x : int = invEvalLM ix_x_i linear_map_x in
     copy @a repr
     (subscript @N @a (reprSizeAlign @a repr)
      (subscript @M @(arr N a) (reprSizeAlign @(arr N a) row_repr)
       (subscript @L @(arr M (arr N a)) (reprSizeAlign @(arr M (arr N a)) plane_repr) ay real_ix_z)
       real_ix_y)
      real_ix_x)
     ret);


TraversableDict_blist_build @(a : bare)
  (repr : Repr a) (s : Stream list_dim a) (ret : OutPtr (blist a))
  -> Store attribute(inline) =

  let type boxed_a = StuckRef (AsBox a) in
  let repr_boxed : Repr boxed_a = repr_StuckRef @(AsBox a) in
  -- Wrap all sequence elements in boxes
  let s2 : Stream list_dim boxed_a =
        ShapeDict_list_dim_map @a @boxed_a repr (repr_StuckRef @(AsBox a))
        (\ (x : a) -> Init boxed_a.
           stuckRef @(AsBox a) (asbox @a repr (copy @a repr x)))
        s in 
  case s2 of {
    sequenceStream @boxed_a (sq : Sequence boxed_a).
      make_blist @a (Sequence_list_build @boxed_a repr_boxed sq) ret
  ; viewStream @boxed_a (vw : view list_dim boxed_a).
      make_blist @a (build_list_dim_list @boxed_a repr_boxed vw) ret
  };

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_blist_traverse @(a : bare) (repr : Repr a) (ls : blist a)
  -> Stream list_dim a attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ls of make_blist @a (ls2 : list boxed_a).
  case ls2 of make_list @boxed_a @(N : intindex)
                       (size : FIInt N) (aref : StuckBox (arr N boxed_a)).
  case aref of stuckBox @(arr N boxed_a) (ay : arr N boxed_a).
  case size of fiInt @N (size_i : int).

  let shp : list_dim = mk_list_dim (justVal @int size_i) in
  let repr_box : Repr boxed_a = repr_StuckRef @(AsBox a) in

  viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a repr shp
   (\ (si : Stored int) (ret : OutPtr a) -> Store.
     case si of stored @int (i : int).
     case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay i of
       stuckRef @(AsBox a) (val : AsBox a).
     asbare @a repr val ret));


TraversableDict_barray1_build
  @(a : bare) (repr : Repr a) (s : view dim1 a) (ret : OutPtr (barray1 a))
  -> Store attribute(inline, inline_dimensionality) =
  let type boxed_a = StuckRef (AsBox a) in
  let brepr : Repr boxed_a = repr_StuckRef @(AsBox a) in
  mk_barray1 @a
  (build_dim1_array @boxed_a brepr
   (view_map @dim1 ShapeDict_dim1 @a @boxed_a
    repr brepr (\ (x : a) -> Init boxed_a.
                  stuckRef @(AsBox a)
                  (asbox @a repr (copy @a repr x))) s))
  ret;


TraversableDict_barray1_traverse
  @(a : bare) (repr : Repr a) (ar : barray1 a)
  -> view dim1 a attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ar of mk_barray1 @a (ar2 : array1 boxed_a).
  case ar2 of mk_array1 @boxed_a @(N : intindex)
    (lo : int) (stride : int) (size : FIInt N)
    (ayref : StuckBox (arr N boxed_a)).
  case ayref of stuckBox @(arr N boxed_a) (ay : arr N boxed_a).

  let linear_map : LinearMap = linearMap stride lo in
  let repr_box : Repr boxed_a = repr_StuckRef @(AsBox a) in

  view_generate @dim1 ShapeDict_dim1 @a repr
  (arrayDescToDim1 @N lo stride size)
  (\ (ix : Stored int) (ret : OutPtr a) -> Store.
    case ix of stored @int (ix_i : int).

    let real_ix : int = invEvalLM ix_i linear_map in
    case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay real_ix of 
      stuckRef @(AsBox a) (val : AsBox a).
    asbare @a repr val ret);


TraversableDict_barray2_build
  @(a : bare) (repr : Repr a) (s : view dim2 a) (ret : OutPtr (barray2 a))
  -> Store attribute(inline, inline_dimensionality) =
  
  case s of mk_view @dim2 @a (dom : dim2) (f : index dim2 -> Init a).
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).

  -- Compute array parameters
  dim1ToArrayDesc @(barray2 a) dom_y
  (\ @(M : intindex)
     (lb_y : int) (stride_y : int) (size_y : FIInt M) (ret : OutPtr (barray2 a))
     -> Store.
     dim1ToArrayDesc @(barray2 a) dom_x
     (\ @(N : intindex)
        (lb_x : int) (stride_x : int) (size_x : FIInt N) (ret : OutPtr (barray2 a))
        -> Store.

        let linear_map_y : LinearMap = linearMap stride_y lb_y in
        let linear_map_x : LinearMap = linearMap stride_x lb_x in
        let type boxed_a = StuckRef (AsBox a) in
        let type out_arr = arr M (arr N boxed_a) in
        let type Sint = Stored int in
        let box_repr : Repr boxed_a = repr_StuckRef @(AsBox a) in

        mk_barray2 @a
        (mk_array2 @boxed_a @M @N lb_y stride_y size_y lb_x stride_x size_x
         (stuckBox @out_arr
          (arr2D_build @M @N @boxed_a box_repr size_y size_x
           (\ (y : int) (x : int) (ret : OutPtr boxed_a) -> Store.
              let logical_y : int = evalLM y linear_map_y in
              let logical_x : int = evalLM x linear_map_x in
              case boxed @(Tuple2 Sint Sint)
                   (tuple2 @Sint @Sint
                    (stored @int logical_y) (stored @int logical_x)) of
                boxed @(Tuple2 Sint Sint) (ix : Tuple2 Sint Sint).

              -- Evaluate the function and box its result
              stuckRef @(AsBox a)
                (asbox @a repr (f ix)) ret))))
         ret)
     ret)
  ret;


TraversableDict_barray2_traverse
  @(a : bare) (repr : Repr a) (ar : barray2 a)
  -> view dim2 a attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ar of mk_barray2 @a (ar2 : array2 boxed_a).
  case ar2 of
    mk_array2 @boxed_a @(M N : intindex)
    (lo_y : int) (stride_y : int) (size_y : FIInt M)
    (lo_x : int) (stride_x : int) (size_x : FIInt N)
    (ayref : StuckBox (arr M (arr N boxed_a))).
  case ayref of stuckBox @(arr M (arr N boxed_a)) (ay : arr M (arr N boxed_a)).

  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_x of fiInt @N (width : int).
  let box_repr : Repr boxed_a = repr_StuckRef @(AsBox a) in
  let row_repr : Repr (arr N boxed_a) = repr_arr @N @boxed_a size_x box_repr in
  let type Sint = Stored int in

  view_generate @dim2 ShapeDict_dim2 @a repr
  (mk_dim2 (arrayDescToDim1 @M lo_y stride_y size_y)
           (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Tuple2 Sint Sint) (ret : OutPtr a) -> Store.
     case ix of tuple2 @Sint @Sint (ix_y : Sint) (ix_x : Sint).
     case ix_y of stored @int (ix_y_i : int).
     case ix_x of stored @int (ix_x_i : int).
     let real_ix_y : int = invEvalLM ix_y_i linear_map_y in
     let real_ix_x : int = invEvalLM ix_x_i linear_map_x in
     case subscript @N @boxed_a (reprSizeAlign @boxed_a box_repr)
          (subscript @M @(arr N boxed_a) (reprSizeAlign @(arr N boxed_a) row_repr) ay real_ix_y) real_ix_x of
       stuckRef @(AsBox a) (val : AsBox a).
     asbare @a repr val ret);


TraversableDict_barray3_build
  @(a : bare) (repr : Repr a) (s : view dim3 a) (ret : OutPtr (barray3 a))
  -> Store attribute(inline, inline_dimensionality) =

  let type boxed_a = StuckRef (AsBox a) in
  let brepr : Repr boxed_a = repr_StuckRef @(AsBox a) in
  case s of mk_view @dim3 @a (dom : dim3) (f : index dim3 -> Init a).
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).

  -- Compute array parameters
  dim1ToArrayDesc @(barray3 a) dom_z
  (\ @(L : intindex)
     (lb_z : int) (stride_z : int) (size_z : FIInt L) (ret : OutPtr (barray3 a))
     -> Store.
     dim1ToArrayDesc @(barray3 a) dom_y
     (\ @(M : intindex)
        (lb_y : int) (stride_y : int) (size_y : FIInt M) (ret : OutPtr (barray3 a))
        -> Store.
        dim1ToArrayDesc @(barray3 a) dom_x
        (\ @(N : intindex)
           (lb_x : int) (stride_x : int) (size_x : FIInt N) (ret : OutPtr (barray3 a))
           -> Store.

           let linear_map_z : LinearMap = linearMap stride_z lb_z in
           let linear_map_y : LinearMap = linearMap stride_y lb_y in
           let linear_map_x : LinearMap = linearMap stride_x lb_x in
           let type out_arr = arr L (arr M (arr N boxed_a)) in
           let type Sint = Stored int in

           mk_barray3 @a
           (mk_array3 @boxed_a @L @M @N
                      lb_z stride_z size_z
                      lb_y stride_y size_y
                      lb_x stride_x size_x
            (stuckBox @out_arr
             (arr3D_build @L @M @N @boxed_a brepr size_z size_y size_x
              (\ (z : int) (y : int) (x : int) (ret : OutPtr boxed_a) -> Store.
                 let logical_z : int = evalLM z linear_map_z in
                 let logical_y : int = evalLM y linear_map_y in
                 let logical_x : int = evalLM x linear_map_x in
                 case boxed @(Tuple3 Sint Sint Sint)
                      (tuple3 @Sint @Sint @Sint
                       (stored @int logical_z)
                       (stored @int logical_y) (stored @int logical_x)) of
                   boxed @(Tuple3 Sint Sint Sint)
                         (ix : Tuple3 Sint Sint Sint).

                 -- Evaluate the function and box its result
                 stuckRef @(AsBox a)
                 (asbox @a repr (f ix))
                 ret))))
            ret)
        ret)
     ret)
  ret;


TraversableDict_barray3_traverse
  @(a : bare) (repr : Repr a) (ar : barray3 a)
  -> view dim3 a attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ar of mk_barray3 @a (ar2 : array3 boxed_a).
  case ar2 of
    mk_array3 @boxed_a @(L M N : intindex)
    (lo_z : int) (stride_z : int) (size_z : FIInt L)
    (lo_y : int) (stride_y : int) (size_y : FIInt M)
    (lo_x : int) (stride_x : int) (size_x : FIInt N)
    (ayref : StuckBox (arr L (arr M (arr N boxed_a)))).
  let type arr1d = arr N boxed_a in
  let type arr2d = arr M arr1d in
  let type arr3d = arr L arr2d in

  case ayref of stuckBox @arr3d (ay : arr3d).

  let linear_map_z : LinearMap = linearMap stride_z lo_z in
  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_y of fiInt @M (height : int).
  case size_x of fiInt @N (width : int).
  let boxed_repr : Repr boxed_a = repr_StuckRef @(AsBox a) in
  let row_repr : Repr arr1d = repr_arr @N @boxed_a size_x boxed_repr in
  let plane_repr : Repr arr2d = repr_arr @M @arr1d size_y row_repr in
  let type Sint = Stored int in

  view_generate @dim3 ShapeDict_dim3 @a repr
  (mk_dim3 (arrayDescToDim1 @L lo_z stride_z size_z)
           (arrayDescToDim1 @M lo_y stride_y size_y)
           (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Tuple3 Sint Sint Sint) (ret : OutPtr a) -> Store.
     case ix of tuple3 @Sint @Sint @Sint
                (ix_z : Sint) (ix_y : Sint) (ix_x : Sint).
     case ix_z of stored @int (ix_z_i : int).
     case ix_y of stored @int (ix_y_i : int).
     case ix_x of stored @int (ix_x_i : int).
     let real_ix_z : int = invEvalLM ix_z_i linear_map_z in
     let real_ix_y : int = invEvalLM ix_y_i linear_map_y in
     let real_ix_x : int = invEvalLM ix_x_i linear_map_x in
     case subscript @N @boxed_a (reprSizeAlign @boxed_a boxed_repr)
          (subscript @M @arr1d (reprSizeAlign @arr1d row_repr)
           (subscript @L @arr2d (reprSizeAlign @arr2d plane_repr) ay real_ix_z)
           real_ix_y)
          real_ix_x of
      stuckRef @(AsBox a) (val : AsBox a).
     asbare @a repr val ret);


-------------------------------------------------------------------------------
-- Shape dictionaries

ShapeDict_list_dim : ShapeDict list_dim =
  shapeDict @list_dim
  repr_int
  repr_SliceObject
  ShapeDict_list_dim_member
  ShapeDict_list_dim_intersect
  ShapeDict_list_dim_flatten
  ShapeDict_list_dim_generate
  ShapeDict_list_dim_map
  ShapeDict_list_dim_zipWith
  ShapeDict_list_dim_zipWith3
  ShapeDict_list_dim_zipWith4
  ShapeDict_list_dim_slice;


ShapeDict_list_dim_member
  (sh : list_dim) (ix : Stored int) -> bool =
  case ix of stored @int (ix_i : int).
  case sh of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    nothingVal @int. ix_i >=# 0
  ; justVal @int (size_i : int). and (ix_i >=# 0) (ix_i <# size_i)
  };


ShapeDict_list_dim_intersect (d1 : list_dim) (d2 : list_dim) -> list_dim =
  case d1 of mk_list_dim (m_size1 : MaybeVal int).
  case d2 of mk_list_dim (m_size2 : MaybeVal int).
  mk_list_dim
  (case m_size1 of {
     justVal @int (size1 : int).
       case m_size2 of {
         justVal @int (size2 : int).
           justVal @int (min_int size1 size2)
       ; nothingVal @int.
           justVal @int size1
       }
   ; nothingVal @int.
       m_size2
   });


ShapeDict_list_dim_flatten @(a : bare) (repr : Repr a) (s : Stream list_dim a)
  -> Stream list_dim a attribute(inline) = s;


ShapeDict_list_dim_generate @(a : bare)
  (repr : Repr a) (d : list_dim) (f : Stored int -> Init a)
  -> Stream list_dim a =
  viewStream @a (view_generate @list_dim
  ShapeDict_list_dim @a repr d f);


ShapeDict_list_dim_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Init b)
  (s : Stream list_dim a)
  -> Stream list_dim b attribute(inline) =
  case s of {
    sequenceStream @a (sq : Sequence a).
      sequenceStream @b (Sequence_map @a @b repr_a repr_b transformer sq)
  ; viewStream @a (vw : view list_dim a).
      viewStream @b
      (view_map @list_dim
       ShapeDict_list_dim @a @b repr_a repr_b transformer vw)
  };


ShapeDict_list_dim_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sA : Stream list_dim a)
  (sB : Stream list_dim b)
  -> Stream list_dim c attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view list_dim b). viewToSequence @b repr_b vwB
            } in
      sequenceStream @c
      (Sequence_zipWith @a @b @c repr_a repr_b repr_c transformer sqA sqB)

  ; viewStream @a (vwA : view list_dim a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          sequenceStream @c
          (Sequence_zipWith @a @b @c repr_a repr_b repr_c transformer
           (viewToSequence @a repr_a vwA) sqB)
      ; viewStream @b (vwB : view list_dim b).
          viewStream @c
          (view_zipWith @list_dim
           ShapeDict_list_dim
           @a @b @c repr_a repr_b repr_c transformer vwA vwB)
    }
  };

ShapeDict_list_dim_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sA : Stream list_dim a)
  (sB : Stream list_dim b)
  (sC : Stream list_dim c)
  -> Stream list_dim d attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view list_dim b). viewToSequence @b repr_b vwB
            } in
      let sqC : Sequence c =
            case sC of {
              sequenceStream @c (sqC : Sequence c). sqC
            ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
            } in
      sequenceStream @d
      (Sequence_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d
       transformer sqA sqB sqC)

  ; viewStream @a (vwA : view list_dim a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          let sqC : Sequence c =
                case sC of {
                  sequenceStream @c (sqC : Sequence c). sqC
                ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
                } in
          sequenceStream @d
          (Sequence_zipWith3 @a @b @c @d repr_a repr_b repr_c repr_d transformer
           (viewToSequence @a repr_a vwA) sqB sqC)

      ; viewStream @b (vwB : view list_dim b).
          case sC of {
            sequenceStream @c (sqC : Sequence c).
              sequenceStream @d
              (Sequence_zipWith3 @a @b @c @d
               repr_a repr_b repr_c repr_d transformer
               (viewToSequence @a repr_a vwA)
               (viewToSequence @b repr_b vwB)
               sqC)

          ; viewStream @c (vwC : view list_dim c).
              viewStream @d
              (view_zipWith3 @list_dim
               ShapeDict_list_dim
               @a @b @c @d repr_a repr_b repr_c repr_d
               transformer vwA vwB vwC)
          }
      }
  };


ShapeDict_list_dim_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sA : Stream list_dim a)
  (sB : Stream list_dim b)
  (sC : Stream list_dim c)
  (sD : Stream list_dim d)
  -> Stream list_dim e attribute(inline) =
  case sA of {
    sequenceStream @a (sqA : Sequence a).
      let sqB : Sequence b =
            case sB of {
              sequenceStream @b (sqB : Sequence b). sqB
            ; viewStream @b (vwB : view list_dim b). viewToSequence @b repr_b vwB
            } in
      let sqC : Sequence c =
            case sC of {
              sequenceStream @c (sqC : Sequence c). sqC
            ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
            } in
      let sqD : Sequence d =
            case sD of {
              sequenceStream @d (sqD : Sequence d). sqD
            ; viewStream @d (vwD : view list_dim d). viewToSequence @d repr_d vwD
            } in
      sequenceStream @e
      (Sequence_zipWith4 @a @b @c @d @e repr_a repr_b repr_c repr_d repr_e
       transformer sqA sqB sqC sqD)

  ; viewStream @a (vwA : view list_dim a).
      case sB of {
        sequenceStream @b (sqB : Sequence b).
          let sqC : Sequence c =
                case sC of {
                  sequenceStream @c (sqC : Sequence c). sqC
                ; viewStream @c (vwC : view list_dim c). viewToSequence @c repr_c vwC
                } in
          let sqD : Sequence d =
                case sD of {
                  sequenceStream @d (sqD : Sequence d). sqD
                ; viewStream @d (vwD : view list_dim d). viewToSequence @d repr_d vwD
                } in
          sequenceStream @e
          (Sequence_zipWith4 @a @b @c @d @e
           repr_a repr_b repr_c repr_d repr_e transformer
           (viewToSequence @a repr_a vwA) sqB sqC sqD)

      ; viewStream @b (vwB : view list_dim b).
          case sC of {
            sequenceStream @c (sqC : Sequence c).
              let sqD : Sequence d =
                    case sD of {
                      sequenceStream @d (sqD : Sequence d).
                        sqD
                    ; viewStream @d (vwD : view list_dim d).
                        viewToSequence @d repr_d vwD
                    } in
              sequenceStream @e
              (Sequence_zipWith4 @a @b @c @d @e
               repr_a repr_b repr_c repr_d repr_e transformer
               (viewToSequence @a repr_a vwA)
               (viewToSequence @b repr_b vwB)
               sqC sqD)

          ; viewStream @c (vwC : view list_dim c).
              case sD of {
                sequenceStream @d (sqD : Sequence d).
                  sequenceStream @e
                  (Sequence_zipWith4 @a @b @c @d @e
                   repr_a repr_b repr_c repr_d repr_e transformer
                   (viewToSequence @a repr_a vwA)
                   (viewToSequence @b repr_b vwB)
                   (viewToSequence @c repr_c vwC)
                   sqD)
              ; viewStream @d (vwD : view list_dim d).
                  viewStream @e
                  (view_zipWith4 @list_dim
                   ShapeDict_list_dim @a @b @c @d @e
                   repr_a repr_b repr_c repr_d repr_e
                   transformer vwA vwB vwC vwD)
              }
          }
      }
  };


ShapeDict_list_dim_slice @(t : bare -> bare) @(a : bare)
  (is_dim1 : coerce @box (shape t) list_dim)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice list_dim)
  -> view list_dim a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute parameters of the sliced list
  case internalApplyListSlice slice_argument
       (coerce @(shape t) @list_dim (get_shape @a container)) of
    (view_domain : list_dim, view_map : LinearMap).

  view_generate @list_dim
  ShapeDict_list_dim @a repr view_domain
  (\ (i : Stored int) (ret : OutPtr a) -> Store.

    -- Compute the index in the original object that holds the value at 'i'
    let source_index : int =
          case i of stored @int (u_i : int). evalLM u_i view_map in
    case boxed @(Stored int) (stored @int source_index) of
      boxed @(Stored int) (source_s_index : Stored int).
    let s_index : index (shape t) =
          coerce @(index list_dim) @(index (shape t)) source_s_index in

    -- Retrieve the value
    at_index @a repr container s_index ret);


ShapeDict_dim0 : ShapeDict dim0 =
  shapeDict @dim0
  repr_NoneType
  repr_NoneType
  ShapeDict_dim0_member
  ShapeDict_dim0_intersect
  ShapeDict_dim0_flatten
  ShapeDict_dim0_generate
  ShapeDict_dim0_map
  ShapeDict_dim0_zipWith
  ShapeDict_dim0_zipWith3
  ShapeDict_dim0_zipWith4
  ShapeDict_dim0_slice;

ShapeDict_dim0_member (d : dim0) (i : index dim0) -> bool attribute(inline) =
  True;

ShapeDict_dim0_intersect (d : dim0) (x : dim0) -> dim0 attribute(inline) =
  d;

ShapeDict_dim0_generate @(a : bare)
  (repr : Repr a) (d : dim0) (f : Stored NoneType -> Init a)
  -> Stream dim0 a attribute(inline) =
  mk_view @dim0 @a mk_dim0 f;

ShapeDict_dim0_flatten @(a : bare) (repr : Repr a) (s : Stream dim0 a)
  -> Stream list_dim a attribute(inline) =
  case s of mk_view @dim0 @a (d : dim0) (f : Stored NoneType -> Init a).

  let d : list_dim = mk_list_dim (justVal @int 1) in

  ShapeDict_list_dim_generate @a repr d
  (\ (i : Stored int) -> Init a.
    case boxed @(Stored NoneType) (stored @NoneType None) of
      boxed @(Stored NoneType) (x : Stored NoneType).
    f x);


ShapeDict_dim0_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Init b)
  (s : Stream dim0 a)
  -> Stream dim0 b attribute(inline) =
  case s of mk_view @dim0 @a (d : dim0) (f : Stored NoneType -> Init a).
  mk_view @dim0 @b d
  (\ (i : Stored NoneType) -> Init b.
    case boxed @a (f i) of boxed @a (x : a). transformer x);


ShapeDict_dim0_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  -> Stream dim0 c attribute(inline) =
  case sA of mk_view @dim0 @a (dA : dim0) (fA : Stored NoneType -> Init a).
  case sB of mk_view @dim0 @b (dB : dim0) (fB : Stored NoneType -> Init b).
  mk_view @dim0 @c dA
  (\ (i : Stored NoneType) -> Init c.
    case boxed @a (fA i) of boxed @a (x : a).
    case boxed @b (fB i) of boxed @b (y : b).
    transformer x y);


ShapeDict_dim0_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  (sC : Stream dim0 c)
  -> Stream dim0 d attribute(inline) =
  case sA of mk_view @dim0 @a (dA : dim0) (fA : Stored NoneType -> Init a).
  case sB of mk_view @dim0 @b (dB : dim0) (fB : Stored NoneType -> Init b).
  case sC of mk_view @dim0 @c (dC : dim0) (fC : Stored NoneType -> Init c).
  mk_view @dim0 @d dA
  (\ (i : Stored NoneType) -> Init d.
    case boxed @a (fA i) of boxed @a (x : a).
    case boxed @b (fB i) of boxed @b (y : b).
    case boxed @c (fC i) of boxed @c (z : c).
    transformer x y z);


ShapeDict_dim0_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sA : Stream dim0 a)
  (sB : Stream dim0 b)
  (sC : Stream dim0 c)
  (sD : Stream dim0 d)
  -> Stream dim0 e attribute(inline) =
  case sA of mk_view @dim0 @a (dA : dim0) (fA : Stored NoneType -> Init a).
  case sB of mk_view @dim0 @b (dB : dim0) (fB : Stored NoneType -> Init b).
  case sC of mk_view @dim0 @c (dC : dim0) (fC : Stored NoneType -> Init c).
  case sD of mk_view @dim0 @d (dD : dim0) (fD : Stored NoneType -> Init d).
  mk_view @dim0 @e dA
  (\ (i : Stored NoneType) -> Init e.
    case boxed @a (fA i) of boxed @a (x : a).
    case boxed @b (fB i) of boxed @b (y : b).
    case boxed @c (fC i) of boxed @c (z : c).
    case boxed @d (fD i) of boxed @d (w : d).
    transformer x y z w);

ShapeDict_dim0_slice @(t : bare -> bare) @(a : bare)
  (has_shape : coerce @box (shape t) dim0)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (sl : slice dim0)
  -> view dim0 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  mk_view @dim0 @a mk_dim0
  (\ (ix : Stored NoneType) -> Init a.
    at_index @a repr container (coerce @(index dim0) @(index (shape t)) ix));


ShapeDict_dim1 : ShapeDict dim1 =
  shapeDict @dim1
  repr_int
  repr_SliceObject
  ShapeDict_dim1_member
  ShapeDict_dim1_intersect
  ShapeDict_dim1_flatten
  ShapeDict_dim1_generate
  ShapeDict_dim1_map
  ShapeDict_dim1_zipWith
  ShapeDict_dim1_zipWith3
  ShapeDict_dim1_zipWith4
  ShapeDict_dim1_slice;


ShapeDict_dim1_member (dom : dim1) (ix : Stored int)
  -> bool attribute(inline) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case ix of stored @int (ix_i : int).

  -- Point must be in the interval and in the linear map
  if inInterval ix_i iv
  then inLM ix_i lm
  else False;


ShapeDict_dim1_intersect (d : dim1) (e : dim1)
  -> dim1 attribute(inline, inline_final) =
  case d of mk_dim1 (iv1 : Interval) (m1 : LinearMap).
  case e of mk_dim1 (iv2 : Interval) (m2 : LinearMap).
  case intersectLM m1 m2 of {
    justVal @LinearMap (m3 : LinearMap).
      let iv3 : Interval = trimInterval (intersectInterval iv1 iv2) m3 in
      mk_dim1 iv3 m3
  ; nothingVal @LinearMap.
      mk_dim1 (interval (justVal @int 0) (justVal @int 0)) (linearMap 1 0)
  };


ShapeDict_dim1_flatten @(a : bare)
  (repr : Repr a) (s : Stream dim1 a) -> Stream list_dim a
  attribute(inline, inline_dimensionality) =
  case s of mk_view @dim1 @a (dom : dim1) (f : Stored int -> Init a).

  -- Compute the size of the list
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case lm of linearMap (stride : int) (alignment : int).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case case lb of {
         justVal @int (lb_i : int).
           case ub of {
             justVal @int (ub_i : int).
               -- Bounded list
               (justVal @int ((ub_i -# lb_i) //# stride),
                linearMap stride lb_i)
           ; nothingVal @int.
               -- Unbounded list
               (nothingVal @int,
                linearMap stride lb_i)
         }
       ; nothingVal @int. except @(MaybeVal int, LinearMap)
       } of
    (list_size : MaybeVal int, list_map : LinearMap).

  viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a
   repr (mk_list_dim list_size)
   (\ (ix : Stored int) -> Init a.
      case ix of stored @int (ix_u : int).
      case boxed @(Stored int) (stored @int (evalLM ix_u list_map)) of
        boxed @(Stored int) (ix2 : Stored int).
      f ix2));


ShapeDict_dim1_generate @(a : bare)
  (repr : Repr a) (dom : dim1) (f : index dim1 -> Init a)
  -> Stream dim1 a attribute(inline) =
  view_generate @dim1
  ShapeDict_dim1 @a repr dom f;


ShapeDict_dim1_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Init b)
  (s : Stream dim1 a)
  -> Stream dim1 b attribute(inline) =
  view_map @dim1
  ShapeDict_dim1 @a @b repr_a repr_b transformer s;


ShapeDict_dim1_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim1 c attribute(inline) =
  view_zipWith @dim1 ShapeDict_dim1 @a @b @c
  repr_a repr_b repr_c transformer sa sb;


ShapeDict_dim1_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  (sc : Stream dim1 c)
  -> Stream dim1 d attribute(inline) =
  view_zipWith3 @dim1 ShapeDict_dim1 @a @b @c @d
  repr_a repr_b repr_c repr_d transformer sa sb sc;


ShapeDict_dim1_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  (sc : Stream dim1 c)
  (sd : Stream dim1 d)
  -> Stream dim1 e attribute(inline) =
  view_zipWith4 @dim1 ShapeDict_dim1 @a @b @c @d @e
  repr_a repr_b repr_c repr_d repr_e transformer sa sb sc sd;


ShapeDict_dim1_slice @(t : bare -> bare) @(a : bare)
  (is_dim1 : coerce @box (shape t) dim1)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice dim1)
  -> view dim1 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute the slice's domain
  let dom : dim1 = coerce @(shape t) @dim1 (get_shape @a container) in
  let slice_dom : dim1 = internalApplyArraySlice slice_argument dom in

  view_generate @dim1
  ShapeDict_dim1 @a repr slice_dom
  (\ (i : index dim1) (ret : OutPtr a) -> Store.
    at_index @a repr container (coerce @(index dim1) @(index (shape t)) i) ret);


ShapeDict_dim2 : ShapeDict dim2 =
  shapeDict @dim2
  repr_index2
  repr_slice2
  ShapeDict_dim2_member
  ShapeDict_dim2_intersect
  ShapeDict_dim2_flatten
  ShapeDict_dim2_generate
  ShapeDict_dim2_map
  ShapeDict_dim2_zipWith
  ShapeDict_dim2_zipWith3
  ShapeDict_dim2_zipWith4
  ShapeDict_dim2_slice;


ShapeDict_dim2_member (dom : dim2) (ix : index dim2) -> bool =
  -- Take the conjunction of x and y membership conditions
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case ix of tuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
  if ShapeDict_dim1_member dom_y ix_y
  then ShapeDict_dim1_member dom_x ix_x
  else False;


ShapeDict_dim2_intersect (domA : dim2) (domB : dim2) -> dim2 =
  -- Take the intersection in each dimension
  case domA of mk_dim2 (domA_y : dim1) (domA_x : dim1).
  case domB of mk_dim2 (domB_y : dim1) (domB_x : dim1).
  mk_dim2 (ShapeDict_dim1_intersect domA_y domB_y)
          (ShapeDict_dim1_intersect domA_x domB_x);


ShapeDict_dim2_generate @(a : bare)
  (repr : Repr a) (dom : dim2) (f : index dim2 -> Init a)
  -> Stream dim2 a attribute(inline) =
  view_generate @dim2 ShapeDict_dim2 @a repr dom f;


ShapeDict_dim2_flatten_helper
  (iv_y : Interval)
  (iv_x : Interval)
  (stride_y : int)
  (stride_x : int)
  -> (list_dim, MaybeVal int, int, int)
  attribute(inline, inline_final) =

  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).

  -- Lower bound must be finite
  case lb_x of {
    justVal @int (lb_x_i : int).
      case ub_x of {
        justVal @int (ub_x_i : int).
          -- Domain has finite x extent
          let count_x : int = (ub_x_i -# lb_x_i) //# stride_x in

          case lb_y of {
            justVal @int (lb_y_i : int).

              -- Compute the number of points in the domain
              let list_size : MaybeVal int =
                    case ub_y of {
                      justVal @int (ub_y_i : int).
                        -- Domain is bounded on all sides
                        let count_y : int = (ub_y_i -# lb_y_i) //# stride_y in
                        justVal @int (count_x *# count_y)
                    ; nothingVal @int.

                        -- Domain is unbounded in the y-dimension
                        nothingVal @int
                    } in

              (mk_list_dim list_size, justVal @int count_x, lb_y_i, lb_x_i)
            ; nothingVal @int.
                except @(list_dim, MaybeVal int, int, int)
            }

      ; nothingVal @int.
          -- Domain has infinite x extent
          case lb_y of {
            justVal @int (lb_y_i : int).
              (mk_list_dim (nothingVal @int), nothingVal @int, lb_y_i, lb_x_i)

          ; nothingVal @int.
              except @(list_dim, MaybeVal int, int, int)
          }
      }

  ; nothingVal @int.
      except @(list_dim, MaybeVal int, int, int)
  };


ShapeDict_dim2_flatten_helper2 (i : int) (divisor : MaybeVal int) -> (int, int)
  attribute(inline, inline_final) =
  case divisor of {
    justVal @int (count_x : int). (i //# count_x, i %# count_x)
  ; nothingVal @int. (0, i)
  };

ShapeDict_dim2_flatten @(a : bare)
  (repr : Repr a) (s : Stream dim2 a) -> Stream list_dim a
  attribute(inline, inline_dimensionality) =
  case s of mk_view @dim2 @a (dom : dim2) (f : index dim2 -> Init a).
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dom_x of mk_dim1 (iv_x : Interval) (lm_x : LinearMap).
  case dom_y of mk_dim1 (iv_y : Interval) (lm_y : LinearMap).
  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lm_x of linearMap (stride_x : int) (alignment_x : int).
  case lm_y of linearMap (stride_y : int) (alignment_y : int).

  -- Compute stream dimensions and indices
  case ShapeDict_dim2_flatten_helper iv_y iv_x stride_y stride_x
  of (flattened_size : list_dim, divisor : MaybeVal int, lb_y_i : int, lb_x_i : int).

  viewStream @a
  (mk_view @list_dim @a flattened_size
   (\ (si : Stored int) (ret : OutPtr a) -> Store.
      -- Linearize the index
      case si of stored @int (i : int).
      case ShapeDict_dim2_flatten_helper2 i divisor
      of (i_y : int, i_x : int).

      -- Apply the stride to get an index in the domain
      let dim2_i_y : int = lb_y_i +# i_y *# stride_y in 
      let dim2_i_x : int = lb_x_i +# i_x *# stride_x in 

      let type index2d = Tuple2 (Stored int) (Stored int) in
      case boxed @index2d
           (tuple2 @(Stored int) @(Stored int)
            (stored @int dim2_i_y) (stored @int dim2_i_x))
      of boxed @index2d (index_2d : index2d).
      f index_2d ret));


ShapeDict_dim2_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Init b)
  (s : Stream dim2 a)
  -> Stream dim2 b attribute(inline) =
  view_map @dim2
  ShapeDict_dim2 @a @b repr_a repr_b transformer s;


ShapeDict_dim2_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sa : Stream dim2 a)
  (sb : Stream dim2 b)
  -> Stream dim2 c attribute(inline) =
  view_zipWith @dim2 ShapeDict_dim2 @a @b @c
  repr_a repr_b repr_c transformer sa sb;


ShapeDict_dim2_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sa : Stream dim2 a)
  (sb : Stream dim2 b)
  (sc : Stream dim2 c)
  -> Stream dim2 d attribute(inline) =
  view_zipWith3 @dim2 ShapeDict_dim2 @a @b @c @d
  repr_a repr_b repr_c repr_d transformer sa sb sc;


ShapeDict_dim2_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sa : Stream dim2 a)
  (sb : Stream dim2 b)
  (sc : Stream dim2 c)
  (sd : Stream dim2 d)
  -> Stream dim2 e attribute(inline) =
  view_zipWith4 @dim2 ShapeDict_dim2 @a @b @c @d @e
  repr_a repr_b repr_c repr_d repr_e transformer sa sb sc sd;


ShapeDict_dim2_slice @(t : bare -> bare) @(a : bare)
  (is_dim2 : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice dim2)
  -> view dim2 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute the slice's domain
  case slice_argument of
    tuple2 @SliceObject @SliceObject
    (slice_y : SliceObject) (slice_x : SliceObject).

  let dom : dim2 = coerce @(shape t) @dim2 (get_shape @a container) in
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  let slice_dom : dim2 =
        mk_dim2 (internalApplyArraySlice slice_y dom_y)
                (internalApplyArraySlice slice_x dom_x) in

  view_generate @dim2
  ShapeDict_dim2 @a repr slice_dom
  (\ (i : index dim2) (ret : OutPtr a) -> Store.
    at_index @a repr container (coerce @(index dim2) @(index (shape t)) i) ret);


ShapeDict_dim3 : ShapeDict dim3 =
  shapeDict @dim3
  repr_index3
  repr_slice3
  ShapeDict_dim3_member
  ShapeDict_dim3_intersect
  ShapeDict_dim3_flatten
  ShapeDict_dim3_generate
  ShapeDict_dim3_map
  ShapeDict_dim3_zipWith
  ShapeDict_dim3_zipWith3
  ShapeDict_dim3_zipWith4
  ShapeDict_dim3_slice;


ShapeDict_dim3_member (dom : dim3) (ix : index dim3) -> bool =
  -- Take the conjunction of x, y, z membership conditions
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case ix of tuple3 @(Stored int) @(Stored int) @(Stored int)
             (ix_z : Stored int) (ix_y : Stored int) (ix_x : Stored int).
  if ShapeDict_dim1_member dom_z ix_z
  then if ShapeDict_dim1_member dom_y ix_y
       then ShapeDict_dim1_member dom_x ix_x
       else False
  else False;


ShapeDict_dim3_intersect (domA : dim3) (domB : dim3) -> dim3 =
  -- Take the intersection in each dimension
  case domA of mk_dim3 (domA_z : dim1) (domA_y : dim1) (domA_x : dim1).
  case domB of mk_dim3 (domB_z : dim1) (domB_y : dim1) (domB_x : dim1).
  mk_dim3 (ShapeDict_dim1_intersect domA_z domB_z)
          (ShapeDict_dim1_intersect domA_y domB_y)
          (ShapeDict_dim1_intersect domA_x domB_x);


ShapeDict_dim3_flatten_helper
  (iv_z : Interval)
  (iv_y : Interval)
  (iv_x : Interval)
  (stride_z : int)
  (stride_y : int)
  (stride_x : int)
  -> (list_dim, MaybeVal (MaybeVal int, int), int, int, int)
  attribute(inline, inline_final) =

  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case iv_z of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).

  -- Lower bound must be finite
  case lb_x of {
    justVal @int (lb_x_i : int).
      case ub_x of {
        justVal @int (ub_x_i : int).
          -- Domain has finite x extent
          let count_x : int = (ub_x_i -# lb_x_i) //# stride_x in

          case lb_y of {
            justVal @int (lb_y_i : int).
              case ub_y of {
                justVal @int (ub_y_i : int).
                  -- Domain has finite y extent
                    let count_y : int = (ub_y_i -# lb_y_i) //# stride_y in
                    let count_xy : int = count_x *# count_y in
                    case lb_z of {
                      justVal @int (lb_z_i : int).

                        -- Compute the number of points in the domain
                        let list_size : MaybeVal int =
                              case ub_z of {
                                justVal @int (ub_z_i : int).
                                  -- Domain is bounded on all sides
                                  let count_z : int =
                                        (ub_z_i -# lb_z_i) //# stride_z in
                                  justVal @int (count_xy *# count_z)
                              ; nothingVal @int.

                                  -- Domain is unbounded in the z-dimension
                                  nothingVal @int
                              } in

                        (mk_list_dim list_size,
                         justVal @(MaybeVal int, int)
                         (justVal @int count_xy, count_x),
                         lb_z_i, lb_y_i, lb_x_i)

                    ; nothingVal @int.
                        except @(list_dim, MaybeVal (MaybeVal int, int),
                                 int, int, int)
                    }
                ; nothingVal @int.

                    -- Domain has infinite y extent
                    case lb_z of {
                      justVal @int (lb_z_i : int).
                        (mk_list_dim (nothingVal @int),
                         justVal @(MaybeVal int, int)
                         (nothingVal @int, count_x),
                         lb_z_i, lb_y_i, lb_x_i)
                    ; nothingVal @int.
                        except @(list_dim, MaybeVal (MaybeVal int, int),
                                 int, int, int)
                    }
                }
            ; nothingVal @int.
                except @(list_dim, MaybeVal (MaybeVal int, int), int, int, int)
            }

      ; nothingVal @int.
          -- Domain has infinite x extent
          case lb_y of {
            justVal @int (lb_y_i : int).
              case lb_z of {
                justVal @int (lb_z_i : int).
                  (mk_list_dim (nothingVal @int),
                   nothingVal @(MaybeVal int, int), lb_z_i, lb_y_i, lb_x_i)
              ; nothingVal @int.
                  except @(list_dim, MaybeVal (MaybeVal int, int),
                           int, int, int)
              }

          ; nothingVal @int.
              except @(list_dim, MaybeVal (MaybeVal int, int), int, int, int)
          }
      }

  ; nothingVal @int.
      except @(list_dim, MaybeVal (MaybeVal int, int), int, int, int)
  };


ShapeDict_dim3_flatten_helper2
  (i : int) (divisors : MaybeVal (MaybeVal int, int))
  -> (int, int, int)
  attribute(inline, inline_final) =
  case divisors of {
    justVal @(MaybeVal int, int) (divisors_yx : (MaybeVal int, int)).

      -- Finite in the X dimension
      case divisors_yx of (divisor_xy : MaybeVal int, count_x : int).
      case divisor_xy of {
        justVal @int (count_xy : int).

          -- Finite in all dimensions
          let i_xy : int = i %# count_xy in
          let i_z : int = i //# count_xy in
          (i_z, i_xy //# count_x, i_xy %# count_x)

      ; nothingVal @int.
          -- Infinite in the Y dimension
          (0, i //# count_x, i %# count_x)
      }
  ; nothingVal @(MaybeVal int, int). (0, 0, i)
  };

ShapeDict_dim3_flatten @(a : bare)
  (repr : Repr a) (s : Stream dim3 a) -> Stream list_dim a
  attribute(inline, inline_dimensionality) =
  case s of mk_view @dim3 @a (dom : dim3) (f : index dim3 -> Init a).
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case dom_z of mk_dim1 (iv_z : Interval) (lm_z : LinearMap).
  case dom_x of mk_dim1 (iv_x : Interval) (lm_x : LinearMap).
  case dom_y of mk_dim1 (iv_y : Interval) (lm_y : LinearMap).
  case iv_z of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).
  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lm_z of linearMap (stride_z : int) (alignment_z : int).
  case lm_x of linearMap (stride_x : int) (alignment_x : int).
  case lm_y of linearMap (stride_y : int) (alignment_y : int).

  -- Compute stream dimensions and indices
  case ShapeDict_dim3_flatten_helper iv_z iv_y iv_x stride_z stride_y stride_x
  of (flattened_size : list_dim,
      divisors : MaybeVal (MaybeVal int, int),
      lb_z_i : int, lb_y_i : int, lb_x_i : int).

  viewStream @a
  (mk_view @list_dim @a flattened_size
   (\ (si : Stored int) (ret : OutPtr a) -> Store.
      -- Linearize the index
      case si of stored @int (i : int).
      case ShapeDict_dim3_flatten_helper2 i divisors
      of (i_z : int, i_y : int, i_x : int).

      -- Apply the stride to get an index in the domain
      let dim2_i_z : int = lb_z_i +# i_z *# stride_z in 
      let dim2_i_y : int = lb_y_i +# i_y *# stride_y in 
      let dim2_i_x : int = lb_x_i +# i_x *# stride_x in 

      let type Sint = Stored int in
      let type index3d = Tuple3 Sint Sint Sint in
      case boxed @index3d
           (tuple3 @Sint @Sint @Sint
            (stored @int dim2_i_z) (stored @int dim2_i_y) (stored @int dim2_i_x))
      of boxed @index3d (index_3d : index3d).
      f index_3d ret));


ShapeDict_dim3_generate @(a : bare)
  (repr : Repr a) (dom : dim3) (f : index dim3 -> Init a)
  -> Stream dim3 a attribute(inline) =
  view_generate @dim3 ShapeDict_dim3 @a repr dom f;


ShapeDict_dim3_map @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (transformer : a -> Init b)
  (s : Stream dim3 a)
  -> Stream dim3 b attribute(inline) =
  view_map @dim3
  ShapeDict_dim3 @a @b repr_a repr_b transformer s;


ShapeDict_dim3_zipWith @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sa : Stream dim3 a)
  (sb : Stream dim3 b)
  -> Stream dim3 c attribute(inline) =
  view_zipWith @dim3 ShapeDict_dim3 @a @b @c
  repr_a repr_b repr_c transformer sa sb;


ShapeDict_dim3_zipWith3 @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sa : Stream dim3 a)
  (sb : Stream dim3 b)
  (sc : Stream dim3 c)
  -> Stream dim3 d attribute(inline) =
  view_zipWith3 @dim3 ShapeDict_dim3 @a @b @c @d
  repr_a repr_b repr_c repr_d transformer sa sb sc;


ShapeDict_dim3_zipWith4 @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sa : Stream dim3 a)
  (sb : Stream dim3 b)
  (sc : Stream dim3 c)
  (sd : Stream dim3 d)
  -> Stream dim3 e attribute(inline) =
  view_zipWith4 @dim3 ShapeDict_dim3 @a @b @c @d @e
  repr_a repr_b repr_c repr_d repr_e transformer sa sb sc sd;


ShapeDict_dim3_slice @(t : bare -> bare) @(a : bare)
  (is_dim3 : coerce @box (shape t) dim3)
  (indexable : IndexableDict t)
  (repr : Repr a)
  (container : t a)
  (slice_argument : slice dim3)
  -> view dim3 a attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Compute the slice's domain
  case slice_argument of
    tuple3 @SliceObject @SliceObject @SliceObject
    (slice_z : SliceObject) (slice_y : SliceObject) (slice_x : SliceObject).

  let dom : dim3 = coerce @(shape t) @dim3 (get_shape @a container) in
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  let slice_dom : dim3 =
        mk_dim3 (internalApplyArraySlice slice_z dom_z)
                (internalApplyArraySlice slice_y dom_y)
                (internalApplyArraySlice slice_x dom_x) in

  view_generate @dim3
  ShapeDict_dim3 @a repr slice_dom
  (\ (i : index dim3) (ret : OutPtr a) -> Store.
    at_index @a repr container (coerce @(index dim3) @(index (shape t)) i) ret);


-------------------------------------------------------------------------------
-- Indexable dictionaries

IndexableDict_list_at_point @(a : bare)
  (repr : Repr a) (ls : list a) (ix : Stored int) (ret : OutPtr a) -> Store
  attribute(inline) =
  case ls of make_list @a @(N : intindex)
             (n : FIInt N) (ayref : StuckBox (arr N a)).
  case ayref of stuckBox @(arr N a) (ay : arr N a).
  case ix of stored @int (ix_i : int).
  copy @a repr (subscript @N @a (reprSizeAlign @a repr) ay ix_i) ret;


IndexableDict_list_get_shape @(a : bare) (ls : list a) -> list_dim
  attribute(inline) =
  case ls of make_list @a @(N : intindex)
             (n : FIInt N) (ayref : StuckBox (arr N a)).
  case n of fiInt @N (size : int).
  mk_list_dim (justVal @int size);


IndexableDict_view_at_point @(sh : box) (dict : ShapeDict sh) ->
  (a : bare) -> Repr a -> view sh a -> index sh -> Init a =
  \ @(a : bare)
    (repr : Repr a) (vw : view sh a) (ix : index sh) -> Init a.
    case vw of mk_view @sh @a (dom : sh) (f : index sh -> Init a).
    f ix;


IndexableDict_view_get_shape @(sh : box) (dict : ShapeDict sh) ->
  (a : bare) -> view sh a -> sh =
  \ @(a : bare) (vw : view sh a) -> sh.
    case vw of mk_view @sh @a (dom : sh) (f : index sh -> Init a).
    dom;


IndexableDict_array0_at_point @(a : bare)
  (repr : Repr a) (ay : array0 a) (ix : Stored NoneType) (ret : OutPtr a)
  -> Store
  attribute(inline) =
  case ay of mk_array0 @a (x : StuckBox a).
  case x of stuckBox @a (ux : a).
  copy @a repr ux ret;


IndexableDict_array0_get_shape @(a : bare)
  (ay : array0 a) -> dim0
  attribute(inline) =
  mk_dim0;


IndexableDict_array1_at_point @(a : bare)
  (repr : Repr a) (ay : array1 a) (ix : Stored int) (ret : OutPtr a)
  -> Store
  attribute(inline) =
  case ay of mk_array1 @a @(N : intindex)
             (lb : int) (stride : int) (size : FIInt N)
             (ayref : StuckBox (arr N a)).
  case ayref of stuckBox @(arr N a) (ay : arr N a).

  -- Compute real array index
  case ix of stored @int (ix_i : int).
  let real_index : int = (ix_i -# lb) //# stride in
  copy @a repr (subscript @N @a (reprSizeAlign @a repr) ay real_index) ret;


IndexableDict_array1_get_shape @(a : bare)
  (ay : array1 a) -> dim1
  attribute(inline) =
  case ay of mk_array1 @a @(N : intindex)
             (lb : int) (stride : int) (size : FIInt N)
             (ayref : StuckBox (arr N a)).
  arrayDescToDim1 @N lb stride size;


IndexableDict_array2_at_point @(a : bare)
  (repr : Repr a)
  (ay : array2 a)
  (ix : Tuple2 (Stored int) (Stored int))
  (ret : OutPtr a)
  -> Store
  attribute(inline) =
  case ay of mk_array2 @a @(M N : intindex)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr M (arr N a))).
  case ayref of stuckBox @(arr M (arr N a)) (ay : arr M (arr N a)).
  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in

  -- Compute real array indices
  case ix of tuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
  case ix_y of stored @int (ix_y_i : int).
  let real_index_y : int = (ix_y_i -# lb_y) //# stride_y in
  case ix_x of stored @int (ix_x_i : int).
  let real_index_x : int = (ix_x_i -# lb_x) //# stride_x in

  -- Copy the desired element
  copy @a repr
  (subscript @N @a (reprSizeAlign @a repr)
   (subscript @M @(arr N a) (reprSizeAlign @(arr N a) row_repr)
    ay real_index_y)
   real_index_x) ret;


IndexableDict_array2_get_shape @(a : bare)
  (ay : array2 a) -> dim2
  attribute(inline) =
  case ay of mk_array2 @a @(M N : intindex)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr M (arr N a))).
  mk_dim2 (arrayDescToDim1 @M lb_y stride_y size_y)
          (arrayDescToDim1 @N lb_x stride_x size_x);


IndexableDict_array3_at_point @(a : bare)
  (repr : Repr a)
  (ay : array3 a)
  (ix : Tuple3 (Stored int) (Stored int) (Stored int))
  (ret : OutPtr a)
  -> Store
  attribute(inline) =
  case ay of mk_array3 @a @(L M N : intindex)
             (lb_z : int) (stride_z : int) (size_z : FIInt L)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr L (arr M (arr N a)))).
  case ayref of stuckBox @(arr L (arr M (arr N a))) (ay : arr L (arr M (arr N a))).
  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  let plane_repr : Repr (arr M (arr N a)) =
        repr_arr @M @(arr N a) size_y row_repr in

  -- Compute real array indices
  case ix of tuple3 @(Stored int) @(Stored int) @(Stored int)
             (ix_z : Stored int) (ix_y : Stored int) (ix_x : Stored int).
  case ix_z of stored @int (ix_z_i : int).
  let real_index_z : int = (ix_z_i -# lb_z) //# stride_z in
  case ix_y of stored @int (ix_y_i : int).
  let real_index_y : int = (ix_y_i -# lb_y) //# stride_y in
  case ix_x of stored @int (ix_x_i : int).
  let real_index_x : int = (ix_x_i -# lb_x) //# stride_x in

  -- Copy the desired element
  copy @a repr
  (subscript @N @a (reprSizeAlign @a repr)
   (subscript @M @(arr N a) (reprSizeAlign @(arr N a) row_repr)
     (subscript @L @(arr M (arr N a)) (reprSizeAlign @(arr M (arr N a)) plane_repr)
      ay real_index_z)
    real_index_y)
   real_index_x) ret;


IndexableDict_array3_get_shape @(a : bare)
  (ay : array3 a) -> dim3
  attribute(inline) =
  case ay of mk_array3 @a @(L M N : intindex)
             (lb_z : int) (stride_z : int) (size_z : FIInt L)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr L (arr M (arr N a)))).
  mk_dim3 (arrayDescToDim1 @L lb_z stride_z size_z)
          (arrayDescToDim1 @M lb_y stride_y size_y)
          (arrayDescToDim1 @N lb_x stride_x size_x);


IndexableDict_blist_at_point @(a : bare)
  (repr : Repr a) (ls : blist a) (ix : Stored int) (ret : OutPtr a) -> Store
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ls of make_blist @a (ls2 : list boxed_a).
  case ls2 of make_list @boxed_a @(N : intindex)
             (n : FIInt N) (ayref : StuckBox (arr N boxed_a)).
  case ayref of stuckBox @(arr N boxed_a) (ay : arr N boxed_a).
  let repr_box : Repr boxed_a = repr_StuckRef @(AsBox a) in
  case ix of stored @int (ix_i : int).
  case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay ix_i of
    stuckRef @(AsBox a) (val : AsBox a).
  asbare @a repr val ret;


IndexableDict_blist_get_shape @(a : bare) (ls : blist a) -> list_dim
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ls of make_blist @a (ls2 : list boxed_a).
  case ls2 of make_list @boxed_a @(N : intindex)
              (n : FIInt N) (ayref : StuckBox (arr N boxed_a)).
  case n of fiInt @N (size : int).
  mk_list_dim (justVal @int size);


IndexableDict_barray1_at_point @(a : bare)
  (repr : Repr a) (ay : barray1 a) (ix : Stored int) (ret : OutPtr a)
  -> Store
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ay of mk_barray1 @a (ay2 : array1 boxed_a).
  case ay2 of mk_array1 @boxed_a @(N : intindex)
             (lb : int) (stride : int) (size : FIInt N)
             (ayref : StuckBox (arr N boxed_a)).
  case ayref of stuckBox @(arr N boxed_a) (ay : arr N boxed_a).
  let boxed_repr : Repr boxed_a = repr_StuckRef @(AsBox a) in

  -- Compute real array index
  case ix of stored @int (ix_i : int).
  let real_index : int = (ix_i -# lb) //# stride in
  case subscript @N @boxed_a (reprSizeAlign @boxed_a boxed_repr) ay real_index
    of stuckRef @(AsBox a) (val : AsBox a).
  asbare @a repr val ret;


IndexableDict_barray1_get_shape @(a : bare)
  (ay : barray1 a) -> dim1
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ay of mk_barray1 @a (ay2 : array1 boxed_a).
  case ay2 of mk_array1 @boxed_a @(N : intindex)
             (lb : int) (stride : int) (size : FIInt N)
             (ayref : StuckBox (arr N boxed_a)).
  arrayDescToDim1 @N lb stride size;


IndexableDict_barray2_at_point @(a : bare)
  (repr : Repr a)
  (ay : barray2 a)
  (ix : Tuple2 (Stored int) (Stored int))
  (ret : OutPtr a)
  -> Store
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ay of mk_barray2 @a (ay2 : array2 boxed_a).
  case ay2 of mk_array2 @boxed_a @(M N : intindex)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr M (arr N boxed_a))).
  case ayref of stuckBox @(arr M (arr N boxed_a)) (ay : arr M (arr N boxed_a)).
  let boxed_repr : Repr boxed_a = repr_StuckRef @(AsBox a) in
  let row_repr : Repr (arr N boxed_a) =
        repr_arr @N @boxed_a size_x boxed_repr in

  -- Compute real array indices
  case ix of tuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
  case ix_y of stored @int (ix_y_i : int).
  let real_index_y : int = (ix_y_i -# lb_y) //# stride_y in
  case ix_x of stored @int (ix_x_i : int).
  let real_index_x : int = (ix_x_i -# lb_x) //# stride_x in

  -- Copy the desired element
  case subscript @N @boxed_a (reprSizeAlign @boxed_a boxed_repr)
       (subscript @M @(arr N boxed_a)
       (reprSizeAlign @(arr N boxed_a) row_repr) ay real_index_y) real_index_x
    of stuckRef @(AsBox a) (val : AsBox a).
  asbare @a repr val ret;


IndexableDict_barray2_get_shape @(a : bare)
  (ay : barray2 a) -> dim2
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in 
  case ay of mk_barray2 @a (ay2 : array2 boxed_a).
  case ay2 of mk_array2 @boxed_a @(M N : intindex)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr M (arr N boxed_a))).
  mk_dim2 (arrayDescToDim1 @M lb_y stride_y size_y)
          (arrayDescToDim1 @N lb_x stride_x size_x);


IndexableDict_barray3_at_point @(a : bare)
  (repr : Repr a)
  (ay : barray3 a)
  (ix : Tuple3 (Stored int) (Stored int) (Stored int))
  (ret : OutPtr a)
  -> Store
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in
  case ay of mk_barray3 @a (ay2 : array3 boxed_a).
  case ay2 of mk_array3 @boxed_a @(L M N : intindex)
             (lb_z : int) (stride_z : int) (size_z : FIInt L)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr L (arr M (arr N boxed_a)))).
  case ayref of stuckBox @(arr L (arr M (arr N boxed_a)))
                (ay : arr L (arr M (arr N boxed_a))).
  let boxed_repr : Repr boxed_a = repr_StuckRef @(AsBox a) in
  let row_repr : Repr (arr N boxed_a) =
        repr_arr @N @boxed_a size_x boxed_repr in
  let plane_repr : Repr (arr M (arr N boxed_a)) =
        repr_arr @M @(arr N boxed_a) size_y row_repr in

  -- Compute real array indices
  case ix of tuple3 @(Stored int) @(Stored int) @(Stored int)
             (ix_z : Stored int) (ix_y : Stored int) (ix_x : Stored int).
  case ix_z of stored @int (ix_z_i : int).
  let real_index_z : int = (ix_z_i -# lb_z) //# stride_z in
  case ix_y of stored @int (ix_y_i : int).
  let real_index_y : int = (ix_y_i -# lb_y) //# stride_y in
  case ix_x of stored @int (ix_x_i : int).
  let real_index_x : int = (ix_x_i -# lb_x) //# stride_x in

  -- Copy the desired element
  case subscript @N @boxed_a (reprSizeAlign @boxed_a boxed_repr)
       (subscript @M @(arr N boxed_a)
        (reprSizeAlign @(arr N boxed_a) row_repr)
        (subscript @L @(arr M (arr N boxed_a))
         (reprSizeAlign @(arr M (arr N boxed_a)) plane_repr)
         ay real_index_z) real_index_y) real_index_x
    of stuckRef @(AsBox a) (val : AsBox a).
  asbare @a repr val ret;


IndexableDict_barray3_get_shape @(a : bare)
  (ay : barray3 a) -> dim3
  attribute(inline) =
  let type boxed_a = StuckRef (AsBox a) in 
  case ay of mk_barray3 @a (ay2 : array3 boxed_a).
  case ay2 of mk_array3 @boxed_a @(L M N : intindex)
             (lb_z : int) (stride_z : int) (size_z : FIInt L)
             (lb_y : int) (stride_y : int) (size_y : FIInt M)
             (lb_x : int) (stride_x : int) (size_x : FIInt N)
             (ayref : StuckBox (arr L (arr M (arr N boxed_a)))).
  mk_dim3 (arrayDescToDim1 @L lb_z stride_z size_z)
          (arrayDescToDim1 @M lb_y stride_y size_y)
          (arrayDescToDim1 @N lb_x stride_x size_x);


-------------------------------------------------------------------------------
-- Comparison dictionaries

EqDict_int : EqDict (Boxed (Stored int));
EqDict_int_eq (bsx : Boxed (Stored int)) (bsy : Boxed (Stored int))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (eqI (unboxIntValue bsx) (unboxIntValue bsy));

EqDict_int_ne (bsx : Boxed (Stored int)) (bsy : Boxed (Stored int))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (neI (unboxIntValue bsx) (unboxIntValue bsy));

EqDict_float : EqDict (Boxed (Stored float));
EqDict_float_eq (bsx : Boxed (Stored float)) (bsy : Boxed (Stored float))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (eqF (unboxFloatValue bsx) (unboxFloatValue bsy));

EqDict_float_ne (bsx : Boxed (Stored float)) (bsy : Boxed (Stored float))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (neF (unboxFloatValue bsx) (unboxFloatValue bsy));

EqDict_Tuple2 : (a b : box) -> Repr a -> Repr b -> EqDict a -> EqDict b
             -> EqDict (Boxed (Tuple2 (AsBare a) (AsBare b)));
EqDict_Tuple2_eq @(a b : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b))
  (eqA : EqDict a) (eqB : EqDict b)
  (bx : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (by : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  case eqA of eqDict @a (eq_a : a -> a -> Boxed (Stored bool)) (ne_a : a -> a -> Boxed (Stored bool)).
  case eqB of eqDict @b (eq_b : b -> b -> Boxed (Stored bool)) (ne_b : b -> b -> Boxed (Stored bool)).
  case bx of boxed @(Tuple2 ba bb) (x : Tuple2 ba bb).
  case by of boxed @(Tuple2 ba bb) (y : Tuple2 ba bb).
  case x of tuple2 @ba @bb (xa : ba) (xb : bb).
  case y of tuple2 @ba @bb (ya : ba) (yb : bb).

  boxBoolValue
  (and (unboxBoolValue
        (eq_a (asbox @ba repA (copy @ba repA xa))
              (asbox @ba repA (copy @ba repA ya))))
       (unboxBoolValue
        (eq_b (asbox @bb repB (copy @bb repB xb))
              (asbox @bb repB (copy @bb repB yb)))));


EqDict_Tuple2_ne @(a b : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b))
  (eqA : EqDict a) (eqB : EqDict b)
  (bx : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (by : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  case eqA of eqDict @a (eq_a : a -> a -> Boxed (Stored bool)) (ne_a : a -> a -> Boxed (Stored bool)).
  case eqB of eqDict @b (eq_b : b -> b -> Boxed (Stored bool)) (ne_b : b -> b -> Boxed (Stored bool)).
  case bx of boxed @(Tuple2 ba bb) (x : Tuple2 ba bb).
  case by of boxed @(Tuple2 ba bb) (y : Tuple2 ba bb).
  case x of tuple2 @ba @bb (xa : ba) (xb : bb).
  case y of tuple2 @ba @bb (ya : ba) (yb : bb).

  boxBoolValue
  (and (unboxBoolValue
        (ne_a (asbox @ba repA (copy @ba repA xa))
              (asbox @ba repA (copy @ba repA ya))))
       (unboxBoolValue
        ((ne_b (asbox @bb repB (copy @bb repB xb))
              (asbox @bb repB (copy @bb repB yb))))));


EqDict_Tuple3 : (a b c : box)
             -> Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c)
             -> EqDict a -> EqDict b -> EqDict c
             -> EqDict (Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)));
EqDict_Tuple3_eq @(a b c : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b)) (repC : Repr (AsBare c))
  (eqA : EqDict a) (eqB : EqDict b) (eqC : EqDict c)
  (bx : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  (by : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  let type bc = AsBare c in
  case eqA of eqDict @a (eq_a : a -> a -> Boxed (Stored bool)) (ne_a : a -> a -> Boxed (Stored bool)).
  case eqB of eqDict @b (eq_b : b -> b -> Boxed (Stored bool)) (ne_b : b -> b -> Boxed (Stored bool)).
  case eqC of eqDict @c (eq_c : c -> c -> Boxed (Stored bool)) (ne_c : c -> c -> Boxed (Stored bool)).
  case bx of boxed @(Tuple3 ba bb bc) (x : Tuple3 ba bb bc).
  case by of boxed @(Tuple3 ba bb bc) (y : Tuple3 ba bb bc).
  case x of tuple3 @ba @bb @bc (xa : ba) (xb : bb) (xc : bc).
  case y of tuple3 @ba @bb @bc (ya : ba) (yb : bb) (yc : bc).

  let eq1 : bool = unboxBoolValue
                   (eq_a (asbox @ba repA (copy @ba repA xa))
                         (asbox @ba repA (copy @ba repA ya))) in
  let eq2 : bool = unboxBoolValue
                   (eq_b (asbox @bb repB (copy @bb repB xb))
                         (asbox @bb repB (copy @bb repB yb))) in
  let eq3 : bool = unboxBoolValue
                   (eq_c (asbox @bc repC (copy @bc repC xc))
                         (asbox @bc repC (copy @bc repC yc))) in
  boxBoolValue (and (and eq1 eq2) eq3);


EqDict_Tuple3_ne @(a b c : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b)) (repC : Repr (AsBare c))
  (eqA : EqDict a) (eqB : EqDict b) (eqC : EqDict c)
  (bx : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  (by : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  let type bc = AsBare c in
  case eqA of eqDict @a (eq_a : a -> a -> Boxed (Stored bool)) (ne_a : a -> a -> Boxed (Stored bool)).
  case eqB of eqDict @b (eq_b : b -> b -> Boxed (Stored bool)) (ne_b : b -> b -> Boxed (Stored bool)).
  case eqC of eqDict @c (eq_c : c -> c -> Boxed (Stored bool)) (ne_c : c -> c -> Boxed (Stored bool)).
  case bx of boxed @(Tuple3 ba bb bc) (x : Tuple3 ba bb bc).
  case by of boxed @(Tuple3 ba bb bc) (y : Tuple3 ba bb bc).
  case x of tuple3 @ba @bb @bc (xa : ba) (xb : bb) (xc : bc).
  case y of tuple3 @ba @bb @bc (ya : ba) (yb : bb) (yc : bc).

  let ne1 : bool = unboxBoolValue
                   (ne_a (asbox @ba repA (copy @ba repA xa))
                         (asbox @ba repA (copy @ba repA ya))) in
  let ne2 : bool = unboxBoolValue
                   (ne_b (asbox @bb repB (copy @bb repB xb))
                         (asbox @bb repB (copy @bb repB yb))) in
  let ne3 : bool = unboxBoolValue
                   (ne_c (asbox @bc repC (copy @bc repC xc))
                         (asbox @bc repC (copy @bc repC yc))) in
  boxBoolValue (and (and ne1 ne2) ne3);


OrdDict_int : OrdDict (Stored int);
OrdDict_int_lt : int -> int -> bool;
OrdDict_int_le : int -> int -> bool;
OrdDict_int_gt : int -> int -> bool;
OrdDict_int_ge : int -> int -> bool;

OrdDict_float : OrdDict (Stored float);
OrdDict_float_lt : float -> float -> bool;
OrdDict_float_le : float -> float -> bool;
OrdDict_float_gt : float -> float -> bool;
OrdDict_float_ge : float -> float -> bool;

OrdDict_Tuple2 : (a b : bare) -> OrdDict a -> OrdDict b -> OrdDict (Tuple2 a b);
OrdDict_Tuple2_lt : (a b : bare) -> OrdDict a -> OrdDict b -> a -> b -> bool;
OrdDict_Tuple2_le : (a b : bare) -> OrdDict a -> OrdDict b -> a -> b -> bool;
OrdDict_Tuple2_gt : (a b : bare) -> OrdDict a -> OrdDict b -> a -> b -> bool;
OrdDict_Tuple2_ge : (a b : bare) -> OrdDict a -> OrdDict b -> a -> b -> bool;

-------------------------------------------------------------------------------
-- Numeric dictionaries

AdditiveDict_int : AdditiveDict (Stored int);
AdditiveDict_int_add : int -> int -> int;
AdditiveDict_int_sub : int -> int -> int;
AdditiveDict_int_negate : int -> int;
AdditiveDict_int_zero : int;

AdditiveDict_uint : AdditiveDict (Stored uint);
AdditiveDict_uint_add : uint -> uint -> uint;
AdditiveDict_uint_sub : uint -> uint -> uint;
AdditiveDict_uint_negate : uint -> uint;
AdditiveDict_uint_zero : uint;

AdditiveDict_float : AdditiveDict (Stored float);
AdditiveDict_float_add : float -> float -> float;
AdditiveDict_float_sub : float -> float -> float;
AdditiveDict_float_negate : float -> float;
AdditiveDict_float_zero : float;

AdditiveDict_Tuple2 : (a b : bare) -> AdditiveDict a -> AdditiveDict b
                   -> AdditiveDict (Tuple2 a b);
AdditiveDict_Tuple2_add @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (x : Tuple2 a b)
  (y : Tuple2 a b)
  (ret : OutPtr (Tuple2 a b))
  -> Store =

  case additive_a of
    additiveDict @a
    (add_a : a -> a -> Init a)
    (sub_a : a -> a -> Init a)
    (negate_a : a -> Init a)
    (zero_a : a).
  case additive_b of
    additiveDict @b
    (add_b : b -> b -> Init b)
    (sub_b : b -> b -> Init b)
    (negate_b : b -> Init b)
    (zero_b : b).

  case x of tuple2 @a @b (x_a : a) (x_b : b).
  case y of tuple2 @a @b (y_a : a) (y_b : b).
  tuple2 @a @b (add_a x_a y_a) (add_b x_b y_b) ret;


AdditiveDict_Tuple2_sub @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (x : Tuple2 a b)
  (y : Tuple2 a b)
  (ret : OutPtr (Tuple2 a b))
  -> Store =

  case additive_a of
    additiveDict @a
    (add_a : a -> a -> Init a)
    (sub_a : a -> a -> Init a)
    (negate_a : a -> Init a)
    (zero_a : a).
  case additive_b of
    additiveDict @b
    (add_b : b -> b -> Init b)
    (sub_b : b -> b -> Init b)
    (negate_b : b -> Init b)
    (zero_b : b).

  case x of tuple2 @a @b (x_a : a) (x_b : b).
  case y of tuple2 @a @b (y_a : a) (y_b : b).
  tuple2 @a @b (sub_a x_a y_a) (sub_b x_b y_b) ret;


AdditiveDict_Tuple2_negate @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (x : Tuple2 a b)
  (ret : OutPtr (Tuple2 a b))
  -> Store =

  case additive_a of
    additiveDict @a
    (add_a : a -> a -> Init a)
    (sub_a : a -> a -> Init a)
    (negate_a : a -> Init a)
    (zero_a : a).
  case additive_b of
    additiveDict @b
    (add_b : b -> b -> Init b)
    (sub_b : b -> b -> Init b)
    (negate_b : b -> Init b)
    (zero_b : b).
  case x of tuple2 @a @b (x_a : a) (x_b : b).
  tuple2 @a @b (negate_a x_a) (negate_b x_b) ret;


AdditiveDict_Tuple2_zero @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (ret : OutPtr (Tuple2 a b))
  -> Store =

  case additive_a of
    additiveDict @a
    (add_a : a -> a -> Init a)
    (sub_a : a -> a -> Init a)
    (negate_a : a -> Init a)
    (zero_a : a).
  case additive_b of
    additiveDict @b
    (add_b : b -> b -> Init b)
    (sub_b : b -> b -> Init b)
    (negate_b : b -> Init b)
    (zero_b : b).
  tuple2 @a @b (copy @a repr_a zero_a) (copy @b repr_b zero_b) ret;

{-AdditiveDict_Complex_add :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
AdditiveDict_Complex_sub :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
AdditiveDict_Complex_negate :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Complex a
 -> Init (Complex a);
AdditiveDict_Complex_zero :
    (a : bare)
 -> Repr a
 -> AdditiveDict a
 -> Init (Complex a);-}

MultiplicativeDict_int : MultiplicativeDict (Stored int);
MultiplicativeDict_int_one : int;
MultiplicativeDict_int_mul : int -> int -> int;

-- Converting int to int is the identity transformation
MultiplicativeDict_int_fromInt (x : int) -> int attribute(inline) = x;

MultiplicativeDict_uint : MultiplicativeDict (Stored uint);
MultiplicativeDict_uint_one : uint;
MultiplicativeDict_uint_mul : uint -> uint -> uint;
MultiplicativeDict_uint_fromInt : int -> uint;

MultiplicativeDict_float : MultiplicativeDict (Stored float);
MultiplicativeDict_float_one : float;
MultiplicativeDict_float_mul : float -> float -> float;
MultiplicativeDict_float_fromInt : int -> float;

{-MultiplicativeDict_Complex_mul :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
MultiplicativeDict_Complex_fromInt :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> int
 -> Init (Complex a);
MultiplicativeDict_Complex_one :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> Init (Complex a);-}


RemainderDict_int_floordiv : int -> int -> int;
RemainderDict_int_mod : int -> int -> int;

RemainderDict_uint_floordiv : uint -> uint -> uint;
RemainderDict_uint_mod : uint -> uint -> uint;

RemainderDict_float_floordiv : float -> float -> int;
RemainderDict_float_mod : float -> float -> float;


FractionalDict_float_div : float -> float -> float;

FractionalDict_Complex_div :
    (a : bare)
 -> Repr a
 -> FractionalDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);


FloatingDict_float_fromfloat : float -> float;
FloatingDict_float_power : float -> float -> float;
FloatingDict_float_exp : float -> float;
FloatingDict_float_log : float -> float;
FloatingDict_float_sqrt : float -> float;
FloatingDict_float_sin : float -> float;
FloatingDict_float_cos : float -> float;
FloatingDict_float_tan : float -> float;
FloatingDict_float_pi : float;

FloatingDict_Complex_fromfloat :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> float
 -> Init (Complex a);
FloatingDict_Complex_power :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_exp :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_log :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_sqrt :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_sin :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_cos :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_tan :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Complex a
 -> Init (Complex a);
FloatingDict_Complex_pi :
    (a : bare)
 -> Repr a
 -> MultiplicativeDict a
 -> FractionalDict a
 -> FloatingDict a
 -> Init (Complex a);


VectorDict_float_scale : float -> float -> float;
VectorDict_float_magnitude : float -> float;
VectorDict_float_dot : float -> float -> float;

VectorDict_Complex_scale :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> float
 -> Init (Complex a);

VectorDict_Complex_magnitude :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> float;

VectorDict_Complex_dot :
    (a : bare)
 -> Repr a
 -> VectorDict a
 -> Complex a
 -> Complex a
 -> float;

CartesianDict_dim0_loBound
  (dom : dim0)
  -> Init (Maybe (index dim0))
  attribute(inline) =
  just @(Stored NoneType) (stored @NoneType None);


CartesianDict_dim0_hiBound
  (dom : dim0)
  -> Init (Maybe (index dim0))
  attribute(inline) =
  just @(Stored NoneType) (stored @NoneType None);


CartesianDict_dim0_stride
  (dom : dim0)
  -> Init (index dim0)
  attribute(inline) =
  stored @NoneType None;


CartesianDict_dim0_arrayDomain
  (lo : index dim0)
  (hi : index dim0)
  -> dim0
  attribute(inline) =
  mk_dim0;


CartesianDict_dim0_displaceDomain
  (dom : dim0)
  (ix : index dim0)
  -> dim0
  attribute(inline) =
  mk_dim0;


CartesianDict_dim0_multiplyDomain
  (dom : dim0)
  (n : Stored NoneType)
  -> dim0
  attribute(inline) =
  mk_dim0;


CartesianDict_dim0_divideDomain
  (dom : dim0)
  (n : Stored NoneType)
  -> dim0
  attribute(inline) =
  mk_dim0;


CartesianDict_dim0_multiplyIndex :
    index dim0 -> index dim0 -> Init (index dim0);

CartesianDict_dim0_divideIndex :
    index dim0 -> index dim0 -> Init (index dim0);

CartesianDict_dim0_unbounded :
    dim0;


CartesianDict_dim1_loBound
  (dom : dim1)
  (ret : OutPtr (Maybe (index dim1)))
  -> Store
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal @int (x : int).  just @(Stored int) (stored @int x) ret
  ; nothingVal @int. nothing @(Stored int) ret
  };


CartesianDict_dim1_hiBound
  (dom : dim1)
  (ret : OutPtr (Maybe (index dim1)))
  -> Store
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case ub of {
    justVal @int (x : int).  just @(Stored int) (stored @int x) ret
  ; nothingVal @int. nothing @(Stored int) ret
  };


CartesianDict_dim1_stride
  (dom : dim1)
  -> Init (index dim1)
  attribute(inline) =
  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case lm of linearMap (stride : int) (alignment : int).
  stored @int stride;
  

CartesianDict_dim1_arrayDomain
  (lo : index dim1)
  (hi : index dim1)
  -> dim1
  attribute(inline, inline_final) =
  case lo of stored @int (lo_i : int).
  case hi of stored @int (hi_i : int).

  -- Check for empty range
  if lo_i ># hi_i
  then mk_dim1 (interval (justVal @int 0) (justVal @int 0)) (linearMap 1 0)
  else mk_dim1 (interval (justVal @int lo_i) (justVal @int hi_i))
               (linearMap 1 0);


CartesianDict_dim1_displaceDomain
  (dom : dim1)
  (ix : index dim1)
  -> dim1
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case m of linearMap (stride : int) (alignment : int).
  case ix of stored @int (offset_i : int).

  let lb2 : MaybeVal int =
        case lb of {
          justVal @int (lb_i : int). justVal @int (lb_i +# offset_i)
        ; nothingVal @int. nothingVal @int
        } in
  let ub2 : MaybeVal int =
        case ub of {
          justVal @int (ub_i : int). justVal @int (ub_i +# offset_i)
        ; nothingVal @int. nothingVal @int
        } in
  mk_dim1 (interval lb2 ub2)
          (linearMap stride ((alignment +# offset_i) %# stride));


CartesianDict_dim1_multiplyDomain
  (dom : dim1)
  (n : Stored int)
  -> dim1
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case m of linearMap (stride : int) (alignment : int).
  case n of stored @int (n_u : int).

  -- Stride must remain positive
  if n_u <=# 0 then except @dim1 else
  
  let lb2 : MaybeVal int =
        case lb of {
          justVal @int (lb_i : int). justVal @int (lb_i *# n_u)
        ; nothingVal @int. nothingVal @int
        } in

  let ub2 : MaybeVal int =
        case ub of {
          justVal @int (ub_i : int). justVal @int (ub_i *# n_u)
        ; nothingVal @int. nothingVal @int
        } in
  mk_dim1 (interval lb2 ub2)
          (linearMap (stride *# n_u) (alignment *# n_u));


CartesianDict_dim1_divideDomain
  (dom : dim1)
  (n : Stored int)
  -> dim1
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case m of linearMap (stride : int) (alignment : int).
  case n of stored @int (n_u : int).

  -- Stride must remain positive
  if n_u <=# 0 then except @dim1 else

  -- Ensure that it divides exactly
  if or (stride %# n_u /=# 0) (alignment %# n_u /=# 0)
  then except @(dim1) else
  
  let lb2 : MaybeVal int =
        case lb of {
          justVal @int (lb_i : int). justVal @int (lb_i //# n_u)
        ; nothingVal @int. nothingVal @int
        } in

  let ub2 : MaybeVal int =
        case ub of {
          justVal @int (ub_i : int). justVal @int (ub_i //# n_u)
        ; nothingVal @int. nothingVal @int
        } in
  mk_dim1 (interval lb2 ub2)
          (linearMap (stride //# n_u) (alignment //# n_u));


CartesianDict_dim1_multiplyIndex :
    index dim1 -> index dim1 -> Init (index dim1);

CartesianDict_dim1_divideIndex :
    index dim1 -> index dim1 -> Init (index dim1);

CartesianDict_dim1_unbounded :
    dim1;


CartesianDict_dim2_loBound
  (dom : dim2)
  (ret : OutPtr (Maybe (index dim2)))
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dom_y of mk_dim1 (iv_y : Interval) (lm : LinearMap).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lb_y of {
    justVal @int (y : int).
      case dom_x of mk_dim1 (iv_x : Interval) (lm : LinearMap).
      case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
      case lb_x of {
        justVal @int (x : int).
          just @(Tuple2 (Stored int) (Stored int))
               (tuple2 @(Stored int) @(Stored int)
                (stored @int y) (stored @int x)) ret
      ; nothingVal @int.
          nothing @(Tuple2 (Stored int) (Stored int)) ret
      }
  ; nothingVal @int.
      nothing @(Tuple2 (Stored int) (Stored int)) ret
  };
  

CartesianDict_dim2_hiBound
  (dom : dim2)
  (ret : OutPtr (Maybe (index dim2)))
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dom_y of mk_dim1 (iv_y : Interval) (lm : LinearMap).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case ub_y of {
    justVal @int (y : int).
      case dom_x of mk_dim1 (iv_x : Interval) (lm : LinearMap).
      case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
      case ub_x of {
        justVal @int (x : int).
          just @(Tuple2 (Stored int) (Stored int))
               (tuple2 @(Stored int) @(Stored int)
               (stored @int y) (stored @int x)) ret
      ; nothingVal @int.
          nothing @(Tuple2 (Stored int) (Stored int)) ret
      }
  ; nothingVal @int.
      nothing @(Tuple2 (Stored int) (Stored int)) ret
  };


CartesianDict_dim2_stride
  (dom : dim2)
  -> Init (index dim2)
  attribute(inline) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  tuple2 @(Stored int) @(Stored int)
  (CartesianDict_dim1_stride dom_y)
  (CartesianDict_dim1_stride dom_x);


CartesianDict_dim2_arrayDomain
  (lo : index dim2)
  (hi : index dim2)
  -> dim2
  attribute(inline) =
  case lo of
    tuple2 @(Stored int) @(Stored int)
               (lo_y : Stored int) (lo_x : Stored int).
  case lo_y of stored @int (lo_y_i : int).
  case lo_x of stored @int (lo_x_i : int).
  case hi of
    tuple2 @(Stored int) @(Stored int)
               (hi_y : Stored int) (hi_x : Stored int).
  case hi_y of stored @int (hi_y_i : int).
  case hi_x of stored @int (hi_x_i : int).
  mk_dim2 (mk_dim1 (interval (justVal @int lo_y_i) (justVal @int hi_y_i))
                   (linearMap 1 0))
          (mk_dim1 (interval (justVal @int lo_x_i) (justVal @int hi_x_i))
                   (linearMap 1 0));


CartesianDict_dim2_displaceDomain
  (dom : dim2)
  (ix : index dim2)
  -> dim2
  attribute(inline) =
  case ix of tuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  mk_dim2 (CartesianDict_dim1_displaceDomain dom_y ix_y)
          (CartesianDict_dim1_displaceDomain dom_x ix_x);


CartesianDict_dim2_multiplyDomain
  (dom : dim2)
  (v : Tuple2 (Stored int) (Stored int))
  -> dim2
  attribute(inline) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case v of tuple2 @(Stored int) @(Stored int)
    (v_y : Stored int) (v_x : Stored int).
  mk_dim2 (CartesianDict_dim1_multiplyDomain dom_y v_y)
          (CartesianDict_dim1_multiplyDomain dom_x v_x);
  
  
CartesianDict_dim2_divideDomain
  (dom : dim2)
  (v : Tuple2 (Stored int) (Stored int))
  -> dim2
  attribute(inline) =
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case v of tuple2 @(Stored int) @(Stored int)
    (v_y : Stored int) (v_x : Stored int).
  mk_dim2 (CartesianDict_dim1_divideDomain dom_y v_y)
          (CartesianDict_dim1_divideDomain dom_x v_x);


CartesianDict_dim2_multiplyIndex :
    index dim2 -> index dim2 -> Init (index dim2);

CartesianDict_dim2_divideIndex :
    index dim2 -> index dim2 -> Init (index dim2);

CartesianDict_dim2_unbounded :
    dim2;


CartesianDict_dim3_loBound
  (dom : dim3)
  (ret : OutPtr (Maybe (index dim3)))
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case dom_z of mk_dim1 (iv_z : Interval) (lm : LinearMap).
  case iv_z of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).
  case lb_z of {
    justVal @int (z : int).
      case dom_y of mk_dim1 (iv_y : Interval) (lm : LinearMap).
      case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
      case lb_y of {
        justVal @int (y : int).
          case dom_x of mk_dim1 (iv_x : Interval) (lm : LinearMap).
          case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
          case lb_x of {
            justVal @int (x : int).
              just @(Tuple3 (Stored int) (Stored int) (Stored int))
                   (tuple3 @(Stored int) @(Stored int) @(Stored int)
                    (stored @int z) (stored @int y) (stored @int x)) ret
          ; nothingVal @int.
              nothing @(Tuple3 (Stored int) (Stored int) (Stored int)) ret
          }
      ; nothingVal @int.
          nothing @(Tuple3 (Stored int) (Stored int) (Stored int)) ret
      }
  ; nothingVal @int.
      nothing @(Tuple3 (Stored int) (Stored int) (Stored int)) ret
  };
  

CartesianDict_dim3_hiBound
  (dom : dim3)
  (ret : OutPtr (Maybe (index dim3)))
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case dom_z of mk_dim1 (iv_z : Interval) (lm : LinearMap).
  case iv_z of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).
  case ub_z of {
    justVal @int (z : int).
      case dom_y of mk_dim1 (iv_y : Interval) (lm : LinearMap).
      case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
      case ub_y of {
        justVal @int (y : int).
          case dom_x of mk_dim1 (iv_x : Interval) (lm : LinearMap).
          case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
          case ub_x of {
            justVal @int (x : int).
              just @(Tuple3 (Stored int) (Stored int) (Stored int))
                   (tuple3 @(Stored int) @(Stored int) @(Stored int)
                   (stored @int z) (stored @int y) (stored @int x)) ret
          ; nothingVal @int.
              nothing @(Tuple3 (Stored int) (Stored int) (Stored int)) ret
          }
      ; nothingVal @int.
          nothing @(Tuple3 (Stored int) (Stored int) (Stored int)) ret
      }
  ; nothingVal @int.
      nothing @(Tuple3 (Stored int) (Stored int) (Stored int)) ret
  };


CartesianDict_dim3_stride
  (dom : dim3)
  -> Init (index dim3)
  attribute(inline) =
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  tuple3 @(Stored int) @(Stored int) @(Stored int)
  (CartesianDict_dim1_stride dom_z)
  (CartesianDict_dim1_stride dom_y)
  (CartesianDict_dim1_stride dom_x);


CartesianDict_dim3_arrayDomain
  (lo : index dim3)
  (hi : index dim3)
  -> dim3
  attribute(inline) =
  case lo of
    tuple3 @(Stored int) @(Stored int) @(Stored int)
               (lo_z : Stored int) (lo_y : Stored int) (lo_x : Stored int).
  case lo_z of stored @int (lo_z_i : int).
  case lo_y of stored @int (lo_y_i : int).
  case lo_x of stored @int (lo_x_i : int).
  case hi of
    tuple3 @(Stored int) @(Stored int) @(Stored int)
               (hi_z : Stored int) (hi_y : Stored int) (hi_x : Stored int).
  case hi_z of stored @int (hi_z_i : int).
  case hi_y of stored @int (hi_y_i : int).
  case hi_x of stored @int (hi_x_i : int).
  mk_dim3 (mk_dim1 (interval (justVal @int lo_z_i) (justVal @int hi_z_i))
                   (linearMap 1 0))
          (mk_dim1 (interval (justVal @int lo_y_i) (justVal @int hi_y_i))
                   (linearMap 1 0))
          (mk_dim1 (interval (justVal @int lo_x_i) (justVal @int hi_x_i))
                   (linearMap 1 0));


CartesianDict_dim3_displaceDomain
  (dom : dim3)
  (ix : index dim3)
  -> dim3
  attribute(inline) =
  case ix of tuple3 @(Stored int) @(Stored int) @(Stored int)
             (ix_z : Stored int) (ix_y : Stored int) (ix_x : Stored int).
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  mk_dim3 (CartesianDict_dim1_displaceDomain dom_z ix_z)
          (CartesianDict_dim1_displaceDomain dom_y ix_y)
          (CartesianDict_dim1_displaceDomain dom_x ix_x);


CartesianDict_dim3_multiplyDomain
  (dom : dim3)
  (v : Tuple3 (Stored int) (Stored int) (Stored int))
  -> dim3
  attribute(inline) =
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case v of tuple3 @(Stored int) @(Stored int) @(Stored int)
    (v_z : Stored int) (v_y : Stored int) (v_x : Stored int).
  mk_dim3 (CartesianDict_dim1_multiplyDomain dom_z v_z)
          (CartesianDict_dim1_multiplyDomain dom_y v_y)
          (CartesianDict_dim1_multiplyDomain dom_x v_x);
  
  
CartesianDict_dim3_divideDomain
  (dom : dim3)
  (v : Tuple3 (Stored int) (Stored int) (Stored int))
  -> dim3
  attribute(inline) =
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case v of tuple3 @(Stored int) @(Stored int) @(Stored int)
    (v_z : Stored int) (v_y : Stored int) (v_x : Stored int).
  mk_dim3 (CartesianDict_dim1_divideDomain dom_z v_z)
          (CartesianDict_dim1_divideDomain dom_y v_y)
          (CartesianDict_dim1_divideDomain dom_x v_x);

CartesianDict_dim3_multiplyIndex :
    index dim3 -> index dim3 -> Init (index dim3);

CartesianDict_dim3_divideIndex :
    index dim3 -> index dim3 -> Init (index dim3);

CartesianDict_dim3_unbounded :
    dim3;

-------------------------------------------------------------------------------
-- Boxing/unboxing helper functions

boxIntValue (n : int) -> Boxed (Stored int) =
  boxed @(Stored int) (stored @int n);

unboxIntValue (n : Boxed (Stored int)) -> int =
  case n of boxed @(Stored int) (sn : Stored int).
  case sn of stored @int (un : int). un;

boxFloatValue (n : float) -> Boxed (Stored float) =
  boxed @(Stored float) (stored @float n);

unboxFloatValue (n : Boxed (Stored float)) -> float =
  case n of boxed @(Stored float) (sn : Stored float).
  case sn of stored @float (un : float). un;

boxBoolValue (n : bool) -> Boxed (Stored bool) =
  boxed @(Stored bool) (stored @bool n);

unboxBoolValue (n : Boxed (Stored bool)) -> bool =
  case n of boxed @(Stored bool) (sn : Stored bool).
  case sn of stored @bool (un : bool). un;

-------------------------------------------------------------------------------
-- other arithmetic

eqI : int -> int -> bool;
neI : int -> int -> bool;
ltI : int -> int -> bool;
leI : int -> int -> bool;
gtI : int -> int -> bool;
geI : int -> int -> bool;

eqF : float -> float -> bool;
neF : float -> float -> bool;
ltF : float -> float -> bool;
leF : float -> float -> bool;
gtF : float -> float -> bool;
geF : float -> float -> bool;

min_int : int -> int -> int;
max_int : int -> int -> int;

min_uint : uint -> uint -> uint;
max_uint : uint -> uint -> uint;

uint_to_int : uint -> int;

floor : float -> int;

oper_BITWISEAND : int -> int -> int;
oper_BITWISEOR : int -> int -> int;
oper_BITWISEXOR : int -> int -> int;

lshift : int -> int -> int;
rshift : int -> int -> int;

or : bool -> bool -> bool;
and : bool -> bool -> bool;
not : bool -> bool;

-- An internal slice object.
-- The two integers are (in_stride, in_offset).
--
-- The slice produces a view with bounds [lo, hi).
-- Element i of the view maps to element i * in_stride + in_offset.
data InternalSlice : box
{
  internalSlice (lo hi : intindex) (IInt lo, IInt hi, int, int);
  emptySlice () ();
};

-------------------------------------------------------------------------------
-- integer index arithmetic

-- Promote an integer to a type index
defineIntIndex : int -> SomeIInt;

type pos_infty : intindex;
type plus_i : intindex -> intindex -> intindex;
type minus_i : intindex -> intindex -> intindex;
type min_i : intindex -> intindex -> intindex;
type max_i : intindex -> intindex -> intindex;

zero_fii : FIInt 0;
one_fii : FIInt 1;

-- Operations on finite indexed ints aren't inlined until near the end,
-- because they don't enable other optimizations.  By delaying inlining,
-- code doesn't expand as much.

plus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	 -> FIInt (plus_i m n)
	 attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(plus_i m n) (x_i +# y_i);


minus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	  -> FIInt (minus_i m n)
	  attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(minus_i m n) (x_i -# y_i);


min_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (min_i m n)
	attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(min_i m n) (min_int x_i y_i);


max_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (max_i m n)
	attribute(inline, inline_final) =
  case x of fiInt @m (x_i : int).
  case y of fiInt @n (y_i : int).
  fiInt @(max_i m n) (max_int x_i y_i);


zero_ii : IInt 0 = iInt @0 (fiInt @0 0);

one_ii : IInt 1 = iInt @1 (fiInt @1 1);

plus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (plus_i m n) attribute(inline) =
  let type sum_t = plus_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (plus_fii @m @n fa fb)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty @n. iNegInfty @sum_t
      }
  };


minus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (minus_i m n) attribute(inline) =
  let type sum_t = minus_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (minus_fii @m @n fa fb)
      ; iPosInfty @n. iNegInfty @sum_t
      ; iNegInfty @n. iPosInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty @n. iPosInfty @sum_t
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty @n. iNegInfty @sum_t
      ; iNegInfty @n. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  };


min_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (min_i m n) attribute(inline) =
  let type sum_t = min_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (min_fii @m @n fa fb)
      ; iPosInfty @n.
          case fa of fiInt @m (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      case b of {
        iInt @n (fb : FIInt n).
	  case fb of fiInt @n (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iNegInfty @m.
      iNegInfty @sum_t
  };


max_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (max_i m n) attribute(inline) =
  let type sum_t = max_i m n in
  case a of {
    iInt @m (fa : FIInt m).
      case b of {
        iInt @n (fb : FIInt n). iInt @sum_t (max_fii @m @n fa fb)
      ; iNegInfty @n.
          case fa of fiInt @m (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iPosInfty @n. iPosInfty @sum_t
      }
  ; iNegInfty @m.
      case b of {
        iInt @n (fb : FIInt n).
	  case fb of fiInt @n (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty @n. iPosInfty @sum_t
      ; iNegInfty @n. iNegInfty @sum_t
      }
  ; iPosInfty @m.
      iPosInfty @sum_t
  };


-- Determine if there are integers that are greater than or equal to @x@,
-- but less than @y@.
-- The result is False if @x == y@.
range_nonempty_ii @(m n : intindex) (x : IInt m) (y : IInt n) -> bool
  attribute(inline) =
  case x of {
    iInt @m (fx : FIInt m).
      case fx of fiInt @m (x_i : int).
      case y of {
        iInt @n (fy : FIInt n).
          case fy of fiInt @n (y_i : int).
          x_i <# y_i
      ; iPosInfty @n. True
      ; iNegInfty @n. False
      }
  ; iNegInfty @m.
      case y of {
        iNegInfty @n. False
      ; iInt @n (fy : FIInt n). True
      ; iPosInfty @n. True
      }
  ; iPosInfty @m. False
  };


gcd : int -> int -> int;
extgcd_x : int -> int -> int;

-- Test whether an interval is empty.
isEmptyInterval (iv : Interval) -> bool =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).
  case l of {
    justVal @int (ll : int).
      case u of {
        justVal @int (uu : int). ll ==# uu
      ; nothingVal @int. False
    }
  ; nothingVal @int. False
  };


-- Decide whether 'i' is in the interval.
inInterval (i : int) (iv : Interval) -> bool =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).

  -- Is 'i' within the lower bound?
  if case l of {
       nothingVal @int. True
     ; justVal @int (ll : int). i >=# ll
     }
  then -- Is 'i' within the upper bound?
       case u of {
         nothingVal @int. True
       ; justVal @int (uu : int). i <# uu
       }
  else False;


-- Compute the intersection of two intervals.
intersectInterval (iv1 : Interval) (iv2 : Interval) -> Interval
  attribute(inline, inline_final) =
  case iv1 of interval (l1 : MaybeVal int) (u1 : MaybeVal int).
  case iv2 of interval (l2 : MaybeVal int) (u2 : MaybeVal int).

  -- Lower bound is the maximum of the two bounds
  let l3 : MaybeVal int =
        case l1 of {
          nothingVal @int.
            l2
        ; justVal @int (ll1 : int).
            case l2 of {
              nothingVal @int.
                l1
            ; justVal @int (ll2 : int).
                justVal @int (max_int ll1 ll2)
            }
        } in

  -- Upper bound is the minimum of the two bounds
  let u3 : MaybeVal int =
        case u1 of {
          nothingVal @int.
            u2
        ; justVal @int (uu1 : int).
            case u2 of {
              nothingVal @int.
                u1
            ; justVal @int (uu2 : int).
                justVal @int (min_int uu1 uu2)
            }
        } in
  case l3 of {
    justVal @int (x : int).
      case u3 of {
        justVal @int (y : int).
          if x ># y
          then interval (justVal @int 0) (justVal @int 0) -- Empty interval
          else interval l3 u3
      ; nothingVal @int.
          interval l3 u3
      }
  ; nothingVal @int.
      interval l3 u3
  };


-- Get an interval consisting of the points {x + y | x <- i1, y <- i2}.
convolveInterval (i1 : Interval) (i2 : Interval) -> Interval
  attribute(inline, inline_final) =

  case i1 of interval (lo1 : MaybeVal int) (hi1 : MaybeVal int).
  case i2 of interval (lo2 : MaybeVal int) (hi2 : MaybeVal int).

  -- If either input is empty, the result is empty
  if or (isEmptyInterval i1) (isEmptyInterval i2)
  then interval (justVal @int 0) (justVal @int 0) else

  -- Add the lower bounds
  let lo3 : MaybeVal int =
        case lo1 of {
          justVal @int (ilo1 : int).
            case lo2 of {
              justVal @int (ilo2 : int). justVal @int (ilo1 +# ilo2)
            ; nothingVal @int. nothingVal @int
            }
        ; nothingVal @int. nothingVal @int
        } in

  -- Add the upper bounds.  Since the upper bound is exclusive,
  -- we must subtract 1 from the result.
  let hi3 : MaybeVal int =
        case hi1 of {
          justVal @int (ihi1 : int).
            case hi2 of {
              justVal @int (ihi2 : int). justVal @int (ihi1 +# ihi2 -# 1)
            ; nothingVal @int. nothingVal @int
            }
        ; nothingVal @int. nothingVal @int
        } in
  interval lo3 hi3;


-- Test whether i1 is a subset of i2.
subsetInterval (i1 : Interval) (i2 : Interval) -> bool attribute(inline) =

  case i1 of interval (lo1 : MaybeVal int) (hi1 : MaybeVal int).
  case i2 of interval (lo2 : MaybeVal int) (hi2 : MaybeVal int).

  -- An empty interval is a subset of anything
  if isEmptyInterval i1 then True else

  -- Check that each bound of i1 is inside the bound of i2
  let lower_subset : bool =
        case lo2 of {
          justVal @int (ilo2 : int).
            case lo1 of {
              justVal @int (ilo1 : int). ilo1 >=# ilo2
            ; nothingVal @int. False
            }
        ; nothingVal @int. True
        } in
  let upper_subset : bool =
        case hi2 of {
          justVal @int (ihi2 : int).
            case hi1 of {
              justVal @int (ihi1 : int). ihi1 <=# ihi2
            ; nothingVal @int. False
            }
        ; nothingVal @int. True
        } in
  and lower_subset upper_subset;


-- Decide whether 'i' is a member of the linear map's range.
inLM (i : int) (m : LinearMap) -> bool =
  case m of linearMap (s : int) (a : int). (i %# s) ==# (a %# s);
  

-- Evaluate a linear map at 'i'. 
evalLM (i : int) (m : LinearMap) -> int =
  case m of linearMap (s : int) (a : int). s *# i +# a;


-- Evaluate the inverse of a linear map at 'i'.
-- The result is undefined if 'i' is not in the range of the map.
invEvalLM (i : int) (m : LinearMap) -> int =
  case m of linearMap (s : int) (a : int). (i -# a) //# s;


-- Compute the intersection of two linear maps.
-- If the intersection is empty, 'Nothing' is returned.
intersectLM (m1 : LinearMap) (m2 : LinearMap) -> MaybeVal LinearMap
  attribute(inline, inline_final) =
  case m1 of linearMap (s1 : int) (a1 : int).
  case m2 of linearMap (s2 : int) (a2 : int).

  -- Special case handling when stride is 1
  if s1 ==# 1 then justVal @LinearMap m2 else
  if s2 ==# 1 then justVal @LinearMap m1 else

  let g : int = gcd s1 s2 in
  let align_remainder : int = (a2 -# a1) %# g in
  let align_quot : int = (a2 -# a1) //# g in

  -- Check if intersection is empty
  if align_remainder /=# 0 then nothingVal @LinearMap else

  let s1p : int = s1 //# g in
  let s2p : int = s2 //# g in
  let s3 : int = s1p *# s2 in
  let yp : int = extgcd_x s1p s2p in
  let y : int = align_quot *# yp in
  let a3 : int = (s1 *# y +# a1) %# s3 in
  justVal @LinearMap (linearMap s3 a3);


trimInterval (iv : Interval) (m : LinearMap) -> Interval
  attribute(inline, inline_final) =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).
  case m of linearMap (s : int) (a : int).

  let l2 : MaybeVal int =
        case l of {
          nothingVal @int. nothingVal @int
        ; justVal @int (n : int). justVal @int (n +# (a -# n) %# s) 
        } in
  let u2 : MaybeVal int =
        case u of {
          nothingVal @int. nothingVal @int
        ; justVal @int (n : int). justVal @int (n +# (a -# n) %# s) 
        } in
  interval l2 u2;


internalApplyListSlice (slice_obj : SliceObject) (dom : list_dim)
  -> (list_dim, LinearMap)
  attribute(inline, inline_final) =
  case slice_obj of
    sliceObject (m_slice_lo : MaybeVal int)
                (m_slice_hi : MaybeVal int)
                (m_m_stride : MaybeVal (MaybeVal int)).
  case dom of mk_list_dim (list_size : MaybeVal int).
  let stride : int =
        case m_m_stride of {
          nothingVal @(MaybeVal int). 1
        ; justVal @(MaybeVal int) (m_stride : MaybeVal int).
            case m_stride of {
              nothingVal @int. 1
            ; justVal @int (stride : int). stride
            }
        } in
  if stride ==# 0 then except @(list_dim, LinearMap) else
  let counting_up : bool = stride ># 0 in

  -- Get the slice's inclusive lower bound.
  -- There must be a lower bound, determined either by the slice or the
  -- list domain.
  let slice_lo : int =
        if counting_up
        then case m_slice_lo of {
               nothingVal @int. 0
             ; justVal @int (l : int). max_int 0 l
             }
        else case m_slice_lo of {
               justVal @int (h : int).
                 case list_size of {
                   justVal @int (n : int). min_int h (n -# 1)
                 ; nothingVal @int. h
                 }
             ; nothingVal @int.
                 case list_size of {
                   justVal @int (n : int). n -# 1
                 ; nothingVal @int. except @int
                 }
             } in

  -- Get the slice's exclusive upper bound.
  let slice_hi : MaybeVal int =
        if counting_up
        then case m_slice_hi of {
               nothingVal @int.
                 list_size
             ; justVal @int (h : int).
                 case list_size of {
                   nothingVal @int. justVal @int h
                 ; justVal @int (n : int). justVal @int (min_int h n)
                 }
             }
        else case m_slice_hi of {
               nothingVal @int. justVal @int -1
             ; justVal @int (h : int). justVal @int (max_int h -1)
             } in

  -- If the slice is nonempty, this is the map from slice member to list member
  let linear_map : LinearMap = linearMap stride slice_lo in

  -- Compute the new list size, which may be unbounded
  let size : MaybeVal int =
        case slice_hi of {
          nothingVal @int. nothingVal @int
        ; justVal @int (h : int).
            let abs_stride : int = if counting_up
                                   then stride
                                   else AdditiveDict_int_negate stride in

            let abs_delta : int =
                  let delta : int = h -# slice_lo in
                  if delta <# 0
                  then AdditiveDict_int_negate delta
                  else delta in

            justVal @int ((abs_delta +# abs_stride -# 1) //# abs_stride)
        } in
  case size of {
    justVal @int (n : int).
      if n <# 0
      then (mk_list_dim (justVal @int 0), linearMap 0 0)
      else (mk_list_dim size, linear_map)
  ; nothingVal @int. (mk_list_dim size, linear_map)
  };


sliceToDomain (slice_obj : SliceObject) -> dim1
  attribute(inline, inline_final) =
  case slice_obj of
    sliceObject (m_slice_lo : MaybeVal int)
                (m_slice_hi : MaybeVal int)
                (m_m_stride : MaybeVal (MaybeVal int)).
  let stride : int =
        case m_m_stride of {
          nothingVal @(MaybeVal int). 1
        ; justVal @(MaybeVal int) (m_stride : MaybeVal int).
            case m_stride of {
              nothingVal @int. 1
            ; justVal @int (stride : int). stride
            }
        } in
  let alignment : int =
        case m_slice_lo of {
          nothingVal @int. 0
        ; justVal @int (n : int). n %# stride
        } in

  -- Stride must be positive
  if stride <=# 0 then except @dim1 else

  let map : LinearMap = linearMap stride alignment in
  let iv : Interval = trimInterval (interval m_slice_lo m_slice_hi) map in
  mk_dim1 iv map;


internalApplyArraySlice (slice_obj : SliceObject) (dom : dim1) -> dim1 =
  let slice_dom : dim1 = sliceToDomain slice_obj in
  ShapeDict_dim1_intersect slice_dom dom;


-------------------------------------------------------------------------------
-- propositions

-- Proof objects
data Pf (p : prop) : val
  attribute(abstract)
{
  pf () ();
};

type eqZ : intindex -> intindex -> prop;
type neZ : intindex -> intindex -> prop;
type trueP : prop;

eqZ_refl : (n : intindex) -> Pf (eqZ n n);

-- Construct an arbitrary proof value.  This function is only called to
-- construct proofs that are never used.  Since the value is not used, it is
-- safe to construct such a value.
deadProof : (p : prop) -> Pf p;

-- Construct an identity coercion.  This function is safe.
idCoercion : (a : box) -> coerce @box a a;
idBareCoercion : (a : bare) -> coerce @bare a a;

-- The type functions 'index' and 'cartesianDomain' are inverses where
-- they are defined.
cartesianIndexCoercion : (sh : box)
                      -> coerce @box (cartesianDomain (index sh)) sh;

-- Construct a coercion.  This function is unsafe.
unsafeMakeCoercion : (a b : box) -> coerce @box a b;

-- Construct a coercion.  This function is unsafe.
unsafeMakeBareCoercion : (a b : bare) -> coerce @bare a b;

-- Construct a coercion.  This function is unsafe.
unsafeMakeViewCoercion : (d : box)
                      -> coerce @(bare -> box) (Stream d) (view d);

-------------------------------------------------------------------------------
-- Debugging

traceInt_int : int -> int -> int;
traceInt_box : (a : box) -> int -> a -> a;

-------------------------------------------------------------------------------
-- Domain functions

fun_list_dim (size : Maybe (Stored int)) -> list_dim
  attribute(inline) =
  mk_list_dim (case size of {
                 just @(Stored int) (si : Stored int).
                   case si of stored @int (i : int).
                   justVal @int i
               ; nothing @(Stored int).
                   nothingVal @int
               });


fun_dim1 (lo_bound : Maybe (Stored int)) (hi_bound : Maybe (Stored int))
         (stride : int) (alignment : int) -> dim1
  attribute(inline) =

  letfun
    cvt_Maybe (x : Maybe (Stored int)) -> MaybeVal int =
      case x of {
        just @(Stored int) (si : Stored int).
          case si of stored @int (i : int).
          justVal @int i
      ; nothing @(Stored int).
          nothingVal @int
      } in

  if stride <=# 0 then except @dim1 else

  -- Create an interval from the given bounds.  If the low bound is
  -- greater than the high bound, use an empty interval.
  let iv : Interval =
        case lo_bound of {
          just @(Stored int) (lb : Stored int).
            case lb of stored @int (lb_i : int).
            case hi_bound of {
              just @(Stored int) (ub : Stored int).
                case ub of stored @int (ub_i : int).
                if lb_i ># ub_i
                then interval (justVal @int 0) (justVal @int 0)
                else interval (justVal @int lb_i) (justVal @int ub_i)
            ; nothing @(Stored int).
                interval (justVal @int lb_i) (nothingVal @int)
            }
        ; nothing @(Stored int).
          case hi_bound of {
            just @(Stored int) (ub : Stored int).
              case ub of stored @int (ub_i : int).
              interval (nothingVal @int) (justVal @int ub_i)
          ; nothing @(Stored int).
              interval (nothingVal @int) (nothingVal @int)
          }
        } in
  let m : LinearMap = linearMap stride (alignment %# stride) in
  mk_dim1 (trimInterval iv m) m;


make_sliceObject
  (has_lower : bool)
  (lower : int)
  (has_upper : bool)
  (upper : int)
  (has_has_stride : bool)
  (has_stride : bool)
  (stride : int)
  (ret : OutPtr SliceObject)
  -> Store
  attribute(inline) =

  sliceObject
  (if has_lower then justVal @int lower else nothingVal @int)
  (if has_upper then justVal @int upper else nothingVal @int)
  (if has_has_stride
   then justVal @(MaybeVal int)
   (if has_stride then justVal @int stride else nothingVal @int)
   else nothingVal @(MaybeVal int))
  ret;


-------------------------------------------------------------------------------
-- Stream consumers

build_list_dim_list @(a : bare)
  (repr : Repr a) (vw : view list_dim a) (ret : OutPtr (list a))
  -> Store
  attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (f : Stored int -> Init a).
  case dom of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    justVal @int (size : int).
      -- Finite view
      case defineIntIndex size of someIInt @(N : intindex) (sz : FIInt N).
      make_list @a @N sz
      (stuckBox @(arr N a)
       (arr1D_build @N @a repr sz
        (\ (i : int) (ret : OutPtr a) -> Store.
           case boxed @(Stored int) (stored @int i) of
             boxed @(Stored int) (s_i : Stored int).
           f s_i ret)))
      ret

  ; nothingVal @int.
      -- Infinte views can't be turned into lists
      except @Store
  };


build_dim1_array @(a : bare)
  (repr : Repr a) (vw : view dim1 a)
  (ret : OutPtr (array1 a))
  -> Store
  attribute(inline, inline_dimensionality) =

  case vw of mk_view @dim1 @a (dom : dim1) (f : Stored int -> Init a).
  dim1ToArrayDesc @(array1 a) dom
  (\ @(N : intindex)
     (lb : int) (stride : int) (size : FIInt N) (ret : OutPtr (array1 a))
     -> Store.

     let linear_map : LinearMap = linearMap stride lb in

     mk_array1 @a @N lb stride size
     (stuckBox @(arr N a)
      (arr1D_build @N @a repr size
       (\ (i : int) (ret : OutPtr a) -> Store.
           -- Compute the logical index corresponding to array index 'i'
           let logical_i : int = evalLM i linear_map in
           case boxed @(Stored int) (stored @int logical_i) of
             boxed @(Stored int) (s_i : Stored int).
           f s_i ret)))
      ret)
  ret;


reduce_list_dim @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Init a)
  (init : a)
  (vw : view list_dim a)
  -> Init a
  attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (gen : Stored int -> Init a).

  primitive_list_dim_reduce @a repr dom gen f init;


reduce1_list_dim @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Init a)
  (vw : view list_dim a)
  -> Init a
  attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (gen : Stored int -> Init a).

  primitive_list_dim_reduce1 @a repr dom gen f;


reduce_dim1 : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> a
  -> view dim1 a
  -> Init a;

scatter_dim1 : (i r : bare)
            -> Repr i -> Repr r -> Scatter r i -> view dim1 i -> Init r;

reduce1_dim1 : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> view dim1 a
  -> Init a;

scatter_list_dim @(i r : bare)
  (repr_i : Repr i)
  (repr_r : Repr r)
  (op : Scatter r i)
  (src : view list_dim i)
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_dimensionality) =

  case src of
    mk_view @list_dim @i (dom : list_dim) (gen : Stored int -> Init i).

  primitive_list_dim_scatter @i @r repr_i repr_r dom op gen ret;


permute1D_list_dim @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (vw : view list_dim (Tuple2 (Stored int) a))
  (ret : OutPtr (array1 a))
  -> Store
  attribute(inline, inline_dimensionality) =

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        repr_Tuple2 @(Stored int) @a repr_int rep in

  let rep_array : Repr (array1 a) = repr_array1 @a in

  -- Create an array of the given size
  dim1ToArrayDesc @(array1 a) dom
  (\ @(N : intindex)
     (lb : int) (stride : int) (count : FIInt N) (ret : OutPtr (array1 a))
     -> Store.

     case count of fiInt @N (count_int : int).

     mk_array1 @a @N lb stride count
     (stuckBox @(arr N a)

      (\ (ret : OutPtr (arr N a)) -> Store.

       -- Loop over the inputs
       case vw of
         mk_view @list_dim @(Tuple2 (Stored int) a)
                 (input_dom : list_dim)
                 (gen : Stored int -> Init (Tuple2 (Stored int) a)).

       case input_dom of mk_list_dim (msize : MaybeVal int).
       case msize of {
         justVal @int (size : int).
           case defineIntIndex size of
             someIInt @(M : intindex) (count : FIInt M).

           -- For each input value
           doall @M @(arr N a) @(arr N a) count
           (\ (i : int) -> Store.
              case boxed @(Stored int) (stored @int i) of
                boxed @(Stored int) (si : Stored int).

              -- Get a value
              case boxed @(Tuple2 (Stored int) a) (gen si) of
                boxed @(Tuple2 (Stored int) a) (pval : Tuple2 (Stored int) a).
              case pval of
                tuple2 @(Stored int) @a (s_index : Stored int) (val : a).
              case s_index of stored @int (index : int).

              -- Convert to real index
              let offset_index : int = index -# lb in
              let real_index : int = offset_index //# stride in

              -- Check bounds
              if offset_index %# stride /=# 0 then except @Store else
              if or (real_index <# 0) (real_index >=# count_int) then except @Store else

              -- Write it to the output
              copy @a rep val
              (subscript_out @N @a (reprSizeAlign @a rep) ret real_index))
       ; nothingVal @int.
           except @Store
       }))
     ret)
  ret;


boxedPermute1D_list_dim @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (vw : view list_dim (Tuple2 (Stored int) a))
  (ret : OutPtr (barray1 a))
  -> Store
  attribute(inline, inline_dimensionality) =

  let type Boxed_a = StuckRef (AsBox a) in

  let rep_Ref : Repr (StuckRef (AsBox a)) = repr_StuckRef @(AsBox a) in

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        repr_Tuple2 @(Stored int) @a repr_int rep in

  -- Create an array of the given size
  dim1ToArrayDesc @(barray1 a) dom
  (\ @(N : intindex)
     (lb : int) (stride : int) (count : FIInt N) (ret : OutPtr (barray1 a))
     -> Store.

     case count of fiInt @N (count_int : int).

     mk_barray1 @a
     (mk_array1 @Boxed_a @N lb stride count
      (stuckBox @(arr N Boxed_a)

       (\ (ret : OutPtr (arr N Boxed_a)) -> Store.

        -- Loop over the inputs
        case vw of
          mk_view @list_dim @(Tuple2 (Stored int) a)
                  (input_dom : list_dim)
                  (gen : Stored int -> Init (Tuple2 (Stored int) a)).

        case input_dom of mk_list_dim (msize : MaybeVal int).
        case msize of {
          justVal @int (size : int).
            case defineIntIndex size of
              someIInt @(M : intindex) (count : FIInt M).

            -- For each input value
            doall @M @(arr N Boxed_a) @(arr N Boxed_a) count
            (\ (i : int) -> Store.
               case boxed @(Stored int) (stored @int i) of
                 boxed @(Stored int) (si : Stored int).

               -- Get a value
               case boxed @(Tuple2 (Stored int) a) (gen si) of
                 boxed @(Tuple2 (Stored int) a) (pval : Tuple2 (Stored int) a).
               case pval of
                 tuple2 @(Stored int) @a (s_index : Stored int) (val : a).
               case s_index of stored @int (index : int).

               -- Convert to real index
               let offset_index : int = index -# lb in
               let real_index : int = offset_index //# stride in

               -- Check bounds
               if offset_index %# stride /=# 0 then except @Store else
               if or (real_index <# 0) (real_index >=# count_int) then except @Store else

               -- Write it to the output
               stuckRef @(AsBox a)
               (asbox @a rep (copy @a rep val))
               (subscript_out @N @Boxed_a (reprSizeAlign @Boxed_a rep_Ref) ret real_index))
        ; nothingVal @int.
            except @Store
        })))
     ret)
  ret;


fold_list_dim @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Init acc)
  (init : acc)
  (vw : view list_dim a)
  (ret : OutPtr acc)
  -> Store
  attribute(inline, inline_dimensionality) =

  case vw of
    mk_view @list_dim @a (dom : list_dim) (g : index list_dim -> Init a).

  primitive_list_dim_fold @acc repr_acc dom
  (\ (ix : index list_dim) (x : acc) (ret : OutPtr acc) -> Store.
     case boxed @a (g ix) of boxed @a (y : a).
     f x y ret)
  init
  ret;

fold_dim1 : (a acc : bare)
         -> Repr a -> Repr acc
         -> (acc -> a -> Init acc)
         -> acc
         -> view dim1 a
         -> Init acc;

reduce_dim2 : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> a
  -> view dim2 a
  -> Init a;

reduce1_dim2 : (a : bare)
  -> Repr a
  -> (a -> a -> Init a)
  -> view dim2 a
  -> Init a;

scatter_dim2 : (i r : bare)
            -> Repr i -> Repr r -> Scatter r i -> view dim2 i -> Init r;

fold_dim2 : (a acc : bare)
         -> Repr a -> Repr acc
         -> (acc -> a -> Init acc)
         -> acc
         -> view dim2 a
         -> Init acc;

-------------------------------------------------------------------------------
-- Stream and Traversable dictionary-like internal methods

view_generate @(sh : box) (shape_dict : ShapeDict sh)
  -> (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> view sh a
  attribute(inline, inline_dimensionality) =

  \ @(a : bare) (repr : Repr a) (dom : sh) (f : index sh -> Init a)
    -> view sh a.
    mk_view @sh @a dom f;


view_map @(sh : box) (shape_dict : ShapeDict sh)
  -> (a b : bare) -> Repr a -> Repr b -> (a -> Init b) -> view sh a -> view sh b
  attribute(inline, inline_dimensionality) =

  \ @(a b : bare) (repr_a : Repr a) (repr_a : Repr b) (t : a -> Init b)
    (s1 : view sh a) -> view sh b.

    case s1 of mk_view @sh @a (d : sh) (f : index sh -> Init a).
    mk_view @sh @b d
    (\ (ix : index sh) (ret : OutPtr b) -> Store.
       case boxed @a (f ix) of boxed @a (x : a).
       t x ret);


view_zipWith @(sh : box)
  (shape_dict : ShapeDict sh)
  -> (a b c : bare) -> Repr a -> Repr b -> Repr c ->
     (a -> b -> Init c) ->
     view sh a ->
     view sh b ->
     view sh c
  attribute(inline, inline_dimensionality) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  \ @(a b c : bare) (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
     (t : a -> b -> Init c)
     (sa : view sh a)
     (sb : view sh b)
     -> view sh c.
    case sa of mk_view @sh @a (dA : sh) (fA : index sh -> Init a).
    case sb of mk_view @sh @b (dB : sh) (fB : index sh -> Init b).
    let dC : sh = shape_intersect dA dB in
    mk_view @sh @c dC
    (\ (ix : index sh) (ret : OutPtr c) -> Store.
      case boxed @a (fA ix) of boxed @a (x : a).
      case boxed @b (fB ix) of boxed @b (y : b).
      t x y ret);


view_zipWith3 @(sh : box)
  (shape_dict : ShapeDict sh)
  -> (a b c d : bare) -> Repr a -> Repr b -> Repr c -> Repr d ->
     (a -> b -> c -> Init d) ->
     view sh a ->
     view sh b ->
     view sh c ->
     view sh d
  attribute(inline, inline_dimensionality) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  \ @(a b c d : bare) (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
     (t : a -> b -> c -> Init d)
     (sa : view sh a)
     (sb : view sh b)
     (sc : view sh c)
     -> view sh d.
    case sa of mk_view @sh @a (dA : sh) (fA : index sh -> Init a).
    case sb of mk_view @sh @b (dB : sh) (fB : index sh -> Init b).
    case sc of mk_view @sh @c (dC : sh) (fC : index sh -> Init c).
    let dD : sh = shape_intersect (shape_intersect dA dB) dC in
    mk_view @sh @d dD
    (\ (ix : index sh) (ret : OutPtr d) -> Store.
      case boxed @a (fA ix) of boxed @a (x : a).
      case boxed @b (fB ix) of boxed @b (y : b).
      case boxed @c (fC ix) of boxed @c (z : c).
      t x y z ret);


view_zipWith4 @(sh : box)
  (shape_dict : ShapeDict sh)
  -> (a b c d e : bare) -> Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
     (a -> b -> c -> d -> Init e) ->
     view sh a ->
     view sh b ->
     view sh c ->
     view sh d ->
     view sh e
  attribute(inline, inline_dimensionality) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  \ @(a b c d e : bare)
     (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
     (t : a -> b -> c -> d -> Init e)
     (sa : view sh a)
     (sb : view sh b)
     (sc : view sh c)
     (sd : view sh d)
     -> view sh e.
    case sa of mk_view @sh @a (dA : sh) (fA : index sh -> Init a).
    case sb of mk_view @sh @b (dB : sh) (fB : index sh -> Init b).
    case sc of mk_view @sh @c (dC : sh) (fC : index sh -> Init c).
    case sd of mk_view @sh @d (dD : sh) (fD : index sh -> Init d).
    let dE : sh =
          shape_intersect (shape_intersect (shape_intersect dA dB) dC) dD in
    mk_view @sh @e dE
    (\ (ix : index sh) (ret : OutPtr e) -> Store.
      case boxed @a (fA ix) of boxed @a (x : a).
      case boxed @b (fB ix) of boxed @b (y : b).
      case boxed @c (fC ix) of boxed @c (z : c).
      case boxed @d (fD ix) of boxed @d (w : d).
      t x y z w ret);


Sequence_flatten : (a : bare) -> Repr a -> Sequence a -> Stream dim1 a;

Sequence_generate @(a : bare)
  (repr : Repr a) (size : list_dim) (f : index list_dim -> Init a)
  -> Sequence a
  attribute(inline, inline_final) =

  let type Sint = Stored int in
  let type st = Boxed Sint in
  case size of mk_list_dim (m_list_size : MaybeVal int).
  case m_list_size of {
    justVal @int (list_size : int).
      -- Finite stream
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @Sint (state_s : Sint).
	  case state_s of stored @int (state_u : int).
	  if state_u <# list_size
	  then let next_value : AsBox a =
	             asbox @a repr (f state_s) in
	       let next_state : st =
	             boxed @Sint (stored @int (state_u +# 1)) in
	       streamValue @st @a next_state next_value
	  else streamEmpty @st @a
      in
      sequence @a @st (boxed @Sint (stored @int 0)) next

  ; nothingVal @int.
      -- Infinite stream
      letfun
        next (state : st) -> StreamNext st a =
	  case state of boxed @Sint (state_s : Stored int).
	  case state_s of stored @int (state_u : int).
	  let next_value : AsBox a =
	        asbox @a repr (f state_s) in
	  let next_state : st =
	        boxed @Sint (stored @int (state_u +# 1)) in
	  streamValue @st @a next_state next_value
      in
      sequence @a @st (boxed @Sint (stored @int 0)) next
  };


Sequence_from_llist @(a : bare) (repr : Repr a) (l : llist a)
  -> Sequence a attribute(inline, inline_final) =
  sequence @a @(llist a) l
  (\ (l : llist a) -> StreamNext (llist a) a.
     case l of {
       cons @a (h : a) (t : llist a).
         streamValue @(llist a) @a t (asbox @a repr (copy @a repr h))
     ; nil @a. streamEmpty @(llist a) @a
     });


Sequence_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
          (transformer : a -> Init b) (sq : Sequence a) -> Sequence b
  attribute(inline, inline_final) =
  case sq of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  letfun
    go (state : st) -> StreamNext st b =
      case next state of {
        streamValue @st @a (next_state : st) (value : AsBox a).
          let output_value : AsBox b =
                case boxed @a (asbare @a repr_a value) of boxed @a (x : a).
		asbox @b repr_b (transformer x)
          in streamValue @st @b next_state output_value;

        streamEmpty @st @a.
          streamEmpty @st @b
      }
  in sequence @b @st state go;


Sequence_zipWith
  @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sqA : Sequence a)
  (sqB : Sequence b)
  -> Sequence c
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).

  let type st_c = Stored (st_a, st_b) in
  
  letfun
    go (state : Boxed st_c) -> StreamNext (Boxed st_c) c =
      -- Unpack the state
      case state of boxed @st_c (u_state : st_c).
      case u_state of stored @(st_a, st_b) (i_state : (st_a, st_b)).
      case i_state of (state_a : st_a, state_b : st_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : AsBox a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : AsBox b).

	      -- Create output value
	      let value : AsBox c =
	            case boxed @a (asbare @a repr_a value_a) of boxed @a (x : a).
	            case boxed @b (asbare @b repr_b value_b) of boxed @b (y : b).
		    asbox @c repr_c (transformer x y) in
	      let next_state : Boxed st_c =
	            boxed @st_c (stored @(st_a, st_b) (next_state_a, next_state_b)) in
	      streamValue @(Boxed st_c) @c next_state value;

	    streamEmpty @st_b @b.
	      streamEmpty @(Boxed st_c) @c
          };

	streamEmpty @st_a @a.
	  streamEmpty @(Boxed st_c) @c
      }
  in sequence @c @(Boxed st_c)
       (boxed @st_c (stored @(st_a, st_b) (state_a, state_b)))
       go;


Sequence_zipWith3
  @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sqA : Sequence a)
  (sqB : Sequence b)
  (sqC : Sequence c)
  -> Sequence d
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).
  case sqC
  of sequence @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c c).

  let type st_d = Stored (st_a, st_b, st_c) in
  
  letfun
    go (state : Boxed st_d) -> StreamNext (Boxed st_d) d =
      -- Unpack the state
      case state of boxed @st_d (u_state : st_d).
      case u_state of stored @(st_a, st_b, st_c) (i_state : (st_a, st_b, st_c)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : AsBox a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : AsBox b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @c
                  (next_state_c : st_c) (value_c : AsBox c).

                  -- Create output value
                  let value : AsBox d =
                        case boxed @a (asbare @a repr_a value_a) of boxed @a (x : a).
                        case boxed @b (asbare @b repr_b value_b) of boxed @b (y : b).
                        case boxed @c (asbare @c repr_c value_c) of boxed @c (z : c).
                        asbox @d repr_d (transformer x y z) in
                  let next_state : Boxed st_d =
                        boxed @st_d (stored @(st_a, st_b, st_c) (next_state_a, next_state_b, next_state_c)) in
                  streamValue @(Boxed st_d) @d next_state value;

                  streamEmpty @st_c @c.
                    streamEmpty @(Boxed st_d) @d
                };

              streamEmpty @st_b @b.
                streamEmpty @(Boxed st_d) @d
            };

        streamEmpty @st_a @a.
          streamEmpty @(Boxed st_d) @d
      }
  in sequence @d @(Boxed st_d)
       (boxed @st_d (stored @(st_a, st_b, st_c) (state_a, state_b, state_c)))
       go;


Sequence_zipWith4
  @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sqA : Sequence a)
  (sqB : Sequence b)
  (sqC : Sequence c)
  (sqD : Sequence d)
  -> Sequence e
  attribute(inline, inline_final) =
  case sqA
  of sequence @a @(st_a : box)
     (state_a : st_a) (next_a : st_a -> StreamNext st_a a).
  case sqB
  of sequence @b @(st_b : box)
     (state_b : st_b) (next_b : st_b -> StreamNext st_b b).
  case sqC
  of sequence @c @(st_c : box)
     (state_c : st_c) (next_c : st_c -> StreamNext st_c c).
  case sqD
  of sequence @d @(st_d : box)
     (state_d : st_d) (next_d : st_d -> StreamNext st_d d).

  let type st_e = Stored (st_a, st_b, st_c, st_d) in
  
  letfun
    go (state : Boxed st_e) -> StreamNext (Boxed st_e) e =
      -- Unpack the state
      case state of boxed @st_e (u_state : st_e).
      case u_state of stored @(st_a, st_b, st_c, st_d) (i_state : (st_a, st_b, st_c, st_d)).
      case i_state of (state_a : st_a, state_b : st_b, state_c : st_c, state_d : st_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue @st_a @a
          (next_state_a : st_a) (value_a : AsBox a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue @st_b @b
	      (next_state_b : st_b) (value_b : AsBox b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue @st_c @c
                  (next_state_c : st_c) (value_c : AsBox c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue @st_d @d
                      (next_state_d : st_d) (value_d : AsBox d).

                      -- Create output value
                      let value : AsBox e =
                            case boxed @a (asbare @a repr_a value_a) of boxed @a (x : a).
                            case boxed @b (asbare @b repr_b value_b) of boxed @b (y : b).
                            case boxed @c (asbare @c repr_c value_c) of boxed @c (z : c).
                            case boxed @d (asbare @d repr_d value_d) of boxed @d (w : d).
                            asbox @e repr_e (transformer x y z w) in
                      let next_state : Boxed st_e =
                            boxed @st_e (stored @(st_a, st_b, st_c, st_d) (next_state_a, next_state_b, next_state_c, next_state_d)) in
                      streamValue @(Boxed st_e) @e next_state value;

                      streamEmpty @st_d @d.
                        streamEmpty @(Boxed st_e) @e
                    };

                  streamEmpty @st_c @c.
                    streamEmpty @(Boxed st_e) @e
                };

              streamEmpty @st_b @b.
                streamEmpty @(Boxed st_e) @e
            };

        streamEmpty @st_a @a.
          streamEmpty @(Boxed st_e) @e
      }
  in sequence @e @(Boxed st_e)
       (boxed @st_e (stored @(st_a, st_b, st_c, st_d) (state_a, state_b, state_c, state_d)))
       go;

-------------------------------------------------------------------------------
-- Sequence operations

--view1_fold : (a acc : bare)
--          -> Repr a -> Repr acc
--          -> (acc -> a -> Init acc) -> acc -> view list_dim a
--          -> Init acc;

Sequence_reduce @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Init a)
  (init : a)
  (sq : Sequence a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  Sequence_fold @a @a repr repr f init sq ret;


Sequence_reduce1 @(a : bare)
  (repr : Repr a)
  (f : a -> a -> Init a)
  (sq : Sequence a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  -- Use the stream's first element as the initial value
  case sq of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  case next state of {
    streamValue @st @a (next_state : st) (init : AsBox a).
      case boxed @a (asbare @a repr init) of boxed @a (u_init : a).
      let new_sequence : Sequence a =
            sequence @a @st next_state next in
      Sequence_fold @a @a repr repr f u_init new_sequence ret;

    streamEmpty @st @a.
      except @Store
  };


Sequence_scatter @(i r : bare)
  (repr_i : Repr i)
  (repr_r : Repr r)
  (op : Scatter r i)
  (src : Sequence i)
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_sequential) =

  case op of
    mk_scatter @r @i @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (make_updater : i -> updF)
    (make_init : iniF).

  finish_scatter @r @s repr_r repr_s finalizer
  (Sequence_partial_scatter @i @s @iniF @updF
   repr_i repr_s initializer updater make_updater make_init src)
  ret;


Sequence_permute1D @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (s : Sequence (Tuple2 (Stored int) a))
  (ret : OutPtr (array1 a))
  -> Store
  attribute(inline, inline_final) =

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        repr_Tuple2 @(Stored int) @a repr_int rep in

  let rep_array : Repr (array1 a) = repr_array1 @a in

  let type SEffTok = Stored EffTok in

  -- Create an array of the given size
  dim1ToArrayDesc @(array1 a) dom
  (\ @(N : intindex) (lb : int) (stride : int) (size : FIInt N)
     (ret : OutPtr (array1 a)) -> Store.

     case size of fiInt @N (size_int : int).

     mk_array1 @a @N lb stride size
     (stuckBox @(arr N a)

      (\ (ret : OutPtr (arr N a)) -> Store.

       -- Loop over the inputs
       case boxed @SEffTok (stored @EffTok emptyEffTok) of
         boxed @SEffTok (eff_tok_in : Stored EffTok).

       case boxed @SEffTok
            (Sequence_fold @(Tuple2 (Stored int) a) @SEffTok
             rep_tuple repr_EffTok
             (\ (acc : SEffTok) (x : Tuple2 (Stored int) a)
                (eff_ret : OutPtr SEffTok)
                -> Store.

                case x of tuple2 @(Stored int) @a (s_index : Stored int) (val : a).
                case s_index of stored @int (index : int).

                -- Convert to real index
                let offset_index : int = index -# lb in
                let real_index : int = offset_index //# stride in

                -- Check bounds
                if offset_index %# stride /=# 0 then except @Store else
                if or (real_index <# 0) (real_index >=# size_int) then except @Store else

                -- Store it
                case acc of stored @EffTok (u_acc : EffTok).
                let new_acc : EffTok =
                      seqEffTok u_acc
                      (toEffTok @a
                       (copy @a rep val
                        (subscript_out @N @a (reprSizeAlign @a rep) ret real_index))) in
                stored @EffTok new_acc eff_ret)
             eff_tok_in s) of
         boxed @SEffTok (eff_tok_out : Stored EffTok).

       case eff_tok_out of stored @EffTok (tok : EffTok).
       fromEffTok @(arr N a) tok))
     ret)
  ret;


Sequence_boxedPermute1D @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (s : Sequence (Tuple2 (Stored int) a))
  (ret : OutPtr (barray1 a))
  -> Store
  attribute(inline, inline_final) =

  let type Boxed_a = StuckRef (AsBox a) in

  let rep_Ref : Repr Boxed_a = repr_StuckRef @(AsBox a) in

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        repr_Tuple2 @(Stored int) @a repr_int rep in

  let type SEffTok = Stored EffTok in

  -- Create an array of the given size
  dim1ToArrayDesc @(barray1 a) dom
  (\ @(N : intindex) (lb : int) (stride : int) (size : FIInt N)
     (ret : OutPtr (barray1 a)) -> Store.

     case size of fiInt @N (size_int : int).

     mk_barray1 @a
     (mk_array1 @Boxed_a @N lb stride size
      (stuckBox @(arr N Boxed_a)

       (\ (ret : OutPtr (arr N Boxed_a)) -> Store.

        -- Loop over the inputs
        case boxed @SEffTok (stored @EffTok emptyEffTok) of
          boxed @SEffTok (eff_tok_in : Stored EffTok).

        case boxed @SEffTok
             (Sequence_fold @(Tuple2 (Stored int) a) @SEffTok
              rep_tuple repr_EffTok
              (\ (acc : SEffTok) (x : Tuple2 (Stored int) a)
                 (eff_ret : OutPtr SEffTok)
                 -> Store.

                 case x of tuple2 @(Stored int) @a (s_index : Stored int) (val : a).
                 case s_index of stored @int (index : int).

                 -- Convert to real index
                 let offset_index : int = index -# lb in
                 let real_index : int = offset_index //# stride in

                 -- Check bounds
                 if offset_index %# stride /=# 0 then except @Store else
                 if or (real_index <# 0) (real_index >=# size_int) then except @Store else

                 -- Store it
                 case acc of stored @EffTok (u_acc : EffTok).
                 let new_acc : EffTok =
                       seqEffTok u_acc
                       (toEffTok @Boxed_a
                        (stuckRef @(AsBox a)
                         (asbox @a rep (copy @a rep val))
                         (subscript_out @N @Boxed_a (reprSizeAlign @Boxed_a rep_Ref) ret real_index))) in
                 stored @EffTok new_acc eff_ret)
              eff_tok_in s) of
          boxed @SEffTok (eff_tok_out : Stored EffTok).

        case eff_tok_out of stored @EffTok (tok : EffTok).
        fromEffTok @(arr N Boxed_a) tok)))
     ret)
  ret;


Sequence_fold @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Init acc)
  (init : acc)
  (src : Sequence a)
  (ret : OutPtr acc)
  -> Store
  attribute(inline, inline_final) =
  case src of
    sequence @a @(st : box) (state : st) (next : st -> StreamNext st a).

  letfun
    go (state : st) (accumulator : AsBox acc) (ret : OutPtr acc)
      -> Store =
      case next state of {

        -- Obtain value from stream
        streamValue @st @a (next_state : st) (result : AsBox a).
          -- Compute the new value
          let new_accumulator : AsBox acc =
                case boxed @a (asbare @a repr_a result)
                of boxed @a (y : a).
                case boxed @acc (asbare @acc repr_acc accumulator)
                of boxed @acc (x : acc).
                asbox @acc repr_acc (f x y)

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty @st @a.
	  asbare @acc repr_acc accumulator ret
      }
  in go state (asbox @acc repr_acc (copy @acc repr_acc init)) ret;


Sequence_parallel_reduce @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (f : a -> a -> Init a)
  (init : a)
  (g : Stored int -> Sequence a)
  (ret : OutPtr a)
  -> Store =
  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type b = AsBox a in
      letfun
        combiner (x : b) (y : b) -> b =
          case boxed @a (asbare @a repr x) of boxed @a (bx : a).
          case boxed @a (asbare @a repr y) of boxed @a (by : a).
          asbox @a repr (f bx by)
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =

          -- Reduce over the sequence [lb, lb + count)
          case boxed @a (asbare @a repr acc_in) of boxed @a (acc : a).
          case count of fiInt @range_N (count_i : int).
          asbox @a repr
          (Sequence_reduce @a repr f acc
           (Sequence_generate_bind @a (mk_list_dim (justVal @int count_i))
            (\ (si : Stored int) -> Sequence a.
               -- Add 'lb' to the index
               case si of stored @int (i : int).
               case boxed @(Stored int) (stored @int (lb +# i)) of
                 boxed @(Stored int) (real_si : Stored int).
               g real_si)))
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = asbox @a repr (copy @a repr init) in
      asbare @a repr
      (blocked_1d_reduce @N @b count combiner boxed_init reducer)
      ret

  ; nothingVal @int.
      except @Store
  };


Sequence_parallel_build @(a : bare)
  (rep : Repr a) (dom : list_dim) (f : Stored int -> Sequence a)
  (ret : OutPtr (list a))
  -> Store
  attribute(inline) =

  let reduced_tree : PBTree a = PBTree_parallel_build @a rep dom f in

  PBTree_flatten @a rep reduced_tree ret;


-- Run a blocked parallel computation over a sequence.
-- Collect the results into a tree, where each tree leaf is the result of one
-- parallel step.
PBTree_parallel_build @(a : bare)
  (rep : Repr a) (dom : list_dim)
  (f : Stored int -> Sequence a)
  -> PBTree a
  attribute(inline) =

  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      letfun
        -- Sequentially build a list from a subset of the original range.
        -- Put the list in a tree leaf.
        rangeProc @(M : intindex)
          (start : int) (count : FIInt M) (init : PBTree a) -> PBTree a =
          case count of fiInt @M (count_new : int).
          let count_i : int = count_new in
          let outLeaf : PBTree a =
                pbLeaf @a
                (Sequence_list_build @a rep
                 (Sequence_generate_bind @a (mk_list_dim (justVal @int count_i))
                  (\ (si : Stored int) -> Sequence a.
                     -- Add 'start' to the index
                     case si of stored @int (i : int).
                     case boxed @(Stored int) (stored @int (start +# i)) of
                     boxed @(Stored int) (real_si : Stored int).
                     f real_si))) in
          PBTree_branch @a outLeaf init in

      case defineIntIndex size of
        someIInt @(n : intindex) (range_count : FIInt n).

      -- Create lists in parallel and build a tree out of them
      blocked_1d_reduce @n @(PBTree a)
      range_count (PBTree_branch @a) (pbEmpty @a) rangeProc

  ; nothingVal @int.
      except @(PBTree a)
  };


Sequence_parallel_scatter @(i r : bare)
  (rep_i : Repr i) (rep_r : Repr r)
  (dom : list_dim)
  (scatter : Scatter r i)
  (f : Stored int -> Sequence i)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case scatter of
    mk_scatter @r @i @(s : bare) @(iniF : box) @(updF : box)
    (rep_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (update_func : i -> updF)
    (init_func : iniF).

  let type bs = StuckBox s in

  letfun
    -- Version of 'combiner' for boxed objects
    boxed_combiner (x : bs) (y : bs) -> bs =
      case x of stuckBox @s (ux : s).
      case y of stuckBox @s (uy : s).
      stuckBox @s (combiner ux uy)
  in

  case dom of mk_list_dim (maybe_size : MaybeVal int).

  case maybe_size of {
    justVal @int (count : int).
      case defineIntIndex count of someIInt @(N : intindex) (size : FIInt N).

      -- Perform a parallel reduction over this range
      case blocked_1d_reduceip @N @bs size
           boxed_combiner
           (\ @(M : intindex) (start : int) (range_size : FIInt M) -> bs.
              -- Sequential reduction over this sub-range
              case range_size of fiInt @M (range_count : int).
              let subdom : list_dim = mk_list_dim (justVal @int range_count) in
                    
              stuckBox @s
              (Sequence_partial_scatter @i @s @iniF @updF rep_i rep_s
               initializer updater update_func init_func
               (Sequence_generate_bind @i subdom
                (\ (sindex : Stored int) -> Sequence i.
                   -- Add 'start' to the index
                   case sindex of stored @int (uindex : int).
                   case stuckBox @(Stored int)
                        (stored @int (uindex +# start)) of
                     stuckBox @(Stored int) (sindex2 : Stored int).
                     f sindex2)))) of
        stuckBox @s (final_state : s).

      -- Create the final object
      finish_scatter @r @s rep_r rep_s finalizer
      (copy @s rep_s final_state) ret

  ; nothingVal @int.
      except @Store
  };

-------------------------------------------------------------------------------
-- High-level stream and container functions

fun_map @(t : bare -> bare)
        @(a b : bare)
        (traversable : TraversableDict t)
        (shape_dict : ShapeDict (shape t))
        (repr_a : Repr a)
        (repr_b : Repr b)
        (transformer : a -> Init b)
        (container : t a)
	(ret : OutPtr (t b))
        -> Store
 	attribute(inline) =
  let type sh = shape t in

  case traversable of
    traversableDict @t
    (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
    (build : (a : bare) -> Repr a -> Stream sh a -> Init (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  build @b repr_b
  (shape_map @a @b repr_a repr_b transformer
   (traverse @a repr_a container))
  ret;


fun_filter @(t : bare -> bare) @(a : bare)
     (traversable : TraversableDict t)
     (is_list : coerce @box (shape t) list_dim)
     (repr : Repr a)
     (predicate : a -> bool)
     (input : t a)
     (ret : OutPtr (t a))
  -> Store attribute(inline) =
  case traversable of
    traversableDict @t
    (traverse : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
    (build : (a : bare) -> Repr a -> Stream (shape t) a -> Init (t a)).

  -- Traverse the input
  let input_stream : Stream1 a =
        coerce @(Stream (shape t) a) @(Stream1 a)
        (traverse @a repr input) in

  -- Guard.  For each stream element,
  -- return the element if predicate evaluates to true.
  -- Otherwise, return nothing.
  let s : Stream1 a =
        Stream1_bind @a @a repr repr input_stream
        (\ (x : a) -> Stream1 a.
           if predicate x
           then sequenceStream @a (Sequence_return @a repr (copy @a repr x))
           else sequenceStream @a (Sequence_empty @a repr)) in

  -- Build the return value
  build @a repr (coerce @(Stream1 a) @(Stream (shape t) a) s) ret;


fun_zip @(t1 t2 : bare -> bare) @(a : bare) @(b : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (equal12 : coerce @box (shape t1) (shape t2))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b)
        (inputA : t1 a) (inputB : t2 b)
  -> Stream (shape t1) (Tuple2 a b)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Init (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Init (t2 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (ret : OutPtr (Tuple2 a b))
    		-> Store =
      tuple2 @a @b (copy @a reprA x) (copy @b reprB y) ret
  in

  shape_zipWith @a @b @(Tuple2 a b)
  reprA reprB (repr_Tuple2 @a @b reprA reprB)
  transformer stream1 stream2;

fun_zip3 @(t1 t2 t3 : bare -> bare) @(a b c : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (equal12 : coerce @box (shape t1) (shape t2))
        (equal23 : coerce @box (shape t2) (shape t3))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c)
  -> Stream (shape t1) (Tuple3 a b c)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Init (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Init (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Init (t3 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (z : c) (ret : OutPtr (Tuple3 a b c))
    		-> Store =
      tuple3 @a @b @c (copy @a reprA x) (copy @b reprB y) (copy @c reprC z) ret
  in

  shape_zipWith3 @a @b @c @(Tuple3 a b c)
  reprA reprB reprC (repr_Tuple3 @a @b @c reprA reprB reprC)
  transformer stream1 stream2 stream3;


fun_zip4 @(t1 t2 t3 t4 : bare -> bare) @(a b c d : bare)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (traversable4 : TraversableDict t4)
        (equal12 : coerce @box (shape t1) (shape t2))
        (equal23 : coerce @box (shape t2) (shape t3))
        (equal34 : coerce @box (shape t3) (shape t4))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr a) (reprB : Repr b) (reprC : Repr c) (reprD : Repr d)
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c) (inputD : t4 d)
  -> Stream (shape t1) (Tuple4 a b c d)
  attribute(inline) =
  case traversable1
  of traversableDict @t1
       (traverse1 : (a : bare) -> Repr a -> t1 a -> Stream (shape t1) a)
       (build1 : (a : bare) -> Repr a -> Stream (shape t1) a -> Init (t1 a)).
  case traversable2
  of traversableDict @t2
       (traverse2 : (a : bare) -> Repr a -> t2 a -> Stream (shape t2) a)
       (build2 : (a : bare) -> Repr a -> Stream (shape t2) a -> Init (t2 a)).
  case traversable3
  of traversableDict @t3
       (traverse3 : (a : bare) -> Repr a -> t3 a -> Stream (shape t3) a)
       (build3 : (a : bare) -> Repr a -> Stream (shape t3) a -> Init (t3 a)).
  case traversable4
  of traversableDict @t4
       (traverse4 : (a : bare) -> Repr a -> t4 a -> Stream (shape t4) a)
       (build4 : (a : bare) -> Repr a -> Stream (shape t4) a -> Init (t4 a)).
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in
  let stream4 : Stream (shape t1) d =
        coerce @(Stream (shape t4) d) @(Stream (shape t1) d)
	(traverse4 @d reprD inputD) in

  let type sh = shape t1 in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  letfun
    transformer (x : a) (y : b) (z : c) (w : d) (ret : OutPtr (Tuple4 a b c d))
    		-> Store =
      tuple4 @a @b @c @d (copy @a reprA x) (copy @b reprB y) (copy @c reprC z) (copy @d reprD w) ret
  in

  shape_zipWith4 @a @b @c @d @(Tuple4 a b c d)
  reprA reprB reprC reprD (repr_Tuple4 @a @b @c @d reprA reprB reprC reprD)
  transformer stream1 stream2 stream3 stream4;


fun_reduce @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Init a)
  (init : a)
  (input : t a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_dimensionality) =
  let type sh = shape t in

  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Init (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let s : Stream1 a = shape_flatten @a repr (traverse @a repr input) in
  case s of {
    viewStream @a (vw : view list_dim a).
      reduce_list_dim @a repr reducer init vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce @a repr reducer init sq ret
  };


fun_reduce1 @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (reducer : a -> a -> Init a)
  (input : t a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_dimensionality) =
  let type sh = shape t in

  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Init (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let s : Stream1 a = shape_flatten @a repr (traverse @a repr input) in
  case s of {
    viewStream @a (vw : view list_dim a).
      reduce1_list_dim @a repr reducer vw ret
  ; sequenceStream @a (sq : Sequence a).
      Sequence_reduce1 @a repr reducer sq ret
  };


fun_sum @(t : bare -> bare) @(a : bare)
  (traversable : TraversableDict t)
  (shape : ShapeDict (shape t))
  (rep : Repr a)
  (additive : AdditiveDict a)
  (src : t a)
  (ret : OutPtr a)
  -> Store
  attribute(inline) =

  case additive of
    additiveDict @a
    (add : a -> a -> Init a)
    (sub : a -> a -> Init a)
    (negate : a -> Init a)
    (zero : a).

  fun_reduce @t @a traversable shape rep add zero src ret;


fun_indices @(sh : box) (shape_dict : ShapeDict sh) (shp : sh)
  -> Stream sh (index sh)
  attribute(inline) =

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  shape_generate @(index sh) index_repr shp (copy @(index sh) index_repr);


displaceView @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (cartesian : CartesianDict (shape t))
  (additive : AdditiveDict (index (shape t)))
  (repr : Repr a)
  (c : t a)
  (disp : index (shape t))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in
  let type ix = index (shape t) in
  case cartesian of
    cartesianDict @sh
    (has_shape : coerce @box (cartesianDomain (index sh)) sh)
    (loBound : sh -> Init (Maybe ix))
    (hiBound : sh -> Init (Maybe ix))
    (get_stride : sh -> Init ix)
    (arrayDomain : ix -> ix -> sh)
    (displaceDomain : sh -> ix -> sh)
    (multiplyDomain : sh -> ix -> sh)
    (divideDomain : sh -> ix -> sh)
    (multiplyIndex : ix -> ix -> Init ix)
    (divideIndex : ix -> ix -> Init ix)
    (unbounded : sh).

  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  case additive of
    additiveDict @ix
    (add : ix -> ix -> Init ix)
    (sub : ix -> ix -> Init ix)
    (negate : ix -> Init ix)
    (zero : ix).

  -- Note that we transform from new index to old index by subtracting the
  -- displacement 
  view_generate @sh shape_dict @a repr (displaceDomain (get_shape @a c) disp)
  (\ (i : ix) (ret : OutPtr a) -> Store.
     case boxed @ix (sub i disp) of boxed @ix (i2 : ix).
     at_index @a repr c i2 ret);


multiplyView @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (cartesian : CartesianDict (shape t))
  (additive : AdditiveDict (index (shape t)))
  (repr : Repr a)
  (c : t a)
  (scale : index (shape t))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in
  let type ix = index (shape t) in
  case cartesian of
    cartesianDict @sh
    (has_shape : coerce @box (cartesianDomain (index sh)) sh)
    (loBound : sh -> Init (Maybe ix))
    (hiBound : sh -> Init (Maybe ix))
    (get_stride : sh -> Init ix)
    (arrayDomain : ix -> ix -> sh)
    (displaceDomain : sh -> ix -> sh)
    (multiplyDomain : sh -> ix -> sh)
    (divideDomain : sh -> ix -> sh)
    (multiplyIndex : ix -> ix -> Init ix)
    (divideIndex : ix -> ix -> Init ix)
    (unbounded : sh).

  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Note that we transform from new index to old index by dividing the
  -- scale factor 
  view_generate @sh shape_dict @a repr (multiplyDomain (get_shape @a c) scale)
  (\ (i : ix) (ret : OutPtr a) -> Store.
     case boxed @ix (divideIndex i scale) of boxed @ix (i2 : ix).
     at_index @a repr c i2 ret);


divideView @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (cartesian : CartesianDict (shape t))
  (additive : AdditiveDict (index (shape t)))
  (repr : Repr a)
  (c : t a)
  (scale : index (shape t))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in
  let type ix = index (shape t) in
  case cartesian of
    cartesianDict @sh
    (has_shape : coerce @box (cartesianDomain (index sh)) sh)
    (loBound : sh -> Init (Maybe ix))
    (hiBound : sh -> Init (Maybe ix))
    (get_stride : sh -> Init ix)
    (arrayDomain : ix -> ix -> sh)
    (displaceDomain : sh -> ix -> sh)
    (multiplyDomain : sh -> ix -> sh)
    (divideDomain : sh -> ix -> sh)
    (multiplyIndex : ix -> ix -> Init ix)
    (divideIndex : ix -> ix -> Init ix)
    (unbounded : sh).

  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  -- Note that we transform from new index to old index by multiplying the
  -- scale factor.
  -- 'divideDomain' will throw an error if the scale factor is invalid.
  view_generate @sh shape_dict @a repr (divideDomain (get_shape @a c) scale)
  (\ (i : ix) (ret : OutPtr a) -> Store.
     case boxed @ix (multiplyIndex i scale) of boxed @ix (i2 : ix).
     at_index @a repr c i2 ret);


-------------------------------------------------------------------------------
-- Domain loops (sequential)

primitive_list_dim_chain @(a : bare) (repr : Repr a)
  (v1 : view list_dim a)
  (v2 : view list_dim a)
  -> view list_dim a
  attribute(inline, inline_final) =
  case v1 of
    mk_view @list_dim @a (dom1 : list_dim) (f1 : Stored int -> Init a).
  case v2 of
    mk_view @list_dim @a (dom2 : list_dim) (f2 : Stored int -> Init a).

  case dom1 of mk_list_dim (size1 : MaybeVal int).
  case dom2 of mk_list_dim (size2 : MaybeVal int).
  case size1 of {
    justVal @int (sz : int).
      let dom : list_dim =
            mk_list_dim (case size2 of {
                           justVal @int (sz2 : int). justVal @int (sz +# sz2)
                         ; nothingVal @int. nothingVal @int}) in
      mk_view @list_dim @a dom
      (\ (ix : Stored int) (ret : OutPtr a) -> Store.
         -- Get a value from the first or the second view
         case ix of stored @int (i : int).
         if i <# sz
         then f1 ix ret
         else case boxed @(Stored int) (stored @int (i -# sz)) of
                boxed @(Stored int) (ix2 : Stored int).
              f2 ix2 ret)

  ; nothingVal @int.
      -- The first domain is infinite, so the second is unreachable
      mk_view @list_dim @a dom1 f1
  };


primitive_list_dim_reduce @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (generator : Stored int -> Init a)
  (reducer : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    justVal @int (size : int).
      case defineIntIndex size of someIInt @(N : intindex) (sz : FIInt N).

      for @N @a repr sz init
      (\ (i : int) (x : a) (loop_ret : OutPtr a) -> Store.
         case boxed @(Stored int) (stored @int i) of
           boxed @(Stored int) (s_i : Stored int).
         case boxed @a (generator s_i) of boxed @a (y : a).
         reducer x y loop_ret)
      ret

  ; nothingVal @int.
      -- Can't evaluate on an infinite domain
      except @Store
  };


primitive_list_dim_reduce1 @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (generator : Stored int -> Init a)
  (reducer : a -> a -> Init a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_list_dim (m_size : MaybeVal int).
  case m_size of {
    justVal @int (size : int).
      -- Can't reduce on empty range
      if size ==# 0 then except @Store else

      -- Evaluate at index 0 to get initial value
      case boxed @(Stored int) (stored @int 0) of
        boxed @(Stored int) (s_zero : Stored int).
      case boxed @a (generator s_zero) of
        boxed @a (init : a).

      -- Reduce remaining values
      case defineIntIndex (size -# 1) of
        someIInt @(N : intindex) (sz : FIInt N).

      for @N @a repr sz init
      (\ (i : int) (x : a) (loop_ret : OutPtr a) -> Store.
         case boxed @(Stored int) (stored @int (i +# 1)) of
           boxed @(Stored int) (s_i : Stored int).
         case boxed @a (generator s_i) of boxed @a (y : a).
         reducer x y loop_ret)
      ret

  ; nothingVal @int.
      -- Can't evaluate on an infinite domain
      except @Store
  };


primitive_list_dim_scatter @(i r : bare)
  (repr_i : Repr i)
  (repr_r : Repr r)
  (dom : list_dim)
  (op : Scatter r i)
  (src : Stored int -> Init i)
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_sequential) =

  case op of
    mk_scatter @r @i @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (make_updater : i -> updF)
    (make_init : iniF).

  finish_scatter @r @s repr_r repr_s finalizer
  (partial_list_dim_scatter @i @s @iniF @updF repr_i repr_s
   initializer updater make_updater make_init dom src)
  ret;


primitive_list_dim_fold @(acc : bare)
  (repr : Repr acc)
  (d : list_dim)
  (f : index list_dim -> acc -> Init acc)
  (init : acc)
  (ret : OutPtr acc)
  -> Store
  attribute(inline) =

  case d of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      
      for @N @acc repr count init
      (\ (i : int) (loop_acc : acc) (ret : OutPtr acc) -> Store.
         case boxed @(Stored int) (stored @int i) of
           boxed @(Stored int) (real_index : Stored int).

         -- Accumulate value
         f real_index loop_acc ret)
      ret

  ; nothingVal @int.
      except @Store
  };


primitive_dim1_reduce @(a : bare)
  (repr : Repr a)
  (dom : dim1)
  (generator : Stored int -> Init a)
  (reducer : a -> a -> Init a)
  (init : a)
  -> Init a
  attribute(inline, inline_final) =

  dim1ToArrayDesc @a dom
  (\ @(N : intindex)
     (lb : int) (stride : int) (size : FIInt N) (ret : OutPtr a)
     -> Store.

     let linear_map : LinearMap = linearMap stride lb in

     for @N @a repr size init
     (\ (i : int) (x : a) (loop_ret : OutPtr a) -> Store.
        let logical_i : int = evalLM i linear_map in
        case boxed @(Stored int) (stored @int logical_i) of
           boxed @(Stored int) (s_i : Stored int).
         case boxed @a (generator s_i) of boxed @a (y : a).
         reducer x y loop_ret)
     ret);


primitive_dim1_reduce1 : (a : bare)
  -> Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;


primitive_dim1_fold @(acc : bare)
  (repr : Repr acc)
  (d : dim1)
  (f : index dim1 -> acc -> Init acc)
  (init : acc)
  -> Init acc
  attribute(inline) =

  -- Loop over the domain
  dim1ToArrayDesc @acc d
  (\ @(N : intindex)
     (lb : int) (stride : int) (count : FIInt N) (ret : OutPtr acc)
     -> Store.

     for @N @acc repr count init
     (\ (i : int) (loop_acc : acc) (ret : OutPtr acc) -> Store.

        -- Compute the real index in this loop iteration
        case boxed @(Stored int) (stored @int (lb +# i *# stride)) of
          boxed @(Stored int) (real_index : Stored int).

        -- Accumulate value
        f real_index loop_acc ret)
     ret);


primitive_dim2_reduce : (a : bare) -> Repr a -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

primitive_dim2_reduce1 : (a : bare) -> Repr a -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> Init a;


-------------------------------------------------------------------------------
-- Domain loops (parallel)

parallel_list_dim_reduce @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (g : Stored int -> Init a)
  (f : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store =

  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type b = AsBox a in
      letfun
        combiner (x : b) (y : b) -> b =
          case boxed @a (asbare @a repr x) of boxed @a (bx : a).
          case boxed @a (asbare @a repr y) of boxed @a (by : a).
          asbox @a repr (f bx by)
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
          for_box @range_N @b count acc_in
          (\ (i : int) (acc_loop : b) -> b.
            -- Add the lower bound to get the real index
            case boxed @(Stored int) (stored @int (i +# lb)) of
              boxed @(Stored int) (real_index : Stored int).

            -- Call 'g' to compute a value, and 'f' to combine it
            case boxed @a (asbare @a repr acc_loop) of
              boxed @a (x : a).
            case boxed @a (g real_index) of boxed @a (y : a).
            asbox @a repr (f x y))
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = asbox @a repr (copy @a repr init) in
      asbare @a repr
      (blocked_1d_reduce @N @b count combiner boxed_init reducer)
      ret

  ; nothingVal @int.
      except @Store
  };


parallel_dim1_reduce @(a : bare)
  (repr : Repr a)
  (dom : dim1)
  (g : Stored int -> Init a)
  (f : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store
  attribute(inline) =

  case dom of mk_dim1 (iv : Interval) (lm : LinearMap).
  case lm of linearMap (stride : int) (alignemnt : int).
  case iv of
    interval (lower_bound : MaybeVal int) (upper_bound : MaybeVal int).
  case lower_bound of {
    justVal @int (lb : int).
      case upper_bound of {
        justVal @int (ub : int).          
          -- Create combiner and reducer functions using 'f' and 'g'
          let type b = AsBox a in
          letfun
            combiner (x : b) (y : b) -> b =
              case boxed @a (asbare @a repr x) of boxed @a (bx : a).
              case boxed @a (asbare @a repr y) of boxed @a (by : a).
              asbox @a repr (f bx by)
          in
          letfun
            reducer @(range_N : intindex)
              (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
              for_box @range_N @b count acc_in
              (\ (i : int) (acc_loop : b) -> b.
                -- Compute the real index from iteration 'i'
                let real_index_u : int = lb +# i *# stride in
                case boxed @(Stored int) (stored @int real_index_u) of
                  boxed @(Stored int) (real_index : Stored int).

                -- Call 'g' to compute a value, and 'f' to combine it
                case boxed @a (asbare @a repr acc_loop) of
                  boxed @a (x : a).
                case boxed @a (g real_index) of boxed @a (y : a).
                asbox @a repr (f x y))
          in
          let size : int = (ub -# lb) //# stride in
          case defineIntIndex size of
            someIInt @(N : intindex) (count : FIInt N).
          let boxed_init : b = asbox @a repr (copy @a repr init) in
          asbare @a repr
          (blocked_1d_reduce @N @b count combiner boxed_init reducer)
          ret

      ; nothingVal @int.
          except @Store
      }
  ; nothingVal @int.
      except @Store
  };


parallel_list_dim_reduce1 @(a : bare)
  (repr : Repr a)
  (dom : list_dim)
  (g : Stored int -> Init a)
  (f : a -> a -> Init a)
  (ret : OutPtr a)
  -> Store =

  let mrepr : Repr (Maybe a) = repr_Maybe @a repr in
  case dom of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type ma = Maybe a in
      let type b = AsBox ma in
      letfun
        combiner (x : b) (y : b) -> b =
          -- Combine 'Maybe' values.  Use 'f' if both values are 'Just'.
          case boxed @ma (asbare @ma mrepr x) of
            boxed @ma (maybe_x : ma).
          case maybe_x of {
            just @a (bx : a).
              case boxed @ma (asbare @ma mrepr y) of
                boxed @ma (maybe_y : ma).
              case maybe_y of {
                just @a (by : a). asbox @ma mrepr (just @a (f bx by))
              ; nothing @a. x
            }
          ; nothing @a. y
          }
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
          case boxed @ma (asbare @ma mrepr acc_in) of
            boxed @ma (m_acc_in : ma).

          letfun
            reduce_with_initial_value @(subrange_N : intindex)
              (subrange_lb : int)
              (subrange_count : FIInt subrange_N)
              (subrange_acc : a)
              -> b =
            asbox @ma mrepr
            (just @a
             (for @subrange_N @a repr subrange_count subrange_acc
              (\ (i : int) (x : a) (ret : OutPtr a) -> Store.
                 -- Add the lower bound to get the real index
                 case boxed @(Stored int) (stored @int (i +# subrange_lb)) of
                   boxed @(Stored int) (real_index : Stored int).
               
                 -- Call 'g' to compute a value, and 'f' to combine it
                 case boxed @a (g real_index) of boxed @a (y : a).
                 f x y ret)))
          in
          -- Get an initial value.  The value comes from either
          -- the given accumulator or the beginning of the range.
          -- We know the range is nonempty.
          case m_acc_in of {
            just @a (b_acc_in : a).
              reduce_with_initial_value @range_N lb count b_acc_in
          ; nothing @a.
              case boxed @(Stored int) (stored @int lb) of
                boxed @(Stored int) (first_index : Stored int).
              case boxed @a (g first_index) of boxed @a (b_acc_in : a).

              reduce_with_initial_value @(minus_i range_N 1)
              (lb +# 1)
              (minus_fii @range_N @1 count one_fii)
              b_acc_in
          }
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = asbox @ma mrepr (nothing @a) in
      case boxed @ma
           (asbare @ma mrepr
            (blocked_1d_reduce @N @b count combiner boxed_init reducer)) of
        boxed @ma (m_result : Maybe a).
      case m_result of {
        just @a (result : a). copy @a repr result ret
      ; nothing @a. except @Store
      }

  ; nothingVal @int.
      except @Store
  };


parallel_list_dim_scatter @(i r : bare)
  (repr_i : Repr i) (repr_r : Repr r)
  (dom : list_dim)
  (op : Scatter r i)
  (f : Stored int -> Init i)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case op of
    mk_scatter @r @i @(s : bare) @(iniF : box) @(updF : box)
    (rep_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (update_func : i -> updF)
    (init_func : iniF).

  let type bs = StuckBox s in

  letfun
    -- Version of 'combiner' for boxed objects
    boxed_combiner (x : bs) (y : bs) -> bs =
      case x of stuckBox @s (ux : s).
      case y of stuckBox @s (uy : s).
      stuckBox @s (combiner ux uy)
  in

  case dom of mk_list_dim (maybe_size : MaybeVal int).

  case maybe_size of {
    justVal @int (count : int).
      case defineIntIndex count of someIInt @(N : intindex) (size : FIInt N).

      -- Perform a parallel reduction over this range
      case blocked_1d_reduceip @N @bs size
           boxed_combiner
           (\ @(M : intindex) (start : int) (range_size : FIInt M) -> bs.
              -- Sequential reduction over this sub-range
              case range_size of fiInt @M (range_count : int).
              let subdom : list_dim = mk_list_dim (justVal @int range_count) in
                    
              stuckBox @s
              (partial_list_dim_scatter @i @s @iniF @updF repr_i rep_s
               initializer updater update_func init_func subdom
               (\ (sindex : Stored int) (local_ret : OutPtr i) -> Store.
                  -- Add 'start' to the index
                  case sindex of stored @int (uindex : int).
                  case stuckBox @(Stored int)
                       (stored @int (uindex +# start)) of
                    stuckBox @(Stored int) (sindex2 : Stored int).
                  f sindex2 local_ret))) of
        stuckBox @s (final_state : s).

      -- Create the final object
      finish_scatter @r @s repr_r rep_s finalizer
      (copy @s rep_s final_state) ret

  ; nothingVal @int.
      except @Store
  };


parallel_dim1_reduce1 : (a : bare)
  -> Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

parallel_dim2_reduce : (a : bare)
  -> Repr a
  -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

parallel_dim2_reduce1 : (a : bare)
  -> Repr a
  -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

-------------------------------------------------------------------------------
-- Other functions

fun_undefined @(a : box) -> a = except @a;

-- Convert an indexed int to a finite indexed int.  Raise an exception
-- if not finite.
fromIndInt @(N : intindex) (ii : IInt N) -> FIInt N attribute(inline) =
  case ii of {
    iInt @N (fii : FIInt N). fii;
    iPosInfty @N. except @(FIInt N);
    iNegInfty @N. except @(FIInt N)
  };

-- A dummy boxed object that is used as a placeholder for a dead value.
deadBox : (a : box) -> a;

-- A dummy referenced object that is used as a placeholder for a dead value.
deadRef : (a : bare) -> Init a;


fun_isNothing @(a : bare) (repr : Repr a) (x : Maybe a)
  -> bool attribute(inline) =
  case x of {
    just @a (value : a). False
  ; nothing @a. True
  };


fun_isJust @(a : bare) (repr : Repr a) (x : Maybe a)
  -> bool attribute(inline) =
  case x of {
    just @a (value : a). True
  ; nothing @a. False
  };
  

fun_fromJust @(a : bare) (repr : Repr a) (x : Maybe a) (ret : OutPtr a)
  -> Store attribute(inline) =
  case x of {
    just @a (value : a). copy @a repr value ret
  ; nothing @a. except @Store
  };


isCons @(a : bare) (repr : Repr a) (l : llist a) -> bool attribute(inline) =
  case l of {
    cons @a (h : a) (t : llist a). True
  ; nil @a. False
  };


isNil @(a : bare) (repr : Repr a) (l : llist a) -> bool attribute(inline) =
  case l of {
    cons @a (h : a) (t : llist a). False
  ; nil @a. True
  };


head @(a : bare) (repr : Repr a) (l : llist a) -> a attribute(inline) =
  case l of {
    cons @a (h : a) (t : llist a). h
  ; nil @a. except @a
  };


tail @(a : bare) (repr : Repr a) (l : llist a) -> llist a attribute(inline) =
  case l of {
    cons @a (h : a) (t : llist a). t
  ; nil @a. except @(llist a)
  };


arr1D_build @(N : intindex) @(a : bare)
  (repr : Repr a) (size : FIInt N) (f : int -> Init a)
  (arr_ptr : OutPtr (arr N a))
  -> Store
  attribute(inline) =

  doall @N @(arr N a) @a size
  (\ (i : int) -> Store.
     f i (subscript_out @N @a (reprSizeAlign @a repr) arr_ptr i));


arr2D_build @(M N : intindex) @(a : bare)
  (repr : Repr a)
  (size_y : FIInt M) (size_x : FIInt N) (f : int -> int -> Init a)
  (arr_ptr : OutPtr (arr M (arr N a)))
  -> Store
  attribute(inline) =

  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  doall @M @(arr M (arr N a)) @(arr N a) size_y
  (\ (y : int) -> Store.
     doall @N @(arr N a) @a size_x
     (\ (x : int) -> Store.
        f y x
        (subscript_out @N @a (reprSizeAlign @a repr)
         (subscript_out @M @(arr N a) (reprSizeAlign @(arr N a) row_repr)
          arr_ptr y) x)));


arr3D_build @(L M N : intindex) @(a : bare)
  (repr : Repr a)
  (size_z : FIInt L)
  (size_y : FIInt M)
  (size_x : FIInt N)
  (f : int -> int -> int -> Init a)
  (arr_ptr : OutPtr (arr L (arr M (arr N a))))
  -> Store
  attribute(inline) =

  let row_repr : Repr (arr N a) = repr_arr @N @a size_x repr in
  let plane_repr : Repr (arr M (arr N a)) =
        repr_arr @M @(arr N a) size_y row_repr in
  doall @L @(arr L (arr M (arr N a))) @(arr M (arr N a)) size_z
  (\ (z : int) -> Store.
     doall @M @(arr M (arr N a)) @(arr N a) size_y
     (\ (y : int) -> Store.
        doall @N @(arr N a) @a size_x
        (\ (x : int) -> Store.
           f z y x
           (subscript_out @N @a (reprSizeAlign @a repr)
            (subscript_out @M @(arr N a) (reprSizeAlign @(arr N a) row_repr)
             (subscript_out @L @(arr M (arr N a)) (reprSizeAlign @(arr M (arr N a)) plane_repr)
              arr_ptr z) y) x))));


empty_list_dim_view : (a : bare) -> Repr a -> view list_dim a;

viewToSequence @(a : bare) (repr : Repr a) (vw : view list_dim a)
  -> Sequence a attribute(inline, inline_dimensionality) =
  case vw of
    mk_view @list_dim @a (dom : list_dim) (f : Stored int -> Init a).
      Sequence_generate @a repr dom f;


sequenceToView @(a : bare) (repr : Repr a) (sq : Sequence a)
  -> view list_dim a attribute(inline, inline_dimensionality) =
  -- Write the entire sequence to a list
  case boxed @(list a) (Sequence_list_build @a repr sq)
  of boxed @(list a) (ls : list a).

  -- Then traverse the list
  case ls of make_list @a @(N : intindex)
                       (size : FIInt N) (aref : StuckBox (arr N a)).
  case aref of stuckBox @(arr N a) (ay : arr N a).

  case size of fiInt @N (size_i : int).
  let dom : list_dim = mk_list_dim (justVal @int size_i) in
  view_generate @list_dim ShapeDict_list_dim @a repr dom
  (\ (si : Stored int) (ret : OutPtr a) -> Store.
     case si of stored @int (i : int).
     copy @a repr (subscript @N @a (reprSizeAlign @a repr) ay i) ret);


-- Given a mapping from old to new domains and from new to old indices,
-- transform a view.
view_transform @(sh : box) @(a : bare)
  (repr : Repr a)
  (transform_domain : sh -> sh)
  (transform_index : index sh -> Init (index sh))
  (vw : view sh a)
  -> view sh a
  attribute(inline, inline_dimensionality) =
  case vw of mk_view @sh @a (dom : sh) (f : index sh -> Init a).
  mk_view @sh @a (transform_domain dom)
  (\ (i : index sh) (ret : OutPtr a) -> Store.
     case boxed @(index sh) (transform_index i) of
       boxed @(index sh) (i2 : index sh).
     f i2 ret);


-- An identity function needed in the frontend
fun_from_MatrixView_Stream : (a : bare)
			  -> Stream dim2 a
			  -> Stream dim2 a;

-- Reinterpret an array stream as having array2 shape
fun_asMatrix_Stream : (M N : intindex)
		   -> (a : bare)
		   -> IInt M
		   -> IInt N
		   -> Stream (arr_shape M (arr_shape N dim0)) a
		   -> Stream dim2 a;

-- Reinterpret a array2 stream as having array shape
fun_asArray2_Stream : (a b : bare)
		   -> Stream dim2 a
		   -> ((M N : intindex)
		       -> IInt M -> IInt N
		       -> Stream (arr_shape M (arr_shape N dim0))
		       -> Init b)
		   -> Init b;

fun_map_Stream : (sh a b : bare)
	      -> ShapeDict sh
       	      -> Repr a
       	      -> Repr b
       	      -> (a -> Init b)
       	      -> Stream sh a
       	      -> Stream sh b;



fun_zip_Stream : (sh a b : bare)
	      -> ShapeDict sh
       	      -> Repr a
       	      -> Repr b
       	      -> Stream sh a
       	      -> Stream sh b
       	      -> Stream sh (Tuple2 a b);

fun_zip3_Stream : (sh a b c : bare)
	       -> ShapeDict sh
               -> Repr a
               -> Repr b
               -> Repr c
               -> Stream sh a
               -> Stream sh b
               -> Stream sh c
               -> Stream sh (Tuple3 a b c);

fun_zip4_Stream : (sh a b c d : bare)
	       -> ShapeDict sh
               -> Repr a
               -> Repr b
               -> Repr c
               -> Repr d
               -> Stream sh a
               -> Stream sh b
               -> Stream sh c
               -> Stream sh d
               -> Stream sh (Tuple4 a b c d);

count : Stream list_dim (Stored int);


range (length : int) -> Stream list_dim (Stored int)
  attribute(inline) =
  viewStream @(Stored int)
  (view_generate @list_dim ShapeDict_list_dim @(Stored int) repr_int
   (mk_list_dim (justVal @int length))
   (\ (i : Stored int) -> Init (Stored int).
      copy @(Stored int) repr_int i));


arrayRange @(sh : box) (shape : ShapeDict sh) (cartesian : CartesianDict sh)
  (lo : index sh) (hi : index sh)
  -> Stream sh (index sh)
  attribute(inline) =

  let type ix = index sh in
  case cartesian of
    cartesianDict @sh
    (has_shape : coerce @box (cartesianDomain ix) sh)
    (loBound : sh -> Init (Maybe ix))
    (hiBound : sh -> Init (Maybe ix))
    (get_stride : sh -> Init ix)
    (arrayDomain : ix -> ix -> sh)
    (displaceDomain : sh -> ix -> sh)
    (multiplyDomain : sh -> ix -> sh)
    (divideDomain : sh -> ix -> sh)
    (multiplyIndex : ix -> ix -> Init ix)
    (divideIndex : ix -> ix -> Init ix)
    (unbounded : sh).

  fun_indices @sh shape (arrayDomain lo hi);


singletonIter @(a : bare) (repr : Repr a) (w : Init a) -> Stream list_dim a
  attribute(inline) =
  viewStream @a (singleton_list_dim_view @a repr w);


-- Helper function for 'singletonIter'
singleton_list_dim_view @(a : bare) (repr : Repr a) (w : Init a)
  -> view list_dim a
  attribute(inline, inline_dimensionality) =
  view_generate @list_dim ShapeDict_list_dim @a repr
  (mk_list_dim (justVal @int 1))
  (\ (i : Stored int) -> Init a. w);


-- Helper function for stream rewriting transformations
peel_generate_bind @(a r : bare)
  (rep_a : Repr a)
  (rep_r : Repr r)
  (dom : list_dim)
  (proceed : int -> list_dim -> Init r -> Init r)
  (failure : Init r)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case dom of mk_list_dim (msize : MaybeVal int).
  case msize of {
    justVal @int (size : int).
      letfun
        -- Loop over each element of the domain
        loop (i : int) (ret : OutPtr r) -> Store =
          if i <# size
          then let new_dom : list_dim =
                     mk_list_dim (justVal @int (size -# i -# 1)) in

               -- Pass the index, leftover domain, and loop continuation
               -- to 'proceed'.  'proceed' will call the continuation or
               -- do its own thing.
               proceed i new_dom (loop (i +# 1)) ret
          else failure ret
      in loop 0 ret

  ; nothingVal @int.
      except @Store
  };


peel_generate @(a r : bare)
  (rep_a : Repr a)
  (rep_r : Repr r)
  (dom : list_dim)
  (proceed : list_dim -> Init r)
  (failure : Init r)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case dom of mk_list_dim (msize : MaybeVal int).
  case msize of {
    justVal @int (size : int).
      if size ==# 0
      then failure ret
      else let new_dom : list_dim = mk_list_dim (justVal @int (size -# 1)) in
           proceed new_dom ret

  ; nothingVal @int.
      except @Store
  };


chain @(a : bare)
  (repr : Repr a) (i1 : Stream list_dim a) (i2 : Stream list_dim a)
  -> Stream list_dim a
  attribute(inline) =
  case i1 of {
    viewStream @a (v1 : view list_dim a).
      case i2 of {
        viewStream @a (v2 : view list_dim a).
          viewStream @a (primitive_list_dim_chain @a repr v1 v2)
      ; sequenceStream @a (s2 : Sequence a).
          sequenceStream @a
          (Sequence_chain @a repr (viewToSequence @a repr v1) s2)
      }
  ; sequenceStream @a (s1 : Sequence a).
      case i2 of {
        viewStream @a (v2 : view list_dim a).
          sequenceStream @a
          (Sequence_chain @a repr s1 (viewToSequence @a repr v2))
      ; sequenceStream @a (s2 : Sequence a).
          sequenceStream @a
          (Sequence_chain @a repr s1 s2)
      }
  };


len @(t : bare -> bare) @(a : bare)
  (is_linear : coerce @box (shape t) list_dim)
  (indexable : IndexableDict t)
  (container : t a)
  -> int
  attribute(inline) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  let sh : list_dim = coerce @(shape t) @list_dim (get_shape @a container) in
  case sh of mk_list_dim (list_size : MaybeVal int).
  case list_size of {
    justVal @int (n : int). n
  ; nothingVal @int. except @int
  };


width @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (container : t a)
  -> int
  attribute(inline) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  let sh : dim2 = coerce @(shape t) @dim2 (get_shape @a container) in
  case sh of mk_dim2 (dim_y : dim1) (dim_x : dim1).
  case dim_x of mk_dim1 (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal @int (lb_i : int).
      case ub of {
        justVal @int (ub_i : int). ub_i -# lb_i
      ; nothingVal @int. except @int
      }
    ; nothingVal @int. except @int
  };


height @(t : bare -> bare) @(a : bare)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (container : t a)
  -> int
  attribute(inline) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  let sh : dim2 = coerce @(shape t) @dim2 (get_shape @a container) in
  case sh of mk_dim2 (dim_y : dim1) (dim_x : dim1).
  case dim_y of mk_dim1 (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal @int (lb_i : int).
      case ub of {
        justVal @int (ub_i : int). ub_i -# lb_i
      ; nothingVal @int. except @int
      }
    ; nothingVal @int. except @int
  };


safeIndex @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (ix : index (shape t))
  (ret : OutPtr a)
  -> Store
  attribute(inline) =

  let type sh = shape t in
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index sh -> Init a)
    (get_shape : (a : bare) -> t a -> sh).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let container_shape : sh = get_shape @a container in
  if shape_member container_shape ix
  then at_index @a repr container ix ret
  else except @Store;


safeSlice @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (repr : Repr a)
  (container : t a)
  (sl : slice (shape t))
  -> view (shape t) a
  attribute(inline) =
  
  let type sh = shape t in
  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  shape_slice @t @a (idCoercion @sh) indexable repr container sl;


rows @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (shape t) dim2)
  (repr : Repr a)
  (container : t a)
  -> view dim1 (Ref (view dim1 a))
  attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).
  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 (shape_y : dim1) (shape_x : dim1).

  view_generate @dim1
  ShapeDict_dim1 @(Ref (view dim1 a))
  (repr_Box @(view dim1 a)) shape_y
  (\ (s_y : Stored int) -> Init (Ref (view dim1 a)).
    ref @(view dim1 a)
    (view_generate @dim1 ShapeDict_dim1
     @a repr shape_x
     (\ (s_x : Stored int) (ret : OutPtr a) -> Store.
       case boxed @(index dim2)
            (tuple2 @(Stored int) @(Stored int)
             (copy @(Stored int) repr_int s_y)
             (copy @(Stored int) repr_int s_x)) of
         boxed @(index dim2) (ix : index dim2).
       at_index @a repr container
       (coerce @(index dim2) @(index (shape t)) ix)
       ret)));
  

cols @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (shape t) dim2)
  (repr : Repr a)
  (container : t a)
  -> view dim1 (Ref (view dim1 a))
  attribute(inline) =
  case indexable of
    indexableDict @t
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).
  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 (shape_y : dim1) (shape_x : dim1).

  view_generate @dim1
  ShapeDict_dim1 @(Ref (view dim1 a))
  (repr_Box @(view dim1 a)) shape_x
  (\ (s_x : Stored int) -> Init (Ref (view dim1 a)).
    ref @(view dim1 a)
    (view_generate @dim1
     ShapeDict_dim1 @a repr shape_y
     (\ (s_y : Stored int) (ret : OutPtr a) -> Store.
       case boxed @(index dim2)
            (tuple2 @(Stored int) @(Stored int)
             (copy @(Stored int) repr_int s_y)
             (copy @(Stored int) repr_int s_x)) of
         boxed @(index dim2) (ix : index dim2).
       at_index @a repr container
       (coerce @(index dim2) @(index (shape t)) ix)
       ret)));


outerproduct @(t u : bare -> bare) @(a b : bare)
  (traversable_t : TraversableDict t)
  (traversable_u : TraversableDict u)
  (t_is_linear : coerce @box (shape t) dim1)
  (u_is_linear : coerce @box (shape u) dim1)
  (repr_a : Repr a) (repr_b : Repr b)
  (container_t : t a)
  (container_u : u b)
  -> Stream dim2 (Tuple2 a b)
  attribute(inline) =

  case traversable_t
  of traversableDict @t
       (traverseT : (a : bare) -> Repr a -> t a -> Stream (shape t) a)
       (buildT : (a : bare) -> Repr a -> Stream (shape t) a -> Init (t a)).
  case traversable_u
  of traversableDict @u
       (traverseU : (a : bare) -> Repr a -> u a -> Stream (shape u) a)
       (buildU : (a : bare) -> Repr a -> Stream (shape u) a -> Init (u a)).

  let sa : Stream dim1 a =
        coerce @(Stream (shape t) a) @(Stream dim1 a)
        (traverseT @a repr_a container_t) in
  let sb : Stream dim1 b =
        coerce @(Stream (shape u) b) @(Stream dim1 b)
        (traverseU @b repr_b container_u) in

  outerproductStream @a @b repr_a repr_b sa sb;


outerproductStream @(a b : bare)
  (repr_a : Repr a) (repr_b : Repr b)
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim2 (Tuple2 a b)
  attribute(inline, inline_dimensionality) =

  case sa of mk_view @dim1 @a (domA : dim1) (fA : Stored int -> Init a).
  case sb of mk_view @dim1 @b (domB : dim1) (fB : Stored int -> Init b).

  let type Sint = Stored int in
  let type out_type = Tuple2 a b in

  view_generate @dim2 ShapeDict_dim2 @out_type
  (repr_Tuple2 @a @b repr_a repr_b)
  (mk_dim2 domA domB)
  (\ (ix : Tuple2 Sint Sint) (ret : OutPtr out_type) -> Store.

    -- Index each view with one component of the index
    case ix of tuple2 @Sint @Sint (ix_y : Sint) (ix_x : Sint).
    tuple2 @a @b (fA ix_y) (fB ix_x) ret);


transpose : (t : bare -> bare) -> (a : bare)
         -> IndexableDict t
	 -> coerce @box (shape t) dim2
	 -> Repr a
	 -> t a -> view dim2 a;


boxedStencil2D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (output_dom : dim2)
  (stencil_dom : dim2)
  (gen_f : view dim2 a -> Init b)
  (input : t a)
  (ret: OutPtr (barray2 b))
  -> Store
  attribute(inline, inline_dimensionality) =

  -- This function is defined in terms of stencil2D.
  let type boxed_b = StuckRef (AsBox b) in
  let repr_boxed_b : Repr boxed_b = repr_StuckRef @(AsBox b) in

  mk_barray2 @b
  (stencil2D @t @a @(StuckRef (AsBox b))
   indexable is_2d repr_a repr_boxed_b
   output_dom stencil_dom
   (\ (vw : view dim2 a) (ret : OutPtr boxed_b) -> Store.

      -- Call 'gen_f' and re-box the result
      stuckRef @(AsBox b)
      (asbox @b repr_b (gen_f vw)) ret)
   input)
  ret;


stencil2D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (output_dom : dim2)
  (stencil_dom : dim2)
  (gen_f : view dim2 a -> Init b)
  (input : t a)
  (ret: OutPtr (array2 b))
  -> Store
  attribute(inline, inline_dimensionality) =

  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  let input_dom : dim2 = coerce @(shape t) @dim2 (get_shape @a input) in

  case output_dom of mk_dim2 (output_dom_y : dim1) (output_dom_x : dim1).
  case output_dom_y of mk_dim1 (output_y_iv : Interval) (output_y_lm : LinearMap).
  case output_dom_x of mk_dim1 (output_x_iv : Interval) (output_x_lm : LinearMap).
  case output_y_lm of linearMap (output_y_stride : int) (output_y_align : int).
  case output_x_lm of linearMap (output_x_stride : int) (output_x_align : int).

  case input_dom of mk_dim2 (input_dom_y : dim1) (input_dom_x : dim1).
  case input_dom_y of mk_dim1 (input_y_iv : Interval) (input_y_lm : LinearMap).
  case input_dom_x of mk_dim1 (input_x_iv : Interval) (input_x_lm : LinearMap).
  case input_y_lm of linearMap (input_y_stride : int) (input_y_align : int).
  case input_x_lm of linearMap (input_x_stride : int) (input_x_align : int).

  case stencil_dom of mk_dim2 (stencil_dom_y : dim1) (stencil_dom_x : dim1).
  case stencil_dom_y of mk_dim1 (stencil_y_iv : Interval) (stencil_y_lm : LinearMap).
  case stencil_dom_x of mk_dim1 (stencil_x_iv : Interval) (stencil_x_lm : LinearMap).
  case stencil_y_lm of linearMap (stencil_y_stride : int) (stencil_y_align : int).
  case stencil_x_lm of linearMap (stencil_x_stride : int) (stencil_x_align : int).

  -- Verify that all stencil inputs are in the input domain:

  -- 1. any linear combination of output and stencil strides must be a
  -- multiple of the input stride.
  if gcd output_y_stride stencil_y_stride %# input_y_stride /=# 0
  then except @Store else

  if gcd output_x_stride stencil_x_stride %# input_x_stride /=# 0
  then except @Store else

  -- 2. The alignment of the output plus the alignment of the stencil must be
  --    equal to the alignment of the input, modulo the input stride.
  if (output_y_align +# stencil_y_align -# input_y_align) %# input_y_stride /=# 0
  then except @Store else

  if (output_x_align +# stencil_x_align -# input_x_align) %# input_x_stride /=# 0
  then except @Store else

  -- 3. The bounds of the output range plus the bounds of the stencil range
  --    must be within the bounds of the input range.
  if not (subsetInterval (convolveInterval output_y_iv stencil_y_iv) input_y_iv)
  then except @Store else

  if not (subsetInterval (convolveInterval output_x_iv stencil_x_iv) input_x_iv)
  then except @Store else

  -- Loop over all stencil indices
  let output_view : view dim2 b =
        view_generate @dim2 ShapeDict_dim2 @b repr_b output_dom
        (\ (ix : index dim2) (ret : OutPtr b) -> Store.
           case ix of
             tuple2 @(Stored int) @(Stored int)
             (ix_y : Stored int) (ix_x : Stored int).
           case ix_y of stored @int (o_y : int).
           case ix_x of stored @int (o_x : int).

           -- Apply the generator function to a view of the input array
           gen_f
           (view_generate @dim2 ShapeDict_dim2 @a repr_a stencil_dom
            (\ (s_ix : index dim2) (s_ret : OutPtr a) -> Store.
               case s_ix of
                 tuple2 @(Stored int) @(Stored int)
                 (s_ix_y : Stored int) (s_ix_x : Stored int).
               case s_ix_y of stored @int (s_y : int).
               case s_ix_x of stored @int (s_x : int).

               -- The real index is the output index plus the stencil index
               case boxed @(index dim2)
                    (tuple2 @(Stored int) @(Stored int)
                     (stored @int (o_y +# s_y))
                     (stored @int (o_x +# s_x))) of
                 boxed @(index dim2) (i_ix : index dim2).
               at_index @a repr_a input (coerce @(index dim2) @(index (shape t)) i_ix) s_ret))
           ret) in

  TraversableDict_array2_build @b repr_b output_view ret;


boxedStencil3D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_3d : coerce @box (shape t) dim3)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (output_dom : dim3)
  (stencil_dom : dim3)
  (gen_f : view dim3 a -> Init b)
  (input : t a)
  (ret: OutPtr (barray3 b))
  -> Store
  attribute(inline, inline_dimensionality) =

  -- This function is defined in terms of stencil3D.
  let type boxed_b = StuckRef (AsBox b) in
  let repr_boxed_b : Repr boxed_b = repr_StuckRef @(AsBox b) in

  mk_barray3 @b
  (stencil3D @t @a @(StuckRef (AsBox b))
   indexable is_3d repr_a repr_boxed_b
   output_dom stencil_dom
   (\ (vw : view dim3 a) (ret : OutPtr boxed_b) -> Store.

      -- Call 'gen_f' and re-box the result
      stuckRef @(AsBox b)
      (asbox @b repr_b (gen_f vw)) ret)
   input)
  ret;


stencil3D @(t : bare -> bare) @(a b : bare)
  (indexable : IndexableDict t)
  (is_3d : coerce @box (shape t) dim3)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (output_dom : dim3)
  (stencil_dom : dim3)
  (gen_f : view dim3 a -> Init b)
  (input : t a)
  (ret: OutPtr (array3 b))
  -> Store
  attribute(inline, inline_dimensionality) =

  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  let input_dom : dim3 = coerce @(shape t) @dim3 (get_shape @a input) in

  case output_dom of mk_dim3 (output_dom_z : dim1) (output_dom_y : dim1) (output_dom_x : dim1).
  case output_dom_z of mk_dim1 (output_z_iv : Interval) (output_z_lm : LinearMap).
  case output_dom_y of mk_dim1 (output_y_iv : Interval) (output_y_lm : LinearMap).
  case output_dom_x of mk_dim1 (output_x_iv : Interval) (output_x_lm : LinearMap).
  case output_z_lm of linearMap (output_z_stride : int) (output_z_align : int).
  case output_y_lm of linearMap (output_y_stride : int) (output_y_align : int).
  case output_x_lm of linearMap (output_x_stride : int) (output_x_align : int).

  case input_dom of mk_dim3 (input_dom_z : dim1) (input_dom_y : dim1) (input_dom_x : dim1).
  case input_dom_z of mk_dim1 (input_z_iv : Interval) (input_z_lm : LinearMap).
  case input_dom_y of mk_dim1 (input_y_iv : Interval) (input_y_lm : LinearMap).
  case input_dom_x of mk_dim1 (input_x_iv : Interval) (input_x_lm : LinearMap).
  case input_z_lm of linearMap (input_z_stride : int) (input_z_align : int).
  case input_y_lm of linearMap (input_y_stride : int) (input_y_align : int).
  case input_x_lm of linearMap (input_x_stride : int) (input_x_align : int).

  case stencil_dom of mk_dim3 (stencil_dom_z : dim1) (stencil_dom_y : dim1) (stencil_dom_x : dim1).
  case stencil_dom_z of mk_dim1 (stencil_z_iv : Interval) (stencil_z_lm : LinearMap).
  case stencil_dom_y of mk_dim1 (stencil_y_iv : Interval) (stencil_y_lm : LinearMap).
  case stencil_dom_x of mk_dim1 (stencil_x_iv : Interval) (stencil_x_lm : LinearMap).
  case stencil_z_lm of linearMap (stencil_z_stride : int) (stencil_z_align : int).
  case stencil_y_lm of linearMap (stencil_y_stride : int) (stencil_y_align : int).
  case stencil_x_lm of linearMap (stencil_x_stride : int) (stencil_x_align : int).

  -- Verify that all stencil inputs are in the input domain:

  -- 1. any linear combination of output and stencil strides must be a
  -- multiple of the input stride.
  if gcd output_z_stride stencil_z_stride %# input_z_stride /=# 0
  then except @Store else

  if gcd output_y_stride stencil_y_stride %# input_y_stride /=# 0
  then except @Store else

  if gcd output_x_stride stencil_x_stride %# input_x_stride /=# 0
  then except @Store else

  -- 2. The alignment of the output plus the alignment of the stencil must be
  --    equal to the alignment of the input, modulo the input stride.
  if (output_z_align +# stencil_z_align -# input_z_align) %# input_z_stride /=# 0
  then except @Store else

  if (output_y_align +# stencil_y_align -# input_y_align) %# input_y_stride /=# 0
  then except @Store else

  if (output_x_align +# stencil_x_align -# input_x_align) %# input_x_stride /=# 0
  then except @Store else

  -- 3. The bounds of the output range plus the bounds of the stencil range
  --    must be within the bounds of the input range.
  if not (subsetInterval (convolveInterval output_z_iv stencil_z_iv) input_z_iv)
  then except @Store else

  if not (subsetInterval (convolveInterval output_y_iv stencil_y_iv) input_y_iv)
  then except @Store else

  if not (subsetInterval (convolveInterval output_x_iv stencil_x_iv) input_x_iv)
  then except @Store else

  -- Loop over all stencil indices
  let type Sint = Stored int in
  let output_view : view dim3 b =
        view_generate @dim3 ShapeDict_dim3 @b repr_b output_dom
        (\ (ix : index dim3) (ret : OutPtr b) -> Store.
           case ix of
             tuple3 @Sint @Sint @Sint
             (ix_z : Sint) (ix_y : Sint) (ix_x : Sint).
           case ix_z of stored @int (o_z : int).
           case ix_y of stored @int (o_y : int).
           case ix_x of stored @int (o_x : int).

           -- Apply the generator function to a view of the input array
           gen_f
           (view_generate @dim3 ShapeDict_dim3 @a repr_a stencil_dom
            (\ (s_ix : index dim3) (s_ret : OutPtr a) -> Store.
               case s_ix of
                 tuple3 @Sint @Sint @Sint
                 (s_ix_z : Sint) (s_ix_y : Sint) (s_ix_x : Sint).
               case s_ix_z of stored @int (s_z : int).
               case s_ix_y of stored @int (s_y : int).
               case s_ix_x of stored @int (s_x : int).

               -- The real index is the output index plus the stencil index
               case boxed @(index dim3)
                    (tuple3 @Sint @Sint @Sint
                     (stored @int (o_z +# s_z))
                     (stored @int (o_y +# s_y))
                     (stored @int (o_x +# s_x))) of
                 boxed @(index dim3) (i_ix : index dim3).
               at_index @a repr_a input (coerce @(index dim3) @(index (shape t)) i_ix) s_ret))
           ret) in

  TraversableDict_array3_build @b repr_b output_view ret;


extend2D @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr : Repr a)
  (container : t a)
  -> view dim2 a
  attribute(inline, inline_sequential) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 (dim_y : dim1) (dim_x : dim1).
  case dim_y of mk_dim1 (y_interval : Interval) (y_linear_map : LinearMap).
  case y_interval of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case y_linear_map of linearMap (stride_y : int) (alignment_y : int).
  case dim_x of mk_dim1 (x_interval : Interval) (x_linear_map : LinearMap).
  case x_interval of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case x_linear_map of linearMap (stride_x : int) (alignment_x : int).

  -- Input must be nonempty
  if or (case lb_y of {
           justVal @int (lb_y_i : int).
             case ub_y of {
               justVal @int (ub_y_i : int). lb_y_i ==# ub_y_i
             ; nothingVal @int. False
             }
         ; nothingVal @int. False
         })
         (case lb_x of {
           justVal @int (lb_x_i : int).
             case ub_x of {
               justVal @int (ub_x_i : int). lb_x_i ==# ub_x_i
             ; nothingVal @int. False
             }
         ; nothingVal @int. False
         })
  then except @(view dim2 a) else

  -- Create a view with no bounds
  let unbounded_interval : Interval =
        interval (nothingVal @int) (nothingVal @int) in
  let dom : dim2 =
        mk_dim2 (mk_dim1 unbounded_interval y_linear_map)
                (mk_dim1 unbounded_interval x_linear_map) in

  mk_view @dim2 @a dom
  (\ (ix : Tuple2 (Stored int) (Stored int)) (ret : OutPtr a)
     -> Store.
     case ix of tuple2 @(Stored int) @(Stored int)
                (sy : Stored int) (sx : Stored int).
     case sy of stored @int (y : int).
     case sx of stored @int (x : int).

     -- Coerce the x and y indices to be in bounds
     letfun
       coerce_to_bounds
         (i : int) (lb : MaybeVal int) (ub : MaybeVal int) (stride : int)
         -> int =
         letfun
           coerce_upper (dummy : NoneType) -> int =
             case ub of {
               justVal @int (ub_i : int).
                 if i >=# ub_i then ub_i -# stride else i
             ; nothingVal @int. i
             } in
         case lb of {
           justVal @int (lb_i : int).
             if i <# lb_i then lb_i else coerce_upper None
         ; nothingVal @int. coerce_upper None
         } in
     let real_y : int = coerce_to_bounds y lb_y ub_y stride_y in
     let real_x : int = coerce_to_bounds x lb_x ub_x stride_x in

     -- Create new index
     case boxed @(Tuple2 (Stored int) (Stored int))
          (tuple2 @(Stored int) @(Stored int)
           (stored @int real_y) (stored @int real_x)) of
       boxed @(Tuple2 (Stored int) (Stored int))
             (inbounds_ix : Tuple2 (Stored int) (Stored int)).
     at_index @a repr container
     (coerce @(index dim2) @(index (shape t)) inbounds_ix)
     ret);


extend3D @(t : bare -> bare) @(a : bare)
  (indexable : IndexableDict t)
  (is_3d : coerce @box (shape t) dim3)
  (repr : Repr a)
  (container : t a)
  -> view dim3 a
  attribute(inline, inline_sequential) =
  case indexable of
    indexableDict @t 
    (at_index : (a : bare) -> Repr a -> t a -> index (shape t) -> Init a)
    (get_shape : (a : bare) -> t a -> shape t).

  case coerce @(shape t) @dim3 (get_shape @a container) of
    mk_dim3 (dim_z : dim1) (dim_y : dim1) (dim_x : dim1).
  case dim_z of mk_dim1 (z_interval : Interval) (z_linear_map : LinearMap).
  case z_interval of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).
  case z_linear_map of linearMap (stride_z : int) (alignment_z : int).
  case dim_y of mk_dim1 (y_interval : Interval) (y_linear_map : LinearMap).
  case y_interval of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case y_linear_map of linearMap (stride_y : int) (alignment_y : int).
  case dim_x of mk_dim1 (x_interval : Interval) (x_linear_map : LinearMap).
  case x_interval of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case x_linear_map of linearMap (stride_x : int) (alignment_x : int).

  -- Input must be nonempty
  if or (case lb_z of {
           justVal @int (lb_z_i : int).
             case ub_z of {
               justVal @int (ub_z_i : int). lb_z_i ==# ub_z_i
             ; nothingVal @int. False
             }
         ; nothingVal @int. False
         })
        (or (case lb_y of {
               justVal @int (lb_y_i : int).
                 case ub_y of {
                   justVal @int (ub_y_i : int). lb_y_i ==# ub_y_i
                 ; nothingVal @int. False
                 }
             ; nothingVal @int. False
             })
             (case lb_x of {
               justVal @int (lb_x_i : int).
                 case ub_x of {
                   justVal @int (ub_x_i : int). lb_x_i ==# ub_x_i
                 ; nothingVal @int. False
                 }
             ; nothingVal @int. False
             }))
  then except @(view dim3 a) else

  -- Create a view with no bounds
  let unbounded_interval : Interval =
        interval (nothingVal @int) (nothingVal @int) in
  let dom : dim3 =
        mk_dim3 (mk_dim1 unbounded_interval z_linear_map)
                (mk_dim1 unbounded_interval y_linear_map)
                (mk_dim1 unbounded_interval x_linear_map) in

  let type Sint = Stored int in
  mk_view @dim3 @a dom
  (\ (ix : Tuple3 Sint Sint Sint) (ret : OutPtr a)
     -> Store.
     case ix of tuple3 @Sint @Sint @Sint
                (sz : Sint) (sy : Sint) (sx : Sint).
     case sz of stored @int (z : int).
     case sy of stored @int (y : int).
     case sx of stored @int (x : int).

     -- Coerce the indices to be in bounds
     letfun
       coerce_to_bounds
         (i : int) (lb : MaybeVal int) (ub : MaybeVal int) (stride : int)
         -> int =
         letfun
           coerce_upper (dummy : NoneType) -> int =
             case ub of {
               justVal @int (ub_i : int).
                 if i >=# ub_i then ub_i -# stride else i
             ; nothingVal @int. i
             } in
         case lb of {
           justVal @int (lb_i : int).
             if i <# lb_i then lb_i else coerce_upper None
         ; nothingVal @int. coerce_upper None
         } in
     let real_z : int = coerce_to_bounds z lb_z ub_z stride_z in
     let real_y : int = coerce_to_bounds y lb_y ub_y stride_y in
     let real_x : int = coerce_to_bounds x lb_x ub_x stride_x in

     -- Create new index
     case boxed @(Tuple3 Sint Sint Sint)
          (tuple3 @Sint @Sint @Sint
           (stored @int real_z) (stored @int real_y) (stored @int real_x)) of
       boxed @(Tuple3 Sint Sint Sint)
             (inbounds_ix : Tuple3 Sint Sint Sint).
     at_index @a repr container
     (coerce @(index dim3) @(index (shape t)) inbounds_ix)
     ret);


-- Take the union of an inner and outer view
unionView3D @(a : bare) (repr : Repr a)
  (inner : view dim3 a) (edge : view dim3 a)
  -> view dim3 a attribute(inline, inline_dimensionality) =

  case inner of mk_view @dim3 @a (inner_dom : dim3) (inner_f : index dim3 -> Init a).
  case edge of mk_view @dim3 @a (edge_dom : dim3) (edge_f : index dim3 -> Init a).

  case inner_dom of mk_dim3 (inner_dom_z : dim1) (inner_dom_y : dim1) (inner_dom_x : dim1).
  case inner_dom_z of mk_dim1 (inner_z_iv : Interval) (inner_z_lm : LinearMap).
  case inner_dom_y of mk_dim1 (inner_y_iv : Interval) (inner_y_lm : LinearMap).
  case inner_dom_x of mk_dim1 (inner_x_iv : Interval) (inner_x_lm : LinearMap).
  case inner_z_lm of linearMap (inner_z_stride : int) (inner_z_align : int).
  case inner_y_lm of linearMap (inner_y_stride : int) (inner_y_align : int).
  case inner_x_lm of linearMap (inner_x_stride : int) (inner_x_align : int).

  case edge_dom of mk_dim3 (edge_dom_z : dim1) (edge_dom_y : dim1) (edge_dom_x : dim1).
  case edge_dom_z of mk_dim1 (edge_z_iv : Interval) (edge_z_lm : LinearMap).
  case edge_dom_y of mk_dim1 (edge_y_iv : Interval) (edge_y_lm : LinearMap).
  case edge_dom_x of mk_dim1 (edge_x_iv : Interval) (edge_x_lm : LinearMap).
  case edge_z_lm of linearMap (edge_z_stride : int) (edge_z_align : int).
  case edge_y_lm of linearMap (edge_y_stride : int) (edge_y_align : int).
  case edge_x_lm of linearMap (edge_x_stride : int) (edge_x_align : int).

  -- Verify that the inner domain is a subset of the outer domain.
  -- The outer domain's stride must divide the inner domain's stride.
  if inner_z_stride %# edge_z_stride /=# 0
  then except @(view dim3 a) else

  if inner_y_stride %# edge_y_stride /=# 0
  then except @(view dim3 a) else

  if inner_x_stride %# edge_x_stride /=# 0
  then except @(view dim3 a) else

  -- The outer domain's stride must divide the difference in alignments.
  if (edge_z_align -# inner_z_align) %# edge_z_stride /=# 0
  then except @(view dim3 a) else

  if (edge_y_align -# inner_y_align) %# edge_y_stride /=# 0
  then except @(view dim3 a) else

  if (edge_x_align -# inner_x_align) %# edge_x_stride /=# 0
  then except @(view dim3 a) else

  -- THe inner domain's interval is a subset of the outer domain's interval
  if not (subsetInterval inner_x_iv edge_x_iv)
  then except @(view dim3 a) else

  if not (subsetInterval inner_y_iv edge_y_iv)
  then except @(view dim3 a) else

  if not (subsetInterval inner_z_iv edge_z_iv)
  then except @(view dim3 a) else

  -- If an element of the new map is an element of the inner view,
  -- its value is the inner view's; otherwise it is the outer view's
  view_generate @dim3 ShapeDict_dim3 @a repr edge_dom
  (\ (ix : Tuple3 (Stored int) (Stored int) (Stored int)) (ret : OutPtr a)
     -> Store.

    case ix of tuple3 @(Stored int) @(Stored int) @(Stored int)
               (sz : Stored int) (sy : Stored int) (sx : Stored int).
    case sz of stored @int (z : int).
    case sy of stored @int (y : int).
    case sx of stored @int (x : int).

    -- Is this part of the inner view?
    let in_stride : bool =
          and (and (inLM z inner_z_lm) (inLM y inner_y_lm))
              (inLM x inner_x_lm) in
    let in_interval : bool =
          and (and (inInterval z inner_z_iv) (inInterval y inner_y_iv))
              (inInterval x inner_x_iv) in

    if and in_stride in_interval
    then inner_f ix ret
    else edge_f ix ret);


permute1D @(t : bare -> bare) @(a : bare)
  (shape_dict : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep_s : Repr (t a))
  (rep_a : Repr a)
  (dom : dim1)
  (src : t (Tuple2 (Stored int) a))
  (ret : OutPtr (array1 a))
  -> Store
  attribute(inline) =

  let type indexval = Tuple2 (Stored int) a in

  let type sh = shape t in
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Init (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let rep_tuple : Repr indexval =
        repr_Tuple2 @(Stored int) @a repr_int rep_a in

  -- Do a sequential in-place update
  case shape_flatten @indexval rep_tuple (traverse @indexval rep_tuple src) of {
    viewStream @indexval (vw : view list_dim indexval).
      permute1D_list_dim @a rep_a dom vw ret

  ; sequenceStream @indexval (sq : Sequence indexval).
      Sequence_permute1D @a rep_a dom sq ret
  };


boxedPermute1D @(t : bare -> bare) @(a : bare)
  (shape_dict : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep_s : Repr (t a))
  (rep_a : Repr a)
  (dom : dim1)
  (src : t (Tuple2 (Stored int) a))
  (ret : OutPtr (barray1 a))
  -> Store
  attribute(inline) =

  let type indexval = Tuple2 (Stored int) a in

  let type sh = shape t in
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Init (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  let rep_tuple : Repr indexval =
        repr_Tuple2 @(Stored int) @a repr_int rep_a in

  -- Do a sequential in-place update
  case shape_flatten @indexval rep_tuple (traverse @indexval rep_tuple src) of {
    viewStream @indexval (vw : view list_dim indexval).
      boxedPermute1D_list_dim @a rep_a dom vw ret

  ; sequenceStream @indexval (sq : Sequence indexval).
      Sequence_boxedPermute1D @a rep_a dom sq ret
  };


create_view2 : (a : bare) -> Repr a
            -> index dim2 -> index dim2 -> (index dim2 -> Init a) -> view dim2 a;

-- A type-indexed version of 'range'
rangeIndexed : (n : intindex)
            -> IInt n
            -> Stream (arr_shape n dim0) (Stored int);

fun_scatter @(t : bare -> bare) @(i r : bare)
  (shape_dict : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (repr_s : Repr (t i))
  (repr_i : Repr i)
  (repr_r : Repr r)
  (op : Scatter r i)
  (src : t i)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  let type sh = shape t in
  case traversable
  of traversableDict @t
       (traverse : (a : bare) -> Repr a -> t a -> Stream sh a)
       (build : (a : bare) -> Repr a -> Stream sh a -> Init (t a)).

  case shape_dict of shapeDict @sh
    (index_repr : Repr (index sh))
    (slice_repr : Repr (slice sh))
    (shape_member : sh -> index sh -> bool)
    (shape_intersect : sh -> sh -> sh)
    (shape_flatten : (a : bare) -> Repr a -> Stream sh a -> Stream list_dim a)
    (shape_generate : (a : bare) -> Repr a -> sh -> (index sh -> Init a) -> Stream sh a)
    (shape_map : (a b : bare) ->
                 Repr a -> Repr b ->
		 (a -> Init b) -> Stream sh a -> Stream sh b)
    (shape_zipWith : (a b c : bare) ->
    		     Repr a -> Repr b -> Repr c ->
		     (a -> b -> Init c) ->
		     Stream sh a -> Stream sh b -> Stream sh c)
    (shape_zipWith3 : (a b c d : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d ->
		      (a -> b -> c -> Init d) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d)
    (shape_zipWith4 : (a b c d e : bare) ->
    		      Repr a -> Repr b -> Repr c -> Repr d -> Repr e ->
		      (a -> b -> c -> d -> Init e) ->
		      Stream sh a -> Stream sh b -> Stream sh c -> Stream sh d -> Stream sh e)
    (shape_slice : (t : bare -> bare) -> (a : bare) ->
    		   coerce @box (shape t) sh ->
		   IndexableDict t -> Repr a -> t a -> slice sh -> view sh a).

  -- Do a sequential in-place update
  case shape_flatten @i repr_i (traverse @i repr_i src) of {
    viewStream @i (vw : view list_dim i).
      scatter_list_dim @i @r repr_i repr_r op vw ret

  ; sequenceStream @i (sq : Sequence i).
      Sequence_scatter @i @r repr_i repr_r op sq ret
  };


histogram @(sh : box)
  (shape_dict : ShapeDict sh)
  (lo_bound : int)
  (hi_bound : int)
  (input : Stream sh (Stored int))
  (ret : OutPtr (array1 (Stored int)))
  -> Store
  attribute(inline) =

  let type Sint = Stored int in
  let type SNone = Stored NoneType in
  let sr : Scatter (array1 Sint) (Tuple2 Sint SNone) =
        array1Scatter @Sint @SNone
        repr_NoneType
        repr_int
        (mk_dim1 (interval (justVal @int lo_bound) (justVal @int hi_bound))
                 (linearMap 1 0))
        countingScatter in

  let traversable : TraversableDict (\ (a : bare). Ref (Stream sh a)) =
        traversableDict @(\ (a : bare). Ref (Stream sh a))
        (\ @(a : bare) (repr : Repr a) (x : Ref (Stream sh a))
           -> Stream sh a.
           case x of ref @(Stream sh a) (ux : Stream sh a). ux)
        (\ @(a : bare) (repr : Repr a) (x : Stream sh a)
           -> Init (Ref (Stream sh a)).
           ref @(Stream sh a) x) in

  case boxed @(AsBare (Stream sh Sint)) (ref @(Stream sh Sint) input) of
    boxed @(AsBare (Stream sh Sint)) (b_input : Ref (Stream sh Sint)).

  -- For each input value x, create a tuple (x, None)
  case boxed @(AsBare (Stream sh (Tuple2 Sint SNone)))
       (fun_map @(\ (a : bare). AsBare (Stream sh a))
                @Sint @(Tuple2 Sint SNone)
                traversable
                shape_dict
                repr_int
                (repr_Tuple2 @Sint @SNone repr_int repr_NoneType)
                (\ (x : Sint) -> Init (Tuple2 Sint SNone).
                  tuple2 @Sint @SNone
                  (copy @Sint repr_int x) (stored @NoneType None))
                b_input)
  of boxed @(AsBare (Stream sh (Tuple2 Sint SNone)))
     (b_input2 : AsBare (Stream sh (Tuple2 Sint SNone))).

  fun_scatter @(\ (a : bare). AsBare (Stream sh a))
  @(Tuple2 Sint SNone) @(array1 Sint)
  shape_dict
  traversable
  (repr_Box @(Stream sh (Tuple2 Sint SNone)))
  (repr_Tuple2 @Sint @SNone repr_int repr_NoneType)
  (repr_array1 @(Stored int))
  sr
  b_input2
  ret;


histogramArray : (n : intindex)
              -> FIInt n
              -> int
              -> int
              -> Stream dim1 (Stored int)
              -> Init (arr n (Stored int));

subscript : (n : intindex)
         -> (a : bare)
         -> SizeAlign a
         -> arr n a
         -> int
         -> a
         attribute(conlike);

-- Like subscript, but modifies an output pointer
subscript_out : (n : intindex)
             -> (a : bare)
             -> SizeAlign a
             -> OutPtr (arr n a)
             -> int
             -> OutPtr a;

-------------------------------------------------------------------------------
-- Other rewritable functions

Stream1_empty @(a : bare) (repr : Repr a) -> Stream1 a attribute(inline) =
  sequenceStream @a (Sequence_empty @a repr);


Stream1_return @(a : bare) (repr : Repr a) (w : Init a) -> Stream1 a
  attribute(inline) =
  sequenceStream @a (Sequence_return @a repr w);


Stream1_guard @(a : bare) (repr : Repr a) (condition : bool) (s : Stream1 a)
  -> Stream1 a
  attribute(inline) =
  let sq : Sequence a =
        case s of {
	  viewStream @a (vw : view list_dim a). viewToSequence @a repr vw
	; sequenceStream @a (sq : Sequence a). sq
	} in
  sequenceStream @a (Sequence_guard @a repr condition sq);


Stream1_bind @(a b : bare)
  (repr_a : Repr a)
  (repr_b : Repr b)
  (s : Stream1 a)
  (t : a -> Stream1 b)
  -> Stream1 b
  attribute(inline) =
  let sq : Sequence a =
        case s of {
	  viewStream @a (vw : view list_dim a). viewToSequence @a repr_a vw
	; sequenceStream @a (sq : Sequence a). sq
	} in
  letfun
    sq_t (x : a) -> Sequence b =
      case t x of {
	  viewStream @b (vw : view list_dim b). viewToSequence @b repr_b vw
	; sequenceStream @b (sq : Sequence b). sq
      } in
  
  sequenceStream @b (Sequence_bind @a @b repr_a sq sq_t);


Sequence_empty @(a : bare) (repr : Repr a) -> Sequence a
  attribute(inline, inline_final) =
  let type st = Boxed (Stored NoneType) in
  sequence @a @st
  (boxed @(Stored NoneType) (stored @NoneType None))
  (\ (x : st) -> StreamNext st a. streamEmpty @st @a);


Sequence_return @(a : bare)
  (repr : Repr a)
  (ret : Init a)
  -> Sequence a
  attribute(inline, inline_final) =
  let type st = Boxed (Stored bool) in
  sequence @a @st
  (boxed @(Stored bool) (stored @bool False))
  (\ (depleted : st) -> StreamNext st a.
     case depleted of boxed @(Stored bool) (depleted_s : Stored bool).
     case depleted_s of stored @bool (depleted_u : bool).
     if depleted_u
     then streamEmpty @st @a
     else streamValue @st @a
     	  (boxed @(Stored bool) (stored @bool True))
	  (asbox @a repr ret));


Sequence_chain @(a : bare)
  (repr : Repr a)
  (s1 : Sequence a)
  (s2 : Sequence a)
  -> Sequence a
  attribute(inline, inline_final) =
  -- Create a stream consisting of all contents of s1 followed by all contents
  -- of s2
  case s1 of sequence @a @(state1 : box)
             (s1 : state1) (f1 : state1 -> StreamNext state1 a).
  case s2 of sequence @a @(state2 : box)
             (s2 : state2) (f2 : state2 -> StreamNext state2 a).

  let type state = ChainState state1 state2 in
  sequence @a @state (chainFromFirst @state1 @state2 s1 s2)
  (\ (s : state) -> StreamNext state a.
     letfun
       pull_from_second (s2 : state2) -> StreamNext state a =
         -- Pull from second stream
         case f2 s2 of {
           streamValue @state2 @a (new_s2 : state2) (result : AsBox a).
             streamValue @state @a (chainFromNext @state1 @state2 new_s2) result
         ; streamEmpty @state2 @a.
             streamEmpty @state @a
         } in
     case s of {
       chainFromFirst @state1 @state2 (s1 : state1) (s2 : state2).
         -- Pull from first stream
         case f1 s1 of {
           streamValue @state1 @a (new_s1 : state1) (result : AsBox a).
             streamValue @state @a (chainFromFirst @state1 @state2 new_s1 s2) result
         ; streamEmpty @state1 @a.
             pull_from_second s2
         }
     ; chainFromNext @state1 @state2 (s2 : state2).
         pull_from_second s2
     });


Sequence_guard @(a : bare)
  (repr : Repr a) (condition : bool) (s : Sequence a) -> Sequence a
  attribute(inline) =
  if condition then s else Sequence_empty @a repr;


Sequence_bind @(a b : bare)
  (repr : Repr a)
  (src : Sequence a)
  (trans : a -> Sequence b)
  -> Sequence b
  attribute(inline, inline_final) =
  case src of
    sequence @a @(src_st : box)
    (src_state : src_st)
    (src_next : src_st -> StreamNext src_st a).

  let type bind_state = BindState src_st a b in

  letfun {
    next_from_source (src_state : src_st) -> StreamNext bind_state b =
      case src_next src_state of {
        streamValue @src_st @a (src_next_state : src_st) (src_value : AsBox a).
          case boxed @a (asbare @a repr src_value) of boxed @a (x : a).
	  case trans x of
	    sequence @b @(trans_st : box)
	    (trans_state : trans_st)
	    (trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_next_state trans_state trans_next
      ; streamEmpty @src_st @a.
	  streamEmpty @bind_state @b
      };

    next_from_trans @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st b)
      -> StreamNext bind_state b =
      case trans_next trans_state of {
        streamValue @trans_st @b (trans_next_state : trans_st) (trans_value : AsBox b).
          let next_state : bind_state =
	        bindFromTrans @src_st @a @b @trans_st
		src_state trans_next_state trans_next in
          streamValue @bind_state @b next_state trans_value
      ; streamEmpty @trans_st @b.
	  next_from_source src_state
      };

    next (state : bind_state) -> StreamNext bind_state b =
      case state of {
        bindFromSource @src_st @a @b (src_state : src_st).
	  next_from_source src_state
      ; bindFromTrans @src_st @a @b @(trans_st : box)
      	(src_state : src_st)
	(trans_state : trans_st)
	(trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_state trans_state trans_next
      }
  } in

  sequence @b @bind_state (bindFromSource @src_st @a @b src_state) next;


-- A fused version of 'bind' and 'generate'.
Sequence_generate_bind @(a : bare)
  (shp : list_dim) (transformer : Stored int -> Sequence a)
  -> Sequence a
  attribute(inline, inline_final) =
  Sequence_bind @(Stored int) @a repr_int
  (Sequence_generate @(Stored int) repr_int shp (copy @(Stored int) repr_int))
  transformer;


view_array1_build : (a : bare)
                 -> Repr a
                 -> view dim1 a
                 -> Init (array1 a);

Sequence_list_build @(a : bare)
  (repr : Repr a) (sq : Sequence a) (ret : OutPtr (list a))
  -> Store
  attribute(inline, inline_sequential) =

  let type acc = Stored (ListBuilder a) in
  let repr_acc : Repr acc = repr_ListBuilder @a in

  -- Build a list by repeatedly appending to it
  append_build_list @a repr
  (\ (writer : Init a -> ListBuilder a -> ListBuilder a)
     (init_state : ListBuilder a)
     -> ListBuilder a.
     case stuckBox @acc (stored @(ListBuilder a) init_state) of
       stuckBox @acc (stored_init_state : acc).

     -- The list-building process is a fold
     case stuckBox @acc
          (Sequence_fold @a @acc repr repr_acc
           (\ (local_state : acc) (item : a) (ret : OutPtr acc) -> Store.
              case local_state of
                stored @(ListBuilder a) (u_local_state : ListBuilder a).

              -- Call the writer to save this value to the list
              let u_new_state : ListBuilder a =
                    writer (copy @a repr item) u_local_state in

              stored @(ListBuilder a) u_new_state ret)
           stored_init_state
           sq) of
       stuckBox @acc (stored_final_state : acc).
       case stored_final_state of
         stored @(ListBuilder a) (final_state : ListBuilder a).
       final_state)
  ret;


Sequence_array1_build : (a : bare)
		     -> Repr a
		     -> Sequence a
		     -> Init (array1 a);

llist_fold @(a r : bare)
  (repr_a : Repr a)
  (repr_r : Repr r)
  (f : a -> r -> Init r)
  (init : r)
  (source : llist a)
  (ret : OutPtr r)
  -> Store attribute(inline, inline_final) =

  letfun
    go (source : llist a) (acc : r) (ret : OutPtr r) -> Store =
      case source of {
        cons @a (h : a) (t : llist a).
          case stuckBox @r (f h acc) of stuckBox @r (new_acc : r).
          go t new_acc ret
      ; nil @a. copy @r repr_r acc ret
      } in

  go source init ret;

-------------------------------------------------------------------------------
-- Loops

-- Parallelizable loop
doall : (n : intindex)
     -> (a b : bare)
     -> FIInt n
     -> (int -> Store)
     -> Store;

-- A doall loop that won't be parallelized
sequential_doall @(n : intindex) @(a b : bare)
     (count : FIInt n)
     (f : int -> Store)
     -> Store
     attribute(inline, inline_sequential) =

     doall @n @a @b count f;

-- Sequential loop
for @(N : intindex) @(acc : bare)
  (repr : Repr acc) (count : FIInt N) (init : acc)
  (f : int -> acc -> Init acc) (ret : OutPtr acc)
  -> Store
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of fiInt @N (bound : int).

  -- Main loop
  letfun
    loop (i : int) (x : acc) (r : OutPtr acc) -> Store =
      if i ==# bound
      then copy @acc repr x r
      else case boxed @acc (f i x) of boxed @acc (y : acc).
           loop (i +# 1) y r
  in loop 0 init ret;


for_box @(N : intindex) @(acc : box)
  (count : FIInt N)
  (init : acc)
  (f : int -> acc -> acc)
  -> acc
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of fiInt @N (bound : int).

  -- Main loop
  letfun
    loop (i : int) (x : acc) -> acc =
      if i ==# bound
      then x
      else loop (i +# 1) (f i x)
  in loop 0 init;


parallel_doall @(N : intindex) @(a b : bare)
  (count : FIInt N)
  (f : int -> Store)
  -> Store
  attribute(inline, inline_sequential) =

  letfun
    do_range @(M : intindex)
      (lb : int) (range_count : FIInt M)
      -> Store =
    doall @M @b @b range_count
    (\ (range_i : int) -> Store. f (range_i +# lb))
  in
  blocked_doall @N @a @b count do_range;


parallel_doall2 : (M N : intindex)
     -> (a b : bare)
     -> FIInt M
     -> FIInt N
     -> (int -> int -> Store)
     -> Store;

-- Blocked parallel reduction, implemented in low-level.
blocked_1d_reduce :
    (N : intindex)
 -> (acc : box)
 -> FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> acc			-- Initial value
 -> ((M : intindex) -> int -> FIInt M -> acc -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked 2D parallel reduction
blocked_2d_reduce :
    (M N : intindex)
 -> (acc : box)
 -> FIInt M		-- Size of range
 -> FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> acc			-- Initial value
 -> ((M N : intindex) -> int -> FIInt M -> int -> FIInt N -> acc -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked parallel in-place reduction, implemented in low-level.

blocked_1d_reduceip :
    (N : intindex)
 -> (acc : box)
 -> FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> ((M : intindex) -> int -> FIInt M -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked parallel loop
blocked_doall :
    (N : intindex)
 -> (a b : bare)
 -> FIInt N
 -> ((M : intindex) -> int -> FIInt M -> Store)
 -> Store;

-- Blocked 2D parallel loop
blocked_doall2 :
    (M N : intindex)
 -> (a b : bare)
 -> FIInt M
 -> FIInt N
 -> ((M N : intindex) -> int -> FIInt M -> int -> FIInt N -> Store)
 -> Store;

-- Blocked parallel loop over a PBTree
blocked_PBTree_doall :
    (a b : bare)
 -> PBTree a
 -> (int -> PBTree a -> Store)
 -> Store;
