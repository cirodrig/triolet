type ReprBox = \ (a : box). Repr (AsBare a);
type BoxIndex = \ (a : box). AsBox (index a);
type BoxOffset = \ (a : box). AsBox (offset a);
type BoxSlice = \ (a : box). AsBox (slice a);
type MessageWriter = OpaqueRef -> Store -> Store;
type MessageReader = cursor (Stored byte);

{- This data type definition should be caught as an error, because its
   memory layout depends on an existential type parameter.
data ErroneousType : bare
{
  erroneousType @(a : bare) (a);
};
-}

-- Built-in data types

-- data Stored (a : val) : bare
-- { stored (a); };

-- data Ref (a : box) : bare
-- { ref (a); };

-- A stuck reference is like a 'Ref' but doesn't get unwrapped by 'asbare'.
data StuckRef (a : box) : bare
{
  stuckRef (a);
};

data Boxed (a : bare) : box attribute(builtin)
{
  boxed (a);
};

con_boxed @(a : bare) (rep : Repr a) (x : Init a) -> Boxed a attribute(inline) =
  boxed @a (reprSizeAlign @a rep) (boxedinfo boxed @a rep) x;

-- A stuck box is like a 'boxed' but doesn't get unwrapped
-- by 'asbox'.
data StuckBox (a : bare) : box
{
  stuckBox (a);
};

con_stuckBox @(a : bare) (rep : Repr a) (i : Init a)
  -> StuckBox a attribute(inline) =

  stuckBox @a (reprSizeAlign @a rep) (boxedinfo stuckBox @a rep) i;

-- An unspecified data type
data Any : box
{
};

-- Type functions to convert between representations
type AsBox : bare -> box attribute(builtin);
type AsBare : box -> bare attribute(builtin);

-- Normal data types

data bool : val
  attribute(builtin)
{
  -- False becomes 0 after lowering
  False () attribute(builtin);
  -- True becomes 1 after lowering
  True () attribute(builtin);
};

data NoneType : val
  attribute(builtin)
{
  None ();
};

data Maybe (a : bare) : bare
{
  just (a);
  nothing ();
};

-- A value-form of 'Maybe'.  It must be used with statically known arguments.
data MaybeVal (a : val) : val
{
  justVal (a);
  nothingVal ();
};

data Either (a b : box) : box
{
  left (a);
  right (b);
};

con_left @(a b : box) (x : a) -> Either a b attribute(inline) =
  left @a @b (boxedinfo left @a @b) x;

con_right @(a b : box) (x : b) -> Either a b attribute(inline) =
  right @a @b (boxedinfo right @a @b) x;

-- A linked list
data llist (a : bare) : box
{
  cons (a, llist a);
  nil ();
};


con_cons @(a : bare) (rep : Repr a) (hd : Init a) (tl : llist a)
  -> llist a attribute(inline) =
  cons @a (reprSizeAlign @a rep) (boxedinfo cons @a rep) hd tl;


con_nil @(a : bare) (rep : Repr a) -> llist a attribute(inline) =
  nil @a (reprSizeAlign @a rep) (boxedinfo nil @a rep);


-- An integer interval, given by inclusive lower and exclusive upper bounds.
-- The upper bound must be greater or equal to the lower bound.
-- 'Nothing' means that the interval is unbounded at that end.
data Interval : val
{
  interval (MaybeVal int, MaybeVal int);
};

-- | A linear map, representing the function y = s*x + a.
--   The stride 's' must be nonzero.
--
--   Negative strides are valid; however, note that many functions expect
--   linear maps with positive strides.
data LinearMap : val
{
  linearMap (int, int);
};

-- A finite indexed integer 
data FIInt (n : intindex) : val
  attribute(builtin, singleton)
{
  fiInt (int) attribute(builtin);
};

-- An indexed singleton integer type.
-- Invariant: The type index gives up the integer value.
data IInt (n : intindex) : val
{
  -- Finite value
  iInt (FIInt n);

  -- Positive and negative infinity
  iPosInfty ();
  iNegInfty ();
};

-- An existential indexed singleton integer type.
-- We can convert int to this type.
data SomeIInt : val
{
  someIInt @(n : intindex) (FIInt n);
};

-- A user-specified slice.
--
-- If the third field is Nothing, the slice specifies a contiguous range.
-- Otherwise it specifies a triple.
data SliceObject : bare
{
  sliceObject
  (MaybeVal int, MaybeVal int, MaybeVal (MaybeVal int));
};

data Complex (a : bare) : bare
{
  complex (a, a);
};

data Tuple0 : bare
{
  tuple0 ();
};

data Tuple1 (a : bare) : bare
{
  tuple1 (a);
};


data Tuple2 (a b : bare) : bare
{
  tuple2 (a, b);
};

data Tuple3 (a b c : bare) : bare
{
  tuple3 (a, b, c);
};

data Tuple4 (a b c d : bare) : bare
{
  tuple4 (a, b, c, d);
};

-- Create a Tuple2 holding boxed references
pack_Tuple2_box @(a b : box) (x : a) (y : b)
  -> Boxed (Tuple2 (StuckRef a) (StuckRef b)) attribute(inline) =
  let rep_a = unboxedinfo StuckRef @a in
  let rep_b = unboxedinfo StuckRef @b in
  let rep_tuple = unboxedinfo Tuple2 @(StuckRef a) @(StuckRef b) rep_a rep_b in

  con_boxed @(Tuple2 (StuckRef a) (StuckRef b)) rep_tuple
  (tuple2 @(StuckRef a) @(StuckRef b)
   (reprSizeAlign @(StuckRef a) rep_a)
   (reprSizeAlign @(StuckRef b) rep_b) (stuckRef @a x) (stuckRef @b y));

-- Deconstruct a Tuple2 holding boxed references
unpack_Tuple2_box @(a b : box) (t : Boxed (Tuple2 (StuckRef a) (StuckRef b)))
  -> (a, b) attribute(inline) =
  let rep_a = unboxedinfo StuckRef @a in
  let rep_b = unboxedinfo StuckRef @b in
  let rep_tuple = unboxedinfo Tuple2 @(StuckRef a) @(StuckRef b) rep_a rep_b in

  case t of
    [reprSizeAlign @(Tuple2 (StuckRef a) (StuckRef b)) rep_tuple]
    boxed tyob ([reprSizeAlign @(StuckRef a) rep_a,
                 reprSizeAlign @(StuckRef b) rep_b]
                tuple2 (stuckRef x) (stuckRef y)).
  (x, y);

-- Create a Tuple3 holding boxed references
pack_Tuple3_box @(a b c : box) (x : a) (y : b) (z : c)
  -> Boxed (Tuple3 (StuckRef a) (StuckRef b) (StuckRef c)) attribute(inline) =
  let rep_a = unboxedinfo StuckRef @a in
  let rep_b = unboxedinfo StuckRef @b in
  let rep_c = unboxedinfo StuckRef @c in
  let rep_tuple = unboxedinfo Tuple3 @(StuckRef a) @(StuckRef b) @(StuckRef c)
                  rep_a rep_b rep_c in

  con_boxed @(Tuple3 (StuckRef a) (StuckRef b) (StuckRef c)) rep_tuple
  (tuple3 @(StuckRef a) @(StuckRef b) @(StuckRef c)
   (reprSizeAlign @(StuckRef a) rep_a)
   (reprSizeAlign @(StuckRef b) rep_b)
   (reprSizeAlign @(StuckRef c) rep_c)
   (stuckRef @a x) (stuckRef @b y) (stuckRef @c z));

-- Deconstruct a Tuple3 holding boxed references
unpack_Tuple3_box @(a b c : box)
  (t : Boxed (Tuple3 (StuckRef a) (StuckRef b) (StuckRef c)))
  -> (a, b, c) attribute(inline) =
  let rep_a = unboxedinfo StuckRef @a in
  let rep_b = unboxedinfo StuckRef @b in
  let rep_c = unboxedinfo StuckRef @c in
  let rep_tuple =
        unboxedinfo Tuple3 @(StuckRef a) @(StuckRef b) @(StuckRef c)
        rep_a rep_b rep_c in

  case t of
    [reprSizeAlign @(Tuple3 (StuckRef a) (StuckRef b) (StuckRef c)) rep_tuple]
    boxed tyob ([reprSizeAlign @(StuckRef a) rep_a,
                 reprSizeAlign @(StuckRef b) rep_b,
                 reprSizeAlign @(StuckRef c) rep_c]
                tuple3 (stuckRef x) (stuckRef y) (stuckRef z)).
  (x, y, z);

-- Create a Tuple4 holding boxed references
pack_Tuple4_box @(a b c d : box) (x : a) (y : b) (z : c) (w : d)
  -> Boxed (Tuple4 (StuckRef a) (StuckRef b) (StuckRef c) (StuckRef d))
  attribute(inline) =
  let rep_a = unboxedinfo StuckRef @a in
  let rep_b = unboxedinfo StuckRef @b in
  let rep_c = unboxedinfo StuckRef @c in
  let rep_d = unboxedinfo StuckRef @d in
  let rep_tuple = unboxedinfo Tuple4 @(StuckRef a) @(StuckRef b) @(StuckRef c) @(StuckRef d)
                  rep_a rep_b rep_c rep_d in

  con_boxed @(Tuple4 (StuckRef a) (StuckRef b) (StuckRef c) (StuckRef d)) rep_tuple
  (tuple4 @(StuckRef a) @(StuckRef b) @(StuckRef c) @(StuckRef d)
   (reprSizeAlign @(StuckRef a) rep_a)
   (reprSizeAlign @(StuckRef b) rep_b)
   (reprSizeAlign @(StuckRef c) rep_c)
   (reprSizeAlign @(StuckRef d) rep_d)
   (stuckRef @a x) (stuckRef @b y) (stuckRef @c z) (stuckRef @d w));

-- Deconstruct a Tuple3 holding boxed references
unpack_Tuple4_box @(a b c d : box)
  (t : Boxed (Tuple4 (StuckRef a) (StuckRef b) (StuckRef c) (StuckRef d)))
  -> (a, b, c, d) attribute(inline) =
  let rep_a = unboxedinfo StuckRef @a in
  let rep_b = unboxedinfo StuckRef @b in
  let rep_c = unboxedinfo StuckRef @c in
  let rep_d = unboxedinfo StuckRef @d in
  let rep_tuple =
        unboxedinfo Tuple4 @(StuckRef a) @(StuckRef b) @(StuckRef c) @(StuckRef d)
        rep_a rep_b rep_c rep_d in

  case t of
    [reprSizeAlign @(Tuple4 (StuckRef a) (StuckRef b) (StuckRef c) (StuckRef d)) rep_tuple]
    boxed tyob ([reprSizeAlign @(StuckRef a) rep_a,
                 reprSizeAlign @(StuckRef b) rep_b,
                 reprSizeAlign @(StuckRef c) rep_c,
                 reprSizeAlign @(StuckRef d) rep_d]
                tuple4 (stuckRef x) (stuckRef y) (stuckRef z) (stuckRef w)).
  (x, y, z, w);


-- Dictionaries

-- Size, alignment, and pointerfreeness
-- used by a data constructor/deconstructor
data SizeAlign (a : bare) : val
  attribute(builtin, singleton)
{
  sizeAlign (uint, uint, bool) attribute(builtin);
};

-- Size, alignment, and pointerfreeness
-- used by a data constructor/deconstructor
data SizeAlignVal (a : val) : val
  attribute(builtin, singleton)
{
  sizeAlignVal (uint, uint, bool) attribute(builtin);
};

-- Evidence that a bare type is or is not of the form 'Ref t'.
data IsRef (a : bare) : val attribute(builtin, singleton)
{
  notAReference (coerce @box (AsBox a) (Boxed a)) attribute(builtin);
  isAReference @(b : box) (coerce @bare a (Ref b)) attribute(builtin);
};

data Repr (a : bare) : box
  attribute(builtin, singleton)
{
  repr
  (SizeAlign a,       -- Size and alignment
   IsRef a,           -- Whether 'a' is an application of 'Ref'
   a -> MessageWriter, -- Serializer
   MessageReader -> (MessageReader, OutPtr a -> Store) -- Deserializer
  )
  attribute(builtin);
};


copy @(a : bare) (r : Repr a) (x : a) (y : OutPtr a)
  -> Store attribute(inline, inline_sequential) =
  case r of repr tyob sa isref put get.
  blockcopy @a sa x y;


-- Convert from boxed to bare
asbox @(a : bare) (r : Repr a) (x : Init a)
  -> AsBox a attribute(inline, inline_sequential) =
  case r of repr tyob sa isref put get.
  case isref of {
    notAReference co.
      -- Write into a new 'boxed' container
      let tyob = boxedinfo boxed @a r in
      coerce @(Boxed a) @(AsBox a) (boxed @a sa tyob x)

  ; isAReference @b co.
      -- Write to a temporary object, then read the temporary object
      let tyob = boxedinfo stuckBox @a r in
      case stuckBox @a sa tyob x of [sa] stuckBox tyob y.
      case coerce @a @(Ref b) y of ref z.
      coerce @b @(AsBox a) z
  };
  

-- Convert from bare to boxed
asbare @(a : bare) (r : Repr a) (x : AsBox a) (ret : OutPtr a) -> Store
  attribute(inline, inline_sequential) =

  case r of repr tyob sa isref put get.
  case isref of {
    notAReference co.
      -- Copy contents of boxed object
      case coerce @(AsBox a) @(Boxed a) x of [sa] boxed tyob y.
      blockcopy @a sa y ret

  ; isAReference @b co.
      -- Write into a new reference
      let ret2 : OutPtr (Ref b) = coerce @(OutPtr a) @(OutPtr (Ref b)) ret in
      ref @b (coerce @(AsBox a) @b x) ret2
  };


-- Primitive copy operation
blockcopy : forall a : bare. SizeAlign a -> a -> OutPtr a -> Store
  attribute(conlike, builtin);


-- A data type that can be read from or written to mutable storage
data Mutable (a : bare) : box
{
  mutable (
    -- Read mutable value
    OutPtr a -> Store -> (AsBox a, Store),

    -- Write mutable value
    AsBox a -> OutPtr a -> Store -> Store,

    -- Is the bitwise-zero value?
    AsBox a -> bool);
};


readMutable @(a : bare) (m : Mutable a) (p : OutPtr a) (s : Store)
  -> (AsBox a, Store)
  attribute(inline) =

  case m of mutable tyob read write isZero. read p s;


writeMutable @(a : bare) (m : Mutable a) (x : AsBox a) (p : OutPtr a) (s : Store)
  -> Store
  attribute(inline) =

  case m of mutable tyob read write isZero. write x p s;


isZeroMutable @(a : bare) (m : Mutable a) (x : AsBox a)
  -> bool attribute(inline) =

  case m of mutable tyob read write isZero. isZero x;


data ReprVal (a : val) : box
  attribute(builtin, singleton)
{
  reprVal
  (SizeAlignVal a,               -- Size and alignment
   Stored a -> MessageWriter, -- Serializer
   MessageReader -> (MessageReader, OutPtr (Stored a) -> Store) -- Deserializer
  )
  attribute(builtin);
};

-- Run-time type info for boxed objects.
-- Each instantiated data constructor is described by a TypeObject.
data TypeObject (a : box) : box
  attribute(builtin, singleton)
{
  typeObject
  (uint,                  -- Data constructor index
   a -> MessageWriter,    -- Serializer
   TypeObject a -> MessageReader -> (MessageReader, a) -- Deserializer
  ) 
  attribute(builtin);
};

-- Type information for all 'reprVal' objects
typeObject_reprVal @(a : val) -> TypeObject (ReprVal a) attribute(builtin, inline_never) =
  boxedinfo reprVal @a;

-- Type information for all 'repr' objects
typeObject_repr @(a : bare) -> TypeObject (Repr a) attribute(builtin, inline_never) =
  boxedinfo repr @a;

-- Type information for all 'typeObject' objects
-- This is a global constant, containing a reference to itself.
typeObject_typeObject @(a : box)
  -> TypeObject (TypeObject a) attribute(builtin, inline_never) =
  boxedinfo typeObject @a;

data EqDict (a : box) : box
  attribute(singleton)
{
  eqDict
  (a -> a -> Boxed (Stored bool), a -> a -> Boxed (Stored bool));
};

data OrdDict (a : box) : box
  attribute(singleton)
{
  ordDict
  (EqDict a,
   a -> a -> Boxed (Stored bool),   -- Less than
   a -> a -> Boxed (Stored bool),   -- Less or equal
   a -> a -> Boxed (Stored bool),   -- Greater than
   a -> a -> Boxed (Stored bool));  -- Greater or equal
};

data AdditiveDict (a : box) : box
  attribute(singleton)
{
  additiveDict
  (a -> a -> a,                 -- add
   a -> a -> a,                 -- subtract
   a -> a,                      -- negate
   a);                          -- zero
};

data MultiplicativeDict (a : box) : box
  attribute(singleton)
{
  multiplicativeDict
  (AdditiveDict a,
   a -> a -> a,                 -- multiply
   Boxed (Stored int) -> a,     -- from integer
   a);                          -- one
};

data RemainderDict (a : box) : box
  attribute(singleton)
{
  remainderDict
  (MultiplicativeDict a,
   a -> a -> Boxed (Stored int), -- floor division
   a -> a -> a);                 -- remainder
};

data FractionalDict (a : box) : box
  attribute(singleton)
{
  fractionalDict
  (MultiplicativeDict a, a -> a -> a); -- true division
};

data FloatingDict (a : box) : box
  attribute(singleton)
{
  floatingDict
  (Boxed (Stored float) -> a,   -- from float
   a -> a -> a,                 -- power
   a -> a,                      -- exp
   a -> a,                      -- log
   a -> a,                      -- sqrt
   a -> a,                      -- sin
   a -> a,                      -- cos
   a -> a,                      -- tan
   a);                          -- pi
};

data VectorDict (a : box) : box
  attribute(singleton)
{
  vectorDict
  (AdditiveDict a,
   a -> Boxed (Stored float) -> a,
   a -> Boxed (Stored float),
   a -> a -> Boxed (Stored float));
};

-- Cartesian domains, indexed by their index type.
--
-- The methods are:
-- 1. Get lower bound of finite range
-- 2. Get upper bound of finite range
-- 3. Get strides
-- 4. Create a finite range
-- 5. Displace a domain by an offset
-- 6. Scale a domain by a scale factor
-- 7. Scale a domain by an inverse scale factor
-- 8. Scale an index by a scale factor
-- 9. Scale an index by an inverse scale factor
-- 10.The largest domain
data CartesianDict (sh : box) : box
  attribute(singleton)
{
  cartesianDict
  (coerce @box (cartesianDomain (index sh)) sh,
   sh -> Boxed (Maybe (index sh)),
   sh -> Boxed (Maybe (index sh)),
   sh -> AsBox (index sh),
   AsBox (index sh) -> AsBox (index sh) -> sh,
   sh -> AsBox (index sh) -> sh,
   sh -> AsBox (index sh) -> sh,
   sh -> AsBox (index sh) -> sh,
   AsBox (index sh) -> AsBox (index sh) -> AsBox (index sh),
   AsBox (index sh) -> AsBox (index sh) -> AsBox (index sh),
   sh);
};

data TraversableDict (t : box -> box) : box
  attribute(singleton)
{
  traversableDict
  (forall a : box. ReprBox a -> t a -> Stream (shape t) a,
   forall a : box. ReprBox a -> Stream (shape t) a -> t a);
};

-- A subdomain is the result of splitting a domain. 
-- It consists of an offset and a domain.
data Subdomain (d : box) : box
{
  subdomain (BoxOffset d, d);
};

con_subdomain @(d : box) (off : BoxOffset d) (dom : d)
  -> Subdomain d attribute(inline) =

  subdomain @d (boxedinfo subdomain @d) off dom;


-- Operations related to data domains and traversals over them.
data ShapeDict (d : box) : box
  attribute(singleton)
{
  shapeDict
  (Repr (index d),
   Repr (offset d),
   Repr (slice d),
   -- noOffset
   BoxOffset d,
   -- addOffset
   BoxOffset d -> BoxOffset d -> BoxOffset d,
   -- appOffset
   BoxOffset d -> BoxIndex d -> BoxIndex d,
   -- intersect
   d -> d -> d,
   -- member
   BoxIndex d -> d -> bool,
   -- slice
   BoxSlice d -> d -> (BoxOffset d, d),
   -- split
   d -> MaybeVal (d, BoxOffset d, d),
   -- splitN
   int -> d -> view list_dim (Subdomain d),
   -- checkSubdomain (check whether second argument is subdomain of the first)
   -- This is not a complete check!  It only aids optimization.
   d -> d -> bool,
   -- peel
   forall a r : box.
   Repr (AsBare a) -> Boxed (Stored ParHint) ->
   (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
   view d (Stream list_dim a) -> r,
   -- flatten
   forall a : box. Repr (AsBare a) -> Stream d a -> Stream list_dim a,
   -- generate
   forall a : box.
   Repr (AsBare a) -> BoxOffset d -> d -> (BoxIndex d -> a) -> Stream d a,
   -- zipWith
   forall a b c : box.
   Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
   (a -> b -> c) -> Stream d a -> Stream d b -> Stream d c,
   -- fold
   forall a acc : box.
   Repr (AsBare a) -> Repr (AsBare acc) ->
   (a -> acc -> acc) -> Stream d a -> acc -> acc,
   -- imperative fold
   -- This is inside a data structure for compatibility with the frontend
   ImperativeFoldFunction d,
   -- foreach
   ImperativeForeachFunction d,
   -- foreach as a sequence
   forall a : box. d -> (BoxIndex d -> Seq a) -> Seq a
  );
};

data ImperativeFoldFunction (d : box) : val
{
  imperativeFoldFunction
  (forall a : box.
   Repr (AsBare a) -> (a -> Store -> Store) -> Stream d a -> Store -> Store);
};

data ImperativeForeachFunction (d : box) : val
{
  imperativeForeachFunction
  (d -> BoxOffset d -> (BoxIndex d -> Store -> Store) -> Store -> Store)
};

shRepOffset @(d : box) (sh : ShapeDict d) -> Repr (offset d) attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    rep_o;

shRepIndex @(d : box) (sh : ShapeDict d) -> Repr (index d) attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    rep_i;

shNoOffset @(d : box) (sh : ShapeDict d)
    -> BoxOffset d attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    noOff;

shAddOffset @(d : box) (sh : ShapeDict d)
    -> BoxOffset d -> BoxOffset d -> BoxOffset d attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    addOff;

shAppOffset @(d : box) (sh : ShapeDict d)
    -> BoxOffset d -> BoxIndex d -> BoxIndex d attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    appOff;

shIntersect @(d : box) (sh : ShapeDict d) -> d -> d -> d attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    intersect;

shMember @(d : box) (sh : ShapeDict d) -> BoxIndex d -> d -> bool attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    member;


shSlice @(d : box) (sh : ShapeDict d)
  -> BoxSlice d -> d -> (BoxOffset d, d) attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    sl;


shSplit @(d : box) (sh : ShapeDict d)
   -> d -> MaybeVal (d, BoxOffset d, d) attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    split;

shSplitN @(d : box) (sh : ShapeDict d)
   -> int -> d -> view list_dim (Subdomain d) attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    splitN;

shCheckSubdomain @(d : box) (sh : ShapeDict d)
   -> d -> d -> bool attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    checkSubdomain;

shPeel @(d : box) (sh : ShapeDict d)
   -> forall a r : box.
      ReprBox a -> Boxed (Stored ParHint) ->
      (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
      view d (Stream list_dim a) -> r attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    peel;

shFlatten @(d : box) (sh : ShapeDict d)
   -> forall a : box. ReprBox a -> Stream d a -> Stream list_dim a attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    flat;

shGenerate @(d : box) (sh : ShapeDict d)
   -> forall a : box.
      ReprBox a -> BoxOffset d -> d -> (BoxIndex d -> a) -> Stream d a attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    gen;

shZipWith @(d : box) (sh : ShapeDict d)
   -> forall a b c : box.
      ReprBox a -> ReprBox b -> ReprBox c ->
      (a -> b -> c) -> Stream d a -> Stream d b -> Stream d c attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    zipWith;

shFold @(d : box) (sh : ShapeDict d)
   -> forall a acc : box.
      ReprBox a -> ReprBox acc ->
      (a -> acc -> acc) -> Stream d a -> acc -> acc attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    fold;

shImpFold @(d : box) (sh : ShapeDict d)
   -> forall a : box.
      ReprBox a ->
      (a -> Store -> Store) -> Stream d a -> Store -> Store attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    case imp_fold of imperativeFoldFunction f.
    f;

shForeach @(d : box) (sh : ShapeDict d)
   -> d -> BoxOffset d -> (BoxIndex d -> Store -> Store) -> Store -> Store
   attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    case foreach of imperativeForeachFunction f.
    f;

shForeachSeq @(d : box) (sh : ShapeDict d)
   -> forall a : box. d -> (BoxIndex d -> Seq a) -> Seq a
   attribute(inline) =
    case sh of shapeDict tyob rep_i rep_o rep_s
               noOff addOff appOff intersect member sl split splitN
               checkSubdomain peel flat gen zipWith
               fold imp_fold foreach foreach_seq.
    foreach_seq;

-- The functor type class
data FunctorDict (t : box -> box) : box
  attribute(singleton)
{
  functorDict (forall a b : box.
               Repr (AsBare a) -> Repr (AsBare b) -> (a -> b) -> t a -> t b);
};


-- The type class for random-access containers.
-- Methods should not perform bounds checking.
data IndexableDict (t : box -> box) : box
  attribute(singleton)
{
  indexableDict
  (-- functor
   FunctorDict t,
   -- shape
   forall a: box. t a -> shape t,
   -- at
   forall a: box. ReprBox a -> t a -> BoxIndex (shape t) -> a,
   -- slice
   forall a: box.
   ReprBox a -> t a -> shape t -> BoxOffset (shape t) -> SomeIndexable (shape t) a,
   -- preserveHint
   forall a : box. t a -> t a
  );
};

ix_shape @(t : box -> box) (ix : IndexableDict t)
    -> forall a : box. t a -> shape t attribute(inline) =
    case ix of indexableDict tyob f sh at sl ph.
    sh;

ix_at @(t : box -> box) (ix : IndexableDict t)
    -> forall a : box. ReprBox a -> t a -> BoxIndex (shape t) -> a attribute(inline) =
    case ix of indexableDict tyob f sh at sl ph.
    at;

ix_slice @(t : box -> box) (ix : IndexableDict t)
    -> forall a : box. ReprBox a -> t a -> shape t -> BoxOffset (shape t)
       -> SomeIndexable (shape t) a attribute(inline) =
    case ix of indexableDict tyob f sh at sl ph.
    sl;

ix_preserveHint @(t : box -> box) (ix : IndexableDict t)
    -> forall a : box. t a -> t a attribute(inline) =
    case ix of indexableDict tyob f sh at sl ph.
    ph;

data SomeIndexable (d a : box) : box
{
  someIndexable @(t : box -> box)
  (coerce @box (shape t) d, IndexableDict t, t a)
};

con_someIndexable @(d a : box) @(t : box -> box)
  (co : coerce @box (shape t) d) 
  (dict : IndexableDict t)
  (x : t a)
  -> SomeIndexable d a attribute(inline) =

  someIndexable @d @a @t (boxedinfo someIndexable @d @a) co dict x;


-- Two indexable data structures zipped together
data Zip2Indexable (d c : box) : box
{
  zip2Indexable @(a b : box)
  (Repr (AsBare a), Repr (AsBare b),
   a -> b -> c, SomeIndexable d a, SomeIndexable d b);
};

con_zip2Indexable @(d c a b : box) (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b -> c) (x : SomeIndexable d a) (y : SomeIndexable d b)
  -> Zip2Indexable d c attribute(inline) =

  zip2Indexable @d @c @a @b (boxedinfo zip2Indexable @d @c) rep_a rep_b f x y;


-- The cartesian domain corresponding to an index type
type cartesianDomain : bare -> box;
type index : box -> bare;
type offset : box -> bare;
type slice : box -> bare;

-- A parallelism hint
data ParHint : val
{
  hintAny ();                   -- Unspecified parallelism
  hintSeq ();                   -- Sequential execution indicated
  hintLocalPar ();              -- Shared memory parallel execution indicated
  hintPar ();                   -- Distributed parallel execution indicated
};

-- The externally visible stream data type
data Stream (sh a : box) : box
{
  stream (ParHint, IStream sh a);
};

con_stream @(sh a : box) (h : ParHint) (s : IStream sh a)
  -> Stream sh a attribute(inline) =
  stream @sh @a (boxedinfo stream @sh @a) h s;


-- Discard the hints on a stream
unStream @(sh a : box) (s : Stream sh a) -> IStream sh a attribute(inline) =
  case s of stream tyob h i_s. i_s;


-- The internal stream data type
data IStream (sh a : box) : box
{
  -- As a sequence
  seqStream (coerce @box sh list_dim, Seq a);

  -- As an indexed collection of streams
  nestedIxStream @(sh2 : box)
  (coerce @box sh list_dim, ShapeDict sh2, RStream sh2 (Stream list_dim a));

  -- As a sequence of streams
  nestedSeqStream (coerce @box sh list_dim, Seq (Stream list_dim a));

  -- As a random-access object
  ixStream (RStream sh a);
};

con_seqStream @(a : box) (sq : Seq a) -> IStream list_dim a attribute(inline) =
  seqStream @list_dim @a (boxedinfo seqStream @list_dim @a)
  (idCoercion @list_dim) sq;

con_nestedIxStream @(a sh : box)
  (d : ShapeDict sh) (s : RStream sh (Stream list_dim a))
  -> IStream list_dim a attribute(inline) =
  nestedIxStream @list_dim @a @sh (boxedinfo nestedIxStream @list_dim @a)
  (idCoercion @list_dim) d s;

con_nestedSeqStream @(a : box) (s : Seq (Stream list_dim a))
  -> IStream list_dim a attribute(inline) =
  nestedSeqStream @list_dim @a (boxedinfo nestedSeqStream @list_dim @a)
  (idCoercion @list_dim) s;

con_ixStream @(sh a : box) (s : RStream sh a)
  -> IStream sh a attribute(inline) =
  ixStream @sh @a (boxedinfo ixStream @sh @a) s;

-- A random-access stream.
-- This is very similar to the encoding of the co-Yoneda lemma
-- used for instance in Haskell.
data RStream (sh a : box) : box
{
  rStream @(b : box) (Repr (AsBare b), b -> a, SomeIndexable sh b);
};

con_rStream @(sh a b : box)
  (rep : ReprBox b) (f : b -> a) (v : SomeIndexable sh b)
  -> (RStream sh a) attribute(inline) =
  rStream @sh @a @b (boxedinfo rStream @sh @a) rep f v;

-------------------------------------------------------------------------------
-- Imperative computation support

emptyStore : Store;

seqStore : Store -> Store -> Store;

Mutable_int : Mutable (Stored int) =
  mutable @(Stored int) (boxedinfo mutable @(Stored int))
  read_int_helper write_int_helper isZero_int;

read_int_helper (p : OutPtr (Stored int)) (s : Store)
  -> (Boxed (Stored int), Store) =
  case read_int p s of (x, s2). (boxIntValue x, s2);

read_int :  OutPtr (Stored int) -> Store -> (int, Store);

write_int_helper (x : Boxed (Stored int)) (p : OutPtr (Stored int)) (s : Store)
  -> Store =
  write_int (unboxIntValue x) p s;

write_int :  int -> OutPtr (Stored int) -> Store -> Store;

isZero_int (bx : Boxed (Stored int)) -> bool =
  unboxIntValue bx ==# 0;


Mutable_int64 : Mutable (Stored int64) =
  mutable @(Stored int64) (boxedinfo mutable @(Stored int64))
  read_int64_helper write_int64_helper isZero_int64;

read_int64_helper (p : OutPtr (Stored int64)) (s : Store)
  -> (Boxed (Stored int64), Store) =
  case read_int64 p s of (x, s2). (boxInt64Value x, s2);

read_int64 :  OutPtr (Stored int64) -> Store -> (int64, Store);

write_int64_helper (x : Boxed (Stored int64)) (p : OutPtr (Stored int64)) (s : Store)
  -> Store =
  write_int64 (unboxInt64Value x) p s;

write_int64 :  int64 -> OutPtr (Stored int64) -> Store -> Store;

isZero_int64 (bx : Boxed (Stored int64)) -> bool =
  eqI64 (unboxInt64Value bx) (intToInt64 0);


Mutable_float : Mutable (Stored float) =
  mutable @(Stored float) (boxedinfo mutable @(Stored float))
  read_float_helper write_float_helper isZero_float;

read_float_helper (p : OutPtr (Stored float)) (s : Store)
  -> (Boxed (Stored float), Store) =
  case read_float p s of (x, s2). (boxFloatValue x, s2);

read_float :  OutPtr (Stored float) -> Store -> (float, Store);

write_float_helper (x : Boxed (Stored float)) (p : OutPtr (Stored float)) (s : Store)
  -> Store =
  write_float (unboxFloatValue x) p s;

write_float :  float -> OutPtr (Stored float) -> Store -> Store;

isZero_float (bx : Boxed (Stored float)) -> bool =
  eqF (unboxFloatValue bx) 0.0;


-- A 'Collector k v r' creates a return value from a collection of
-- key-value pairs
data Collector (k v r : box) : box
{
  collector @(acc : bare) (
    Repr acc,

    -- Initialize
    OutPtr acc -> Store,

    -- Read mutable value at index
    k -> OutPtr acc -> Store -> (v, Store),

    -- Write mutable value at index
    k -> v -> OutPtr acc -> Store -> Store,

    -- Update mutable value
    v -> v -> v,

    -- Combine two accumulators
    acc -> acc -> OutPtr acc -> Store,

    -- Combine residual accumulators from a parallel task.
    -- Scalars are processed sequentially.
    Stream list_dim (Boxed (Stored (cursor acc))) -> OutPtr acc -> Store,

    -- Create result
    CollectorFinalize acc r
    );
};

data CollectorFinalize (acc : bare) (r : box) : box {
  collectorFinalizeInPlace (coerce @box (AsBox acc) r);
  collectorFinalize (Init acc -> r, acc -> r);
};

con_collectorFinalizeInPlace @(acc : bare) @(r : box)
  (co : coerce @box (AsBox acc) r)
  -> CollectorFinalize acc r attribute(inline) =

  collectorFinalizeInPlace @acc @r
  (boxedinfo collectorFinalizeInPlace @acc @r) co;

con_collectorFinalize @(acc : bare) @(r : box)
  (f : Init acc -> r) (g : acc -> r)
  -> CollectorFinalize acc r attribute(inline) =

  collectorFinalize @acc @r
  (boxedinfo collectorFinalize @acc @r) f g;


-- An opaque reference to mutable data.
data OpaqueRef : box
  attribute(abstract, nonalgebraic, builtin)
{};

-- The state of a list-building computation.
-- This is used when constructing a list from a sequence.
data ListBuilder (a : bare) : val
{
  listBuilder (int, int, OpaqueRef);
};

-- Primitive function for building a list by appending to it.
-- Defined in low-level.
append_build_list : forall a : bare.
                    Repr a
                 -> ((Init a -> ListBuilder a -> ListBuilder a) ->
                     ListBuilder a -> ListBuilder a)
                 -> Init (list a);

-- The finalizer of an in-place update operation.
-- A finalizer performs a one-time computation to convert the updatable
-- data structure to a read-only data structure.  In some cases, a finalizer
-- is not required, in which case the update is really performed in-place.
data UpdateInPlaceFinalizer (mut_t immut_t : bare) : box
{
  -- The data can be mutated in place if the mutable and immutable data formats
  -- are the same
  mutateInPlace (coerce @bare mut_t immut_t);

  -- Data should be mutated out-of-place, then written to the output
  mutateAndCopy (mut_t -> Init immut_t);
};

-- A scatter-reduce operation.  Reductions are performed with a combination of
-- sequential in-place updates and parallel reduction.
--
-- The type parameters and existential types are:
-- * a return type 'r', which is the result type of a scatter reduction
-- * an index type 'i', which is the type of inputs to a scatter reduction
-- * a state type 's', which is the memory representation that's modified by
--   in-place upate
-- * a scalar type 'a', which is the data type that's loaded and stored
--   (or atomically updated) during an in-place update
--
-- The code is organized such that only function types are parameterized on
-- 'a'.  There are no values of type 'a', because values can only have ground
-- types.  By organizing functions this way, we can generally ensure that the
-- low-level API does not need to perform memory allocation.
--
-- Token passing is used to represent dependences during the in-place part of
-- the reduction.
data Scatter (r i : bare) : box
{
  mk_scatter @(s : bare) @(iniF updF : box)
  (Repr s,
   iniF -> OutPtr s -> Store,                -- Initializer
   updF -> i -> Store -> OutPtr s -> Store, -- Updater
   s -> s -> Init s,                          -- Combining function
   UpdateInPlaceFinalizer s r,                -- Final value constructor
   i -> updF,                                 -- Update function
   iniF                                       -- Initial value
  );
};


-- These functions are implemented in low-level code.
intUpdateInPlace_initializer : (NoneType -> int)
                            -> OutPtr (Stored int)
                            -> Store;
intUpdateInPlace_updater : (int -> int) -> Store
                        -> OutPtr (Stored int)
                        -> Store;
floatUpdateInPlace_initializer : (NoneType -> float)
                              -> OutPtr (Stored float)
                              -> Store;
floatUpdateInPlace_updater : (float -> float) -> Store
                          -> OutPtr (Stored float)
                          -> Store;
boolUpdateInPlace_initializer : (NoneType -> bool)
                              -> OutPtr (Stored bool)
                              -> Store;
boolUpdateInPlace_updater : (bool -> bool) -> Store
                          -> OutPtr (Stored bool)
                          -> Store;

-- TEMPORARILY COMMENTED OUT FOR DEVELOPMENT
{-

-- Helper functions for scatter reductions

intUpdateInPlace_int_coercion : coerce @bare (Stored int) (Stored int) =
  idBareCoercion @(Stored int);


intUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored int) (Stored int) =
  mutateInPlace @(Stored int) @(Stored int)
  intUpdateInPlace_int_coercion;


intUpdateInPlace_combiner (x : Stored int) (y : Stored int)
  (ret : OutPtr (Stored int))
  -> Store =
  case x of stored ux.
  case y of stored uy.
  stored @int (ux +# uy) ret;


floatUpdateInPlace_float_coercion : coerce @bare (Stored float) (Stored float) =
  idBareCoercion @(Stored float);


floatUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored float) (Stored float) =
  mutateInPlace @(Stored float) @(Stored float)
  floatUpdateInPlace_float_coercion;


floatUpdateInPlace_combiner (x : Stored float) (y : Stored float)
  (ret : OutPtr (Stored float))
  -> Store =
  case x of stored ux.
  case y of stored uy.
  stored @float (addF ux uy) ret;


boolUpdateInPlace_bool_coercion : coerce @bare (Stored bool) (Stored bool) =
  idBareCoercion @(Stored bool);


boolUpdateInPlace_finalizer : UpdateInPlaceFinalizer (Stored bool) (Stored bool) =
  mutateInPlace @(Stored bool) @(Stored bool)
  boolUpdateInPlace_bool_coercion;

-- Scatter reduction algorithms

intScatter @(a : box) (rep : Repr (AsBare a))
  (f : a -> Boxed (Stored int) -> Boxed (Stored int))
  (g : Boxed (Stored int) -> Boxed (Stored int) -> Boxed (Stored int))
  (init : Boxed (Stored int))
  -> Scatter (Stored int) (AsBare a)
  attribute(inline) =
  let type Sint = Stored int in

  let u_init = unboxIntValue init in

  mk_scatter @Sint @(AsBare a) @Sint @(NoneType -> int) @(int -> int)
  repr_int
  intUpdateInPlace_initializer
  (\ (modify : int -> int) (ix : AsBare a)
     (tok_in : EffTok) (ret : OutPtr Sint) -> EffTok.
     intUpdateInPlace_updater modify tok_in ret)
  (\ (x : Sint) (y : Sint) (r : OutPtr Sint) -> Store.
    case x of stored ux.
    case y of stored uy.
    let z = unboxIntValue (g (boxIntValue ux) (boxIntValue uy)) in
    stored @int z r)
  intUpdateInPlace_finalizer
  (\ (x : AsBare a) (y : int) -> int.
     unboxIntValue (f (bareToBox @(AsBare a) rep x) (boxIntValue y)))
  (\ (dummy : NoneType) -> int. u_init);


floatScatter @(a : box) (rep : Repr (AsBare a))
  (f : a -> Boxed (Stored float) -> Boxed (Stored float))
  (g : Boxed (Stored float) -> Boxed (Stored float) -> Boxed (Stored float))
  (init : Boxed (Stored float))
  -> Scatter (Stored float) (AsBare a)
  attribute(inline) =
  let type Sfloat = Stored float in
  let u_init = unboxFloatValue init in

  mk_scatter @Sfloat @(AsBare a) @Sfloat @(NoneType -> float) @(float -> float)
  repr_float
  floatUpdateInPlace_initializer
  (\ (modify : float -> float) (ix : AsBare a)
     (tok_in : EffTok) (ret : OutPtr Sfloat) -> EffTok.
     floatUpdateInPlace_updater modify tok_in ret)
  (\ (x : Sfloat) (y : Sfloat) (r : OutPtr Sfloat) -> Store.
    case x of stored ux.
    case y of stored uy.
    let z = unboxFloatValue (g (boxFloatValue ux) (boxFloatValue uy)) in
    stored @float z r)
  floatUpdateInPlace_finalizer
  (\ (x : AsBare a) (y : float) -> float.
     unboxFloatValue (f (bareToBox @(AsBare a) rep x) (boxFloatValue y)))
  (\ (dummy : NoneType) -> float. u_init);


boolScatter @(a : box) (rep : Repr (AsBare a))
  (f : a -> Boxed (Stored bool) -> Boxed (Stored bool))
  (g : Boxed (Stored bool) -> Boxed (Stored bool) -> Boxed (Stored bool))
  (init : Boxed (Stored bool))
  -> Scatter (Stored bool) (AsBare a)
  attribute(inline) =
  let type Sbool = Stored bool in
  let u_init = unboxBoolValue init in

  mk_scatter @Sbool @(AsBare a) @Sbool @(NoneType -> bool) @(bool -> bool)
  repr_bool
  boolUpdateInPlace_initializer
  (\ (modify : bool -> bool) (ix : AsBare a)
     (tok_in : EffTok) (ret : OutPtr Sbool) -> EffTok.
     boolUpdateInPlace_updater modify tok_in ret)
  (\ (x : Sbool) (y : Sbool) (r : OutPtr (Sbool)) -> Store.
    case x of stored ux.
    case y of stored uy.
    let z = unboxBoolValue (g (boxBoolValue ux) (boxBoolValue uy)) in
    stored @bool z r)
  boolUpdateInPlace_finalizer
  (\ (x : AsBare a) (y : bool) -> bool.
     unboxBoolValue (f (bareToBox @(AsBare a) rep x) (boxBoolValue y)))
  (\ (dummy : NoneType) -> bool. u_init);


intSumScatter : Scatter (Stored int) (Stored int) =
  let type Sint = Stored int in
  mk_scatter @Sint @Sint @Sint @(NoneType -> int) @(int -> int)
  repr_int
  intUpdateInPlace_initializer
  intSumScatter_updater
  intUpdateInPlace_combiner
  intUpdateInPlace_finalizer
  intSumScatter_make_update
  intSumScatter_make_init;


intSumScatter_updater (modify : int -> int) (ix : Stored int)
  (tok_in : EffTok) (ret : OutPtr (Stored int)) -> EffTok =
  intUpdateInPlace_updater modify tok_in ret;


intSumScatter_make_update (i : Stored int) -> int -> int =
  case i of stored ui.
  (\ (n : int) -> int. ui +# n);

-}

intSumScatter_make_init (dummy : NoneType) -> int = 0;

{-

floatSumScatter : Scatter (Stored float) (Stored float) =
  let type Sfloat = Stored float in
  mk_scatter @Sfloat @Sfloat @Sfloat @(NoneType -> float) @(float -> float)
  repr_float
  floatUpdateInPlace_initializer
  floatSumScatter_updater
  floatUpdateInPlace_combiner
  floatUpdateInPlace_finalizer
  floatSumScatter_make_update
  floatSumScatter_make_init;


floatSumScatter_updater
  (modify : float -> float) (ix : Stored float)
  (tok_in : EffTok) (ret : OutPtr (Stored float)) -> EffTok =
  floatUpdateInPlace_updater modify tok_in ret;


floatSumScatter_make_update (i : Stored float) -> float -> float =
  case i of stored ui.
  (\ (n : float) -> float. addF ui n);

-}

floatSumScatter_make_init (dummy : NoneType) -> float = 0.0;

{-

countingScatter : Scatter (Stored int) (Stored NoneType) =

  mk_scatter @(Stored int) @(Stored NoneType) @(Stored int)
             @(NoneType -> int) @(int -> int)
  repr_int
  intUpdateInPlace_initializer
  countingScatter_updater
  intUpdateInPlace_combiner
  intUpdateInPlace_finalizer
  countingScatter_make_update
  countingScatter_make_init;


countingScatter_updater (modify : int -> int) (ix : Stored NoneType)
  (tok_in : EffTok) (ret : OutPtr (Stored int)) -> EffTok =
  intUpdateInPlace_updater modify tok_in ret;


countingScatter_make_update (i : Stored NoneType) -> int -> int =
  (\ (n : int) -> int. n +# 1);

-}

countingScatter_make_init (dummy : NoneType) -> int = 0;

{-

boxedScatter @(a b : box) (rep : Repr (AsBare b))
  (f : b -> a -> a)
  (g : a -> a -> a)
  (init : a)
  -> Scatter (StuckRef a) (AsBare b) =
  mk_scatter @(StuckRef a) @(AsBare b) @(StuckRef a) @(NoneType -> a) @(a -> a)
  (unboxedinfo StuckRef @a)
  -- Initializer
  (\ (init_f : NoneType -> a) (p : OutPtr (StuckRef a)) -> EffTok.
     toEffTok @(StuckRef a) (stuckRef @a (init_f None) p))
  -- Updater
  (\ (modify : a -> a) (ix : AsBare b) (eff_in : EffTok)
     (p : OutPtr (StuckRef a)) -> EffTok.
     boxedScatter_updater @a modify eff_in p)
  (\ (x : StuckRef a) (y : StuckRef a) (ret : OutPtr (StuckRef a))
     -> Store.
     case x of stuckRef ux.
     case y of stuckRef uy.
     stuckRef @a (g ux uy) ret)
  (mutateInPlace @(StuckRef a) @(StuckRef a) (idBareCoercion @(StuckRef a)))
  (\ (x : AsBare b) (old : a) -> a. f (bareToBox @(AsBare b) rep x) old)
  (\ (dummy : NoneType) -> a. init);

-}

boxedScatter_updater : forall a : box.
                       (a -> a)
                    -> Store
                    -> OutPtr (StuckRef a)
                    -> Store;

{-

appendScatter @(box_a : box) (rep : Repr (AsBare box_a))
  -> Scatter (list (AsBare box_a)) (AsBare box_a) =
  let type a = AsBare box_a in
  mk_scatter @(list a) @a @(append_list a)
             @(NoneType -> NoneType)
             @(OutPtr a -> Store)
  (repr_append_list @a rep)
  (appendScatter_initializer @a (reprSizeAlign @a rep))
  (appendScatter_updater @a rep)
  (appendScatter_concatenate @a rep)
  (mutateAndCopy @(append_list a) @(list a)
   (\ (x : append_list a) (ret : OutPtr (list a)) -> Store.

      -- Create a copy of the list that contains no unused array elements.

      -- Inspect the old value
      case x of
        make_append_list @(M : intindex)
        (ls_count : FIInt M) (real_length : int) (ls_data : StuckBox (arr M a)).
      case ls_data of stuckBox (ls_arr : arr M a).

      -- Construct the new list; copy from the old list
      case defineIntIndex real_length of
        someIInt @(N : intindex) (count : FIInt N).
      make_list @a @N count
      (stuckBox @(arr N a)
       (\ (ret : OutPtr (arr N a)) -> Store.
          doall @N @a @a count
          (\ (i : int) -> Store.
             copy @a rep
             (subscript @M @a (reprSizeAlign @a rep) ls_arr i)
             (subscript_out @N @a (reprSizeAlign @a rep) ret i))))
      ret))
  (copy @a rep)
  (\ (dummy : NoneType) -> NoneType. dummy);


appendScatter_updater @(a : bare)
  (rep : Repr a)
  (writer : OutPtr a -> Store)
  (arg : a)
  (tok_in : EffTok)
  (update_list : OutPtr (append_list a))
  -> EffTok =
  appendScatter_update_real @a
  (reprSizeAlign @a rep) writer tok_in update_list;


appendScatter_concatenate @(a : bare)
  (rep : Repr a)
  (l1 : append_list a)
  (l2 : append_list a)
  (ret : OutPtr (append_list a))
  -> Store
  attribute(inline) =

  case l1 of make_append_list @N (s1 : FIInt N) (n1 : int) (stuckBox arr1).
  case l2 of make_append_list @M (s2 : FIInt M) (n2 : int) (stuckBox arr2).

  -- Concatenate both lists
  -- TODO: This function may be called repeatedly, but we shouldn't copy
  -- more than once.  Avoid excess copying by building a cord, then
  -- flattening the cord later.
  case defineIntIndex n1 of someIInt @(Np : intindex) (count1 : FIInt Np).
  case defineIntIndex n2 of someIInt @(Mp : intindex) (count2 : FIInt Mp).

  case defineIntIndex (n1 +# n2) of someIInt @(P : intindex) (s3 : FIInt P).
  case s3 of fiInt (n3 : int).

  let sizealign : SizeAlign a = reprSizeAlign @a rep in

  make_append_list @a @P s3 n3
  (stuckBox @(arr P a)
   (\ (ret : OutPtr (arr P a)) -> Store.

      -- Copy data from l1 and l2 into the output
      seqStore
       (sequential_doall @Np count1
         (\ (i : int) -> Store.
            -- Copy l1 into the beginning of the list
            copy @a rep
            (subscript @N @a sizealign arr1 i)
            (subscript_out @P @a sizealign ret i)))
       (sequential_doall @Mp count2
         (\ (i : int) -> Store.
            -- Copy l2 into the end of the list
            copy @a rep
            (subscript @M @a sizealign arr2 i)
            (subscript_out @P @a sizealign ret (i +# n1)))))))
  ret;

-}

appendScatter_initializer : forall a : bare.
                            SizeAlign a -> (NoneType -> NoneType)
                         -> OutPtr (append_list a) -> Store;

appendScatter_update_real : forall a : bare.
                        SizeAlign a
                     -> (OutPtr a -> Store)
                     -> Store
                     -> OutPtr (append_list a)
                     -> Store;

{-

arrScatter @(N : intindex) @(e i : bare)
  (repr_i : Repr i)
  (repr_e : Repr e)
  (count : FIInt N)
  (reduction_op : Scatter e i)
  -> Scatter (arr N e) (Tuple2 (Stored int) i)
  attribute(inline, inline_final) =

  case reduction_op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s e)
    (update_f : i -> updF)
    (init_f : iniF).

  let type arr_t = arr N e in
  let type i2 = Tuple2 (Stored int) i in

  case count of fiInt (u_count : int).

  case repr_s of
    repr
    (sa_s : SizeAlign s)
    (copy_s : s -> Init s)
    (to_boxed_s : Init s -> AsBox s)
    (to_bare_s : AsBox s -> Init s)
    (pointerless_s : bool).

  mk_scatter @arr_t @i2 @(arr N s) @iniF @updF
  (repr_arr @N @s count repr_s)
  (\ (f : iniF) (p : OutPtr (arr N s)) -> EffTok.
     -- Initialize all array elements
     toEffTok @(arr N s)
     (arr1D_build @N @s repr_s count
      (\ (i : int) (ret : OutPtr s) -> Store.
         fromEffTok @s (initializer f ret)) p))
  (\ (f : updF) (ix : i2) (in_tok : EffTok) (p : OutPtr (arr N s))
     -> EffTok.
     case ix of tuple2 (arr_index : Stored int) (elt_index : i).
     case arr_index of stored (u_arr_index : int).

     -- If index is out of bounds, do nothing
     if or (u_arr_index <# 0) (u_arr_index >=# u_count)
     then in_tok
     else updater f elt_index in_tok
          (subscript_out @N @s sa_s p u_arr_index))

  -- Combine arrays elementwise
  (\ (x : arr N s) (y : arr N s) (ret : OutPtr (arr N s)) -> Store.
     arr1D_build @N @s repr_s count
     (\ (i : int) (local_ret : OutPtr s) -> Store.
        combiner (subscript @N @s sa_s x i) (subscript @N @s sa_s y i)
        local_ret)
     ret)

  -- Update in place if array elements can be updated in place
  -- Otherwise, make a copy
  (case finalizer of {
     mutateInPlace (co : coerce @bare s e).
       mutateInPlace @(arr N s) @(arr N e)
       (unsafeMakeBareCoercion @(arr N s) @(arr N e))
   ; mutateAndCopy (f : s -> Init e).
       mutateAndCopy @(arr N s) @(arr N e)
       (\ (accumulator : arr N s) (ret : OutPtr (arr N e))
          -> Store.
          arr1D_build @N @e repr_e count
          (\ (i : int) (ret : OutPtr e) -> Store.
             f (subscript @N @s sa_s accumulator i) ret)
          ret)
   })
   (\ (ix : i2) -> updF.
      case ix of tuple2 (arr_index : Stored int) (elt_index : i).
      update_f elt_index)
   init_f;


comapScatterIndex @(r i1 i2 : bare)
  (repr_i1 : Repr i1)
  (repr_i2 : Repr i2)
  (repr_r : Repr r)
  (transform : i2 -> Init i1)
  (sr : Scatter r i1)
  -> Scatter r i2
  attribute(inline, inline_final) =

  case sr of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i1 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (update_f : i1 -> updF)
    (init_f : iniF).

  letfun
    updater2 (f : updF) (ix : i2) (tok_in : EffTok) (out_ptr : OutPtr s)
      -> EffTok =
      case boxed @i1 (transform ix) of boxed index1.
      updater f index1 tok_in out_ptr in

  letfun
    update_f2 (ix : i2) -> updF =
      case boxed @i1 (transform ix) of boxed index1.
      update_f index1 in

  mk_scatter @r @i2 @s @iniF @updF repr_s initializer
  updater2 combiner finalizer update_f2 init_f;


blistScatter @(box_a i : box)
  (repr_i : Repr (AsBare i))
  (repr_a : Repr (AsBare box_a))
  (dom : list_dim)
  (reduction_op : Scatter (StuckRef box_a) (AsBare i))
  -> Scatter (blist (AsBare box_a)) (Tuple2 (Stored int) (AsBare i)) =
  let type a = AsBare box_a in
  let type boxed_a = StuckRef box_a in
  let type i2 = Tuple2 (Stored int) (AsBare i) in

  -- Use listScatter
  case listScatter @(AsBox boxed_a) @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (list boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with blist
  let repr_list_a : Repr (list boxed_a) = repr_list @boxed_a in

  let blist_finalizer : UpdateInPlaceFinalizer s (blist a) =
        case finalizer of {
          mutateInPlace
          (co : coerce @bare s (list boxed_a)).
            mutateAndCopy @s @(blist a)
            (\ (x : s) -> Init (blist a).
               make_blist @a
               (copy @(list boxed_a) repr_list_a
                (coerce @s @(list boxed_a) x)))
        ; mutateAndCopy (f : s -> Init (list boxed_a)).
            mutateAndCopy @s @(blist a)
            (\ (x : s) -> Init (blist a). make_blist @a (f x))
        } in

  mk_scatter @(blist a) @i2 @s @iniF @updF repr_s initializer updater combiner
  blist_finalizer make_updater make_init;


listScatter @(box_e i : box)
  (repr_i : Repr (AsBare i))
  (repr_e : Repr (AsBare box_e))
  (dom : list_dim)
  (reduction_op : Scatter (AsBare box_e) (AsBare i))
  -> Scatter (list (AsBare box_e)) (Tuple2 (Stored int) (AsBare i)) =

  let type e = AsBare box_e in
  let type i2 = Tuple2 (Stored int) (AsBare i) in
  let type ret_type = Scatter (list e) i2 in

  case dom of mk_list_dim (mlist_size : MaybeVal int).
  case mlist_size of {
    justVal list_size.
      case defineIntIndex list_size of
        someIInt @(N : intindex) (count : FIInt N).

      -- Create a plain array scatter reducer.
      case arrScatter @N @e @(AsBare i) repr_i repr_e count reduction_op of
        mk_scatter @(s : bare) @(iniF : box) @(updF : box)
        (repr_s : Repr s)
        (initializer : iniF -> OutPtr s -> EffTok)
        (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
        (combiner : s -> s -> Init s)
        (finalizer : UpdateInPlaceFinalizer s (arr N e))
        (make_updater : i2 -> updF)
        (make_init : iniF).

      -- Create a scatter reducer that wraps it in a list
      let list_finalizer : UpdateInPlaceFinalizer s (list e) =
            mutateAndCopy @s @(list e)
            (\ (accumulator : s) (ret : OutPtr (list e)) -> Store.
               make_list @e @N count
               (stuckBox @(arr N e)
                (case finalizer of {
                   mutateInPlace (co : coerce @bare s (arr N e)).
                     copy @(arr N e) (repr_arr @N @e count repr_e)
                     (coerce @s @(arr N e) accumulator)
                 ; mutateAndCopy (f : s -> Init (arr N e)).
                     f accumulator
                 }))
               ret) in

      mk_scatter @(list e) @i2 @s @iniF @updF
      repr_s
      initializer
      updater
      combiner
      list_finalizer
      make_updater
      make_init

  ; nothingVal.
      except @(Scatter (list e) i2)
  };


array1Scatter @(box_e i : box)
  (repr_i : Repr (AsBare i))
  (repr_e : Repr (AsBare box_e))
  (dom : dim1)
  (reduction_op : Scatter (AsBare box_e) (AsBare i))
  -> Scatter (array1 (AsBare box_e)) (Tuple2 (Stored int) (AsBare i)) =

  let type e = AsBare box_e in
  let type i2 = Tuple2 (Stored int) (AsBare i) in
  let type ret_type = Scatter (array1 e) i2 in

  -- Compute array size
  case dim1ToArraySize dom of arraySize @(N : intindex) lb stride count.

  -- Create a plain array scatter reducer.
  case arrScatter @N @e @(AsBare i) repr_i repr_e count reduction_op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (arr N e))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Create a scatter reducer that wraps it in an array
  let array_finalizer : UpdateInPlaceFinalizer s (array1 e) =
        mutateAndCopy @s @(array1 e)
        (\ (accumulator : s) (ret : OutPtr (array1 e))
           -> Store.
           mk_array1 @e @N lb stride count
           (stuckBox @(arr N e)
            (case finalizer of {
               mutateInPlace (co : coerce @bare s (arr N e)).
                 copy @(arr N e) (repr_arr @N @e count repr_e)
                 (coerce @s @(arr N e) accumulator)
             ; mutateAndCopy (f : s -> Init (arr N e)).
                 f accumulator
             }))
           ret) in

  -- Transform dim1 indices to linear indices
  letfun
    linearized_updater
      (f : updF) (ix : i2) (tok_in : EffTok) (ret : OutPtr s)
      -> EffTok =
      case ix of tuple2 (arr_ix : Stored int) (val : AsBare i).
      case arr_ix of stored (u_arr_ix : int).

      -- Drop values whose indices are out of bounds due to alignment
      let zeroed_ix : int = u_arr_ix -# lb in
      if zeroed_ix %# stride /=# 0 then tok_in else
      let linearized_ix : int = zeroed_ix //# stride in
      case boxed @i2 (tuple2 @(Stored int) @(AsBare i)
                      (stored @int linearized_ix) (copy @(AsBare i) repr_i val)) of
        boxed new_ix.
      updater f new_ix tok_in ret
  in

  mk_scatter @(array1 e) @i2 @s @iniF @updF
   repr_s
   initializer
   linearized_updater
   combiner
   array_finalizer
   make_updater
   make_init;


barray1Scatter @(box_a i : box)
  (repr_i : Repr (AsBare i))
  (repr_a : Repr (AsBare box_a))
  (dom : dim1)
  (reduction_op : Scatter (StuckRef box_a) (AsBare i))
  -> Scatter (barray1 (AsBare box_a)) (Tuple2 (Stored int) (AsBare i)) =
  let type a = AsBare box_a in
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (Stored int) (AsBare i) in

  -- Use array1Scatter
  case array1Scatter @(AsBox boxed_a) @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (array1 boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with barray1
  let repr_array_a : Repr (array1 boxed_a) = repr_array1 @boxed_a in

  let barray_finalizer : UpdateInPlaceFinalizer s (barray1 a) =
        case finalizer of {
          mutateInPlace
          (co : coerce @bare s (array1 boxed_a)).
            mutateAndCopy @s @(barray1 a)
            (\ (x : s) -> Init (barray1 a).
               mk_barray1 @a
               (copy @(array1 boxed_a) repr_array_a
                (coerce @s @(array1 boxed_a) x)))
        ; mutateAndCopy (f : s -> Init (array1 boxed_a)).
            mutateAndCopy @s @(barray1 a)
            (\ (x : s) -> Init (barray1 a). mk_barray1 @a (f x))
        } in

  mk_scatter @(barray1 a) @i2 @s @iniF @updF repr_s initializer updater combiner
  barray_finalizer make_updater make_init;


array2Scatter @(box_e i : box)
  (repr_i : Repr (AsBare i))
  (repr_e : Repr (AsBare box_e))
  (dom : dim2)
  (reduction_op : Scatter (AsBare box_e) (AsBare i))
  -> Scatter (array2 (AsBare box_e)) (Tuple2 (index dim2) (AsBare i)) =

  let type e = AsBare box_e in
  let type i2 = (Tuple2 (index dim2) (AsBare i)) in
  let type ret_type = Scatter (array2 e) i2 in

  let repr_i2 = repr_Tuple2 @(index dim2) @(AsBare i) repr_index2 repr_i in


  -- Compute array size
  case dom of mk_dim2 (dom_y : dim1) (dom_x : dim1).
  case dim1ToArraySize dom_y of arraySize @(M : intindex) lb_y stride_y count_y.
  case dim1ToArraySize dom_x of arraySize @(N : intindex) lb_x stride_x count_x.

  let type index_1d = Tuple2 (Stored int) (AsBare i) in
  let type index_2d = Tuple2 (Stored int) index_1d in

  let repr_inner_array : Repr (arr N e) =
        repr_arr @N @e count_x repr_e in
  let repr_array : Repr (arr M (arr N e)) =
        repr_arr @M @(arr N e) count_y repr_inner_array in
  let repr_inner_index : Repr index_1d =
        repr_Tuple2 @(Stored int) @(AsBare i) repr_int repr_i in
  let repr_index : Repr index_2d =
        repr_Tuple2 @(Stored int) @index_1d repr_int repr_inner_index in


  -- Create a plain array scatter reducer using two calls to
  -- 'arrScatter'
  let x_scatter_reduction : Scatter (arr N e) index_1d  =
        arrScatter @N @e @(AsBare i) repr_i repr_e count_x reduction_op in
  let xy_scatter_reduction : Scatter (arr M (arr N e)) index_2d =
        arrScatter @M @(arr N e) @index_1d
        repr_inner_index repr_inner_array count_y x_scatter_reduction in

  -- Change the index to the expected data type
  -- Deconstruct the result.
  let arr_scatter_reduction : Scatter (arr M (arr N e)) i2 =
       comapScatterIndex @(arr M (arr N e)) @index_2d @i2
       repr_index repr_i2 repr_array
       (\ (index_in : i2) (ret : OutPtr index_2d) -> Store.
          case index_in of tuple2 (yx : index dim2) (z : AsBare i).
          case yx of tuple2 y x.
          case x of stored u_x.
          case y of stored u_y.

          tuple2 @(Stored int) @index_1d
          (stored @int u_y)
          (tuple2 @(Stored int) @(AsBare i)
           (stored @int u_x) (copy @(AsBare i) repr_i z))
          ret)
       xy_scatter_reduction in
  case arr_scatter_reduction of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (arr M (arr N e)))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Create a scatter reducer that wraps it in an array
  let array_finalizer : UpdateInPlaceFinalizer s (array2 e) =
        mutateAndCopy @s @(array2 e)
        (\ (accumulator : s) (ret : OutPtr (array2 e))
           -> Store.
           mk_array2 @e @M @N
           lb_y stride_y count_y lb_x stride_x count_x
           (stuckBox @(arr M (arr N e))
            (case finalizer of {
               mutateInPlace (co : coerce @bare s (arr M (arr N e))).
                 copy @(arr M (arr N e)) repr_array
                 (coerce @s @(arr M (arr N e)) accumulator)
             ; mutateAndCopy (f : s -> Init (arr M (arr N e))).
                 f accumulator
             }))
           ret) in

  -- Transform dim2 indices to linear indices
  letfun
    linearized_updater
      (f : updF) (ix : i2) (tok_in : EffTok) (ret : OutPtr s)
      -> EffTok =
      case ix of tuple2 (arr_ix : index dim2) (val : AsBare i).
      case arr_ix of tuple2 (ix_y : Stored int) (ix_x : Stored int).
      case ix_y of stored u_ix_y.
      case ix_x of stored u_ix_x.

      -- Drop values whose indices are out of bounds due to alignment
      let zeroed_ix_y : int = u_ix_y -# lb_y in
      let zeroed_ix_x : int = u_ix_x -# lb_x in
      if zeroed_ix_y %# stride_y /=# 0 then tok_in else
      if zeroed_ix_x %# stride_x /=# 0 then tok_in else
      let linearized_ix_y : int = zeroed_ix_y //# stride_y in
      let linearized_ix_x : int = zeroed_ix_x //# stride_x in
      case boxed @i2 (tuple2 @(index dim2) @(AsBare i)
                      (tuple2 @(Stored int) @(Stored int)
                       (stored @int linearized_ix_y) (stored @int linearized_ix_x))
                      (copy @(AsBare i) repr_i val)) of
        boxed new_ix.
      updater f new_ix tok_in ret
  in

  mk_scatter @(array2 e) @i2 @s @iniF @updF
   repr_s
   initializer
   linearized_updater
   combiner
   array_finalizer
   make_updater
   make_init;


barray2Scatter @(box_a i : box)
  (repr_i : Repr (AsBare i))
  (repr_a : Repr (AsBare box_a))
  (dom : dim2)
  (reduction_op : Scatter (StuckRef box_a) (AsBare i))
  -> Scatter (barray2 (AsBare box_a)) (Tuple2 (index dim2) (AsBare i)) =
  let type a = AsBare box_a in
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (index dim2) (AsBare i) in

  -- Use array2Scatter
  case array2Scatter @(AsBox boxed_a) @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (array2 boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with barray2
  let repr_array_a : Repr (array2 boxed_a) = repr_array2 @boxed_a in

  let barray_finalizer : UpdateInPlaceFinalizer s (barray2 a) =
        case finalizer of {
          mutateInPlace (co : coerce @bare s (array2 boxed_a)).
            mutateAndCopy @s @(barray2 a)
            (\ (x : s) -> Init (barray2 a).
               mk_barray2 @a
               (copy @(array2 boxed_a) repr_array_a
                (coerce @s @(array2 boxed_a) x)))
        ; mutateAndCopy (f : s -> Init (array2 boxed_a)).
            mutateAndCopy @s @(barray2 a)
            (\ (x : s) -> Init (barray2 a). mk_barray2 @a (f x))
        } in

  mk_scatter @(barray2 a) @i2 @s @iniF @updF repr_s initializer updater combiner
  barray_finalizer make_updater make_init;


array3Scatter @(box_e i : box)
  (repr_i : Repr (AsBare i))
  (repr_e : Repr (AsBare box_e))
  (dom : dim3)
  (reduction_op : Scatter (AsBare box_e) (AsBare i))
  -> Scatter (array3 (AsBare box_e)) (Tuple2 (index dim3) (AsBare i)) =

  let type e = AsBare box_e in
  let type i3 = (Tuple2 (index dim3) (AsBare i)) in
  let type ret_type = Scatter (array3 e) i3 in

  let repr_i3 = repr_Tuple2 @(index dim3) @(AsBare i) repr_index3 repr_i in

  -- Compute array size
  case dom of mk_dim3 (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case dim1ToArraySize dom_z of arraySize @(L : intindex) lb_z stride_z count_z.
  case dim1ToArraySize dom_y of arraySize @(M : intindex) lb_y stride_y count_y.
  case dim1ToArraySize dom_x of arraySize @(N : intindex) lb_x stride_x count_x.

  let type index_1d = Tuple2 (Stored int) (AsBare i) in
  let type index_2d = Tuple2 (Stored int) index_1d in
  let type index_3d = Tuple2 (Stored int) index_2d in
  let type arr1d = arr N e in
  let type arr2d = arr M arr1d in
  let type arr3d = arr L arr2d in

  let repr_inner_array : Repr arr1d =
        repr_arr @N @e count_x repr_e in
  let repr_plane : Repr arr2d =
        repr_arr @M @arr1d count_y repr_inner_array in
  let repr_array : Repr arr3d =
        repr_arr @L @arr2d count_z repr_plane in
  let repr_inner_index : Repr index_1d =
        repr_Tuple2 @(Stored int) @(AsBare i) repr_int repr_i in
  let repr_plane_index : Repr index_2d =
        repr_Tuple2 @(Stored int) @index_1d repr_int repr_inner_index in
  let repr_index : Repr index_3d =
        repr_Tuple2 @(Stored int) @index_2d repr_int repr_plane_index in

  -- Create a plain array scatter reducer using three calls to
  -- 'arrScatter'
  let x_scatter_reduction : Scatter arr1d index_1d  =
        arrScatter @N @e @(AsBare i) repr_i repr_e count_x reduction_op in
  let xy_scatter_reduction : Scatter arr2d index_2d =
        arrScatter @M @arr1d @index_1d
        repr_inner_index repr_inner_array count_y x_scatter_reduction in
  let xyz_scatter_reduction : Scatter arr3d index_3d =
        arrScatter @L @arr2d @index_2d
        repr_plane_index repr_plane count_z xy_scatter_reduction in

  -- Change the index to the expected data type
  -- Deconstruct the result.
  let arr_scatter_reduction : Scatter arr3d i3 =
       comapScatterIndex @arr3d @index_3d @i3
       repr_index repr_i3 repr_array
       (\ (index_in : i3) (ret : OutPtr index_3d) -> Store.
          case index_in of
            tuple2 (zyx : index dim3) (val : AsBare i).
          case zyx of tuple3 z y x.
          case z of stored u_z.
          case y of stored u_y.
          case x of stored u_x.

          tuple2 @(Stored int) @index_2d
          (stored @int u_z)
          (tuple2 @(Stored int) @index_1d
           (stored @int u_y)
           (tuple2 @(Stored int) @(AsBare i)
            (stored @int u_x) (copy @(AsBare i) repr_i val)))
          ret)
       xyz_scatter_reduction in
  case arr_scatter_reduction of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i3 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s arr3d)
    (make_updater : i3 -> updF)
    (make_init : iniF).

  -- Create a scatter reducer that wraps it in an array
  let array_finalizer : UpdateInPlaceFinalizer s (array3 e) =
        mutateAndCopy @s @(array3 e)
        (\ (accumulator : s) (ret : OutPtr (array3 e))
           -> Store.
           mk_array3 @e @L @M @N
           lb_z stride_z count_z
           lb_y stride_y count_y
           lb_x stride_x count_x
           (stuckBox @arr3d
            (case finalizer of {
               mutateInPlace (co : coerce @bare s arr3d).
                 copy @arr3d repr_array
                 (coerce @s @arr3d accumulator)
             ; mutateAndCopy (f : s -> Init arr3d).
                 f accumulator
             }))
           ret) in

  -- Transform dim3 indices to linear indices
  letfun
    linearized_updater
      (f : updF) (ix : i3) (tok_in : EffTok) (ret : OutPtr s)
      -> EffTok =
      case ix of tuple2 (arr_ix : index dim3) (val : AsBare i).
      case arr_ix of tuple3 ix_z ix_y ix_x.
      case ix_z of stored u_ix_z.
      case ix_y of stored u_ix_y.
      case ix_x of stored u_ix_x.

      -- Drop values whose indices are out of bounds due to alignment
      let zeroed_ix_z : int = u_ix_z -# lb_z in
      let zeroed_ix_y : int = u_ix_y -# lb_y in
      let zeroed_ix_x : int = u_ix_x -# lb_x in
      if zeroed_ix_z %# stride_z /=# 0 then tok_in else
      if zeroed_ix_y %# stride_y /=# 0 then tok_in else
      if zeroed_ix_x %# stride_x /=# 0 then tok_in else
      let linearized_ix_z : int = zeroed_ix_z //# stride_z in
      let linearized_ix_y : int = zeroed_ix_y //# stride_y in
      let linearized_ix_x : int = zeroed_ix_x //# stride_x in
      case boxed @i3 (tuple2 @(index dim3) @(AsBare i)
                      (tuple3 @(Stored int) @(Stored int) @(Stored int)
                       (stored @int linearized_ix_z)
                       (stored @int linearized_ix_y)
                       (stored @int linearized_ix_x))
                      (copy @(AsBare i) repr_i val)) of
        boxed new_ix.
      updater f new_ix tok_in ret
  in

  mk_scatter @(array3 e) @i3 @s @iniF @updF
   repr_s
   initializer
   linearized_updater
   combiner
   array_finalizer
   make_updater
   make_init;


barray3Scatter @(box_a i : box)
  (repr_i : Repr (AsBare i))
  (repr_a : Repr (AsBare box_a))
  (dom : dim3)
  (reduction_op : Scatter (StuckRef box_a) (AsBare i))
  -> Scatter (barray3 (AsBare box_a)) (Tuple2 (index dim3) (AsBare i)) =

  let type a = AsBare box_a in
  let type boxed_a = StuckRef (AsBox a) in
  let type i2 = Tuple2 (index dim3) (AsBare i) in

  -- Use array3Scatter
  case array3Scatter @(AsBox boxed_a) @i
       repr_i (repr_StuckRef @(AsBox a)) dom reduction_op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i2 -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s (array3 boxed_a))
    (make_updater : i2 -> updF)
    (make_init : iniF).

  -- Wrap with barray3
  let repr_array_a : Repr (array3 boxed_a) = repr_array3 @boxed_a in

  let barray_finalizer : UpdateInPlaceFinalizer s (barray3 a) =
        case finalizer of {
          mutateInPlace
          (co : coerce @bare s (array3 boxed_a)).
            mutateAndCopy @s @(barray3 a)
            (\ (x : s) -> Init (barray3 a).
               mk_barray3 @a
               (copy @(array3 boxed_a) repr_array_a
                (coerce @s @(array3 boxed_a) x)))
        ; mutateAndCopy (f : s -> Init (array3 boxed_a)).
            mutateAndCopy @s @(barray3 a)
            (\ (x : s) -> Init (barray3 a). mk_barray3 @a (f x))
        } in

  mk_scatter @(barray3 a) @i2 @s @iniF @updF repr_s initializer updater combiner
  barray_finalizer make_updater make_init;


-- Using the contents of a 'Scatter' object, perform part of a scatter
-- operation sequentially on a list_dim.  Return the scatter state.

Sequence_partial_scatter @(i s : bare) @(iniF updF : box)
  (repr_i : Repr i) (repr_s : Repr s)
  (initializer : iniF -> OutPtr s -> EffTok)
  (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
  (make_updater : i -> updF)
  (make_init : iniF)
  (src : Sequence (AsBox i))
  (ret : OutPtr s)
  -> Store
  attribute(inline, inline_sequential) =

  let type SEff = Stored EffTok in

   -- Initialize the output
   case boxed @SEff (stored @EffTok (initializer make_init ret)) of
     boxed init_eff_tok.

   case boxed @SEff
        (Sequence_fold @i @SEff
         repr_i repr_EffTok
         (\ (x : SEff) (y : i) (loop_ret : OutPtr SEff) -> Store.
            case x of stored x_u.
            stored @EffTok (updater (make_updater y) y x_u ret) loop_ret)
            init_eff_tok
            src) of
     boxed s_final_eff_tok.

   -- Translate to a return value
   case s_final_eff_tok of stored final_eff_tok.
   fromEffTok @s final_eff_tok;


-- Using the contents of a 'Scatter' object, perform part of a scatter
-- operation sequentially on a list_dim.  Return the scatter state.

partial_list_dim_scatter @(i s : bare) @(iniF updF : box)
  (repr_i : Repr i) (repr_s : Repr s)
  (initializer : iniF -> OutPtr s -> EffTok)
  (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
  (make_updater : i -> updF)
  (make_init : iniF)
  (dom : list_dim)
  (f : Stored int -> Init i)
  (ret : OutPtr s)
  -> Store
  attribute(inline, inline_sequential) =

  let type SEff = Stored EffTok in

  -- Initialize the output
  case boxed @SEff (stored @EffTok (initializer make_init ret)) of
     boxed init_eff_tok.

   -- Sequential in-place update
   case boxed @SEff
        (primitive_list_dim_fold @SEff
         repr_EffTok dom
         (\ (ix : Stored int) (x : SEff) (loop_ret : OutPtr SEff) -> Store.
            case x of stored x_u.

            -- Compute a value
            case stuckBox @i (f ix) of stuckBox y.

            -- Perform an update
            stored @EffTok (updater (make_updater y) y x_u ret) loop_ret)
         init_eff_tok) of
     boxed s_final_eff_tok.

   -- Translate to a return value
   case s_final_eff_tok of stored final_eff_tok.
   fromEffTok @s final_eff_tok;


finish_scatter @(r s : bare) 
  (rep_r : Repr r)
  (rep_s : Repr s)
  (finalizer : UpdateInPlaceFinalizer s r)
  (w : Init s)
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_sequential) =

  case finalizer of {
    mutateInPlace (co : coerce @bare s r).
      (coerce @(Init s) @(Init r) w) ret

  ; mutateAndCopy (f : s -> Init r).
      case boxed @s w of boxed tmp.
      f tmp ret
  };

TEMPORARILY COMMENTED OUT FOR DEVELOPMENT
-}

-------------------------------------------------------------------------------
-- Serialization and deserialization

putInt : int -> MessageWriter attribute(builtin);
putUint : uint -> MessageWriter attribute(builtin);
putUintAsUint8 : uint -> MessageWriter attribute(builtin);
putUintAsUint16 : uint -> MessageWriter attribute(builtin);
putFloat : float -> MessageWriter attribute(builtin);
putByte : byte -> MessageWriter attribute(builtin);
putCursor : forall a : bare. cursor a -> MessageWriter attribute(builtin);
putStore : Store -> MessageWriter attribute(builtin);
putBareCoercion : forall a b : bare. coerce @bare a b -> MessageWriter attribute(builtin);
putBoxCoercion : forall a b : box. coerce @box a b -> MessageWriter attribute(builtin);
putStoredInt : Stored int -> MessageWriter attribute(builtin);
putStoredUint : Stored uint -> MessageWriter attribute(builtin);
putStoredFloat : Stored float -> MessageWriter attribute(builtin);
putStoredByte : Stored byte -> MessageWriter attribute(builtin);
putStoredInt64 : Stored int64 -> MessageWriter attribute(builtin);
putStoredCursor : forall a : bare. Stored (cursor a) -> MessageWriter attribute(builtin);

putArrWithSerializer : forall n : intindex, a : bare.
                       FIInt n -> SizeAlign a -> (a -> MessageWriter)
                    -> arr n a -> MessageWriter;

putRef : forall a : box. Ref a -> MessageWriter attribute(builtin);

-- Write a boxed object out.
putBoxedObject : forall a : box. a -> MessageWriter attribute(builtin);
putPointerlessObject : forall a : bare. SizeAlign a -> a -> OpaqueRef -> Store
  -> Store attribute(builtin);

getInt : MessageReader -> (MessageReader, int) attribute(builtin);
getUint : MessageReader -> (MessageReader, uint) attribute(builtin);
getUint8AsUint : MessageReader -> (MessageReader, uint) attribute(builtin);
getUint16AsUint : MessageReader -> (MessageReader, uint) attribute(builtin);
getFloat : MessageReader -> (MessageReader, float) attribute(builtin);
getByte : MessageReader -> (MessageReader, byte) attribute(builtin);
getCursor : forall a : bare. MessageReader -> (MessageReader, cursor a) attribute(builtin);
getStore : MessageReader -> (MessageReader, Store) attribute(builtin);
getBareCoercion : forall a b : bare. MessageReader -> (MessageReader, coerce @bare a b) attribute(builtin);
getBoxCoercion : forall a b : box. MessageReader -> (MessageReader, coerce @box a b) attribute(builtin);
getStoredInt : MessageReader -> (MessageReader, Init (Stored int)) attribute(builtin);
getStoredUint : MessageReader -> (MessageReader, Init (Stored uint)) attribute(builtin);
getStoredFloat : MessageReader -> (MessageReader, Init (Stored float)) attribute(builtin);
getStoredByte : MessageReader -> (MessageReader, Init (Stored byte)) attribute(builtin);
getStoredInt64 : MessageReader -> (MessageReader, Init (Stored int64)) attribute(builtin);
getStoredCursor : forall a : bare. MessageReader -> (MessageReader, Init (Stored (cursor a))) attribute(builtin);

getArrWithSerializer : forall n : intindex, a : bare.
                       FIInt n -> Repr a
                    -> (MessageReader -> (MessageReader, Init a))
                    -> MessageReader -> (MessageReader, Init (arr n a));

getRef : forall a : box.
         MessageReader -> (MessageReader, OutPtr (Ref a) -> Store) attribute(builtin);
getPointerlessObject : forall a : bare. SizeAlign a -> MessageReader
  -> (MessageReader, OutPtr a -> Store) attribute(builtin);
getBoxedObject : forall a : box. MessageReader -> (MessageReader, a) attribute(builtin);

-- For testing: Write an object to a buffer and read it back
testCopyViaBuffer : forall a : box. Repr (AsBare a) -> a -> a;

-- Write a list section to a buffer.
-- This optimized function writes only the subarray
-- that is part of the list section.
putListSection_optimized @(a : box)
  (x : ListSection a) (writer : OpaqueRef) (s1 : Store) -> Store
  attribute(builtin) =

  case x of listSection @N count rep arr_cursor.
  let type arr_t = arr N (AsBare a) in
  let arr = fromCursor @arr_t arr_cursor in

  putListSection_low_level @N @a count rep
  (\ (buf : OpaqueRef) (s : Store) -> Store.
     putArr @N @(AsBare a) count rep arr buf s)
  writer s1;

putListSection_low_level : forall N : intindex, a : box.
  FIInt N -> ReprBox a -> MessageWriter -> MessageWriter;


-- Read a list section from a buffer.
getListSection_optimized @(a : box) (rdr : MessageReader)
  -> (MessageReader, Init (ListSection a))
  attribute(builtin) =

  getListSection_low_level @a
  (\ @(N : intindex)
     (count : FIInt N) (rep : ReprBox a) (mk_arr : Init (arr N (AsBare a)))
     (ret : OutPtr (ListSection a))
     -> Store.

      -- Build a 'ListSection' from the given components
      let rep_arr = repr_arr @N @(AsBare a) count rep in
      let arr_copy = initToBare @(arr N (AsBare a)) rep_arr mk_arr in
      listSection @a @N count rep (toCursor @(arr N (AsBare a)) arr_copy) ret)
  rdr;

getListSection_low_level : forall a : box.
  (forall N : intindex. FIInt N -> ReprBox a -> Init (arr N (AsBare a))
                     -> Init (ListSection a))
  -> MessageReader -> (MessageReader, Init (ListSection a));


-------------------------------------------------------------------------------
-- Sets of integers

-- A set of integers, represented as a hash table.
-- The hash table consists of an array of integers and an array
-- of linked list indices (used for collisions).
data intset : bare
{
  mk_intset @(N : intindex) (FIInt N,
                             StuckBox (Tuple2 (arr N (Stored int))
                                              (arr N (Stored uint))));
};


-- TEMPORARILY COMMENTED OUT FOR DEVELOPMENT
{-


build_intset (ls : Boxed (list (Stored int)))
  -> Boxed intset attribute(inline) =
  case ls of boxed u_ls.
  case u_ls of make_list @(N : intindex) (list_size : FIInt N) barr.
  case barr of stuckBox (a : arr N (Stored int)).

  -- Compute size of hash table
  let table_count : int = compute_hash_table_size @N list_size in

  case defineIntIndex table_count of
    someIInt @(M : intindex) (table_size : FIInt M).

  -- Create hash table
  let type HT = Tuple2 (arr M (Stored int)) (arr M (Stored uint)) in
  let hash_table =
   stuckBox @HT (build_hash_table @N @M list_size table_size a) in

  boxed @intset (mk_intset @M table_size hash_table);

-}

compute_hash_table_size : forall N : intindex. FIInt N -> int;
build_hash_table : forall N M : intindex.
                   FIInt N -> FIInt M
                -> arr N (Stored int)
                -> Init (Tuple2 (arr M (Stored int)) (arr M (Stored uint)));

{-
intsetLookup (set : Boxed intset) (key : Boxed (Stored int))
  -> Boxed (Maybe (Stored int)) attribute(inline) =

  case set of boxed u_set.
  case u_set of mk_intset @(N : intindex) (size : FIInt N) contents.
  case contents of stuckBox tuple.
  case tuple of tuple2 keys_array inds_array.

  let ix =
        lookup_hash_table @N size keys_array inds_array (unboxIntValue key) in
  if ix ==# -1
  then boxed @(Maybe (Stored int)) (nothing @(Stored int))
  else boxed @(Maybe (Stored int)) (just @(Stored int) (stored @int ix));

-}

lookup_hash_table : forall N : intindex.
                    FIInt N
                 -> arr N (Stored int)
                 -> arr N (Stored uint)
                 -> int
                 -> int;

{-
intsetElements (set : Boxed intset)
  -> Stream1 (Boxed (Stored int)) attribute(inline) =
  case set of boxed u_set.
  case u_set of mk_intset @(N : intindex) (size : FIInt N) contents.
  case size of fiInt (count : int).
  case contents of stuckBox tuple.
  case tuple of tuple2 keys_array inds_array.

  -- For each array element
  let dom : list_dim = mk_list_dim (justVal @int count) in

  sequenceStream @(Boxed (Stored int))
  (Sequence_generate_bind @(Stored int) dom
   (\ (si : Boxed (Stored int)) -> Sequence (Boxed (Stored int)).

     let i = unboxIntValue si in

     -- Check inds_array to determine if the i_th element of keys_array
     -- holds a key
     case subscript @N @(Stored uint)
          (reprSizeAlign @(Stored uint) repr_uint) inds_array i
       of stored indirection.

     if oper_BITWISEAND (uintToInt indirection) 1 ==# 1
     then case subscript @N @(Stored int)
          (reprSizeAlign @(Stored int) repr_int) keys_array i
            of stored key.
          Sequence_return @(Stored int) repr_int (stored @int key)
     else Sequence_empty @(Stored int) repr_int));

-------------------------------------------------------------------------------
-- Trees of lists

  
-}  -- end TEMPORARILY COMMENTED OUT FOR DEVELOPMENT

-- Trees of lists.  These are used as temporary data structures
-- when constructing irregular arrays.
--
-- Invariant: 'pbBranch' never contains 'pbEmpty'.
data PBTree (a : bare) : box
{
  -- A branch with two children.
  -- The 'int' is the total number of list elements in its leaves.
  pbBranch (int, PBTree a, PBTree a);
  pbLeaf (list a);
  pbEmpty ();
};

con_pbBranch @(a : bare) (n : int) (l : PBTree a) (r : PBTree a)
  -> PBTree a attribute(inline) =
  pbBranch @a (boxedinfo pbBranch @a) n l r;

con_pbLeaf @(a : bare) (l : Init (list a)) -> PBTree a attribute(inline) =
  pbLeaf @a (boxedinfo pbLeaf @a) l;

con_pbEmpty @(a : bare) -> PBTree a attribute(inline) =
  pbEmpty @a (boxedinfo pbEmpty @a);


-- Get the number of 'a's in a PBtree 
PBTree_size @(a : bare) (t : PBTree a) -> int =
  case t of {
    pbLeaf tyob l.
      case l of make_list @(n : intindex) (len : FIInt n) b.
      case len of fiInt i. i
  ; pbBranch tyob i t1 t2.
      i
  ; pbEmpty tyob.
      0
  };


-- Create a new branch, computing the number of 'a's in the branch.
-- Do not create a branch if one of the leaves is empty.
PBTree_branch @(a : bare) (ta : PBTree a) (tb : PBTree a) -> PBTree a =
  let tot_sz : int = PBTree_size @a ta +# PBTree_size @a tb in
  letfun both (x : NoneType) -> PBTree a = con_pbBranch @a tot_sz ta tb in
  letfun
    k1 (empty : NoneType) -> PBTree a =
      case tb of {
        pbEmpty tyob. ta
      ; pbLeaf tyob l. both None
      ; pbBranch tyob n e_ta e_tb. both None
      } in
  case ta of {
    pbEmpty tyob. tb
  ; pbLeaf tyob l. k1 None
  ; pbBranch tyob n e_ta e_tb. k1 None
  };


-- Flatten a PBTree to a list.  The list contains the elements of the PBTree
-- in the same order.
PBTree_flatten @(a : bare)
  (rep : Repr a) (tree : PBTree a) (ret : OutPtr (list a)) -> Store
  attribute(inline) =
  -- Get the list size
  case defineIntIndex (PBTree_size @a tree) of
    someIInt @(n : intindex) (out_list_dim : FIInt n).

  let rep_array : Repr (arr n a) = unboxedinfo arr @n @a out_list_dim rep in

  letfun
    -- Copy the given subtree to the output, at the given offset
    storeTreeVal (new_ind : int) (t : PBTree a) (ret_p : OutPtr (arr n a)) -> Store =
      let ind : int = new_ind in
      case t of {
        pbEmpty tyob.
          emptyStore

      ; pbBranch tyob e_i ta tb.
          let ta_sz : int = PBTree_size @a ta in
          seqStore (storeTreeVal new_ind ta ret_p)
                   (storeTreeVal (new_ind +# ta_sz) tb ret_p)

      ; pbLeaf tyob tree_list.
          case tree_list of make_list @m (tree_list_dim : FIInt m) list_sb.
          let rep_array_m : Repr (arr m a) = unboxedinfo arr @m @a tree_list_dim rep in
          case list_sb of [reprSizeAlign @(arr m a) rep_array_m]
            stuckBox tyob (tree_list_array : (arr m a)).
          let sa = reprSizeAlign @a rep in

          doall @m tree_list_dim
          (\ (i : int) -> Store.
            copy @a rep
            (subscript @m @a sa tree_list_array i)
            (subscript_out @n @a sa ret_p (i +# ind)))
      } in

  -- Create a new list.
  -- In parallel, copy results into the list.
  make_list @a @n out_list_dim
  (con_stuckBox @(arr n a) rep_array
   (\ (ret_p : OutPtr (arr n a)) -> Store.
     blocked_PBTree_doall @a @(list a) tree
     (\ (i : int) (t : PBTree a) -> Store.
     storeTreeVal i t ret_p)))
  ret;



{- REPLACED BY NEW STREAM CODE

-------------------------------------------------------------------------------
-- Streams

-- A dynamically computed sequence of values, possibly with run-time
-- shape information.
type Stream : box -> box -> box;

-- A 1-dimensional stream of values, represented either as a
-- view or as a linear stream.
data Stream1 (a : box) : box
{
  sequenceStream (Sequence a);
  viewStream (view list_dim a);
};

con_sequenceStream @(a : box) (sq : Sequence a) -> Stream1 a attribute(inline) =
  sequenceStream @a (boxedinfo sequenceStream @a) sq;

con_viewStream @(a : box) (vw : view list_dim a) -> Stream1 a attribute(inline) =
  viewStream @a (boxedinfo viewStream @a) vw;

-- A dynamically computed sequence of values.
data Sequence (a : box) : box
{
  -- A stream is a (state, generator) pair.
  sequence @(st : box) (st, st -> StreamNext st a);
};

con_sequence @(a st : box) (x : st) (f : st -> StreamNext st a) -> Sequence a
  attribute(inline) =
  sequence @a @st (boxedinfo sequence @a) x f;

-- The result of attempting to pull a value from a stream.
data StreamNext (st : box) (a : box) : val
{
  streamEmpty ();
  streamValue (st, a);
};

-- The state of the stream 'bind' operator
data BindState (src_st : box) (src_elt trans_elt : box) : box
{
  -- Pull the next value from the source stream
  -- (Also represents a depleted stream)
  bindFromSource (src_st);

  -- Pull the next value from the stream transformer
  bindFromTrans @(trans_st : box)
    (src_st,
     trans_st,
     trans_st -> StreamNext trans_st trans_elt);
};

-- State of a chained stream
data ChainState (a b : box) : box
{
  chainFromFirst (a, b);
  chainFromNext (b);
};

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Views

--  A view is a container represented by a function
data view (sh : box) (a : box) : box
{
  mk_view (sh, AsBox (index sh) -> a);
};

con_view @(sh a : box) (shp : sh) (f : AsBox (index sh) -> a) -> view sh a
  attribute(inline) =
  mk_view @sh @a (boxedinfo mk_view @sh @a) shp f;

-------------------------------------------------------------------------------
-- Storage

data list (a : bare) : bare
{
  make_list @(n : intindex)
  (FIInt n, StuckBox (arr n a));
};

-- A list section is a sub-list that's treated like a list.
-- The @Repr (AsBare a)@ field is used by run-time marshaling code.
data ListSection (a : box) : bare attribute(builtin)
{
  listSection @(n : intindex) (FIInt n, Repr (AsBare a), cursor (arr n (AsBare a)));
};

-- A list of boxed objects
data blist (a : bare): bare
{
  make_blist (list (StuckRef (AsBox a)));
};

-- A list with extra fields supporting a mutable "append" operation.
-- The 'FIInt n' field is the actual array size.
-- The int field is the number of valid array elements.  Other elements are
-- zeroed.
-- Mutable operations are implemented in low-level code.
data append_list (a : bare) : bare
{
  make_append_list @(n : intindex)
  (FIInt n, int, StuckBox (arr n a));
};

-- An array type, parameterized over its dimension.
-- The array type contains its bounds.
type array : bare -> bare -> bare;

-- A singleton container
data array0 (a : bare) : bare
{
  mk_array0 (StuckBox a);
};

-- A 1D array.
-- The array's domain is described by a lower bound, stride, and size.
data array1 (a : bare) : bare
{
  mk_array1 @(N : intindex)
  (int, int, FIInt N, StuckBox (arr N a));
};

-- An array section is a subarray that's treated like an array
data Array1Section (a : box) : bare
{
  array1Section @(N : intindex)
  (int, int, FIInt N, Repr (AsBare a), cursor (arr N (AsBare a)));
};

-- A 2D array.
-- The array's domain is described by a lower bound, stride, and size in
-- the Y dimension, and a lower bound, stride, and size in the X dimension.
data array2 (a : bare) : bare
{
  mk_array2 @(M N : intindex)
  (int, int, FIInt M, int, int, FIInt N, StuckBox (arr M (arr N a)));
};

-- A 3D array.
-- The array's domain is described by a lower bound, stride, and size in
-- the Z, Y, and X dimensions.
data array3 (a : bare) : bare
{
  mk_array3 @(L M N : intindex)
  (int, int, FIInt L,
   int, int, FIInt M,
   int, int, FIInt N,
   StuckBox (arr L (arr M (arr N a))));
};

-- A 1D boxed array.
data barray1 (a : bare) : bare
{
  mk_barray1 (array1 (StuckRef (AsBox a)));
};

-- A 2D boxed array.
data barray2 (a : bare) : bare
{
  mk_barray2 (array2 (StuckRef (AsBox a)));
};

-- A 3D boxed array.
data barray3 (a : bare) : bare
{
  mk_barray3 (array3 (StuckRef (AsBox a)));
};

-- Array size, computed from a 'dim1'.  These values are more
-- convenient for constructing loops.  
data ArraySize : val
{
  -- The fields are a lower bound, stride, and size.
  arraySize @(N : intindex) (int, int, FIInt N);
};

-- Convert the "size" fields of an array to an equivalent dim1.
arrayDescToDim1 @(N : intindex) (lb : int) (stride : int) (size : FIInt N)
  -> dim1 attribute(inline) =
  case size of fiInt (size_i : int).

  let ub : int = lb +# stride *# size_i in
  con_dim1 (interval (justVal @int lb) (justVal @int ub)) (linearMap stride lb);


-- Convert a dim1 to the equivalent "size" fields of an array.
dim1ToArraySize (shp : dim1) -> ArraySize attribute(inline) =
  case shp of mk_dim1 tyob (interval lb ub) (linearMap stride alignment).
  case lb of {
    justVal lb_i.
      let size_i = dim1Cardinality shp in
      case defineIntIndex size_i of someIInt @(N : intindex) (size : FIInt N).
      arraySize @N lb_i stride size
  ; nothingVal.
      except @ArraySize
  };


-------------------------------------------------------------------------------
-- Shapes

-- Get the stream shape corresponding to a container
type shape : (box -> box) -> box;

-- The domain of nonempty subsets of {0, 1}.  Used for concatenating lists.
-- The field is an integer in the range 0--3.
-- 0 \in mk_chain_dim n <-> n & 1 /= 0
-- 1 \in mk_chain_dim n <-> n & 2 /= 0
data chain_dim : box
{
  mk_chain_dim (int);
};

con_chain_dim (n : int) -> chain_dim attribute(inline) =
  mk_chain_dim (boxedinfo mk_chain_dim) n;

-- The domain of subsets of {1}.  Used for implementing 'filter'.
data guard_dim : box
{
  guard_skip ();                -- Skip this element
  guard_keep ();                -- Keep this element
};


boolToGuard (b : bool) -> guard_dim attribute(inline) =
  if b
  then guard_skip (boxedinfo guard_skip)
  else guard_keep (boxedinfo guard_keep);


-- Convert a guard_dim to a boolean.
-- This is delayed to avoid undesirable case-of-case transformations.
guardToBool (g : guard_dim) -> bool attribute(inline, inline_postfinal) =
  case g of {
    guard_skip tyob. False
  ; guard_keep tyob. True
  };


-- The shape of a list stream.
-- 'Nothing' is an infinite stream; otherwise the shape is the length.
data list_dim : box
{
  mk_list_dim (MaybeVal int);
};

con_list_dim (x : MaybeVal int) -> list_dim attribute(inline) =
  mk_list_dim (boxedinfo mk_list_dim) x;


fiIntToList_dim @(N : intindex) (n : FIInt N) -> list_dim attribute(inline) =
  case n of fiInt i. con_list_dim (justVal @int i);


list_dimToFIInt (x : list_dim) -> SomeIInt attribute(inline) =
  case x of mk_list_dim tyob bound.
  case bound of {
    justVal b.  defineIntIndex b
  ; nothingVal. except @SomeIInt
  };


-- The shape of a singleton stream
data dim0 : box
{
  mk_dim0 ();
};

con_dim0 : dim0 = mk_dim0 (boxedinfo mk_dim0);

-- A one-dimensional domain.
-- The domain is the intersection of an interval and a linear map's range.
--
-- Invariants:
-- The interval's lower and upper bounds are in the range of the linear map.
-- The linear map's stride is positive.
-- The linear map's alignment may be anything; it's not constrained to be a
-- small positive number.
data dim1 : box
{
  mk_dim1 (Interval, LinearMap);
};

con_dim1 (iv : Interval) (lm : LinearMap) -> dim1 attribute(inline) =
  mk_dim1 (boxedinfo mk_dim1) iv lm;

-- A two-dimensional domain.  The cross product of two domains.
-- The fields are the projections into (y, x).
data dim2 : box
{
  mk_dim2 (dim1, dim1);
};

con_dim2 (x y : dim1) -> dim2 attribute(inline) =
  mk_dim2 (boxedinfo mk_dim2) x y;

-- A three-dimensional domain.  The cross product of three domains.
-- The fields are the projections into (z, y, x).
data dim3 : box
{
  mk_dim3 (dim1, dim1, dim1);
};

con_dim3 (x y z : dim1) -> dim3 attribute(inline) =
  mk_dim3 (boxedinfo mk_dim3) x y z;

-- The shape of an array stream.
-- Array streams are zero-indexed.
data arr_shape (n : intindex) (sh : box) : box
{
  mk_arr_shape (sh);
};

shapeIndexRepr : forall sh : box. ShapeDict sh -> Repr (index sh);
shapeSliceRepr : forall sh : box. ShapeDict sh -> Repr (slice sh);

-------------------------------------------------------------------------------
-- Representation dictionaries

bareToBox @(a : bare) (rep : Repr a) (x : a) -> AsBox a attribute(inline) =
  asbox @a rep (copy @a rep x);


boxToBare @(a : bare) (rep : Repr a) (x : AsBox a) -> a attribute(inline) =
  case con_stuckBox @a rep (asbare @a rep x) of [reprSizeAlign @a rep]
    stuckBox tyob y. y;


-- Convert an initializer to a bare object
initToBare @(a : bare) (rep : Repr a) (x : Init a) -> a attribute(inline) =
  case con_stuckBox @a rep x of [reprSizeAlign @a rep]
    stuckBox tyob y. y;


reprSizeAlign @(a : bare) (rep : Repr a) -> SizeAlign a
  attribute(inline, inline_sequential) =

  case rep of repr tyob sa isref put get.

  sa;


{-
-- Copy an array.  Use a loop to copy individual array elements.
copyArray @(N : intindex) @(a : bare)
  (rep : Repr a) (size : IInt N) (src : arr N a) (ret : OutPtr (arr N a))
  -> Store
  attribute(inline) =
  case rep of repr tyob sa is_ref.
  case sa of SizeAlign elem_size elem_align elem_pointerless.

  if elem_pointerless
  then blockcopy @(arr N a) 

  case size of {
    iInt (fsize : FIInt N).
      -- Copy each item in a loop
      doall @N fsize
      (\ (i : int) -> Store.
        copy @a rep
        (subscript @N @a sa src i)
        (subscript_out @N @a sa ret i))
  ; iPosInfty. except @Store
  ; iNegInfty. except @Store
  };
-}

-- Convert an initializer to a value.  This function is not executable,
-- and is only used during the simplifier.
reify : forall a : bare. Init a -> a;

defaultAsBox @(a : bare) (mk_rep : NoneType -> Repr a) (x : Init a) -> Boxed a
  attribute(inline, inline_postfinal, builtin) =
  let rep = mk_rep None in
  boxed @a (reprSizeAlign @a rep) (boxedinfo boxed @a rep) x;

defaultAsBare @(a : bare)
  (sa : SizeAlign a) (c : a -> Init a) (x : Boxed a) (r : OutPtr a)
  -> Store
  attribute(inline, inline_postfinal, builtin) =
  case x of [sa] boxed tyob ux. c ux r;

repr_Ref @(a : box) -> Repr (Ref a)
  attribute(inline, inline_postfinal, builtin) =

  repr @(Ref a) (boxedinfo repr @(Ref a)) (sizealign_Ref @a)
  (isAReference @(Ref a) @a (idBareCoercion @(Ref a)))
  (putRef @a) (getRef @a);

sizealign_int : SizeAlign (Stored int);
sizealign_uint : SizeAlign (Stored uint);
sizealign_float : SizeAlign (Stored float);
sizealign_bool : SizeAlign (Stored bool);
sizealign_NoneType : SizeAlign (Stored NoneType);

-- FIXME: These sizes are architecture-dependent!
sizealign_Ref @(a : box) -> SizeAlign (Ref a) =
  sizeAlign @(Ref a) 8U 8U False;

-- FIXME: These sizes are architecture-dependent!
sizeAlign_cursor @(a : bare) -> SizeAlignVal (cursor a) =
  sizeAlignVal @(cursor a) 16U 8U False;

sizealign_arr @(n : intindex) @(e : bare) (len : FIInt n) (sa : SizeAlign e)
  -> SizeAlign (arr n e)
  attribute(inline, inline_postfinal) =

  case sa of sizeAlign elt_size elt_align elt_pointerless.
  case len of fiInt length_int.

  -- Pad size to a multiple of alignment
  let size2 = uintToInt elt_size in
  let padded = size2 +# negI size2 %# uintToInt elt_align in

  -- Multiply by number of array elements
  let array_size = intToUint (length_int *# padded) in

  sizeAlign @(arr n e) array_size elt_align elt_pointerless;


repr_arr @(n : intindex) @(e : bare)
  (size : FIInt n) (repr_e : Repr e) -> Repr (arr n e)
  attribute(inline, inline_postfinal, builtin) =

  case repr_e of repr tyob sa_e is_ref_e put get.

  repr @(arr n e)
  (boxedinfo repr @(arr n e))
  (sizealign_arr @n @e size sa_e)
  (notAReference @(arr n e) (idCoercion @(Boxed (arr n e))))
  (putArr @n @e size repr_e)
  (getArrWithSerializer @n @e size repr_e get);

putArr @(n : intindex) @(e : bare) (size : FIInt n) (repr_e : Repr e)
  (x : arr n e) (buf : OpaqueRef) (s : Store) -> Store
  attribute(inline, builtin) =

  case repr_e of repr tyob sa_e is_ref_e put get.
  putArrWithSerializer @n @e size sa_e put x buf s;

getArr @(n : intindex) @(e : bare) (size : FIInt n) (repr_e : Repr e)
  (buf : MessageReader) -> (MessageReader, Init (arr n e))
  attribute(inline, builtin) =

  case repr_e of repr tyob sa_e is_ref_e put get.
  getArrWithSerializer @n @e size repr_e get buf;

repr_Stored @(a : val) (rep : ReprVal a)
  -> Repr (Stored a) attribute(inline, inline_postfinal, builtin) =
  case rep of reprVal tyob (sizeAlignVal sz al pointerless) ser des.

  repr @(Stored a) (typeObject_repr @(Stored a))
  (sizeAlign @(Stored a) sz al pointerless)
  (notAReference @(Stored a) (idCoercion @(Boxed (Stored a))))
  ser des;

repr_int : Repr (Stored int) attribute(inline, inline_final) =
  repr_Stored @int (unboxedinfo int);

repr_uint : Repr (Stored uint) attribute(inline, inline_final) =
  repr_Stored @uint (unboxedinfo uint);

repr_float : Repr (Stored float) attribute(inline, inline_final) =
  repr_Stored @float (unboxedinfo float);

repr_int64 : Repr (Stored int64) attribute(inline, inline_final) =
  repr_Stored @int64 (unboxedinfo int64);

repr_bool : Repr (Stored bool) attribute(inline, inline_final) =
  repr_Stored @bool (unboxedinfo bool);

repr_NoneType : Repr (Stored NoneType) attribute(inline, inline_final) =
  repr_Stored @NoneType (unboxedinfo NoneType);

repr_cursor @(a : bare) -> Repr (Stored (cursor a)) attribute(inline, inline_final) =
  repr_Stored @(cursor a) (unboxedinfo cursor @a);

repr_FIInt @(n : intindex) -> Repr (Stored (FIInt n))
  attribute(inline, inline_final) =
  repr_Stored @(FIInt n) (unboxedinfo FIInt @n);

reprVal_cursor @(a : bare) -> ReprVal (cursor a) attribute(builtin, inline, inline_final) =
  reprVal @(cursor a) (boxedinfo reprVal @(cursor a))
  (sizeAlign_cursor @a)
  (putStoredCursor @a)
  (getStoredCursor @a);

repr_SliceObject : Repr SliceObject = unboxedinfo SliceObject;
repr_list_dim : Repr (Ref list_dim);
repr_dim0 : Repr (Ref dim0);
repr_dim1 : Repr (Ref dim1);
repr_dim2 : Repr (Ref dim2);
repr_dim3 : Repr (Ref dim3);
repr_Any : Repr (AsBare Any);
repr_view : forall sh a : box. Repr (AsBare (view sh a));
repr_Scatter : forall a b : bare. Repr (AsBare (Scatter a b));
repr_intset : Repr intset;

frontend_repr_list @(a : box) -> Repr (list (AsBare a)) attribute(inline) =
  unboxedinfo list @(AsBare a);

repr_StuckRef @(a : box) -> Repr (StuckRef a)
  attribute(inline, inline_postfinal) =
  unboxedinfo StuckRef @a;

-- Representation of any boxed object
-- TODO: Add equality constraint (AsBare a ~ Ref a)
repr_Box @(a : box) -> Repr (AsBare a)
  attribute(inline, inline_postfinal) =
  coerce @(Repr (Ref a)) @(Repr (AsBare a)) (repr_Ref @a);

-- Representation of a referenced object that contains nothing and will
-- never be accessed.  At runtime, the reference will be an arbitrary pointer,
-- possibly NULL.
repr_EmptyReference : forall a : bare. Repr a;

-- This is only used for coercions.  Since we don't have
-- kind polymorphism, we cheat a bit on the type.
repr_Coercion : forall a : val. Repr (Stored a);

repr_index2 : Repr (Tuple2 (Stored int) (Stored int)) attribute(inline) =
  unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int;

pack_index2 (y x : int) -> Boxed (Tuple2 (Stored int) (Stored int))
  attribute(inline) =

  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int))
                 (unboxedinfo Tuple2 @(Stored int) @(Stored int)
                  repr_int repr_int) in
  con_boxed @(Tuple2 (Stored int) (Stored int)) repr_index2
  (tuple2 @(Stored int) @(Stored int) sa_int sa_int
    (stored @int y) (stored @int x));


unpack_index2 (idx : Boxed (Tuple2 (Stored int) (Stored int))) -> (int, int)
  attribute(inline) =

  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int))
                 (unboxedinfo Tuple2 @(Stored int) @(Stored int)
                  repr_int repr_int) in
  case idx of
    [sa_tuple] boxed tyob ([sa_int, sa_int] tuple2 (stored y) (stored x)).
  (y, x);


repr_slice2 : Repr (Tuple2 SliceObject SliceObject) =
  unboxedinfo Tuple2 @SliceObject @SliceObject
  (unboxedinfo SliceObject)
  (unboxedinfo SliceObject);


-- Wrapper functions to create Repr objects for the frontend

frontend_repr_stuckBox @(a : box) (rep : Repr (AsBare a))
  -> TypeObject (StuckBox (AsBare a)) attribute(inline) =
  boxedinfo stuckBox @(AsBare a) rep;

frontend_repr_Maybe @(a : box) (rep : Repr (AsBare a))
  -> Repr (Maybe (AsBare a)) attribute(inline) =
  unboxedinfo Maybe @(AsBare a) rep;

frontend_repr_array1 @(a : box) -> Repr (array1 (AsBare a)) =
  unboxedinfo array1 @(AsBare a);

frontend_repr_array2 @(a : box) -> Repr (array2 (AsBare a)) =
  unboxedinfo array2 @(AsBare a);

frontend_repr_array3 @(a : box) -> Repr (array3 (AsBare a)) =
  unboxedinfo array3 @(AsBare a);

frontend_repr_blist @(a : box) -> Repr (blist (AsBare a)) =
  unboxedinfo blist @(AsBare a);

frontend_repr_barray1 @(a : box) -> Repr (barray1 (AsBare a)) =
  unboxedinfo barray1 @(AsBare a);

frontend_repr_barray2 @(a : box) -> Repr (barray2 (AsBare a)) =
  unboxedinfo barray2 @(AsBare a);

frontend_repr_barray3 @(a : box) -> Repr (barray3 (AsBare a)) =
  unboxedinfo barray3 @(AsBare a);

frontend_repr_Tuple0 : Repr Tuple0 =
  unboxedinfo Tuple0;

frontend_repr_Tuple1 @(a : box)
  (rep_a : Repr (AsBare a))
  -> Repr (Tuple1 (AsBare a)) =
  unboxedinfo Tuple1 @(AsBare a) rep_a;

frontend_repr_Tuple2 @(a b : box)
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b))
  -> Repr (Tuple2 (AsBare a) (AsBare b)) =
  unboxedinfo Tuple2 @(AsBare a) @(AsBare b) rep_a rep_b;

frontend_repr_Tuple3 @(a b c : box)
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b)) (rep_c : Repr (AsBare c))
  -> Repr (Tuple3 (AsBare a) (AsBare b) (AsBare c)) =
  unboxedinfo Tuple3 @(AsBare a) @(AsBare b) @(AsBare c) rep_a rep_b rep_c;

frontend_repr_Tuple4 @(a b c d : box)
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b)) (rep_c : Repr (AsBare c)) (rep_d : Repr (AsBare d))
  -> Repr (Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)) =
  unboxedinfo Tuple4 @(AsBare a) @(AsBare b) @(AsBare c) @(AsBare d) rep_a rep_b rep_c rep_d;

--frontend_repr_SliceObject : Repr SliceObject = unboxedinfo SliceObject;

frontend_repr_arr @(n : intindex) @(e : box)
  (size : Boxed (Stored int)) (repr_e : Repr (AsBare e))
  -> Repr (arr n (AsBare e))
  attribute(inline) =
  unboxedinfo arr @n @(AsBare e) (fiInt @n (unboxIntValue size)) repr_e;

-- TEMPORARILY COMMENTED OUT FOR DEVELOPMENT
{-

repr_Stream : forall sh a: box. Repr (AsBare (Stream sh a));

reprVal_store : ReprVal Store attribute(builtin) =
  reprVal @Store (sizeAlignVal @Store 0U 1U) True;

-- Platform-dependent sizes and alignments
reprVal_int : ReprVal int attribute(inline, builtin) =
  reprVal @int (sizeAlignVal @int 4U 4U) True;

reprVal_uint : ReprVal uint attribute(inline, builtin) =
  reprVal @uint (sizeAlignVal @uint 4U 4U) True;

reprVal_float : ReprVal float attribute(inline, builtin) =
  reprVal @float (sizeAlignVal @float 4U 4U) True;

reprVal_byte : ReprVal byte attribute(inline, builtin) =
  reprVal @byte (sizeAlignVal @byte 1U 1U) True;

sizealign_store : SizeAlign (Stored Store);
sizealign_EffTok : SizeAlign (Stored EffTok);
sizealign_StuckRef : forall a : box. SizeAlign (StuckRef a);


repr_index2 : Repr (Tuple2 (Stored int) (Stored int)) =
  repr_Tuple2 @(Stored int) @(Stored int) repr_int repr_int;

repr_slice2 : Repr (Tuple2 SliceObject SliceObject) =
  repr_Tuple2 @SliceObject @SliceObject
  (unboxedinfo SliceObject) (unboxedinfo SliceObject);

repr_index3 : Repr (Tuple3 (Stored int) (Stored int) (Stored int)) =
  repr_Tuple3 @(Stored int) @(Stored int) @(Stored int)
  repr_int repr_int repr_int;

repr_slice3 : Repr (Tuple3 SliceObject SliceObject SliceObject) =
  repr_Tuple3 @SliceObject @SliceObject @SliceObject
  (unboxedinfo SliceObject) (unboxedinfo SliceObject)
  (unboxedinfo SliceObject);

repr_append_list @(a : bare) (rep : Repr a) -> Repr (append_list a)
  attribute(inline, inline_postfinal) =

  letfun
    copy_append_list (src : append_list a) (dst : OutPtr (append_list a)) -> Store =
      case src of
        make_append_list @(N : intindex)
        (capacity : FIInt N) (size : int) (arr : StuckBox (arr N a)).

      make_append_list @a @N capacity size arr dst
  in

  repr @(append_list a) (sizealign_append_list @a)
  copy_append_list
  (\ (x : Init (append_list a)) -> Boxed (append_list a).
    boxed @(append_list a) x)
  (\ (x : Boxed (append_list a)) (ret : OutPtr (append_list a)) -> Store.
    case x of boxed (y : append_list a). copy_append_list y ret)
  False;

copy_ListBuilder @(a : bare)
  (src : Stored (ListBuilder a)) (ret : OutPtr (Stored (ListBuilder a))) -> Store
  attribute(inline) =
  case src of stored x. stored @(ListBuilder a) x ret;

box_ListBuilder @(a : bare) (x : Init (Stored (ListBuilder a)))
  -> Boxed (Stored (ListBuilder a))
  attribute(inline) =
  boxed @(Stored (ListBuilder a)) x;

unbox_ListBuilder @(a : bare) (x : Boxed (Stored (ListBuilder a)))
  (ret : OutPtr (Stored (ListBuilder a))) -> Store
  attribute(inline) =
  case x of boxed sf.
  case sf of stored x. stored @(ListBuilder a) x ret;

repr_ListBuilder @(a : bare) -> Repr (Stored (ListBuilder a))
  attribute(inline, inline_postfinal) =
  repr @(Stored (ListBuilder a))
  (sizealign_ListBuilder @a)
  (copy_ListBuilder @a)
  (box_ListBuilder @a)
  (unbox_ListBuilder @a)
  False;

repr_array0 @(a : bare) -> Repr (array0 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array0 a) (ret : OutPtr (array0 a)) -> Store =
    case x of mk_array0 arr_ref. mk_array0 @a arr_ref ret
  in

  repr @(array0 a) (sizealign_array0 @a) copy_array
  (\ (x : Init (array0 a)) -> Boxed (array0 a).
    boxed @(array0 a) x)
  (\ (x : Boxed (array0 a)) (ret : OutPtr (array0 a)) -> Store.
     case x of boxed ux. copy_array ux ret)
  False;


repr_array1 @(a : bare) -> Repr (array1 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array1 a) (ret : OutPtr (array1 a)) -> Store =
     case x of mk_array1 @(N : intindex) lb stride count arr_ref.

     mk_array1 @a @N lb stride count arr_ref ret
  in

  repr @(array1 a) (sizealign_array1 @a) copy_array
  (\ (x : Init (array1 a)) -> Boxed (array1 a).
    boxed @(array1 a) x)
  (\ (x : Boxed (array1 a)) (ret : OutPtr (array1 a)) -> Store.
     case x of boxed ux. copy_array ux ret)
  False;


repr_array2 @(a : bare) -> Repr (array2 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array2 a) (ret : OutPtr (array2 a)) -> Store =
     case x of
       mk_array2 @(M N : intindex)
       lb_y stride_y count_y lb_x stride_x count_x arr_ref.

     mk_array2 @a @M @N lb_y stride_y count_y lb_x stride_x count_x arr_ref ret
  in

  repr @(array2 a) (sizealign_array2 @a) copy_array
  (\ (x : Init (array2 a)) -> Boxed (array2 a).
    boxed @(array2 a) x)
  (\ (x : Boxed (array2 a)) (ret : OutPtr (array2 a)) -> Store.
     case x of boxed ux. copy_array ux ret)
  False;


repr_array3 @(a : bare) -> Repr (array3 a)
  attribute(inline, inline_postfinal) =

  letfun copy_array (x : array3 a) (ret : OutPtr (array3 a)) -> Store =
     case x of
       mk_array3 @(L M N : intindex)
       lb_z stride_z count_z lb_y stride_y count_y lb_x stride_x count_x
       arr_ref.

     mk_array3 @a @L @M @N lb_z stride_z count_z lb_y stride_y count_y lb_x stride_x count_x arr_ref ret
  in

  repr @(array3 a) (sizealign_array3 @a) copy_array
  (\ (x : Init (array3 a)) -> Boxed (array3 a).
    boxed @(array3 a) x)
  (\ (x : Boxed (array3 a)) (ret : OutPtr (array3 a)) -> Store.
     case x of boxed ux. copy_array ux ret)
  False;


repr_list @(a : bare) -> Repr (list a)
  attribute(inline, inline_postfinal) =

  letfun copy_list (x : list a) (ret : OutPtr (list a)) -> Store =
     case x of make_list @(N : intindex) count arr_ref.

     make_list @a @N count arr_ref ret
  in

  repr @(list a) (sizealign_list @a) copy_list
  (\ (x : Init (list a)) -> Boxed (list a). boxed @(list a) x)
  (\ (x : Boxed (list a)) (ret : OutPtr (list a)) -> Store.
     case x of boxed ux. copy_list ux ret)
  False;
  

repr_llist : forall a : bare. Repr (Ref (llist a));


repr_barray1 @(a : bare) -> Repr (barray1 a)
  attribute(inline, inline_postfinal) =

  let type a_ref = StuckRef (AsBox a) in

  letfun copy_array (x : barray1 a) (ret : OutPtr (barray1 a)) -> Store =
     case x of mk_barray1 (y : array1 a_ref).
     case y of
       mk_array1 @(N : intindex) lb stride count arr_ref.

     mk_barray1 @a (mk_array1 @a_ref @N lb stride count arr_ref) ret
  in

  repr @(barray1 a) (sizealign_barray1 @a) copy_array
  (\ (x : Init (barray1 a)) -> Boxed (barray1 a).
    boxed @(barray1 a) x)
  (\ (x : Boxed (barray1 a)) (ret : OutPtr (barray1 a)) -> Store.
     case x of boxed ux. copy_array ux ret)
  False;


repr_barray2 @(a : bare) -> Repr (barray2 a)
  attribute(inline, inline_postfinal) =

  let type a_ref = StuckRef (AsBox a) in

  letfun copy_barray (x : barray2 a) (ret : OutPtr (barray2 a)) -> Store =
     case x of mk_barray2 (y : array2 a_ref).
     case y of
       mk_array2 @(M N : intindex)
       lb_y stride_y count_y lb_x stride_x count_x arr_ref.

     mk_barray2 @a
     (mk_array2 @a_ref @M @N lb_y stride_y count_y lb_x stride_x count_x arr_ref)
     ret
  in

  repr @(barray2 a) (sizealign_barray2 @a) copy_barray
  (\ (x : Init (barray2 a)) -> Boxed (barray2 a).
    boxed @(barray2 a) x)
  (\ (x : Boxed (barray2 a)) (ret : OutPtr (barray2 a)) -> Store.
     case x of boxed ux. copy_barray ux ret)
  False;


repr_barray3 @(a : bare) -> Repr (barray3 a)
  attribute(inline, inline_postfinal) =

  let type a_ref = StuckRef (AsBox a) in

  letfun copy_barray (x : barray3 a) (ret : OutPtr (barray3 a)) -> Store =
     case x of mk_barray3 (y : array3 a_ref).
     case y of
       mk_array3 @(L M N : intindex)
       lb_z stride_z count_z
       lb_y stride_y count_y
       lb_x stride_x count_x
       arr_ref.

     mk_barray3 @a
     (mk_array3 @a_ref @L @M @N lb_z stride_z count_z lb_y stride_y count_y lb_x stride_x count_x arr_ref)
     ret
  in

  repr @(barray3 a) (sizealign_barray3 @a) copy_barray
  (\ (x : Init (barray3 a)) -> Boxed (barray3 a).
    boxed @(barray3 a) x)
  (\ (x : Boxed (barray3 a)) (ret : OutPtr (barray3 a)) -> Store.
     case x of boxed ux. copy_barray ux ret)
  False;


repr_blist @(a : bare) -> Repr (blist a)
  attribute(inline, inline_postfinal) =

  let type ref_a = StuckRef (AsBox a) in

  letfun copy_list (x : blist a) (ret : OutPtr (blist a)) -> Store =
     case x of make_blist l.
     case l of
       make_list @(N : intindex) count arr_ref.

     make_blist @a (make_list @ref_a @N count arr_ref) ret
  in

  repr @(blist a) (sizealign_blist @a) copy_list
  (\ (x : Init (blist a)) -> Boxed (blist a). boxed @(blist a) x)
  (\ (x : Boxed (blist a)) (ret : OutPtr (blist a)) -> Store.
     case x of boxed ux. copy_list ux ret)
  False;

repr_Complex : forall a : bare. Repr a -> Repr (Complex a);

repr_Tuple0 : Repr Tuple0;

repr_Tuple1 :
    forall a : bare. Repr a -> Repr (Tuple1 a);

repr_Tuple2 @(a b : bare) (rep_a : Repr a) (rep_b : Repr b)
  -> Repr (Tuple2 a b)
  attribute(inline, inline_postfinal) =

  case rep_a of repr sa_a copy_a tboxed_a fboxed_a pl_a.
  case rep_b of repr sa_b copy_b tboxed_b fboxed_b pl_b.

  letfun
    copy_tuple (x : Tuple2 a b) (ret : OutPtr (Tuple2 a b)) -> Store =
      case x of tuple2 fa fb.
      tuple2 @a @b (copy @a rep_a fa) (copy @b rep_b fb) ret
  in

  repr @(Tuple2 a b)

  (sizealign_Tuple2 @a @b sa_a sa_b)

  copy_tuple

  (\ (f : Init (Tuple2 a b)) -> Boxed (Tuple2 a b). boxed @(Tuple2 a b) f)

  (\ (i : Boxed (Tuple2 a b)) (ret : OutPtr (Tuple2 a b)) -> Store.
    case i of boxed tup. copy_tuple tup ret)

  (and pl_a pl_b);


repr_Tuple3 @(a b c : bare) (rep_a : Repr a) (rep_b : Repr b) (rep_c : Repr c)
 -> Repr (Tuple3 a b c)
 attribute(inline, inline_postfinal) =

  case rep_a of repr sa_a copy_a tboxed_a fboxed_a pl_a.
  case rep_b of repr sa_b copy_b tboxed_b fboxed_b pl_b.
  case rep_c of repr sa_c copy_c tboxed_c fboxed_c pl_c.

  letfun
    copy_tuple (x : Tuple3 a b c) (ret : OutPtr (Tuple3 a b c)) -> Store =
      case x of tuple3 fa fb fc.
      tuple3 @a @b @c (copy @a rep_a fa) (copy @b rep_b fb) (copy @c rep_c fc) ret
  in

  repr @(Tuple3 a b c)

  (sizealign_Tuple3 @a @b @c sa_a sa_b sa_c)

  copy_tuple

  (\ (f : Init (Tuple3 a b c)) -> Boxed (Tuple3 a b c).
    boxed @(Tuple3 a b c) f)

  (\ (i : Boxed (Tuple3 a b c)) (ret : OutPtr (Tuple3 a b c)) -> Store.
    case i of boxed tup. copy_tuple tup ret)

  (and pl_a (and pl_b pl_c));


repr_Tuple4 @(a b c d : bare)
  (rep_a : Repr a) (rep_b : Repr b) (rep_c : Repr c) (rep_d : Repr d)
  -> Repr (Tuple4 a b c d)
  attribute(inline, inline_postfinal) =

  case rep_a of repr sa_a copy_a tboxed_a fboxed_a pl_a.
  case rep_b of repr sa_b copy_b tboxed_b fboxed_b pl_b.
  case rep_c of repr sa_c copy_c tboxed_c fboxed_c pl_c.
  case rep_d of repr sa_d copy_d tboxed_d fboxed_d pl_d.

  letfun
    copy_tuple (x : Tuple4 a b c d) (ret : OutPtr (Tuple4 a b c d)) -> Store =
      case x of tuple4 fa fb fc fd.
      tuple4 @a @b @c @d (copy @a rep_a fa) (copy @b rep_b fb) (copy @c rep_c fc) (copy @d rep_d fd) ret
  in

  repr @(Tuple4 a b c d)

  (sizealign_Tuple4 @a @b @c @d sa_a sa_b sa_c sa_d)

  copy_tuple

  (\ (f : Init (Tuple4 a b c d)) -> Boxed (Tuple4 a b c d).
    boxed @(Tuple4 a b c d) f)

  (\ (i : Boxed (Tuple4 a b c d)) (ret : OutPtr (Tuple4 a b c d)) -> Store.
    case i of boxed tup. copy_tuple tup ret)

  (and pl_a (and pl_b (and pl_c pl_d)));


copy_EffTok (x : Stored EffTok) (ret : OutPtr (Stored EffTok)) -> Store
  attribute(inline) =
  case x of stored t. stored @EffTok t ret;

box_EffTok (f : Init (Stored EffTok)) -> Boxed (Stored EffTok)
  attribute(inline) =
  boxed @(Stored EffTok) f;

unbox_EffTok (x : Boxed (Stored EffTok)) (ret : OutPtr (Stored EffTok))
  -> Store attribute(inline) =
  case x of boxed sx.
  case sx of stored t.
  stored @EffTok t ret;

--getReprSizeAlignTuple : forall a : bare. Repr a -> (uint, uint);
--getSizeAlignValTuple : (a : val) -> SizeAlignVal a -> (uint, uint);

--productSizeAlign : (uint, uint) -> (uint, uint) -> (uint, uint);
--unionSizeAlign : (uint, uint) -> (uint, uint) -> (uint, uint);

--toSizeAlignVal : (a : val) -> (uint, uint) -> SizeAlignVal a;
--toSizeAlign : forall a : bare. (uint, uint) -> SizeAlign a;

sizealign_append_list : forall a : bare. SizeAlign (append_list a);

sizealign_ListBuilder : forall a : bare. SizeAlign (Stored (ListBuilder a));

sizealign_Tuple2 : forall a b : bare.
                   SizeAlign a -> SizeAlign b
                -> SizeAlign (Tuple2 a b);
sizealign_Tuple3 : forall a b c : bare.
                   SizeAlign a -> SizeAlign b -> SizeAlign c
                -> SizeAlign (Tuple3 a b c);
sizealign_Tuple4 : forall a b c d : bare.
                   SizeAlign a -> SizeAlign b -> SizeAlign c -> SizeAlign d
                -> SizeAlign (Tuple4 a b c d);

sizealign_list : forall a : bare. SizeAlign (list a);
sizealign_array0 : forall a : bare. SizeAlign (array0 a);
sizealign_array1 : forall a : bare. SizeAlign (array1 a);
sizealign_array2 : forall a : bare. SizeAlign (array2 a);
sizealign_array3 : forall a : bare. SizeAlign (array3 a);
sizealign_blist : forall a : bare. SizeAlign (blist a);
sizealign_barray1 : forall a : bare. SizeAlign (barray1 a);
sizealign_barray2 : forall a : bare. SizeAlign (barray2 a);
sizealign_barray3 : forall a : bare. SizeAlign (barray3 a);

-}

-------------------------------------------------------------------------------
-- Conversions and traversal helper routines


-- Convert a list view to a sequence
viewToSeq @(a : box) (vw : view list_dim a) -> Seq a attribute(inline) =

  case vw of mk_view tyob dom g.
  let n : int = case dom of mk_list_dim tyob mbound.
                case mbound of {justVal n. n; nothingVal. except @int} in

  letfun
    step (s : Boxed (Stored int)) -> SeqStep (Boxed (Stored int)) a =
      let us = unboxIntValue s in
      if us <# n
      then seqYield @(Boxed (Stored int)) @a (boxIntValue (us +# 1)) (g s)
      else seqDone @(Boxed (Stored int)) @a
  in
  con_seq @a @(Boxed (Stored int)) (boxIntValue 0) step;


-- Build a list _sequentially_ from the contents of a view.
-- Used in the implementation of stream operations.
viewToList @(a : box)
  (rep : ReprBox a) (is_parallel : bool) (vw : view list_dim a)
  -> Boxed (list (AsBare a)) attribute(inline) =

  let type a_bare = AsBare a in

  case vw of mk_view tyob dom visit.
  case list_dimToFIInt dom of someIInt @N size.
  let rep_array = repr_arr @N @a_bare size rep in

  con_boxed @(list a_bare) (unboxedinfo list @a_bare)
  (make_list @a_bare @N size
   (con_stuckBox @(arr N a_bare) rep_array
    (\ (ret : OutPtr (arr N a_bare)) -> Store.
      arr1D_build @N @a_bare rep size is_parallel
      (\ (i : int) (ret : OutPtr a_bare) -> Store.
       asbare @a_bare rep (visit (boxIntValue i)) ret)
      ret)));


viewToArray1 @(a : box)
  (rep : ReprBox a) (is_parallel : bool) (vw : view dim1 a)
  -> Boxed (array1 (AsBare a)) attribute(inline) =

  let type a_bare = AsBare a in

  case vw of mk_view tyob dom visit.
  case dim1ToArraySize dom of arraySize @N lb stride size.
  let rep_array = repr_arr @N @a_bare size rep in

  con_boxed @(array1 a_bare) (unboxedinfo array1 @a_bare)
  (mk_array1 @a_bare @N lb stride size
   (con_stuckBox @(arr N a_bare) rep_array
    (\ (ret : OutPtr (arr N a_bare)) -> Store.
      arr1D_build @N @a_bare rep size is_parallel
      (\ (i : int) (ret : OutPtr a_bare) -> Store.
       asbare @a_bare rep (visit (boxIntValue (lb +# i *# stride))) ret)
      ret)));


viewToArray2 @(a : box)
  (rep : ReprBox a) (is_parallel : bool) (vw : view dim2 a)
  -> Boxed (array2 (AsBare a)) attribute(inline) =

  let type a_bare = AsBare a in

  case vw of mk_view tyob dom visit.
  case dom of mk_dim2 tyob dom_y dom_x.
  case dim1ToArraySize dom_y of arraySize @M lb_y stride_y size_y.
  case dim1ToArraySize dom_x of arraySize @N lb_x stride_x size_x.

  let rep_array = repr_arr @M @(arr N a_bare) size_y
                  (repr_arr @N @a_bare size_x rep) in

  con_boxed @(array2 a_bare) (unboxedinfo array2 @a_bare)
  (mk_array2 @a_bare @M @N lb_y stride_y size_y lb_x stride_x size_x
   (con_stuckBox @(arr M (arr N a_bare)) rep_array
    (\ (ret : OutPtr (arr M (arr N a_bare))) -> Store.
      arr2D_build @M @N @a_bare rep size_y size_x is_parallel
      (\ (y x : int) (ret : OutPtr a_bare) -> Store.
       let idx = pack_index2 (lb_y +# y *# stride_y) (lb_x +# x *# stride_x) in
       asbare @a_bare rep (visit idx) ret)
      ret)));


viewToRStream @(d a : box) (sh : ShapeDict d) (rep : ReprBox a) (vw : view d a)
  -> RStream d a attribute(inline) =

  con_rStream @d @a @a rep (\ (x : a) -> a. x)
  (con_someIndexable @d @a @(view d) (idCoercion @d)
   (Indexable_view @d sh) vw);


viewToSplittable @(d a : box)
  (sh : ShapeDict d) (vw : view d (Stream list_dim a))
  -> IStream list_dim a attribute(inline) =
  con_nestedIxStream @a @d sh
  (viewToRStream @d @(Stream list_dim a) sh (repr_Box @(Stream list_dim a)) vw);
  

someIndexableToView @(d a : box)
  (rep : ReprBox a) (si : SomeIndexable d a)
  -> view d a attribute(inline) =
  case si of someIndexable @t tyob c ix x.
  coerce @(view (shape t) a) @(view d a) (indexableToView @t @a rep ix x);


someIndexableShape @(d a : box) (si : SomeIndexable d a)
  -> d attribute(inline) =
  case si of someIndexable @t tyob c ix x.
  coerce @(shape t) @d (ix_shape @t ix @a x);


indexableToView @(t : box -> box) @(a : box)
  (rep : ReprBox a) (ix : IndexableDict t) (x : t a)
  -> view (shape t) a attribute(inline) =

  con_view @(shape t) @a (ix_shape @t ix @a x) (ix_at @t ix @a rep x);


listToListSection @(a : box) (rep : ReprBox a) (l : Boxed (list (AsBare a)))
  -> Boxed (ListSection a) =

  let type a_bare = AsBare a in

  case l of [reprSizeAlign @(list a_bare) (unboxedinfo list @a_bare)]
            boxed tyob (make_list @N size ay_ref).

  let rep_array = repr_arr @N @a_bare size rep in
  case ay_ref of [reprSizeAlign @(arr N a_bare) rep_array] stuckBox tyob2 ay.

  con_boxed @(ListSection a) (unboxedinfo ListSection @a)
  (listSection @a @N size rep
   (subarray @N @N @a_bare (reprSizeAlign @a_bare rep) ay 0));


-- Zip together two indexables
zip_Indexable @(d : box) @(a b c : box)
  (sh : ShapeDict d) (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b -> c) (x : SomeIndexable d a) (y : SomeIndexable d b)
  -> Zip2Indexable d c attribute(inline) =

  case x of someIndexable @s tyob co1 ix1 container1.
  case y of someIndexable @t tyob co2 ix2 container2.

  -- Find the intersection of the two indexable objects' domains
  let dom = shIntersect @d sh
            (coerce @(shape s) @d (ix_shape @s ix1 @a container1))
            (coerce @(shape t) @d (ix_shape @t ix2 @b container2)) in

  let off = shNoOffset @d sh in

  con_zip2Indexable @d @c @a @b rep_a rep_b f
  (coerce @(SomeIndexable (shape s) a) @(SomeIndexable d a)
   (ix_slice @s ix1 @a rep_a container1
    (coerce @d @(shape s) dom)
    (coerce @(AsBox (offset d)) @(AsBox (offset (shape s))) off)))
  (coerce @(SomeIndexable (shape t) b) @(SomeIndexable d b)
   (ix_slice @t ix2 @b rep_b container2
    (coerce @d @(shape t) dom)
    (coerce @(AsBox (offset d)) @(AsBox (offset (shape t))) off)));


-- This function is recursive via flattenSplittable
-- FIXME: Handle recursive function inlining properly
streamToSequence @(a : box) (s : Stream list_dim a)
  -> Seq a
  attribute(inline,
            inline_struct(D(T C)) -- Stream constructor must be known
           ) =

  case unStream @list_dim @a s of {
    seqStream tyob co sq. sq

  ; nestedIxStream @d2 tyob co shape_dict rs.
      case rStreamToView @d2 @(Stream list_dim a) rs of mk_view tyob dom f.
      shForeachSeq @d2 shape_dict @a dom
      (\ (x : BoxIndex d2) -> Seq a. streamToSequence @a (f x))

  ; nestedSeqStream tyob co sq.
      bind_Seq @(Stream list_dim a) @a sq
      (\ (x : Stream list_dim a) -> Seq a. streamToSequence @a x)

  ; ixStream tyob rs.
      rStreamToSeq @a rs
  };

{-
streamToSequence2 @(a : box)
  (s : Stream list_dim a) -> Seq a attribute(inline) =

  case unStream @list_dim @a s of {
    seqStream tyob co sq. sq

  ; nestedIxStream @d2 tyob co shape_dict rs.
      case rStreamToView @d2 @(Stream list_dim a) rs of mk_view tyob dom f.
      shForeachSeq @d2 shape_dict @a dom
      (\ (x : BoxIndex d2) -> Seq a. streamToSequence3 @a (f x))

  ; nestedSeqStream tyob co sq.
      bind_Seq @(Stream list_dim a) @a sq
      (\ (x : Stream list_dim a) -> Seq a. streamToSequence3 @a x)

  ; ixStream tyob rs.
      rStreamToSeq @a rs
  };


streamToSequence3 @(a : box)
  (s : Stream list_dim a) -> Seq a attribute(inline_never) =

  case unStream @list_dim @a s of {
    seqStream tyob co sq. sq

  ; nestedIxStream @d2 tyob co shape_dict rs.
      case rStreamToView @d2 @(Stream list_dim a) rs of mk_view tyob dom f.
      shForeachSeq @d2 shape_dict @a dom
      (\ (x : BoxIndex d2) -> Seq a. streamToSequence3 @a (f x))

  ; nestedSeqStream tyob co sq.
      bind_Seq @(Stream list_dim a) @a sq
      (\ (x : Stream list_dim a) -> Seq a. streamToSequence3 @a x)

  ; ixStream tyob rs.
      rStreamToSeq @a rs
  };
-}

{-
-- These functions are obsolete 
flattenSplittable @(d a : box)
  (sh : ShapeDict d) (rs : RStream d (Stream list_dim a))
  -> Seq a attribute(inline) =

  case rStreamToView @d @(Stream list_dim a) rs of mk_view tyob dom f.
  shForeachSeq @d sh @a dom
  (\ (x : BoxIndex d) -> Seq a. streamToSequence2 @a (f x));


flattenSplittable2 @(d a : box)
  (sh : ShapeDict d) (rs : RStream d (Stream list_dim a))
  -> Seq a attribute(inline) =

  case rs of rStream @b tyob rep_b f ix.
  case someIndexableToView @d @b rep_b ix of mk_view tyob dom g.

  -- Traverse all indices in the view's domain
  let view_indices : Seq (BoxIndex d) =
        streamToSequence3 @(BoxIndex d)
        (shFlatten @d sh @(BoxIndex d) (shRepIndex @d sh) (indices @d sh dom)) in

  bind_Seq @(BoxIndex d) @a view_indices
  (\ (x : BoxIndex d) -> Seq a. streamToSequence3 @a (f (g x)));
-}

peel_Stream @(a r : box)
  (rep_a : ReprBox a)
  (value_k : a -> Stream list_dim a -> r)
  (empty_k : NoneType -> r)
  (s : Stream list_dim a)
  -> r attribute(inline) =

  let type peeled_pair = Tuple2 (StuckRef a) (Ref (Seq a)) in
  let rep_ref_a = unboxedinfo StuckRef @a in
  let rep_seq = unboxedinfo Ref @(Seq a) in
  let rep_tuple = unboxedinfo Tuple2 @(StuckRef a) @(Ref (Seq a))
                  rep_ref_a rep_seq in
  let rep_maybe = unboxedinfo Maybe @peeled_pair rep_tuple in

  case s of stream tyob_stream par_hint i_s.
  case i_s of {
    seqStream tyob co sq.
      case peel_Seq @a sq of
        [reprSizeAlign @(Maybe peeled_pair) rep_maybe]
        boxed boxed_tyob peel_result.
      case peel_result of [reprSizeAlign @peeled_pair rep_tuple] {
        just ([reprSizeAlign @(StuckRef a) rep_ref_a,
               reprSizeAlign @(Ref (Seq a)) rep_seq]
              tuple2 (stuckRef x) (ref sq2)).
          -- Create a new stream that is the old stream with one item peeled
          let peeled_stream =
                stream @list_dim @a tyob_stream par_hint
                (seqStream @list_dim @a tyob co sq2) in
          value_k x peeled_stream
      ; nothing.
          empty_k None
      }

  ; nestedIxStream @d tyob co sh rs.
      let vw = rStreamToView @d @(Stream list_dim a) rs in
      shPeel @d sh @a @r rep_a (boxParHintValue par_hint) value_k empty_k vw

  ; nestedSeqStream tyob co sq.
      -- TODO
      except @r
      {- letfun
        -- Peel from the stream, one element at a time
        peel_sequence (sq : Seq (Stream list_d im a)) -> r =
          case peel_Seq @(Stream list_dim a) sq of
            [reprSizeAlign @(Maybe peeled_pair) rep_mtuple]
            boxed m_tuple.
          case m_tuple of {
            just ([reprSizeAlign @(StuckRef a) rep_ref_a,
                   reprSizeAlign @(Ref (Seq a)) rep_seq]
                  tuple2 (stuckRef x) (ref y)).

      ; nothing.
          0
      } -}

  ; ixStream tyob rs.
      -- Convert to a view
      let vw = rStreamToView @list_dim @a rs in

      peel_view_list_dim @a @r rep_a par_hint value_k empty_k vw
  };


take_one_list_dim (x : list_dim)
  -> MaybeVal (list_dim,) attribute(inline, inline_final) =

  let rep_ref = unboxedinfo Ref @list_dim in
  let sa_ref = reprSizeAlign @(Ref list_dim) rep_ref in
  let rep_maybe = unboxedinfo Maybe @(Ref list_dim) rep_ref in

  case x of mk_list_dim tyob m_bound.
  case m_bound of {
    justVal n.
      if n ==# 0
      then nothingVal @(list_dim,)
      else justVal @(list_dim,) (mk_list_dim tyob (justVal @int (n -# 1)),)

  ; nothingVal.
      justVal @(list_dim,) (mk_list_dim tyob (nothingVal @int),)
  };


peel_view_list_dim @(a r : box)
  (rep_a : ReprBox a)
  (par_hint : ParHint)
  (value_k : a -> Stream list_dim a -> r)
  (empty_k : NoneType -> r)
  (vw : view list_dim a)
  -> r attribute(inline) =

  case vw of mk_view tyob dom visit.

  -- Reduce the list domain's size by 1
  case take_one_list_dim dom of {
    justVal (dom2,).
      letfun
        visit2 (i : Boxed (Stored int)) -> a =
          visit (boxIntValue (1 +# unboxIntValue i))
       in
       let new_stream =
             annotateParHint @list_dim @a par_hint
             (traverse_view_real @list_dim @a ShapeDict_list_dim rep_a
              (con_view @list_dim @a dom2 visit2)) in
       value_k (visit (boxIntValue 0)) new_stream
       
  ; nothingVal.
      empty_k None
  };


-------------------------------------------------------------------------------
-- Functor, Indexable, and Traversable dictionaries


Functor_view @(d : box) -> FunctorDict (view d) attribute(inline) =
  functorDict @(view d) (boxedinfo functorDict @(view d)) (map_view @d);


map_view @(d a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (vw : view d a)
  -> view d b attribute(inline) =

  case vw of mk_view tyob dom g.
  con_view @d @b dom (\ (i : BoxIndex d) -> b. f (g i));


-- map_view without unused parameters
real_map_view @(d a b : box)
  (f : a -> b) (vw : view d a)
  -> view d b attribute(inline) =

  case vw of mk_view tyob dom g.
  con_view @d @b dom (\ (i : BoxIndex d) -> b. f (g i));


zipWith_view @(d a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (sh : ShapeDict d)
  (f : a -> b -> c) (v1 : view d a) (v2 : view d b)
  -> view d c attribute(inline) =
  case v1 of mk_view tyob d1 g1.
  case v2 of mk_view tyob d2 g2.
  con_view @d @c (shIntersect @d sh d1 d2)
  (\ (x : BoxIndex d) -> c. f (g1 x) (g2 x));


-- FIXME: This function is recursive via slice_view
-- Handle recursion properly
Indexable_view @(sh : box) (sh_shape : ShapeDict sh)
  -> IndexableDict (view sh) attribute(inline) =

  let f = Functor_view @sh in

  indexableDict @(view sh) (boxedinfo indexableDict @(view sh))
  f
  (shape_view_real @sh)
  (at_view @sh sh_shape f)
  (slice_view @sh sh_shape f)
  (preserve_view_real @sh);


shape_view @(d : box) (sh_shape : ShapeDict d) (f : FunctorDict (view d))
  -> forall a : box. view d a -> d attribute(inline) =
  shape_view_real @d;


shape_view_real @(d a : box) (v : view d a) -> d attribute(inline) =
  case v of mk_view tyob dv rest. dv;


at_view @(d : box) (sh_shape : ShapeDict d) (f : FunctorDict (view d))
  -> forall a : box. ReprBox a -> view d a -> BoxIndex d -> a
  attribute(inline) =

  \ @(a : box) (rep : ReprBox a) (x : view d a) (i : BoxIndex d) -> a.
  at_view_real @d @a x i;


at_view_real @(d a : box) (v : view d a) (i : BoxIndex d) -> a attribute(inline) =
  case v of mk_view tyob f g. g i;


slice_view @(d : box) (sh_shape : ShapeDict d) (f : FunctorDict (view d))
  -> forall a : box. ReprBox a -> view d a -> d -> BoxOffset d -> SomeIndexable d a
  attribute(inline) =
  \ @(a : box)
    (rep : ReprBox a) (v : view d a) (dom : d) (off : BoxOffset d)
    -> SomeIndexable d a.
    slice_view_real @d @a sh_shape f rep v dom off;


slice_view_real @(d a : box) (sh_shape : ShapeDict d) (f : FunctorDict (view d))
  (rep : ReprBox a) (v : view d a) (dom : d) (off : BoxOffset d)
  -> SomeIndexable d a
  attribute(inline,
            inline_struct(T T T C T T) -- View constructor is known
           ) =

  case v of mk_view tyob input_dom f.

  -- Add offset onto an index before viewing
  letfun g (i : BoxIndex d) -> a = f (shAppOffset @d sh_shape off i) in

  con_someIndexable @d @a @(view d) (idCoercion @d)
  (Indexable_view @d sh_shape)
  (con_view @d @a dom g);


preserve_view @(d : box) (sh_shape : ShapeDict d) (f : FunctorDict (view d))
  -> forall a : box. view d a -> view d a attribute(inline) =

  preserve_view_real @d;

  -- There is no advantage to disabling optimization on views
preserve_view_real @(d a : box) (x : view d a) -> view d a = x;


Traversable_view @(sh : box) (sh_shape : ShapeDict sh)
  -> TraversableDict (view sh) attribute(inline) =
  traversableDict @(view sh)
  (boxedinfo traversableDict @(view sh))
  (traverse_view @sh sh_shape)
  (build_view @sh sh_shape);


traverse_view @(sh : box) (sh_shape : ShapeDict sh)
  -> forall a : box. ReprBox a -> view sh a -> Stream sh a attribute(inline) =
  \ @(a : box) (rep : ReprBox a) (vw : view sh a) -> Stream sh a.
  traverse_view_real @sh @a sh_shape rep vw;


build_view @(sh : box) (sh_shape : ShapeDict sh)
  -> forall a : box. ReprBox a -> Stream sh a -> view sh a attribute(inline) =
  \ @(a : box) (unused : ReprBox a) (s : Stream sh a) -> view sh a.
  build_view_real @sh @a sh_shape s;


traverse_view_real @(sh a : box)
  (sh_shape : ShapeDict sh) (rep : ReprBox a) (vw : view sh a)
  -> Stream sh a attribute(inline) =
  con_stream @sh @a hintAny
  (con_ixStream @sh @a (viewToRStream @sh @a sh_shape rep vw));


build_view_real @(sh a : box) (sh_shape : ShapeDict sh) (s : Stream sh a)
  -> view sh a attribute(inline) =
  
  -- TODO
  case unStream @sh @a s of {
    seqStream tyob co sq. except @(view sh a)

  ; nestedIxStream @sh2 tyob co shape_sh2 rs. except @(view sh a)

  ; nestedSeqStream tyob co sq. except @(view sh a)

  ; ixStream tyob (rStream @b tyob rep_b extract si).
      case si of someIndexable @t tyob co indexable container.
      let dom = ix_shape @t indexable @b container in
      letfun
        get (idx : BoxIndex sh) -> a =
          extract (ix_at @t indexable @b rep_b container
                   (coerce @(BoxIndex sh) @(BoxIndex (shape t)) idx))
      in
      con_view @sh @a (coerce @(shape t) @sh dom) get
  };


Functor_Stream @(d : box) -> FunctorDict (Stream d) attribute(inline) =
  functorDict @(Stream d) (boxedinfo functorDict @(Stream d)) (map_Stream @d);


map_Stream @(d a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : Stream d a) -> Stream d b
  attribute(inline,
            inline_struct(T T T D(T C)) -- Stream constructor is known
           ) =
  case s of stream tyob_stream par_hint i_s.
  case i_s of {
    seqStream tyob co sq.
      coerce @(Stream list_dim b) @(Stream d b)
      (con_stream @list_dim @b par_hint
       (con_seqStream @b (map_Seq @a @b f sq)))

  ; nestedIxStream @d2 tyob co shape_d2 rs.
      coerce @(Stream list_dim b) @(Stream d b)
      (con_stream @list_dim @b par_hint
       (con_nestedIxStream @b @d2 shape_d2
        (map_RStream @d2 @(Stream list_dim a) @(Stream list_dim b)
         (map_Stream @list_dim @a @b rep_a rep_b f) rs)))

  ; nestedSeqStream tyob co rs.
      coerce @(Stream list_dim b) @(Stream d b)
      (con_stream @list_dim @b par_hint
       (con_nestedSeqStream @b
        (map_Seq @(Stream list_dim a) @(Stream list_dim b)
         (map_Stream @list_dim @a @b rep_a rep_b f) rs)))

  ; ixStream tyob rs.
      con_stream @d @b par_hint
       (con_ixStream @d @b (map_RStream @d @a @b f rs))
  };

Traversable_Stream @(sh : box)
  -> TraversableDict (Stream sh) attribute(inline) =
  traversableDict @(Stream sh)
  (boxedinfo traversableDict @(Stream sh))
  (traverse_Stream @sh) (build_Stream @sh);

traverse_Stream @(d a : box)
  (unused : ReprBox a) (s : Stream d a) -> Stream d a = s;

build_Stream @(d a : box)
  (unused : ReprBox a) (s : Stream d a) -> Stream d a = s;


Functor_list : FunctorDict (\ (a : box). Boxed (list (AsBare a))) =
  functorDict @(\ (a : box). Boxed (list (AsBare a)))
  (boxedinfo functorDict @(\ (a : box). Boxed (list (AsBare a))))
  map_list;


map_list @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b)
  (l : Boxed (list (AsBare a)))
  -> Boxed (list (AsBare b)) attribute(inline) =

  build_list @b rep_b
  (map_Stream @list_dim @a @b rep_a rep_b f (traverse_list @a rep_a l));


Indexable_list : IndexableDict (\ (a : box). Boxed (list (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (list (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (list (AsBare a))))
  Functor_list
  shape_list_real
  at_list_real
  slice_list_real
  preserve_list_real;


shape_list (f : FunctorDict (\ (a : box). Boxed (list (AsBare a))))
  -> forall a : box. Boxed (list (AsBare a)) -> list_dim =
  shape_list_real;


shape_list_real @(a : box) (lst : Boxed (list (AsBare a)))
  -> list_dim attribute(inline) =

  case lst of [reprSizeAlign @(list (AsBare a)) (unboxedinfo list @(AsBare a))]
    boxed tyob (make_list @N size ayref).

  fiIntToList_dim @N size;


at_list (f : FunctorDict (\ (a : box). Boxed (list (AsBare a))))
  -> forall a : box.
     ReprBox a -> Boxed (list (AsBare a)) -> Boxed (Stored int) -> a =
  at_list_real;


at_list_real @(a : box) (rep : ReprBox a)
  (lst : Boxed (list (AsBare a))) (i : Boxed (Stored int))
  -> a
  attribute(inline) =

  case lst of [reprSizeAlign @(list (AsBare a)) (unboxedinfo list @(AsBare a))]
    boxed tyob (make_list @N size ayref).

  let rep_array = repr_arr @N @(AsBare a) size rep in

  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_array] stuckBox tyob ay.

  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a)
   (reprSizeAlign @(AsBare a) rep) ay (unboxIntValue i));


slice_list (f : FunctorDict (\ (a : box). Boxed (list (AsBare a))))
  -> forall a : box. ReprBox a -> Boxed (list (AsBare a)) -> list_dim ->
     Boxed (Stored int) -> SomeIndexable list_dim a attribute(inline) =
  slice_list_real;


slice_list_real @(a : box) (rep : ReprBox a)
  (lst : Boxed (list (AsBare a))) (d : list_dim) (off : Boxed (Stored int))
  -> SomeIndexable list_dim a attribute(inline) =

  case lst of [reprSizeAlign @(list (AsBare a)) (unboxedinfo list @(AsBare a))]
    boxed tyob (make_list @N size ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let rep_array = repr_arr @N @(AsBare a) size rep in

  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_array] stuckBox tyob ay.

  case list_dimToFIInt d of someIInt @M slice_size.

  con_someIndexable @list_dim @a @(\ (a : box). Boxed (ListSection a))
  (idCoercion @list_dim)
  Indexable_ListSection
  (con_boxed @(ListSection a) (unboxedinfo ListSection @a)
   (listSection @a @M slice_size rep
    (subarray @N @M @(AsBare a) sa_a ay (unboxIntValue off))));


preserve_list (f : FunctorDict (\ (a : box). Boxed (list (AsBare a))))
  -> forall a : box. Boxed (list (AsBare a)) -> Boxed (list (AsBare a)) =
  preserve_list_real;


-- There is no advantage to disabling optimization on lists
preserve_list_real @(a : box) (x : Boxed (list (AsBare a)))
  -> Boxed (list (AsBare a)) attribute(inline) =
  x;


Traversable_list : TraversableDict (\ (a : box). Boxed (list (AsBare a))) =
  traversableDict @(\ (a : box). Boxed (list (AsBare a)))
  (boxedinfo traversableDict @(\ (a : box). Boxed (list (AsBare a))))
  traverse_list build_list;


traverse_list @(a : box) (rep : ReprBox a) (lst : Boxed (list (AsBare a)))
  -> Stream list_dim a =

  con_stream @list_dim @a hintAny
  (con_ixStream @list_dim @a
   (con_rStream @list_dim @a @a rep (\ (x : a) -> a. x)
    (con_someIndexable @list_dim @a @(\ (a : box). Boxed (ListSection a))
     (idCoercion @list_dim)
     Indexable_ListSection (listToListSection @a rep lst))));


build_list @(a : box) (rep : ReprBox a) (s : Stream list_dim a)
  -> Boxed (list (AsBare a)) attribute(inline) =

  case s of stream tyob par_hint i_s.
  case i_s of {
    seqStream tyob co sq.
      -- TODO
      except @(Boxed (list (AsBare a)))

  ; nestedIxStream @d tyob co shape_dict vw.
      -- TODO
      except @(Boxed (list (AsBare a)))

  ; nestedSeqStream tyob co sq.
      -- TODO
      except @(Boxed (list (AsBare a)))

  ; ixStream tybo (rStream @b tyob2 rep_b f si).
      tabulate_list @b @a rep_b rep par_hint f si
  };


Functor_ListSection : FunctorDict (\ (a : box). Boxed (ListSection a)) =
  functorDict @(\ (a : box). Boxed (ListSection a))
  (boxedinfo functorDict @(\ (a : box). Boxed (ListSection a)))
  map_ListSection;


map_ListSection @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : Boxed (ListSection a))
  -> Boxed (ListSection b) =

  build_ListSection @b rep_b
  (map_Stream @list_dim @a @b rep_a rep_b f
   (traverse_ListSection @a rep_a s));


Indexable_ListSection : IndexableDict (\ (a : box). Boxed (ListSection a)) =
  indexableDict @(\ (a : box). Boxed (ListSection a))
  (boxedinfo indexableDict @(\ (a : box). Boxed (ListSection a)))
  Functor_ListSection shape_ListSection at_ListSection slice_ListSection
  preserve_ListSection;


shape_ListSection @(a : box) (s : Boxed (ListSection a)) -> list_dim =
  case s of [reprSizeAlign @(ListSection a) (unboxedinfo ListSection @a)]
            boxed tyob (listSection @N size rep sec).

  fiIntToList_dim @N size;


at_ListSection @(a : box)
  (rep : ReprBox a) (s : Boxed (ListSection a)) (i : Boxed (Stored int)) -> a
  attribute(inline) =

  case s of [reprSizeAlign @(ListSection a) (unboxedinfo ListSection @a)]
            boxed tyob (listSection @N size rep sec).

  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
   (fromCursor @(arr N (AsBare a)) sec) (unboxIntValue i));


slice_ListSection @(a : box)
  (rep : ReprBox a)
  (s : Boxed (ListSection a)) (d : list_dim) (o : Boxed (Stored int))
  -> SomeIndexable list_dim a
  attribute(inline) =

  case s of [reprSizeAlign @(ListSection a) (unboxedinfo ListSection @a)]
            boxed tyob (listSection @N size rep sec).

  -- Take the subarray starting at offset o, with size d
  let start = unboxIntValue o in
  case list_dimToFIInt d of someIInt @M slice_size.

  let sliced_array : cursor (arr M (AsBare a)) =
        subarray @N @M @(AsBare a) (reprSizeAlign @(AsBare a) rep)
        (fromCursor @(arr N (AsBare a)) sec) start in

  con_someIndexable @list_dim @a @(\ (a : box). Boxed (ListSection a))
  (idCoercion @list_dim) Indexable_ListSection
  (con_boxed @(ListSection a) (unboxedinfo ListSection @a)
   (listSection @a @M slice_size rep sliced_array));


-- Don't deconstruct ListSections that are used in distributed computation.
preserve_ListSection @(a : box) (x : Boxed (ListSection a))
  -> Boxed (ListSection a) attribute(inline) =

  let repr_ListSection = unboxedinfo ListSection @a in
  let sa_ListSection = reprSizeAlign @(ListSection a) repr_ListSection in

  case x of [sa_ListSection] boxed tyob (listSection @N count rep ay_ref).

  -- Prevent it from being deconstructed prior to this program point
  let x2 = preserve @(Boxed (ListSection a)) x in

  -- Now deconstruct and rebuild the ListSection, using the old Repr object.
  -- This allows optimizations to propagate the Repr object.
  case x2 of
    [sa_ListSection] boxed tyob (listSection @N count unused_rep ay_ref).

  con_boxed @(ListSection a) repr_ListSection
  (listSection @a @N count rep ay_ref);


traverse_ListSection @(a : box)
  (rep : ReprBox a) (s : Boxed (ListSection a)) -> Stream list_dim a =

  con_stream @list_dim @a hintAny
  (con_ixStream @list_dim @a
   (con_rStream @list_dim @a @a rep (\ (x : a) -> a. x)
    (con_someIndexable @list_dim @a @(\ (a : box). Boxed (ListSection a))
     (idCoercion @list_dim)
     Indexable_ListSection
     s)));


build_ListSection @(a : box)
  (rep : ReprBox a) (s : Stream list_dim a) -> Boxed (ListSection a) =

  listToListSection @a rep (build_list @a rep s);


Functor_Zip2Indexable @(d : box) -> FunctorDict (Zip2Indexable d) =
  functorDict @(Zip2Indexable d) (boxedinfo functorDict @(Zip2Indexable d))
  (map_Zip2Indexable @d);


map_Zip2Indexable @(domain a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (x : Zip2Indexable domain a)
  -> Zip2Indexable domain b attribute(inline) =

  case x of zip2Indexable @c @d tyob rep_c rep_d g si1 si2.

  con_zip2Indexable @domain @b @c @d
  rep_c rep_d (\ (y : c) (z : d) -> b. f (g y z)) si1 si2;


Indexable_Zip2Indexable @(d : box) (sh : ShapeDict d)
  -> IndexableDict (Zip2Indexable d) =
  indexableDict @(Zip2Indexable d) (boxedinfo indexableDict @(Zip2Indexable d))
  (Functor_Zip2Indexable @d)
  (shape_Zip2Indexable @d sh)
  (at_Zip2Indexable @d sh)
  (slice_Zip2Indexable @d sh)
  (preserve_Zip2Indexable @d sh);


shape_Zip2Indexable @(domain : box) (sh : ShapeDict domain)
  -> forall a : box. Zip2Indexable domain a -> domain attribute(inline) =

  \ @(a : box) (x : Zip2Indexable domain a) -> domain.
    case x of zip2Indexable @c @d tyob rep_c rep_d f si1 si2.
    someIndexableShape @domain @c si1;


at_Zip2Indexable @(domain : box) (sh : ShapeDict domain)
  -> forall a : box. ReprBox a -> Zip2Indexable domain a -> BoxIndex domain -> a
  attribute(inline) =

  \ @(a : box) (rep : ReprBox a) (x : Zip2Indexable domain a) (i : BoxIndex domain) -> a.
    case x of zip2Indexable @c @d tyob rep_c rep_d f si1 si2.
    case si1 of someIndexable @s tyob c1 ix1 container1.
    case si2 of someIndexable @t tyob c2 ix2 container2.

    f (ix_at @s ix1 @c rep_c container1 (coerce @(BoxIndex domain) @(BoxIndex (shape s)) i))
      (ix_at @t ix2 @d rep_d container2 (coerce @(BoxIndex domain) @(BoxIndex (shape t)) i));


slice_Zip2Indexable @(domain : box) (sh : ShapeDict domain)
  -> forall a : box. ReprBox a -> Zip2Indexable domain a -> domain
     -> BoxOffset domain -> SomeIndexable domain a
  attribute(inline) =

  \ @(a : box)
    (rep : ReprBox a) (x : Zip2Indexable domain a)
    (dom : domain) (off : BoxOffset domain)
    -> SomeIndexable domain a.

    slice_Zip2Indexable_real @domain @a sh rep x dom off;


slice_Zip2Indexable_real @(domain a : box) (sh : ShapeDict domain)
  (rep : ReprBox a) (x : Zip2Indexable domain a)
  (dom : domain) (off : BoxOffset domain)
  -> SomeIndexable domain a
  attribute(inline,
            inline_struct(T T D(T T T T T) T T) -- Inline if object is known
           ) =

    case x of zip2Indexable @c @d tyob rep_c rep_d f si1 si2.
    case si1 of someIndexable @s tyob c1 ix1 container1.
    case si2 of someIndexable @t tyob c2 ix2 container2.
    
    con_someIndexable @domain @a @(Zip2Indexable domain)
    (idCoercion @domain)
    (Indexable_Zip2Indexable @domain sh)
    (con_zip2Indexable @domain @a @c @d rep_c rep_d f
     (coerce @(SomeIndexable (shape s) c) @(SomeIndexable domain c)
      (ix_slice @s ix1 @c rep_c container1
       (coerce @domain @(shape s) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape s))) off)))
     (coerce @(SomeIndexable (shape t) d) @(SomeIndexable domain d)
      (ix_slice @t ix2 @d rep_d container2
       (coerce @domain @(shape t) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape t))) off))));


preserve_Zip2Indexable @(d : box) (sh : ShapeDict d)
  -> forall a : box. Zip2Indexable d a -> Zip2Indexable d a attribute(inline) =

  \ @(a : box) (x : Zip2Indexable d a) -> Zip2Indexable d a.
    case x of zip2Indexable @(b c : box) tyob rep_b rep_c f c1 c2.
    zip2Indexable @d @a @b @c tyob rep_b rep_c f
    (preserve_SomeIndexable @d @b c1) (preserve_SomeIndexable @d @c c2);


{-
-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_Zip2Indexable2 @(d : box) (sh : ShapeDict d)
  -> IndexableDict (Zip2Indexable d) =
  indexableDict @(Zip2Indexable d) (boxedinfo indexableDict @(Zip2Indexable d))
  (Functor_Zip2Indexable @d)
  (shape_Zip2Indexable @d sh)
  (at_Zip2Indexable @d sh)
  (slice_Zip2Indexable2 @d sh)
  (preserve_Zip2Indexable @d sh);

slice_Zip2Indexable2 @(domain : box) (sh : ShapeDict domain)
  -> forall a : box. ReprBox a -> Zip2Indexable domain a -> domain
     -> BoxOffset domain -> SomeIndexable domain a
  attribute(inline) =

  \ @(a : box)
    (rep : ReprBox a) (x : Zip2Indexable domain a)
    (dom : domain) (off : BoxOffset domain)
    -> SomeIndexable domain a.

    case x of zip2Indexable @c @d tyob rep_c rep_d f si1 si2.
    case si1 of someIndexable @s tyob c1 ix1 container1.
    case si2 of someIndexable @t tyob c2 ix2 container2.
    
    con_someIndexable @domain @a @(Zip2Indexable domain)
    (idCoercion @domain)
    (Indexable_Zip2Indexable3 @domain sh)
    (con_zip2Indexable @domain @a @c @d rep_c rep_d f
     (coerce @(SomeIndexable (shape s) c) @(SomeIndexable domain c)
      (ix_slice @s ix1 @c rep_c container1
       (coerce @domain @(shape s) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape s))) off)))
     (coerce @(SomeIndexable (shape t) d) @(SomeIndexable domain d)
      (ix_slice @t ix2 @d rep_d container2
       (coerce @domain @(shape t) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape t))) off))));


-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_Zip2Indexable3 @(d : box) (sh : ShapeDict d)
  -> IndexableDict (Zip2Indexable d) =
  indexableDict @(Zip2Indexable d) (boxedinfo indexableDict @(Zip2Indexable d))
  (Functor_Zip2Indexable @d)
  (shape_Zip2Indexable @d sh)
  (at_Zip2Indexable @d sh)
  (slice_Zip2Indexable3 @d sh)
  (preserve_Zip2Indexable @d sh);

slice_Zip2Indexable3 @(domain : box) (sh : ShapeDict domain)
  -> forall a : box. ReprBox a -> Zip2Indexable domain a -> domain
     -> BoxOffset domain -> SomeIndexable domain a
  attribute(inline) =

  \ @(a : box)
    (rep : ReprBox a) (x : Zip2Indexable domain a)
    (dom : domain) (off : BoxOffset domain)
    -> SomeIndexable domain a.

    case x of zip2Indexable @c @d tyob rep_c rep_d f si1 si2.
    case si1 of someIndexable @s tyob c1 ix1 container1.
    case si2 of someIndexable @t tyob c2 ix2 container2.
    
    con_someIndexable @domain @a @(Zip2Indexable domain)
    (idCoercion @domain)
    (Indexable_Zip2Indexable4 @domain sh)
    (con_zip2Indexable @domain @a @c @d rep_c rep_d f
     (coerce @(SomeIndexable (shape s) c) @(SomeIndexable domain c)
      (ix_slice @s ix1 @c rep_c container1
       (coerce @domain @(shape s) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape s))) off)))
     (coerce @(SomeIndexable (shape t) d) @(SomeIndexable domain d)
      (ix_slice @t ix2 @d rep_d container2
       (coerce @domain @(shape t) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape t))) off))));


-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_Zip2Indexable4 @(d : box) (sh : ShapeDict d)
  -> IndexableDict (Zip2Indexable d) =
  indexableDict @(Zip2Indexable d) (boxedinfo indexableDict @(Zip2Indexable d))
  (Functor_Zip2Indexable @d)
  (shape_Zip2Indexable @d sh)
  (at_Zip2Indexable @d sh)
  (slice_Zip2Indexable4 @d sh)
  (preserve_Zip2Indexable @d sh);

slice_Zip2Indexable4 @(domain : box) (sh : ShapeDict domain)
  -> forall a : box. ReprBox a -> Zip2Indexable domain a -> domain
     -> BoxOffset domain -> SomeIndexable domain a
  attribute(inline_never) =

  \ @(a : box)
    (rep : ReprBox a) (x : Zip2Indexable domain a)
    (dom : domain) (off : BoxOffset domain)
    -> SomeIndexable domain a.

    case x of zip2Indexable @c @d tyob rep_c rep_d f si1 si2.
    case si1 of someIndexable @s tyob c1 ix1 container1.
    case si2 of someIndexable @t tyob c2 ix2 container2.
    
    con_someIndexable @domain @a @(Zip2Indexable domain)
    (idCoercion @domain)
    (Indexable_Zip2Indexable4 @domain sh)
    (con_zip2Indexable @domain @a @c @d rep_c rep_d f
     (coerce @(SomeIndexable (shape s) c) @(SomeIndexable domain c)
      (ix_slice @s ix1 @c rep_c container1
       (coerce @domain @(shape s) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape s))) off)))
     (coerce @(SomeIndexable (shape t) d) @(SomeIndexable domain d)
      (ix_slice @t ix2 @d rep_d container2
       (coerce @domain @(shape t) dom)
       (coerce @(AsBox (offset domain)) @(AsBox (offset (shape t))) off))));
-}

Functor_array1 : FunctorDict (\ (a : box). Boxed (array1 (AsBare a))) =
  functorDict @(\ (a : box). Boxed (array1 (AsBare a)))
  (boxedinfo functorDict @(\ (a : box). Boxed (array1 (AsBare a))))
  map_array1;


map_array1 @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b)
  (l : Boxed (array1 (AsBare a)))
  -> Boxed (array1 (AsBare b)) attribute(inline) =

  build_array1 @b rep_b
  (map_Stream @dim1 @a @b rep_a rep_b f (traverse_array1 @a rep_a l));


Indexable_array1 : IndexableDict (\ (a : box). Boxed (array1 (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (array1 (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (array1 (AsBare a))))
  Functor_array1
  shape_array1_real
  at_array1_real
  slice_array1_real
  preserve_array1_real;


-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_array1_2 : IndexableDict (\ (a : box). Boxed (array1 (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (array1 (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (array1 (AsBare a))))
  Functor_array1
  shape_array1_real
  at_array1_real
  slice_array1_real_2
  preserve_array1_real;


-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_array1_3 : IndexableDict (\ (a : box). Boxed (array1 (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (array1 (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (array1 (AsBare a))))
  Functor_array1
  shape_array1_real
  at_array1_real
  slice_array1_real_3
  preserve_array1_real;


shape_array1 (f : FunctorDict (\ (a : box). Boxed (array1 (AsBare a))))
  -> forall a : box. Boxed (array1 (AsBare a)) -> dim1 =
  shape_array1_real;


shape_array1_real @(a : box) (lst : Boxed (array1 (AsBare a)))
  -> dim1 attribute(inline) =

  case lst of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @N lb stride size ayref).

  arrayDescToDim1 @N lb stride size;


at_array1 (f : FunctorDict (\ (a : box). Boxed (array1 (AsBare a))))
  -> forall a : box.
     ReprBox a -> Boxed (array1 (AsBare a)) -> Boxed (Stored int) -> a =
  at_array1_real;


at_array1_real @(a : box) (rep : ReprBox a)
  (lst : Boxed (array1 (AsBare a))) (i : Boxed (Stored int))
  -> a
  attribute(inline) =

  case lst of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @N lb stride size ayref).
  let rep_array = repr_arr @N @(AsBare a) size rep in
  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_array] stuckBox tyob ay.

  let real_index = (unboxIntValue i -# lb) //# stride in

  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a)
   (reprSizeAlign @(AsBare a) rep) ay real_index);


slice_array1 (f : FunctorDict (\ (a : box). Boxed (array1 (AsBare a))))
  -> forall a : box. ReprBox a -> Boxed (array1 (AsBare a)) -> dim1 ->
     Boxed (Stored NoneType) -> SomeIndexable dim1 a attribute(inline) =
  slice_array1_real;


slice_array1_real @(a : box) (rep : ReprBox a)
  (lst : Boxed (array1 (AsBare a))) (d : dim1) (off : Boxed (Stored NoneType))
  -> SomeIndexable dim1 a attribute(inline) =

  case lst of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @N lb stride size ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let rep_array = repr_arr @N @(AsBare a) size rep in

  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_array] stuckBox tyob ay.

  case dim1ToArraySize d of arraySize @M slice_lb slice_stride slice_size.

  -- TODO: Use an array section if possible to avoid copying
  -- Copy the array subset into a new array
  let new_arr = build_array1 @a rep
                (traverse_view_real @dim1 @a ShapeDict_dim1 rep
                 (con_view @dim1 @a d
                  (\ (b_ix : Boxed (Stored int)) -> a.
                     let real_index = (unboxIntValue b_ix -# lb) //# stride in
                     bareToBox @(AsBare a) rep
                     (subscript @N @(AsBare a)
                      (reprSizeAlign @(AsBare a) rep) ay real_index)))) in

  con_someIndexable @dim1 @a @(\ (a : box). Boxed (array1 (AsBare a)))
  (idCoercion @dim1) Indexable_array1_2 new_arr;


-- Workaround for inlining
-- FIXME: Handle recursion properly
slice_array1_real_2 @(a : box) (rep : ReprBox a)
  (lst : Boxed (array1 (AsBare a))) (d : dim1) (off : Boxed (Stored NoneType))
  -> SomeIndexable dim1 a attribute(inline) =

  case lst of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @N lb stride size ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let rep_array = repr_arr @N @(AsBare a) size rep in

  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_array] stuckBox tyob ay.

  case dim1ToArraySize d of arraySize @M slice_lb slice_stride slice_size.

  -- TODO: Use an array section if possible to avoid copying
  -- Copy the array subset into a new array
  let new_arr = build_array1 @a rep
                (traverse_view_real @dim1 @a ShapeDict_dim1 rep
                 (con_view @dim1 @a d
                  (\ (b_ix : Boxed (Stored int)) -> a.
                     let real_index = (unboxIntValue b_ix -# lb) //# stride in
                     bareToBox @(AsBare a) rep
                     (subscript @N @(AsBare a)
                      (reprSizeAlign @(AsBare a) rep) ay real_index)))) in

  con_someIndexable @dim1 @a @(\ (a : box). Boxed (array1 (AsBare a)))
  (idCoercion @dim1) Indexable_array1_2 new_arr;


-- Workaround for inlining
-- FIXME: Handle recursion properly
slice_array1_real_3 @(a : box) (rep : ReprBox a)
  (lst : Boxed (array1 (AsBare a))) (d : dim1) (off : Boxed (Stored NoneType))
  -> SomeIndexable dim1 a attribute(inline_never) =

  case lst of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @N lb stride size ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let rep_array = repr_arr @N @(AsBare a) size rep in

  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_array] stuckBox tyob ay.

  case dim1ToArraySize d of arraySize @M slice_lb slice_stride slice_size.

  -- TODO: Use an array section if possible to avoid copying
  -- Copy the array subset into a new array
  let new_arr = build_array1 @a rep
                (traverse_view_real @dim1 @a ShapeDict_dim1 rep
                 (con_view @dim1 @a d
                  (\ (b_ix : Boxed (Stored int)) -> a.
                     let real_index = (unboxIntValue b_ix -# lb) //# stride in
                     bareToBox @(AsBare a) rep
                     (subscript @N @(AsBare a)
                      (reprSizeAlign @(AsBare a) rep) ay real_index)))) in

  con_someIndexable @dim1 @a @(\ (a : box). Boxed (array1 (AsBare a)))
  (idCoercion @dim1) Indexable_array1_3 new_arr;


preserve_array1 (f : FunctorDict (\ (a : box). Boxed (array1 (AsBare a))))
  -> forall a : box. Boxed (array1 (AsBare a)) -> Boxed (array1 (AsBare a)) =
  preserve_array1_real;


Traversable_array1 : TraversableDict (\ (a : box). Boxed (array1 (AsBare a))) =
  traversableDict @(\ (a : box). Boxed (array1 (AsBare a)))
  (boxedinfo traversableDict @(\ (a : box). Boxed (array1 (AsBare a))))
  traverse_array1 build_array1;


traverse_array1 @(a : box) (rep : ReprBox a) (lst : Boxed (array1 (AsBare a)))
  -> Stream dim1 a =

  con_stream @dim1 @a hintAny
  (con_ixStream @dim1 @a
   (con_rStream @dim1 @a @a rep (\ (x : a) -> a. x)
    (con_someIndexable @dim1 @a @(\ (a : box). Boxed (array1 (AsBare a)))
     (idCoercion @dim1)
     Indexable_array1 lst)));


build_array1 @(a : box) (rep : ReprBox a) (s : Stream dim1 a)
  -> Boxed (array1 (AsBare a)) attribute(inline) =

  case s of stream tyob par_hint i_s.
  case fromIxStream @dim1 @a i_s of rStream @b tyob rep_b f si.
  tabulate_array1 @b @a rep_b rep par_hint f si;


-- There is no advantage to disabling optimization on array1s
preserve_array1_real @(a : box) (x : Boxed (array1 (AsBare a)))
  -> Boxed (array1 (AsBare a)) attribute(inline) =
  x;


Functor_array2 : FunctorDict (\ (a : box). Boxed (array2 (AsBare a))) =
  functorDict @(\ (a : box). Boxed (array2 (AsBare a)))
  (boxedinfo functorDict @(\ (a : box). Boxed (array2 (AsBare a))))
  map_array2;


map_array2 @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b)
  (l : Boxed (array2 (AsBare a)))
  -> Boxed (array2 (AsBare b)) attribute(inline) =

  build_array2 @b rep_b
  (map_Stream @dim2 @a @b rep_a rep_b f (traverse_array2 @a rep_a l));


Indexable_array2 : IndexableDict (\ (a : box). Boxed (array2 (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (array2 (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (array2 (AsBare a))))
  Functor_array2
  shape_array2_real
  at_array2_real
  slice_array2_real
  preserve_array2_real;


-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_array2_2 : IndexableDict (\ (a : box). Boxed (array2 (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (array2 (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (array2 (AsBare a))))
  Functor_array2
  shape_array2_real
  at_array2_real
  slice_array2_real_2
  preserve_array2_real;


-- Workaround for inlining
-- FIXME: Handle recursion properly
Indexable_array2_3 : IndexableDict (\ (a : box). Boxed (array2 (AsBare a))) =
  indexableDict @(\ (a : box). Boxed (array2 (AsBare a)))
  (boxedinfo indexableDict @(\ (a : box). Boxed (array2 (AsBare a))))
  Functor_array2
  shape_array2_real
  at_array2_real
  slice_array2_real_3
  preserve_array2_real;


shape_array2 (f : FunctorDict (\ (a : box). Boxed (array2 (AsBare a))))
  -> forall a : box. Boxed (array2 (AsBare a)) -> dim2 =
  shape_array2_real;


shape_array2_real @(a : box) (lst : Boxed (array2 (AsBare a)))
  -> dim2 attribute(inline) =

  case lst of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @M @N lb_y stride_y size_y lb_x stride_x size_x ayref).

  con_dim2 (arrayDescToDim1 @M lb_y stride_y size_y)
           (arrayDescToDim1 @N lb_x stride_x size_x);


at_array2 (f : FunctorDict (\ (a : box). Boxed (array2 (AsBare a))))
  -> forall a : box.
     ReprBox a -> Boxed (array2 (AsBare a)) -> BoxIndex dim2 -> a =
  at_array2_real;


at_array2_real @(a : box) (rep : ReprBox a)
  (lst : Boxed (array2 (AsBare a))) (i : BoxIndex dim2)
  -> a
  attribute(inline) =

  case lst of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @M @N lb_y stride_y size_y lb_x stride_x size_x ayref).

  let type row_type = arr N (AsBare a) in
  let rep_row = repr_arr @N @(AsBare a) size_x rep in
  let rep_array = repr_arr @M @row_type size_y rep_row in
  case ayref of [reprSizeAlign @(arr M row_type) rep_array] stuckBox tyob ay.

  case unpack_index2 i of (y, x).
  let real_y = (y -# lb_y) //# stride_y in
  let real_x = (x -# lb_x) //# stride_x in

  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
   (subscript @M @row_type (reprSizeAlign @row_type rep_row) ay real_y) real_x);


slice_array2 (f : FunctorDict (\ (a : box). Boxed (array2 (AsBare a))))
  -> forall a : box. ReprBox a -> Boxed (array2 (AsBare a)) -> dim2 ->
     Boxed (Stored NoneType) -> SomeIndexable dim2 a attribute(inline) =
  slice_array2_real;


slice_array2_real @(a : box) (rep : ReprBox a)
  (lst : Boxed (array2 (AsBare a))) (d : dim2) (off : Boxed (Stored NoneType))
  -> SomeIndexable dim2 a attribute(inline) =

  case lst of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @M @N lb_y stride_y size_y lb_x stride_x size_x ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let type row_type = arr N (AsBare a) in
  let rep_row = repr_arr @N @(AsBare a) size_x rep in
  let rep_array = repr_arr @M @row_type size_y rep_row in
  case ayref of [reprSizeAlign @(arr M row_type) rep_array] stuckBox tyob ay.

  case d of mk_dim2 tyob d_y d_x.
  case dim1ToArraySize d_y of arraySize @Mslice slice_lb_y slice_stride_y slice_size_y.
  case dim1ToArraySize d_x of arraySize @Nslice slice_lb_x slice_stride_x slice_size_x.

  -- TODO: Use an array section if possible to avoid copying
  -- Copy the array subset into a new array
  let new_arr = build_array2 @a rep
                (traverse_view_real @dim2 @a ShapeDict_dim2 rep
                 (con_view @dim2 @a d
                  (\ (b_ix : BoxIndex dim2) -> a.
                     case unpack_index2 b_ix of (y, x).
                     let real_y = (y -# lb_y) //# stride_y in
                     let real_x = (x -# lb_x) //# stride_x in
                     bareToBox @(AsBare a) rep
                     (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
                      (subscript @M @row_type (reprSizeAlign @row_type rep_row) ay real_y) real_x)))) in

  con_someIndexable @dim2 @a @(\ (a : box). Boxed (array2 (AsBare a)))
  (idCoercion @dim2) Indexable_array2_2 new_arr;


-- Workaround for inlining
-- FIXME: Handle recursion properly
slice_array2_real_2 @(a : box) (rep : ReprBox a)
  (lst : Boxed (array2 (AsBare a))) (d : dim2) (off : Boxed (Stored NoneType))
  -> SomeIndexable dim2 a attribute(inline) =

  case lst of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @M @N lb_y stride_y size_y lb_x stride_x size_x ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let type row_type = arr N (AsBare a) in
  let rep_row = repr_arr @N @(AsBare a) size_x rep in
  let rep_array = repr_arr @M @row_type size_y rep_row in
  case ayref of [reprSizeAlign @(arr M row_type) rep_array] stuckBox tyob ay.

  case d of mk_dim2 tyob d_y d_x.
  case dim1ToArraySize d_y of arraySize @Mslice slice_lb_y slice_stride_y slice_size_y.
  case dim1ToArraySize d_x of arraySize @Nslice slice_lb_x slice_stride_x slice_size_x.

  -- TODO: Use an array section if possible to avoid copying
  -- Copy the array subset into a new array
  let new_arr = build_array2 @a rep
                (traverse_view_real @dim2 @a ShapeDict_dim2 rep
                 (con_view @dim2 @a d
                  (\ (b_ix : BoxIndex dim2) -> a.
                     case unpack_index2 b_ix of (y, x).
                     let real_y = (y -# lb_y) //# stride_y in
                     let real_x = (x -# lb_x) //# stride_x in
                     bareToBox @(AsBare a) rep
                     (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
                      (subscript @M @row_type (reprSizeAlign @row_type rep_row) ay real_y) real_x)))) in

  con_someIndexable @dim2 @a @(\ (a : box). Boxed (array2 (AsBare a)))
  (idCoercion @dim2) Indexable_array2_3 new_arr;


-- Workaround for inlining
-- FIXME: Handle recursion properly
slice_array2_real_3 @(a : box) (rep : ReprBox a)
  (lst : Boxed (array2 (AsBare a))) (d : dim2) (off : Boxed (Stored NoneType))
  -> SomeIndexable dim2 a attribute(inline_never) =

  case lst of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @M @N lb_y stride_y size_y lb_x stride_x size_x ayref).

  let sa_a = reprSizeAlign @(AsBare a) rep in
  let type row_type = arr N (AsBare a) in
  let rep_row = repr_arr @N @(AsBare a) size_x rep in
  let rep_array = repr_arr @M @row_type size_y rep_row in
  case ayref of [reprSizeAlign @(arr M row_type) rep_array] stuckBox tyob ay.

  case d of mk_dim2 tyob d_y d_x.
  case dim1ToArraySize d_y of arraySize @Mslice slice_lb_y slice_stride_y slice_size_y.
  case dim1ToArraySize d_x of arraySize @Nslice slice_lb_x slice_stride_x slice_size_x.

  -- TODO: Use an array section if possible to avoid copying
  -- Copy the array subset into a new array
  let new_arr = build_array2 @a rep
                (traverse_view_real @dim2 @a ShapeDict_dim2 rep
                 (con_view @dim2 @a d
                  (\ (b_ix : BoxIndex dim2) -> a.
                     case unpack_index2 b_ix of (y, x).
                     let real_y = (y -# lb_y) //# stride_y in
                     let real_x = (x -# lb_x) //# stride_x in
                     bareToBox @(AsBare a) rep
                     (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
                      (subscript @M @row_type (reprSizeAlign @row_type rep_row) ay real_y) real_x)))) in

  con_someIndexable @dim2 @a @(\ (a : box). Boxed (array2 (AsBare a)))
  (idCoercion @dim2) Indexable_array2_3 new_arr;


preserve_array2 (f : FunctorDict (\ (a : box). Boxed (array2 (AsBare a))))
  -> forall a : box. Boxed (array2 (AsBare a)) -> Boxed (array2 (AsBare a)) =
  preserve_array2_real;


Traversable_array2 : TraversableDict (\ (a : box). Boxed (array2 (AsBare a))) =
  traversableDict @(\ (a : box). Boxed (array2 (AsBare a)))
  (boxedinfo traversableDict @(\ (a : box). Boxed (array2 (AsBare a))))
  traverse_array2 build_array2;


traverse_array2 @(a : box) (rep : ReprBox a) (lst : Boxed (array2 (AsBare a)))
  -> Stream dim2 a =

  con_stream @dim2 @a hintAny
  (con_ixStream @dim2 @a
   (con_rStream @dim2 @a @a rep (\ (x : a) -> a. x)
    (con_someIndexable @dim2 @a @(\ (a : box). Boxed (array2 (AsBare a)))
     (idCoercion @dim2)
     Indexable_array2 lst)));


build_array2 @(a : box) (rep : ReprBox a) (s : Stream dim2 a)
  -> Boxed (array2 (AsBare a)) attribute(inline) =

  case s of stream tyob par_hint i_s.
  case fromIxStream @dim2 @a i_s of rStream @b tyob rep_b f si.
  tabulate_array2 @b @a rep_b rep par_hint f si;


-- There is no advantage to disabling optimization on array2s
preserve_array2_real @(a : box) (x : Boxed (array2 (AsBare a)))
  -> Boxed (array2 (AsBare a)) attribute(inline) =
  x;



llistLength @(a : box) (rep_a : ReprBox a) (l : llist (AsBare a)) -> int
  attribute(inline) =

  let sa = reprSizeAlign @(AsBare a) rep_a in

  letfun
    go (n : int) (l : llist (AsBare a)) -> int =
      case l of [sa] {
        cons tyob h t. go (n +# 1) t
      ; nil tyob.      n
      }
  in go 0 l;


-- Map over a linked list and write the results into an array.
-- The given size must match the list size.
llistToArrMapped @(N : intindex) @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b) (size : FIInt N)
  (f : AsBare a -> OutPtr (AsBare b) -> Store)
  (l : llist (AsBare a))
  -> Boxed (arr N (AsBare b)) attribute(inline) =

  let type a_bare = AsBare a in
  let type b_bare = AsBare b in
  let sa_a = reprSizeAlign @a_bare rep_a in
  let sa_b = reprSizeAlign @b_bare rep_b in

  let rep_array = repr_arr @N @b_bare size rep_b in

  con_boxed @(arr N b_bare) rep_array
  (\ (ret : OutPtr (arr N b_bare)) -> Store.

     letfun
       loop (i : int) (l : llist a_bare) (s : Store) -> Store =
         case l of [sa_a] {
           cons tyob h t.
             let s2 =
                   seqStore s (f h (subscript_out @N @b_bare sa_b ret i)) in
             loop (i +# 1) t s2
         ; nil tyob.
             s
         }
     in loop 0 l emptyStore);


-- TODO: Use streams
map_llist @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b)
  (l : llist (AsBare a))
  -> llist (AsBare b) attribute(inline, inline_sequential) =

  let type a_bare = AsBare a in
  let type b_bare = AsBare b in
  let sa_a = reprSizeAlign @a_bare rep_a in

  letfun
    loop (l : llist a_bare) -> llist b_bare =
      case l of [sa_a] {
        cons tyob h t.
          con_cons @b_bare rep_b
          (asbare @b_bare rep_b (f (bareToBox @a_bare rep_a h)))
          (loop t)
      ; nil tyob.
          con_nil @b_bare rep_b
      }
  in
  loop l;


map_llist_bare @(a b : bare)
  (rep_a : Repr a) (rep_b : Repr b)
  (f : a -> Init b)
  (l : llist a)
  -> llist b attribute(inline) =

  let sa_a = reprSizeAlign @a rep_a in

  letfun
    loop (l : llist a) -> llist b =
      case l of [sa_a] {
        cons tyob h t.
          con_cons @b rep_b (f h) (loop t)
      ; nil tyob.
          con_nil @b rep_b
      }
  in
  loop l;


-------------------------------------------------------------------------------
-- Additional stream functions


chain @(a : box) (s1 s2 : Stream list_dim a) -> Stream list_dim a =

  -- TODO
  except @(Stream list_dim a);

reduce_Stream @(d a : box) (sh : ShapeDict d) (rep : ReprBox a)
  (f : a -> a -> a) (z : a) (s : Stream d a)
  -> a attribute(inline,
                 inline_struct(T T T T D(T C)) -- Inline if stream is known
                ) =

  letfun
    -- Perform a final reduction on partial results
    reduce_residual (s : Stream list_dim a) -> a =
      real_fold_list_dim @a @a rep rep f s z
  in

  letfun
    reduce_unit (dummy : NoneType) -> a = z
  in

  case s of stream tyob par_hint i_s.
  case i_s of {
    seqStream tyob co sq.
      fold_Seq @a @a f sq z

  ; nestedIxStream @d2 tyob co sh2 (rStream @b tyob2 rep_b extract si).
      let input_domain = someIndexableShape @d2 @b si in

      letfun
        reduce_slice (si : SomeIndexable d2 b) -> a =
          -- Check the domain
          let slice_domain = someIndexableShape @d2 @b si in
          if shCheckSubdomain @d2 sh2 input_domain slice_domain
          then
            case si of someIndexable @t tyob (co : coerce @box (shape t) d2) ix container.
            let vw = indexableToView @t @b rep_b ix container in

            -- Reduce over inner loop
            let vw2 = map_view @d2 @b @a rep_b rep
                      (\ (x : b) -> a.
                         reduce_Stream @list_dim @a ShapeDict_list_dim rep f z
                         (extract x))
                      (coerce @(view (shape t) b) @(view d2 b) vw) in

            -- Sequentially reduce the partial results for this loop
            let local_s = traverse_view_real @d2 @a sh2 rep vw2 in
            shFold @d2 sh2 @a @a rep rep f local_s z
          else except @a
      in
      reduce_loop @d2 @b @a sh2 rep_b rep par_hint
      reduce_unit reduce_slice f reduce_residual si

  ; nestedSeqStream tyob co sq.
      -- Sequential fold over the sequence
      fold_Seq @(Stream list_dim a) @a
      (\ (inner_stream : Stream list_dim a) (ac : a) -> a.
         -- Recursively reduce inner stream
         let inner_value =
               reduce_Stream @list_dim @a ShapeDict_list_dim rep f z inner_stream in
         f ac inner_value)
      sq z

  ; ixStream tyob (rStream @b tyob2 rep_b extract si).
      let input_domain = someIndexableShape @d @b si in
      letfun
        reduce_slice (si : SomeIndexable d b) -> a =
          -- Check the domain
          let slice_domain = someIndexableShape @d @b si in
          if shCheckSubdomain @d sh input_domain slice_domain
          then
            -- Sequentially reduce the partial results for this loop
            let local_s = con_stream @d @a hintSeq
                          (ixStream @d @a tyob (rStream @d @a @b tyob2 rep_b extract si)) in
            shFold @d sh @a @a rep rep f local_s z
          else except @a
      in
      reduce_loop @d @b @a sh rep_b rep par_hint
      reduce_unit reduce_slice f reduce_residual si
  };


-------------------------------------------------------------------------------
-- Collectors

-- Compute a list histogram.
-- This is a specialized instance of 'collect'.
histogram @(t : box -> box) @(v : box)
  (traversable_t : TraversableDict t)
  (shape_t : ShapeDict (shape t))
  (rep_v : ReprBox v)
  (mut_v : Mutable (AsBare v))
  (additive_v : AdditiveDict v)
  (size : int)
  (input : t (Boxed (Tuple2 (Stored int) (AsBare v))))
  -> Boxed (list (AsBare v))
  attribute(inline) =

  let rep_list = unboxedinfo list @(AsBare v) in

  -- Size must be nonnegative
  let dom : list_dim = if size <# 0 then except @list_dim else
                       con_list_dim (justVal @int size) in

  case additive_v of additiveDict tyob add sub negate zero.

  let coll = listCollector @(Boxed (Stored NoneType)) @v @v
             repr_NoneType rep_v rep_v
             (valueCollector @v rep_v mut_v add zero)
             dom in

  -- Transform each input tuple from (k, v) to ((k, None), v)
  case traversable_t of traversableDict tyob traverse build.

  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let sa_NoneType = reprSizeAlign @(Stored NoneType) repr_NoneType in
  let sa_v = reprSizeAlign @(AsBare v) rep_v in
  let type input_tuple = Tuple2 (Stored int) (AsBare v) in
  let rep_input_tuple = unboxedinfo Tuple2 @(Stored int) @(AsBare v)
                        repr_int rep_v in
  let type key = Tuple2 (Stored int) (Stored NoneType) in
  let rep_key = unboxedinfo Tuple2 @(Stored int) @(Stored NoneType)
                repr_int repr_NoneType in
  let sa_key = reprSizeAlign @key rep_key in
  let type transformed_tuple = Tuple2 key (AsBare v) in
  let rep_transformed_tuple = unboxedinfo Tuple2 @key @(AsBare v)
                              rep_key rep_v in

  let input_s = traverse @(Boxed input_tuple) rep_input_tuple input in
  letfun
    transform_tuple (x : Boxed input_tuple) -> Boxed transformed_tuple =
      case x of [reprSizeAlign @input_tuple rep_input_tuple]
        boxed tyob ([sa_int, sa_v] tuple2 (stored idx) bare_v).

      con_boxed @transformed_tuple rep_transformed_tuple
      (tuple2 @key @(AsBare v) sa_key sa_v
       (tuple2 @(Stored int) @(Stored NoneType) sa_int sa_NoneType
        (stored @int idx) (stored @NoneType None))
       (copy @(AsBare v) rep_v bare_v))
  in
  let transformed_s =
        map_Stream @(shape t) @(Boxed input_tuple) @(Boxed transformed_tuple)
        rep_input_tuple rep_transformed_tuple transform_tuple input_s in

  collect @(Stream (shape t)) @(Boxed key) @v
  @(Boxed (list (AsBare v)))
  (Traversable_Stream @(shape t))
  shape_t rep_key rep_v rep_list coll transformed_s;


collect @(t : box -> box) @(k v r : box)
  (traversable_dict : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (rep_k : ReprBox k) (rep_v : ReprBox v) (rep_r : ReprBox r)
  (coll : Collector k v r)
  (input : t (Boxed (Tuple2 (AsBare k) (AsBare v))))
  -> r
  attribute(inline) =

  case traversable_dict of traversableDict tyob traverse build.

  let rep_tuple = unboxedinfo Tuple2 @(AsBare k) @(AsBare v) rep_k rep_v in

  collect_Stream @(shape t) @k @v @r shape_dict rep_k rep_v rep_r
  coll
  (traverse @(Boxed (Tuple2 (AsBare k) (AsBare v))) rep_tuple input);


{-
-- This is the main entry point to the collector interface.
-- Update an accumulator in-place where possible; use a global reduction to
-- combine partial results.
collect_Stream @(d : box) @(k v r : box)
  (shape_dict : ShapeDict d)
  (rep_k : ReprBox k) (rep_v : ReprBox v) (rep_r : ReprBox r)
  (coll : Collector k v r)
  (input : Stream d (Boxed (Tuple2 (AsBare k) (AsBare v))))
  -> r
  attribute(inline) =

  case coll of
    collector @acc tyob
    rep_acc init read write update combine combine_stream finalizer.

  letfun
    do_seq (dummy : NoneType) -> r =
      finalize_collect_seq @acc @r rep_acc
      (\ (ret : OutPtr acc) -> Store.
         -- Initialize
         let init_store = init ret in

         -- Collect
         partial_collect @d @k @v @acc
         shape_dict rep_k rep_v rep_acc
         read write update input ret init_store)
      finalizer
  in

  letfun
    do_par (dummy : NoneType) -> r =
      finalize_collect_seq @acc @r rep_acc
      (\ (ret : OutPtr acc) -> Store.
         -- Initialize
         let init_store = init ret in

         -- Collect
         partial_collect @d @k @v @acc
         shape_dict rep_k rep_v rep_acc
         read write update input ret init_store)
      finalizer
  in

  case input of stream tyob par_hint i_s.
  case par_hint of {
    hintAny. do_seq None
  ; hintSeq. do_seq None
  ; hintLocalPar. do_par None
  ; hintPar. do_par None
  };
-}


-- This is the main entry point to the collector interface.
-- Update an accumulator in-place where possible; use a global reduction to
-- combine partial results.
collect_Stream @(d : box) @(k v r : box)
  (shape_dict : ShapeDict d)
  (rep_k : ReprBox k) (rep_v : ReprBox v) (rep_r : ReprBox r)
  (coll : Collector k v r)
  (input : Stream d (Boxed (Tuple2 (AsBare k) (AsBare v))))
  -> r
  attribute(inline) =

  let type stream_elem = Boxed (Tuple2 (AsBare k) (AsBare v)) in

  case coll of
    collector @acc tyob
    rep_acc init read write update combine combine_stream finalizer.

  letfun
    do_seq (dummy : NoneType) -> r =
      finalize_collect_seq @acc @r rep_acc
      (\ (ret : OutPtr acc) -> Store.
         -- Initialize
         let init_store = init ret in

         -- Collect
         partial_collect @d @k @v @acc
         shape_dict rep_k rep_v rep_acc
         read write update input ret init_store)
      finalizer
  in

  let type acc_cursor = Boxed (Stored (cursor acc)) in

  letfun
    reduce_residual (s : Stream list_dim acc_cursor) -> acc_cursor =
      case con_stuckBox @acc rep_acc (combine_stream s) of
        [reprSizeAlign @acc rep_acc] stuckBox tyob x.
      con_boxed @(Stored (cursor acc)) (repr_cursor @acc)
      (stored @(cursor acc) (toCursor @acc x))
  in

  letfun
    reduce_unit (dummy : NoneType) -> acc_cursor =
      case con_stuckBox @acc rep_acc init of
        [reprSizeAlign @acc rep_acc] stuckBox tyob x.
      con_boxed @(Stored (cursor acc)) (repr_cursor @acc)
      (stored @(cursor acc) (toCursor @acc x))
  in

  letfun
    finalize_cursor (r_cursor : acc_cursor) -> r =
      case r_cursor of [reprSizeAlign @(Stored (cursor acc)) (repr_cursor @acc)]
        boxed tyob (stored c).
      finalize_collect_reduction @acc @r rep_acc (fromCursor @acc c) finalizer
  in

  letfun
    combine_cursors (x_cursor y_cursor : acc_cursor) -> acc_cursor =
      case x_cursor of [reprSizeAlign @(Stored (cursor acc)) (repr_cursor @acc)]
        boxed tyob (stored x).
      case y_cursor of [reprSizeAlign @(Stored (cursor acc)) (repr_cursor @acc)]
        boxed tyob (stored y).
      case con_stuckBox @acc rep_acc
           (combine (fromCursor @acc x) (fromCursor @acc y)) of
        [reprSizeAlign @acc rep_acc] stuckBox tyob z.
      con_boxed @(Stored (cursor acc)) (repr_cursor @acc) (stored @(cursor acc) (toCursor @acc z))
  in

  letfun
    collect_slice @(d : box) (sh : ShapeDict d)
      (s : Stream d stream_elem) -> acc_cursor =
      let bx = con_stuckBox @acc rep_acc
               (\ (ret : OutPtr acc) -> Store.
                  -- Initialize
                  let init_store = init ret in

                  -- Collect
                  partial_collect @d @k @v @acc
                  sh rep_k rep_v rep_acc
                  read write update s ret init_store) in
      case bx of [reprSizeAlign @acc rep_acc] stuckBox tyob x.
      con_boxed @(Stored (cursor acc)) (repr_cursor @acc)
      (stored @(cursor acc) (toCursor @acc x))
  in

  case input of stream tyob par_hint i_s.

  letfun
    -- The parallel algorithm.  It starts by examining the stream argument.
    examine_stream (dummy : NoneType) -> r =
      case i_s of {
        seqStream tyob co sq.
          do_seq None

      ; nestedIxStream @d2 tyob co sh2 (rStream @dat tyob2 rep_dat extract si).
          letfun
            reduce_slice (si : SomeIndexable d2 dat) -> acc_cursor =
              -- Convert the slice back to a stream
              let s = con_stream @list_dim @stream_elem hintSeq
                      (coerce @(IStream d stream_elem) @(IStream list_dim stream_elem)
                       (nestedIxStream @d @stream_elem @d2 tyob co sh2
                        (rStream @d2 @(Stream list_dim stream_elem) @dat
                         tyob2 rep_dat extract si))) in

              -- Collect the slice sequentially
              collect_slice @list_dim ShapeDict_list_dim s
          in

          let r_cursor =
                reduce_loop @d2 @dat @acc_cursor
                sh2 rep_dat (repr_cursor @acc) par_hint
                reduce_unit reduce_slice combine_cursors reduce_residual si in

          finalize_cursor r_cursor

      ; nestedSeqStream tyob co sq.
          -- TODO: Use parallelism if inner loop is parallel
          do_seq None

      ; ixStream tyob (rStream @dat tyob2 rep_dat extract si).
          letfun
            reduce_slice (si : SomeIndexable d dat) -> acc_cursor =
              -- Sequentially reduce the partial results for this loop
              let local_s = con_stream @d @stream_elem hintSeq
                            (ixStream @d @stream_elem tyob
                             (rStream @d @stream_elem @dat tyob2 rep_dat extract si)) in
              collect_slice @d shape_dict local_s
          in
          let r_cursor =
                reduce_loop @d @dat @acc_cursor
                shape_dict rep_dat (repr_cursor @acc) par_hint
                reduce_unit reduce_slice combine_cursors reduce_residual si in

          finalize_cursor r_cursor
      }
  in

  -- Use sequential algorithm, unless parallelism is indicated
  case par_hint of {
    hintAny.      do_seq None
  ; hintSeq.      do_seq None
  ; hintLocalPar. examine_stream None
  ; hintPar.      examine_stream None
  };


-- Collect a stream locally
partial_collect @(d : box) @(k v : box) @(acc : bare)
  (shape_dict : ShapeDict d)
  (rep_k : ReprBox k) (rep_v : ReprBox v) (rep_acc : Repr acc)
  (read : k -> OutPtr acc -> Store -> (v, Store))
  (write : k -> v -> OutPtr acc -> Store -> Store)
  (update : v -> v -> v)
  (input : Stream d (Boxed (Tuple2 (AsBare k) (AsBare v))))
  (ret : OutPtr acc)
  (input_state : Store)
  -> Store
  attribute(inline) =

  let type t2 = Tuple2 (AsBare k) (AsBare v) in
  let rep_t2 = unboxedinfo Tuple2 @(AsBare k) @(AsBare v) rep_k rep_v in
  let sa_t2 = reprSizeAlign @t2 rep_t2 in
  let sa_k = reprSizeAlign @(AsBare k) rep_k in
  let sa_v = reprSizeAlign @(AsBare v) rep_v in

  letfun
    modify_state (x : Boxed t2) (input_state : Store) -> Store =
      case x of [sa_t2] boxed tyob ([sa_k, sa_v] tuple2 key_bare value_bare).
      let key = bareToBox @(AsBare k) rep_k key_bare in
      let value = bareToBox @(AsBare v) rep_v value_bare in
      case read key ret input_state of (acc_value, s1).
      let new_value = update acc_value value in
      write key new_value ret s1
  in

  shImpFold @d shape_dict @(Boxed t2) rep_t2 modify_state input input_state;


-- Finish collecting a stream locally
finalize_collect_seq @(acc : bare) @(r : box) (rep_acc : Repr acc)
  (worker : Init acc) (finalizer : CollectorFinalize acc r)
  -> r attribute(inline) =

  case finalizer of {
    collectorFinalizeInPlace tyob (co : coerce @box (AsBox acc) r).
      coerce @(AsBox acc) @r (asbox @acc rep_acc worker)

  ; collectorFinalize tyob from_initializer from_value.
      from_initializer worker
  };


-- Finish collecting a stream that's been reduced
finalize_collect_reduction @(acc : bare) @(r : box) (rep_acc : Repr acc)
  (x : acc) (finalizer : CollectorFinalize acc r)
  -> r attribute(inline) =

  case finalizer of {
    collectorFinalizeInPlace tyob (co : coerce @box (AsBox acc) r).
      coerce @(AsBox acc) @r (bareToBox @acc rep_acc x)

  ; collectorFinalize tyob from_initializer from_value.
      from_value x
  };


valueCollector @(a : box)
  (rep_a : Repr (AsBare a))
  (mut_a : Mutable (AsBare a))
  (f : a -> a -> a)
  (init : a)
  -> Collector (Boxed (Stored NoneType)) a a
  attribute(inline, inline_sequential) =

  case mut_a of mutable tyob read_a write_a isZero_a.

  let sa_a = reprSizeAlign @(AsBare a) rep_a in

  let rep_c = repr_cursor @(AsBare a) in
  let sa_c = reprSizeAlign @(Stored (cursor (AsBare a))) rep_c in

  collector @(Boxed (Stored NoneType)) @a @a @(AsBare a)
  (boxedinfo collector @(Boxed (Stored NoneType)) @a @a)
  rep_a

  -- Initialize: write the initial value
  (\ (ret : OutPtr (AsBare a)) -> Store.
     asbare @(AsBare a) rep_a init ret)

  -- Load
  (\ (i : Boxed (Stored NoneType)) (ret : OutPtr (AsBare a)) (s : Store)
     -> (a, Store).
     read_a ret s)

  -- Store
  (\ (i : Boxed (Stored NoneType)) (x : a) (ret : OutPtr (AsBare a)) (s : Store) -> Store.
     write_a x ret s)

  f

  -- Combine two
  (\ (x y : AsBare a) (ret : OutPtr (AsBare a)) -> Store.
     let z = f (bareToBox @(AsBare a) rep_a x) (bareToBox @(AsBare a) rep_a y) in
     asbare @(AsBare a) rep_a z ret)

  -- Combine many
  (\ (s : Stream list_dim (Boxed (Stored (cursor (AsBare a)))))
     (ret : OutPtr (AsBare a)) -> Store.
     let r = shFold @list_dim ShapeDict_list_dim
             @(Boxed (Stored (cursor (AsBare a)))) @a
             rep_c rep_a
             (\ (x : Boxed (Stored (cursor (AsBare a)))) (y : a) -> a.
                case x of [sa_c] boxed tyob (stored c).
                let ux = bareToBox @(AsBare a) rep_a (fromCursor @(AsBare a) c) in
                f ux y)
             s
             init
     in asbare @(AsBare a) rep_a r ret)

  (con_collectorFinalizeInPlace @(AsBare a) @a (idCoercion @a));


listCollector @(k v r : box)
  (rep_k : ReprBox k) (rep_v : ReprBox v) (rep_r : ReprBox r)
  (coll : Collector k v r)
  (size : list_dim)
  -> Collector (Boxed (Tuple2 (Stored int) (AsBare k))) v (Boxed (list (AsBare r)))
  attribute(inline, inline_sequential) =

  let type result_type = Boxed (list (AsBare r)) in
  let type t2 = Tuple2 (Stored int) (AsBare k) in
  let rep_t2 = unboxedinfo Tuple2 @(Stored int) @(AsBare k) repr_int rep_k in
  let sa_t2 = reprSizeAlign @t2 rep_t2 in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let sa_k = reprSizeAlign @(AsBare k) rep_k in

  case size of mk_list_dim tyob mbound.
  let size_int : int = case mbound of {justVal n. n; nothingVal. except @int} in
  case defineIntIndex size_int of someIInt @N size.

  case coll of
    collector @acc tyob repr_acc
    c_init c_read c_write c_update c_combine c_combine_stream c_finalize.

  let type acc_cursor = Boxed (Stored (cursor (arr N acc))) in

  let sa_r = reprSizeAlign @(AsBare r) rep_r in
  let sa_acc = reprSizeAlign @acc repr_acc in
  let rep_arr = repr_arr @N @acc size repr_acc in
  let sa_arr = reprSizeAlign @(arr N acc) rep_arr in

  let rep_result_arr = repr_arr @N @(AsBare r) size rep_r in

  letfun
    -- Initialize an accumulator
    initialize_acc (ret : OutPtr (arr N acc)) -> Store =
      doall @N size (\ (i : int) -> Store.
        c_init (subscript_out @N @acc sa_acc ret i))
  in

  letfun
    -- Combine two accumulators
    combine_acc (x y : arr N acc) (ret : OutPtr (arr N acc)) -> Store =
      doall @N size
      (\ (i : int) -> Store.
         c_combine (subscript @N @acc sa_acc x i)
                   (subscript @N @acc sa_acc y i)
                   (subscript_out @N @acc sa_acc ret i))
  in

  letfun {
    -- Given the final array, create a list object
    mk_result_value_init (worker : Init (arr N (AsBare r))) -> result_type =
      con_boxed @(list (AsBare r)) (unboxedinfo list @(AsBare r))
      (make_list @(AsBare r) @N
       size (con_stuckBox @(arr N (AsBare r)) rep_result_arr worker));

    -- Given the final array, create a list object
    mk_result_value_obj (array_data : arr N (AsBare r)) -> result_type =
      mk_result_value_init (copy @(arr N (AsBare r)) rep_result_arr array_data);

    -- Map a finalizer function over the final array and create a list object
    mk_result_value_f (f : acc -> r) (array_data : arr N acc) -> result_type =
      mk_result_value_init
      (\ (ret : OutPtr (arr N (AsBare r))) -> Store.

         -- Call 'f' on each array element
         arr1D_build @N @(AsBare r) rep_r size False
         (\ (i : int) (ret : OutPtr (AsBare r)) -> Store.
            asbare @(AsBare r) rep_r (f (subscript @N @acc sa_acc array_data i)) ret)
         ret)
  } in

  collector @(Boxed t2) @v @result_type @(arr N acc)
  (boxedinfo collector @(Boxed t2) @v @result_type)
  rep_arr

  -- Initialize
  initialize_acc

  -- Load
  (\ (i : Boxed t2) (ret : OutPtr (arr N acc)) (s : Store)
     -> (v, Store).
     case i of [sa_t2] boxed tyob ([sa_int, sa_k] tuple2 (stored idx) i2).

     -- Bounds check
     if and (idx >=# 0) (idx <# size_int)
     then let i2_box = bareToBox @(AsBare k) rep_k i2 in
          c_read i2_box (subscript_out @N @acc sa_acc ret idx) s
     else except @(v, Store))

  -- Store
  (\ (i : Boxed t2) (value : v) (ret : OutPtr (arr N acc)) (s : Store)
     -> Store.
     case i of [sa_t2] boxed tyob ([sa_int, sa_k] tuple2 (stored idx) i2).

     -- Bounds check
     if and (idx >=# 0) (idx <# size_int)
     then let i2_box = bareToBox @(AsBare k) rep_k i2 in
          c_write i2_box value (subscript_out @N @acc sa_acc ret idx) s
     else except @Store)

  c_update

  -- Combine
  combine_acc

  -- Combine many arrays
  (\ (s : Stream list_dim acc_cursor) (ret : OutPtr (arr N acc)) -> Store.

     let rep_c = repr_cursor @(arr N acc) in
     let sa_c = reprSizeAlign @(Stored (cursor (arr N acc))) rep_c in

     let first_array =
           con_stuckBox @(arr N acc) rep_arr initialize_acc in

     letfun
       array_to_cursor (x : StuckBox (arr N acc)) -> acc_cursor =
         -- Create a cursor
         case x of [sa_arr] stuckBox tyob ar.
         con_boxed @(Stored (cursor (arr N acc))) rep_c
         (stored @(cursor (arr N acc)) (toCursor @(arr N acc) ar))
     in

     -- Parallel reduction
     let total =
           reduce_Stream @list_dim @(Boxed (Stored (cursor (arr N acc))))
           ShapeDict_list_dim (repr_cursor @(arr N acc))
           (\ (bc1 bc2 : acc_cursor) -> acc_cursor.
              case bc1 of [sa_c] boxed tyob (stored c1).
              case bc2 of [sa_c] boxed tyob (stored c2).
              array_to_cursor
              (con_stuckBox @(arr N acc) rep_arr
               (combine_acc (fromCursor @(arr N acc) c1)
                            (fromCursor @(arr N acc) c2))))
           (array_to_cursor first_array)
           s in

     -- Copy to output
     case total of [sa_c] boxed tyob (stored c).
     copy @(arr N acc) rep_arr (fromCursor @(arr N acc) c) ret)

  -- Create result
  (case c_finalize of {
    collectorFinalizeInPlace tyob (co : coerce @box (AsBox acc) r).

      -- Coerce function parameters from array of acc to array of (AsBare r)
      con_collectorFinalize @(arr N acc) @result_type
      (coerce @(Init (arr N (AsBare r)) -> result_type)
              @(Init (arr N acc) -> result_type)
              mk_result_value_init)
      (coerce @(arr N (AsBare r) -> result_type)
              @(arr N acc -> result_type)
              mk_result_value_obj)

  ; collectorFinalize tob f_init f_obj.

      con_collectorFinalize @(arr N acc) @result_type
      (\ (x : Init (arr N acc)) -> result_type.
         let bx = initToBare @(arr N acc) rep_arr x in
         mk_result_value_f f_obj bx)
      (mk_result_value_f f_obj)
  });


-------------------------------------------------------------------------------
-- Parallelization markers

fun_par @(t : box -> box) @(a : box)
  (traversable : TraversableDict t) (rep : Repr (AsBare a)) (x : t a)
  -> Stream (shape t) a attribute(inline) =
  case traversable of traversableDict tyob traverse build.
  annotateParHint @(shape t) @a hintPar (traverse @a rep x);


fun_localpar @(t : box -> box) @(a : box)
  (traversable : TraversableDict t) (rep : Repr (AsBare a)) (x : t a)
  -> Stream (shape t) a attribute(inline) =
  case traversable of traversableDict tyob traverse build.
  annotateParHint @(shape t) @a hintLocalPar (traverse @a rep x);


fun_seq @(t : box -> box) @(a : box)
  (traversable : TraversableDict t) (rep : Repr (AsBare a)) (x : t a)
  -> Stream (shape t) a attribute(inline) =
  case traversable of traversableDict tyob traverse build.
  annotateParHint @(shape t) @a hintSeq (traverse @a rep x);


-- Set the stream's parallelism hint to 'h'
annotateParHint @(d a : box) (h : ParHint) (s : Stream d a)
  -> Stream d a attribute(inline) =
  case s of stream tyob old_par_hint i_s. stream @d @a tyob h i_s;

-------------------------------------------------------------------------------
-- Parallelizable loops


tabulate_list @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (par_hint : ParHint)
  (f : a -> b) (s : SomeIndexable list_dim a) -> Boxed (list (AsBare b))
  attribute(inline, inline_sequential) =

  letfun do_seq (dummy : NoneType) -> Boxed (list (AsBare b)) =
    tabulate_list_seq @a @b rep_a rep_b f s
  in

  case par_hint of {
    hintAny. do_seq None
  ; hintSeq. do_seq None
  ; hintLocalPar. tabulate_list_localpar @a @b rep_a rep_b f s
  ; hintPar. tabulate_list_dist @a @b rep_a rep_b f s
  };


tabulate_list_seq @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable list_dim a) -> Boxed (list (AsBare b))
  attribute(inline, inline_sequential) =

  viewToList @b rep_b False
  (map_view @list_dim @a @b
   rep_a rep_b f (someIndexableToView @list_dim @a rep_a s));


tabulate_array1 @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (par_hint : ParHint)
  (f : a -> b) (s : SomeIndexable dim1 a) -> Boxed (array1 (AsBare b))
  attribute(inline, inline_sequential) =

  letfun do_seq (dummy : NoneType) -> Boxed (array1 (AsBare b)) =
    tabulate_array1_seq @a @b rep_a rep_b f s
  in

  case par_hint of {
    hintAny. do_seq None
  ; hintSeq. do_seq None
  ; hintLocalPar. tabulate_array1_localpar @a @b rep_a rep_b f s
  ; hintPar. tabulate_array1_localpar @a @b rep_a rep_b f s
  };


tabulate_array1_seq @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable dim1 a) -> Boxed (array1 (AsBare b))
  attribute(inline, inline_sequential) =

  viewToArray1 @b rep_b False
  (map_view @dim1 @a @b
   rep_a rep_b f (someIndexableToView @dim1 @a rep_a s));


tabulate_array2 @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (par_hint : ParHint)
  (f : a -> b) (s : SomeIndexable dim2 a) -> Boxed (array2 (AsBare b))
  attribute(inline, inline_sequential) =

  letfun do_seq (dummy : NoneType) -> Boxed (array2 (AsBare b)) =
    tabulate_array2_seq @a @b rep_a rep_b f s
  in

  case par_hint of {
    hintAny. do_seq None
  ; hintSeq. do_seq None
  ; hintLocalPar. tabulate_array2_localpar @a @b rep_a rep_b f s
  ; hintPar. tabulate_array2_localpar @a @b rep_a rep_b f s
  };


tabulate_array2_seq @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable dim2 a) -> Boxed (array2 (AsBare b))
  attribute(inline, inline_sequential) =

  viewToArray2 @b rep_b False
  (map_view @dim2 @a @b
   rep_a rep_b f (someIndexableToView @dim2 @a rep_a s));


reduce_loop @(d : box) @(a b : box) (sh : ShapeDict d)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (par_hint : ParHint)
  (reduce_unit : NoneType -> b)
  (reduce_slice : SomeIndexable d a -> b)
  (reduce_pair : b -> b -> b)
  (reduce_residual : Stream list_dim b -> b)
  (input : SomeIndexable d a)
  -> b
  attribute(inline, inline_sequential) =

  letfun do_seq (dummy : NoneType) -> b =
    reduce_loop_seq @d @a @b sh rep_a rep_b
    reduce_slice reduce_residual input
  in

  case par_hint of {
    hintAny. do_seq None
  ; hintSeq. do_seq None
  ; hintLocalPar.
      reduce_loop_localpar @d @a @b sh rep_a rep_b
      reduce_unit reduce_slice reduce_pair input
  ; hintPar.
      reduce_loop_dist @d @a @b sh rep_a rep_b
      reduce_unit reduce_slice reduce_residual reduce_pair input
  };


reduce_loop_seq @(d : box) @(a b : box) (sh : ShapeDict d)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (reduce_slice : SomeIndexable d a -> b)
  (reduce_residual : Stream list_dim b -> b)
  (input : SomeIndexable d a)
  -> b
  attribute(inline, inline_sequential) =

  reduce_slice input;

-------------------------------------------------------------------------------
-- Multicore versions of parallelizable loops

tabulate_list_localpar @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable list_dim a) -> Boxed (list (AsBare b))
  attribute(inline, inline_sequential) =

  let vw = someIndexableToView @list_dim @a rep_a s in

  -- Tabulate a list in parallel
  viewToList @b rep_b True (map_view @list_dim @a @b rep_a rep_b f vw);


tabulate_array1_localpar @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable dim1 a) -> Boxed (array1 (AsBare b))
  attribute(inline, inline_sequential) =

  viewToArray1 @b rep_b True
  (map_view @dim1 @a @b
   rep_a rep_b f (someIndexableToView @dim1 @a rep_a s));


tabulate_array2_localpar @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable dim2 a) -> Boxed (array2 (AsBare b))
  attribute(inline, inline_sequential) =

  viewToArray2 @b rep_b True
  (map_view @dim2 @a @b
   rep_a rep_b f (someIndexableToView @dim2 @a rep_a s));


reduce_loop_localpar @(d : box) @(a b : box) (sh : ShapeDict d)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (reduce_unit : NoneType -> b)
  (reduce_slice : SomeIndexable d a -> b)
  (reduce_pair : b -> b -> b)
  (input : SomeIndexable d a)
  -> b
  attribute(inline, inline_sequential) =

  case input of someIndexable @t tyob co indexable container.

  letfun
    slice_input (off : BoxOffset d) (dom : d) -> SomeIndexable d a =
      coerce @(SomeIndexable (shape t) a) @(SomeIndexable d a)
      (ix_slice @t indexable @a rep_a container
       (coerce @d @(shape t) dom)
       (coerce @(BoxOffset d) @(BoxOffset (shape t)) off))
  in

  blocked_greduce @d @b
  (shNoOffset @d sh)
  (\ (off : BoxOffset d) (dom : d) -> MaybeVal (d, BoxOffset d, d).
     case shSplit @d sh dom of {
       justVal (dom1, off2, dom2).
         -- Add the new and old offsets
         justVal @(d, BoxOffset d, d) (dom1, shAddOffset @d sh off off2, dom2)
     ; nothingVal.
         nothingVal @(d, BoxOffset d, d)
     })
  reduce_pair

  -- Perform local reduction
  (\ (off : BoxOffset d) (local_dom : d) -> b.
     reduce_slice (slice_input off local_dom))
  reduce_unit

  (coerce @(shape t) @d (ix_shape @t indexable @a container));


-------------------------------------------------------------------------------
-- Distributed versions of parallelizable loops

-- Distributed version of 'tabulate'
tabulate_list_dist @(a b : box)
  (rep_a : ReprBox a) (rep_b : ReprBox b)
  (f : a -> b) (s : SomeIndexable list_dim a) -> Boxed (list (AsBare b))
  attribute(inline, inline_sequential) =

  let original_domain = someIndexableShape @list_dim @a s in
  case list_dimToFIInt original_domain of someIInt @Nelems list_length.

  let type dist_result = Boxed (list (AsBare b)) in

  letfun
    worker (si : SomeIndexable list_dim a) -> dist_result =
      tabulate_list_localpar @a @b rep_a rep_b f
      (preserve_SomeIndexable @list_dim @a si)
  in

  case farm_SomeIndexable @list_dim @a @dist_result
       ShapeDict_list_dim rep_a (unboxedinfo list @(AsBare b)) worker s of
    (dist_sizes, chunks).

  case chunks of
    [reprSizeAlign @(list (StuckRef dist_result)) (unboxedinfo list @(StuckRef dist_result))]
    boxed tyob (make_list @Nworkers worker_count chunks).

  let output_array_rep : Repr (arr Nworkers (StuckRef dist_result)) =
        repr_arr @Nworkers @(StuckRef dist_result) worker_count
        (unboxedinfo StuckRef @dist_result) in

  -- Concatenate the chunks
  case chunks of
    [reprSizeAlign @(arr Nworkers (StuckRef dist_result)) output_array_rep]
    stuckBox tyob chunk_array.

  case dist_sizes of mk_view tyob dist_sizes_dom get_dist_size.

  let rep_output_list = unboxedinfo StuckRef @dist_result in
  let sa_output_list = reprSizeAlign @(StuckRef dist_result) rep_output_list in

  letfun
    get_chunk_offset (i : int) -> int =
      -- Get the offset that was computed previously
      case get_dist_size (boxIntValue i) of subdomain tyob off dom.
      unboxIntValue off
  in

  letfun
    get_chunk_list (i : int) -> Boxed (list (AsBare b)) =
      case subscript @Nworkers @(StuckRef dist_result)
           sa_output_list chunk_array i of
        stuckRef list_ref.
      list_ref
  in

  concatenate_with_offsets @b @Nelems @Nworkers
  rep_b list_length worker_count get_chunk_offset get_chunk_list;


reduce_loop_dist @(d : box) @(a b : box)
  (sh : ShapeDict d) (rep_a : ReprBox a) (rep_b : ReprBox b)
  (reduce_unit : NoneType -> b)
  (reduce_slice : SomeIndexable d a -> b)
  (reduce_residual : Stream list_dim b -> b)
  (reduce_pair : b -> b -> b)
  (input : SomeIndexable d a)
  -> b
  attribute(inline, inline_sequential) =

  letfun
    worker (chunk : SomeIndexable d a) -> b =
      reduce_loop_localpar @d @a @b
      sh rep_a rep_b reduce_unit reduce_slice reduce_pair
      (preserve_SomeIndexable @d @a chunk)
  in

  -- Compute partial reductions in parallel
  case farm_SomeIndexable @d @a @b sh rep_a rep_b worker input of
    (dist_sizes, partial_results).

  let repr_ref_b = unboxedinfo StuckRef @b in
  let sa_ref_b = reprSizeAlign @(StuckRef b) repr_ref_b in

  -- Sequentially compute the rest of the reductions
  let residual : Stream list_dim b =
        annotateParHint @list_dim @b hintLocalPar
        (map_Stream @list_dim @(Boxed (StuckRef b)) @b
         (unboxedinfo StuckRef @b) rep_b
         (\ (x : Boxed (StuckRef b)) -> b.
            case x of [sa_ref_b] boxed tyob (stuckRef ux). ux)
         (traverse_list @(Boxed (StuckRef b)) repr_ref_b partial_results)) in

  reduce_residual residual;

-------------------------------------------------------------------------------
-- Distributed computation helper functions

-- Number of distributed processing elements
getNumDistributedPlaces : NoneType -> SomeIInt;

-- True if called from a distributed task.
-- FIXME: This function is not semantically sound, becuase its return value
-- is not a function of its arguments!
inDistributedTask : NoneType -> bool;

-- Prevent deconstruction of the underlying data in a 'SomeIndexable'
preserve_SomeIndexable @(d a : box) (si : SomeIndexable d a)
  -> SomeIndexable d a attribute(inline) =

  case si of someIndexable @t tyob t_has_shape_d indexable_dict container.
  someIndexable @d @a @t tyob t_has_shape_d indexable_dict
  (ix_preserveHint @t indexable_dict @a container);


-- Distribute the elements of a 'SomeIndexable' and map a function over them
farm_SomeIndexable @(d : box) @(a b : box)
  (sh_dict : ShapeDict d) (rep_a : ReprBox a) (rep_b : ReprBox b)
  (worker : SomeIndexable d a -> b)
  (s : SomeIndexable d a)
  -> (view list_dim (Subdomain d), Boxed (list (StuckRef b)))
  attribute(inline) =

  let original_domain = someIndexableShape @d @a s in

  let type dist_thunk = NoneType -> b in

  -- Distribute into subdomains.
  -- If running in a worker thread, produce a single subdomain.
  case if inDistributedTask None
       then defineIntIndex 1
       else getNumDistributedPlaces None of
    someIInt @(Nplaces : intindex) (nplaces : FIInt Nplaces).
  case nplaces of fiInt nplaces_i.

  let dist_sizes : view list_dim (Subdomain d) =
        shSplitN @d sh_dict nplaces_i original_domain in

  -- Farm tasks
  -- Each distributed task tabulates a sub-list
  let rep_output_list = unboxedinfo StuckRef @b in
  let sa_output_list = reprSizeAlign @(StuckRef b) rep_output_list in

  let workers : Boxed (list (AsBare dist_thunk)) =
        distribute_Indexable @d @a @b
        sh_dict rep_a rep_b dist_sizes s worker in

  case workers of
    [reprSizeAlign @(list (AsBare dist_thunk))
     (unboxedinfo list @(AsBare dist_thunk))]
    boxed tyob (make_list @Nworkers worker_count worker_array).

  let output_array_rep : Repr (arr Nworkers (StuckRef b)) =
        repr_arr @Nworkers @(StuckRef b) worker_count
        (unboxedinfo StuckRef @b) in
  let output_array_tyob =
        boxedinfo stuckBox @(arr Nworkers (StuckRef b)) output_array_rep in

  let chunks : StuckBox (arr Nworkers (StuckRef b)) =
        farm @Nworkers @b worker_count output_array_tyob True worker_array in

  -- Concatenate the chunks
  case chunks of
    [reprSizeAlign @(arr Nworkers (StuckRef b)) output_array_rep]
    stuckBox tyob chunk_array.

  let results =
        con_boxed @(list (StuckRef b)) (unboxedinfo list @(StuckRef b))
        (make_list @(StuckRef b) @Nworkers worker_count chunks)

  in (dist_sizes, results);


-- Create a list of thunks, where each thunk applies 'f' to a piece of the
-- given SomeIndexable
distribute_Indexable @(d : box) @(a b : box)
  (sh : ShapeDict d) (rep_a : ReprBox a) (rep_b : ReprBox b)
  (distributed_sizes : view list_dim (Subdomain d))
  (si : SomeIndexable d a)
  (f : SomeIndexable d a -> b)
  -> Boxed (list (AsBare (NoneType -> b)))
  attribute(inline) =

  case si of someIndexable @t tyob t_has_shape_d indexable_dict container.

  letfun
    apply (subdom : Subdomain d) -> NoneType -> b =

      -- Create a slice of the original object
      case subdom of subdomain tyob off dom.
      let sliced_ob =
            coerce @(SomeIndexable (shape t) a) @(SomeIndexable d a)
            (ix_slice @t indexable_dict @a rep_a container
             (coerce @d @(shape t) dom)
             (coerce @(AsBox (offset d)) @(AsBox (offset (shape t))) off)) in

      -- Return a thunk that applies 'f' to the slice
      \ (dummy : NoneType) -> b. f sliced_ob
  in

  let rep_fun = repr_Box @(NoneType -> b) in

  -- Convert the view to a list of thunks.
  -- This should be a sequential function!
  viewToList @(NoneType -> b) rep_fun False
  (map_view @list_dim @(Subdomain d) @(NoneType -> b)
   (repr_Box @(Subdomain d)) rep_fun apply distributed_sizes);


-- Concatenate a collection of lists, where the list offsets and output size 
-- are known.  The offsets and lists must have the same length, and the offsets
-- must be correct, else memory corruption will occur.
concatenate_with_offsets @(a : box) @(Nelems Nworkers : intindex)
  (rep : ReprBox a)
  (elem_count : FIInt Nelems)
  (worker_count : FIInt Nworkers)
  (get_offset : int -> int)
  (get_list : int -> Boxed (list (AsBare a)))
  -> Boxed (list (AsBare a))
  attribute(inline) =

  let rep_list = unboxedinfo list @(AsBare a) in
  let sa_list = reprSizeAlign @(list (AsBare a)) rep_list in

  let type output_arr = arr Nelems (AsBare a) in
  let rep_output_arr = repr_arr @Nelems @(AsBare a) elem_count rep in
  let sa_a = reprSizeAlign @(AsBare a) rep in

  con_boxed @(list (AsBare a)) rep_list
  (make_list @(AsBare a) @Nelems elem_count
   (con_stuckBox @output_arr rep_output_arr
    (\ (ret : OutPtr output_arr) -> Store.

      -- For each chunk, in parallel
      doall @Nworkers worker_count
      (\ (chunk_i : int) -> Store.

        let off = get_offset chunk_i in
        case get_list chunk_i of
          [sa_list] boxed tyob (make_list @M chunk_count chunk_ayref).

        let chunk_arr_rep = repr_arr @M @(AsBare a) chunk_count rep in
        case chunk_ayref of [reprSizeAlign @(arr M (AsBare a)) chunk_arr_rep]
          stuckBox tyob chunk_ay.

        -- Copy this chunk to the output array
        copy @(arr M (AsBare a)) chunk_arr_rep chunk_ay
        (subarray_out @Nelems @M @(AsBare a) sa_a ret off)))));
  

{- REPLACED BY NEW STREAM CODE

TraversableDict_Stream_build @(sh a : box)
  (rep : Repr (AsBare a)) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_Stream_traverse @(sh a : box)
  (rep : Repr (AsBare a)) (s : Stream sh a)
  -> Stream sh a attribute(inline) = s;


TraversableDict_llist_build : forall a : box.
  Repr (AsBare a) -> Stream list_dim a -> llist (AsBare a);


TraversableDict_llist_traverse @(a : box)
  (rep : Repr (AsBare a)) (l : llist (AsBare a)) -> Stream list_dim a
  attribute(inline) =

  con_sequenceStream @a (Sequence_from_llist @(AsBare a) rep l);


TraversableDict_view_list_dim_build @(a : box)
  (rep : Repr (AsBare a)) (s : Stream list_dim a) -> view list_dim a
  attribute(inline) =
  case s of {
    viewStream tyob (vw : view list_dim a). vw
  ; sequenceStream tyob (sq : Sequence a). sequenceToView @(AsBare a) rep sq
  };


TraversableDict_view_list_dim_traverse @(a : box)
  (rep : Repr (AsBare a)) (vw : view list_dim a) -> Stream list_dim a
  attribute(inline) =
  con_viewStream @a vw;


TraversableDict_view_dim0_build
  @(a : box) (rep : Repr (AsBare a)) (s : Stream dim0 a) -> view dim0 a
  attribute(inline) =
  s;


TraversableDict_view_dim0_traverse
  @(a : box) (rep : Repr (AsBare a)) (vw : view dim0 a) -> Stream dim0 a
  attribute(inline) =
  vw;


TraversableDict_view_dim1_build
  @(a : box) (rep : Repr (AsBare a)) (s : Stream dim1 a) -> view dim1 a
  attribute(inline) =
  s;


TraversableDict_view_dim1_traverse
  @(a : box) (rep : Repr (AsBare a)) (vw : view dim1 a) -> Stream dim1 a
  attribute(inline) =
  vw;


TraversableDict_view_dim2_build
  @(a : box) (rep : Repr (AsBare a)) (s : Stream dim2 a) -> view dim2 a
  attribute(inline) =
  s;


TraversableDict_view_dim2_traverse
  @(a : box) (rep : Repr (AsBare a)) (vw : view dim2 a) -> Stream dim2 a
  attribute(inline) =
  vw;


TraversableDict_view_dim3_build
  @(a : box) (rep : Repr (AsBare a)) (s : Stream dim3 a) -> view dim3 a
  attribute(inline) =
  s;


TraversableDict_view_dim3_traverse
  @(a : box) (rep : Repr (AsBare a)) (vw : view dim3 a) -> Stream dim3 a
  attribute(inline) =
  vw;


TraversableDict_list_build @(a : box)
  (rep : Repr (AsBare a)) (s : Stream list_dim a)
  -> AsBox (list (AsBare a)) attribute(inline) =
  let rep_list = unboxedinfo list @(AsBare a) in
  case s of {
    sequenceStream tyob (sq : Sequence a).
      (con_boxed @(list (AsBare a)) rep_list
       (Sequence_list_build @(AsBare a) rep sq))
  ; viewStream tyob (vw : view list_dim a).
      (con_boxed @(list (AsBare a)) rep_list
       (build_list_dim_list @(AsBare a) rep vw))
  };

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_list_traverse @(a : box)
  (rep : Repr (AsBare a)) (ls : AsBox (list (AsBare a)))
  -> Stream list_dim a attribute(inline) =
  let rep_list = unboxedinfo list @(AsBare a) in
  case ls of [reprSizeAlign @(list (AsBare a)) rep_list]
    boxed tyob (make_list @(N : intindex) size aref).

  let rep_arr = unboxedinfo arr @N @(AsBare a) size rep in
  case aref of [reprSizeAlign @(arr N (AsBare a)) rep_arr] stuckBox tyob ay.
  case size of fiInt size_i.

  let shp = con_list_dim (justVal @int size_i) in
  let sa_a = reprSizeAlign @(AsBare a) rep in

  con_viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a rep shp
   (\ (bi : Boxed (Stored int)) -> a.
     let i = unboxIntValue bi in
     bareToBox @(AsBare a) rep (subscript @N @(AsBare a) sa_a ay i)));


TraversableDict_array0_build
  @(a : box)
  (rep : Repr (AsBare a)) (vw : view dim0 a)
  -> AsBox (array0 (AsBare a)) attribute(inline) =

  case vw of mk_view tyob dom f.
  let element_value = f (boxNoneValue None) in
  let boxed_value = con_stuckBox @(AsBare a) rep
                    (asbare @(AsBare a) rep element_value) in
  let rep_array0 = unboxedinfo array0 @(AsBare a) in
  con_boxed @(array0 (AsBare a)) rep_array0 (mk_array0 @(AsBare a) boxed_value);


TraversableDict_array0_traverse
  @(a : box) (rep : Repr (AsBare a)) (ay : array0 (AsBare a))
  -> view dim0 a attribute(inline) =
  case ay of mk_array0 (x : StuckBox (AsBare a)).
  view_generate @dim0 ShapeDict_dim0 @a
  rep con_dim0
  (\ (dummy_index : Boxed (Stored NoneType)) -> a.
    case x of [reprSizeAlign @(AsBare a) rep] stuckBox tyob ux.
      bareToBox @(AsBare a) rep ux);


TraversableDict_array1_build
  @(a : box)
  (rep : Repr (AsBare a))
  (s : view dim1 a)
  -> AsBox (array1 (AsBare a)) attribute(inline, inline_dimensionality) =
  let rep_arr = unboxedinfo array1 @(AsBare a) in
  con_boxed @(array1 (AsBare a)) rep_arr
  (build_dim1_array @(AsBare a) rep s);


TraversableDict_array1_traverse
  @(a : box) (rep : Repr (AsBare a)) (ar : Boxed (array1 (AsBare a)))
  -> view dim1 a attribute(inline) =
  let rep_array1 = unboxedinfo array1 @(AsBare a) in
  case ar of [reprSizeAlign @(array1 (AsBare a)) rep_array1]
    boxed tyob (mk_array1 @(N : intindex) lo stride size ayref).

  let rep_arr = unboxedinfo arr @N @(AsBare a) size rep in
  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_arr] stuckBox tyob ay.
  
  let linear_map = linearMap stride lo in
  let sa_a = reprSizeAlign @(AsBare a) rep in

  view_generate @dim1 ShapeDict_dim1 @a rep
  (arrayDescToDim1 @N lo stride size)
  (\ (ix : Boxed (Stored int)) -> a.
    let ix_i = unboxIntValue ix in
    let real_ix : int = invEvalLM ix_i linear_map in
    bareToBox @(AsBare a) rep (subscript @N @(AsBare a) sa_a ay real_ix));


TraversableDict_array2_build
  @(a : box)
  (rep : Repr (AsBare a))
  (s : view dim2 a)
  -> AsBox (array2 (AsBare a)) attribute(inline, inline_dimensionality) =

  case s of mk_view tyob (mk_dim2 tyob2 dom_y dom_x) f.

  -- Compute array parameters
  case dim1ToArraySize dom_y of arraySize @(M : intindex) lb_y stride_y size_y.
  case dim1ToArraySize dom_x of arraySize @(N : intindex) lb_x stride_x size_x.

  let linear_map_y : LinearMap = linearMap stride_y lb_y in
  let linear_map_x : LinearMap = linearMap stride_x lb_x in
  let type out_arr = arr M (arr N (AsBare a)) in
  let type Sint = Stored int in

  let rep_arr = unboxedinfo arr @M @(arr N (AsBare a)) size_y
                (unboxedinfo arr @N @(AsBare a) size_x rep) in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  con_boxed @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))
  (mk_array2 @(AsBare a) @M @N lb_y stride_y size_y lb_x stride_x size_x
   (con_stuckBox @out_arr rep_arr
    (arr2D_build @M @N @(AsBare a) rep size_y size_x
     (\ (y : int) (x : int) (ret : OutPtr (AsBare a)) -> Store.
        let logical_y : int = evalLM y linear_map_y in
        let logical_x : int = evalLM x linear_map_x in
        let ix = con_boxed @(Tuple2 Sint Sint) repr_index2
                 (tuple2 @Sint @Sint sa_int sa_int
                  (stored @int logical_y) (stored @int logical_x)) in

        -- Evaluate the function
        asbare @(AsBare a) rep (f ix) ret))));


TraversableDict_array2_traverse
  @(a : box) (rep : Repr (AsBare a)) (ar : Boxed (array2 (AsBare a)))
  -> view dim2 a attribute(inline) =
  let rep_array2 = unboxedinfo array2 @(AsBare a) in
  case ar of [reprSizeAlign @(array2 (AsBare a)) rep_array2]
    boxed tyob (mk_array2 @(M N : intindex)
                lo_y stride_y size_y lo_x stride_x size_x ayref).

  let rep_row = unboxedinfo arr @N @(AsBare a) size_x rep in
  let rep_arr = unboxedinfo arr @M @(arr N (AsBare a)) size_y rep_row in
  case ayref of [reprSizeAlign @(arr M (arr N (AsBare a))) rep_arr]
    stuckBox tyob (ay : arr M (arr N (AsBare a))).

  let linear_map_y = linearMap stride_y lo_y in
  let linear_map_x = linearMap stride_x lo_x in
  case size_x of fiInt (width : int).
  let type Sint = Stored int in
  let sa_int = reprSizeAlign @Sint repr_int in

  view_generate @dim2 ShapeDict_dim2 @a rep
  (con_dim2 (arrayDescToDim1 @M lo_y stride_y size_y)
            (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Boxed (Tuple2 Sint Sint)) -> a.
     case ix of [reprSizeAlign @(Tuple2 Sint Sint) repr_index2]
       boxed tyob ([sa_int, sa_int] tuple2 (stored ix_y) (stored ix_x)).
     let real_ix_y : int = invEvalLM ix_y linear_map_y in
     let real_ix_x : int = invEvalLM ix_x linear_map_x in
     bareToBox @(AsBare a) rep
     (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
      (subscript @M @(arr N (AsBare a))
       (reprSizeAlign @(arr N (AsBare a)) rep_row) ay real_ix_y) real_ix_x));


TraversableDict_array3_build
  @(a : box) (rep : Repr (AsBare a)) (s : view dim3 a)
  -> AsBox (array3 (AsBare a)) attribute(inline, inline_dimensionality) =

  case s of mk_view tyob dom f.

  -- Compute array parameters
  case dom of mk_dim3 tyob dom_z dom_y dom_x.
  case dim1ToArraySize dom_y of arraySize @(L : intindex) lb_z stride_z size_z.
  case dim1ToArraySize dom_y of arraySize @(M : intindex) lb_y stride_y size_y.
  case dim1ToArraySize dom_x of arraySize @(N : intindex) lb_x stride_x size_x.

  let linear_map_z : LinearMap = linearMap stride_z lb_z in
  let linear_map_y : LinearMap = linearMap stride_y lb_y in
  let linear_map_x : LinearMap = linearMap stride_x lb_x in
  let type out_arr = arr L (arr M (arr N (AsBare a))) in
  let type Sint = Stored int in

  let rep_arr = unboxedinfo arr @L @(arr M (arr N (AsBare a))) size_z
                (unboxedinfo arr @M @(arr N (AsBare a)) size_y
                 (unboxedinfo arr @N @(AsBare a) size_x rep)) in
  let sa_int = reprSizeAlign @Sint repr_int in

  (con_boxed @(array3 (AsBare a)) (unboxedinfo array3 @(AsBare a))
   (mk_array3 @(AsBare a) @L @M @N lb_z stride_z size_z
                                   lb_y stride_y size_y
                                   lb_x stride_x size_x
    (con_stuckBox @out_arr rep_arr
     (arr3D_build @L @M @N @(AsBare a) rep size_z size_y size_x
      (\ (z : int) (y : int) (x : int) (ret : OutPtr (AsBare a)) -> Store.
         let logical_z : int = evalLM z linear_map_z in
         let logical_y : int = evalLM y linear_map_y in
         let logical_x : int = evalLM x linear_map_x in
         let ix = con_boxed @(Tuple3 Sint Sint Sint) repr_index3
                  (tuple3 @Sint @Sint @Sint sa_int sa_int sa_int
                   (stored @int logical_z)
                   (stored @int logical_y) (stored @int logical_x)) in

         -- Evaluate the function
         asbare @(AsBare a) rep (f ix) ret)))));


TraversableDict_array3_traverse
  @(a : box) (rep : Repr (AsBare a)) (ar : Boxed (array3 (AsBare a)))
  -> view dim3 a attribute(inline) =
  let rep_array3 = unboxedinfo array3 @(AsBare a) in
  case ar of [reprSizeAlign @(array3 (AsBare a)) rep_array3]
    boxed tyob (mk_array3 @(L M N : intindex)
               lo_z stride_z size_z
               lo_y stride_y size_y
               lo_x stride_x size_x
               ayref).
  let type bare_a = AsBare a in
  let type arr3d = arr L (arr M (arr N bare_a)) in

  let rep_row = unboxedinfo arr @N @(AsBare a) size_x rep in
  let rep_plane = unboxedinfo arr @M @(arr N (AsBare a)) size_y rep_row in
  let rep_arr = unboxedinfo arr @L @(arr M (arr N (AsBare a)))
                size_z rep_plane in

  case ayref of [reprSizeAlign @arr3d rep_arr] stuckBox tyob (ay : arr3d).

  let linear_map_z : LinearMap = linearMap stride_z lo_z in
  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_y of fiInt (height : int).
  case size_x of fiInt (width : int).
  let type Sint = Stored int in
  let sa_int = reprSizeAlign @Sint repr_int in

  view_generate @dim3 ShapeDict_dim3 @a rep
  (con_dim3 (arrayDescToDim1 @L lo_z stride_z size_z)
            (arrayDescToDim1 @M lo_y stride_y size_y)
            (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Boxed (Tuple3 Sint Sint Sint)) -> a.
     case ix of [reprSizeAlign @(index dim3) repr_index3]
       boxed tyob ([sa_int, sa_int, sa_int]
                   tuple3 (stored ix_z) (stored ix_y) (stored ix_x)).
     let real_ix_z : int = invEvalLM ix_z linear_map_z in
     let real_ix_y : int = invEvalLM ix_y linear_map_y in
     let real_ix_x : int = invEvalLM ix_x linear_map_x in
     bareToBox @bare_a rep
     (subscript @N @bare_a (reprSizeAlign @bare_a rep)
      (subscript @M @(arr N bare_a) (reprSizeAlign @(arr N bare_a) rep_row)
       (subscript @L @(arr M (arr N bare_a))
        (reprSizeAlign @(arr M (arr N bare_a)) rep_plane) ay real_ix_z)
       real_ix_y)
      real_ix_x));


TraversableDict_blist_build @(a : box)
  (rep : Repr (AsBare a))
  (s : Stream list_dim a)
  -> AsBox (blist (AsBare a)) attribute(inline) =

  let type boxed_a = StuckRef a in
  let repr_boxed : Repr boxed_a = unboxedinfo StuckRef @a in
  let rep_list = unboxedinfo blist @(AsBare a) in
  -- Wrap all sequence elements in boxes
  let s2 =
        ShapeDict_list_dim_map @a @(AsBox boxed_a)
        rep repr_boxed
        (\ (x : a) -> AsBox boxed_a. con_boxed @boxed_a repr_boxed (stuckRef @a x))
        s in 
  case s2 of {
    sequenceStream tyob (sq : Sequence (AsBox boxed_a)).
      con_boxed @(blist (AsBare a)) rep_list
      (make_blist @(AsBare a) (Sequence_list_build @boxed_a repr_boxed sq))
  ; viewStream tyob (vw : view list_dim (AsBox boxed_a)).
      con_boxed @(blist (AsBare a)) rep_list
      (make_blist @(AsBare a) (build_list_dim_list @boxed_a repr_boxed vw))
  };

-- List traversal.
-- Loop over all list indices and return the corresponding array element.
TraversableDict_blist_traverse @(a : box)
  (rep : Repr (AsBare a)) (ls : blist (AsBare a))
  -> Stream list_dim a attribute(inline) =

  let type boxed_a = StuckRef a in
  let repr_box : Repr boxed_a = unboxedinfo StuckRef @a in
  case ls of make_blist (make_list @(N : intindex) size aref).
  let rep_arr = unboxedinfo arr @N @boxed_a size repr_box in
  case aref of [reprSizeAlign @(arr N boxed_a) rep_arr]
    stuckBox tyob (ay : arr N boxed_a).
  case size of fiInt (size_i : int).

  let shp : list_dim = con_list_dim (justVal @int size_i) in

  con_viewStream @a
  (view_generate @list_dim
   ShapeDict_list_dim @a rep shp
   (\ (si : Boxed (Stored int)) -> a.
     let i = unboxIntValue si in
     case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay i of
       stuckRef val.
     val));


TraversableDict_barray1_build
  @(a : box)
  (rep : Repr (AsBare a)) (s : view dim1 a)
  -> AsBox (barray1 (AsBare a)) attribute(inline, inline_dimensionality) =
  let type boxed_a = StuckRef a in
  let brepr : Repr boxed_a = unboxedinfo StuckRef @a in
  let rep_barray1 = unboxedinfo barray1 @(AsBare a) in
  con_boxed @(barray1 (AsBare a)) rep_barray1
  (mk_barray1 @(AsBare a)
   (build_dim1_array @boxed_a brepr
    (view_map @dim1 ShapeDict_dim1 @a @(AsBox boxed_a)
     rep brepr (\ (x : a) -> AsBox boxed_a.
                   con_boxed @(boxed_a) brepr (stuckRef @a x)) s)));


TraversableDict_barray1_traverse
  @(a : box) (rep : Repr (AsBare a)) (ar : Boxed (barray1 (AsBare a)))
  -> view dim1 a attribute(inline) =
  let type boxed_a = StuckRef a in
  let repr_box = unboxedinfo StuckRef @a in
  let rep_barray1 = unboxedinfo barray1 @(AsBare a) in
  case ar of [reprSizeAlign @(barray1 (AsBare a)) rep_barray1]
    boxed tyob (mk_barray1 (mk_array1 @(N : intindex) lo stride size ayref)).
  let rep_arr = unboxedinfo arr @N @boxed_a size repr_box in
  case ayref of [reprSizeAlign @(arr N boxed_a) rep_arr]
    stuckBox tyob (ay : arr N boxed_a).

  let linear_map : LinearMap = linearMap stride lo in

  view_generate @dim1 ShapeDict_dim1 @a rep
  (arrayDescToDim1 @N lo stride size)
  (\ (ix : Boxed (Stored int)) -> a.
    let ix_i = unboxIntValue ix in

    let real_ix : int = invEvalLM ix_i linear_map in
    case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay real_ix of 
      stuckRef val.
    val);


TraversableDict_barray2_build
  @(a : box)
  (rep : Repr (AsBare a)) (s : view dim2 a)
  -> AsBox (barray2 (AsBare a)) attribute(inline, inline_dimensionality) =

  case s of mk_view tyob (mk_dim2 tyob2 dom_y dom_x) f.
  case dim1ToArraySize dom_y of arraySize @(M : intindex) lb_y stride_y size_y.
  case dim1ToArraySize dom_x of arraySize @(N : intindex) lb_x stride_x size_x.

  -- Compute array parameters
  let linear_map_y = linearMap stride_y lb_y in
  let linear_map_x = linearMap stride_x lb_x in
  let type boxed_a = StuckRef a in
  let type out_arr = arr M (arr N boxed_a) in
  let type Sint = Stored int in
  let box_repr : Repr boxed_a = unboxedinfo StuckRef @a in

  let rep_row = unboxedinfo arr @N @boxed_a size_x box_repr in
  let rep_arr = unboxedinfo arr @M @(arr N boxed_a) size_y rep_row in
  let sa_int = reprSizeAlign @Sint repr_int in

  con_boxed @(barray2 (AsBare a)) (unboxedinfo barray2 @(AsBare a))
  (mk_barray2 @(AsBare a)
   (mk_array2 @boxed_a @M @N lb_y stride_y size_y lb_x stride_x size_x
    (con_stuckBox @out_arr rep_arr
     (arr2D_build @M @N @boxed_a box_repr size_y size_x
      (\ (y : int) (x : int) (ret : OutPtr boxed_a) -> Store.
         let logical_y : int = evalLM y linear_map_y in
         let logical_x : int = evalLM x linear_map_x in
         let ix = con_boxed @(Tuple2 Sint Sint) repr_index2
                  (tuple2 @Sint @Sint sa_int sa_int
                   (stored @int logical_y) (stored @int logical_x)) in

         -- Evaluate the function and box its result
         stuckRef @a (f ix) ret)))));


TraversableDict_barray2_traverse
  @(a : box) (rep : Repr (AsBare a)) (ar : Boxed (barray2 (AsBare a)))
  -> view dim2 a attribute(inline) =
  let type boxed_a = StuckRef a in
  let rep_barray2 = unboxedinfo barray2 @(AsBare a) in

  case ar of [reprSizeAlign @(barray2 (AsBare a)) rep_barray2]
    boxed tyob (mk_barray2 (mk_array2 @(M N : intindex)
                            lo_y stride_y size_y lo_x stride_x size_x ayref)).
  let rep_box = unboxedinfo StuckRef @a in
  let rep_row = unboxedinfo arr @N @boxed_a size_x rep_box in
  let rep_arr = unboxedinfo arr @M @(arr N boxed_a) size_y rep_row in
  case ayref of [reprSizeAlign @(arr M (arr N boxed_a)) rep_arr]
    stuckBox tyob (ay : arr M (arr N boxed_a)).

  let linear_map_y : LinearMap = linearMap stride_y lo_y in
  let linear_map_x : LinearMap = linearMap stride_x lo_x in
  case size_x of fiInt (width : int).
  let type Sint = Stored int in
  let sa_int = reprSizeAlign @Sint repr_int in

  view_generate @dim2 ShapeDict_dim2 @a rep
  (con_dim2 (arrayDescToDim1 @M lo_y stride_y size_y)
            (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Boxed (Tuple2 Sint Sint)) -> a.
     case ix of [reprSizeAlign @(index dim2) repr_index2]
       boxed tyob ([sa_int, sa_int] tuple2 (stored ix_y) (stored ix_x)).
     let real_ix_y : int = invEvalLM ix_y linear_map_y in
     let real_ix_x : int = invEvalLM ix_x linear_map_x in
     case subscript @N @boxed_a (reprSizeAlign @boxed_a rep_box)
          (subscript @M @(arr N boxed_a)
           (reprSizeAlign @(arr N boxed_a) rep_row) ay real_ix_y) real_ix_x of
       stuckRef val. val);


TraversableDict_barray3_build
  @(a : box)
  (rep : Repr (AsBare a)) (s : view dim3 a)
  -> AsBox (barray3 (AsBare a)) attribute(inline, inline_dimensionality) =

  let type boxed_a = StuckRef a in
  let brepr : Repr boxed_a = unboxedinfo StuckRef @a in
  case s of mk_view tyob (mk_dim3 tyob2 dom_z dom_y dom_x) f.
  case dim1ToArraySize dom_y of arraySize @(L : intindex) lb_z stride_z size_z.
  case dim1ToArraySize dom_y of arraySize @(M : intindex) lb_y stride_y size_y.
  case dim1ToArraySize dom_x of arraySize @(N : intindex) lb_x stride_x size_x.

  -- Compute array parameters
  let linear_map_z : LinearMap = linearMap stride_z lb_z in
  let linear_map_y : LinearMap = linearMap stride_y lb_y in
  let linear_map_x : LinearMap = linearMap stride_x lb_x in
  let type out_arr = arr L (arr M (arr N boxed_a)) in
  let type Sint = Stored int in

  let rep_row = unboxedinfo arr @N @boxed_a size_x brepr in
  let rep_plane = unboxedinfo arr @M @(arr N boxed_a) size_y rep_row in
  let rep_arr = unboxedinfo arr @L @(arr M (arr N boxed_a)) size_z rep_plane in
  let sa_int = reprSizeAlign @Sint repr_int in

  con_boxed @(barray3 (AsBare a)) (unboxedinfo barray3 @(AsBare a))
  (mk_barray3 @(AsBare a)
   (mk_array3 @boxed_a @L @M @N
              lb_z stride_z size_z
              lb_y stride_y size_y
              lb_x stride_x size_x
    (con_stuckBox @out_arr rep_arr
     (arr3D_build @L @M @N @boxed_a brepr size_z size_y size_x
      (\ (z : int) (y : int) (x : int) (ret : OutPtr boxed_a) -> Store.
         let logical_z : int = evalLM z linear_map_z in
         let logical_y : int = evalLM y linear_map_y in
         let logical_x : int = evalLM x linear_map_x in
         let ix = con_boxed @(Tuple3 Sint Sint Sint) repr_index3
                  (tuple3 @Sint @Sint @Sint sa_int sa_int sa_int
                   (stored @int logical_z)
                   (stored @int logical_y) (stored @int logical_x)) in

         -- Evaluate the function and box its result
         stuckRef @a (f ix) ret)))));


TraversableDict_barray3_traverse
  @(a : box) (rep : Repr (AsBare a)) (ar : Boxed (barray3 (AsBare a)))
  -> view dim3 a attribute(inline) =
  let type boxed_a = StuckRef a in
  let rep_barray3 = unboxedinfo barray3 @(AsBare a) in
  case ar of [reprSizeAlign @(barray3 (AsBare a)) rep_barray3]
    boxed tyob (mk_barray3 (mk_array3 @(L M N : intindex)
                            lo_z stride_z size_z
                            lo_y stride_y size_y
                            lo_x stride_x size_x
                            ayref)).
  let type arr1d = arr N boxed_a in
  let type arr2d = arr M arr1d in
  let type arr3d = arr L arr2d in

  let rep_box : Repr boxed_a = unboxedinfo StuckRef @a in
  let rep_row : Repr arr1d = unboxedinfo arr @N @boxed_a size_x rep_box in
  let rep_plane : Repr arr2d = unboxedinfo arr @M @arr1d size_y rep_row in
  let rep_arr = unboxedinfo arr @L @arr2d size_z rep_plane in

  case ayref of [reprSizeAlign @arr3d rep_arr] stuckBox tyob (ay : arr3d).

  let linear_map_z = linearMap stride_z lo_z in
  let linear_map_y = linearMap stride_y lo_y in
  let linear_map_x = linearMap stride_x lo_x in
  case size_y of fiInt (height : int).
  case size_x of fiInt (width : int).
  let type Sint = Stored int in
  let sa_int = reprSizeAlign @Sint repr_int in

  view_generate @dim3 ShapeDict_dim3 @a rep
  (con_dim3 (arrayDescToDim1 @L lo_z stride_z size_z)
            (arrayDescToDim1 @M lo_y stride_y size_y)
            (arrayDescToDim1 @N lo_x stride_x size_x))
  (\ (ix : Boxed (Tuple3 Sint Sint Sint)) -> a.
     case ix of [reprSizeAlign @(index dim3) repr_index3]
       boxed tyob ([sa_int, sa_int, sa_int]
                   tuple3 (stored ix_z) (stored ix_y) (stored ix_x)).
     let real_ix_z : int = invEvalLM ix_z linear_map_z in
     let real_ix_y : int = invEvalLM ix_y linear_map_y in
     let real_ix_x : int = invEvalLM ix_x linear_map_x in
     case subscript @N @boxed_a (reprSizeAlign @boxed_a rep_box)
          (subscript @M @arr1d (reprSizeAlign @arr1d rep_row)
           (subscript @L @arr2d (reprSizeAlign @arr2d rep_plane) ay real_ix_z)
           real_ix_y)
          real_ix_x of
      stuckRef val. val);

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Shape dictionaries

ShapeDict_guard_dim : ShapeDict guard_dim =
  shapeDict @guard_dim (boxedinfo shapeDict @guard_dim)
  repr_NoneType
  repr_NoneType
  repr_NoneType
  real_noOffset_guard_dim
  real_addOffset_guard_dim
  real_addOffset_guard_dim -- This is 'appOffset'
  real_intersect_guard_dim
  real_member_guard_dim
  real_slice_guard_dim
  real_split_guard_dim
  real_splitN_guard_dim
  real_checkSubdomain_guard_dim
  real_peel_guard_dim
  real_flatten_guard_dim
  real_generate_guard_dim
  real_zipWith_guard_dim
  real_fold_guard_dim
  real_imp_fold_guard_dim_wrapper
  real_foreach_guard_dim_wrapper
  real_foreachSeq_guard_dim;


-- FIXME: This is a workaround for recursion
ShapeDict_guard_dim_loop_breaker (dummy : NoneType) -> ShapeDict guard_dim
  attribute(inline_never) =
  ShapeDict_guard_dim;

imp_fold_guard_dim_wrapper
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> ImperativeFoldFunction guard_dim attribute(inline) =
  real_imp_fold_guard_dim_wrapper;


real_imp_fold_guard_dim_wrapper : ImperativeFoldFunction guard_dim attribute(inline) =
  imperativeFoldFunction @guard_dim imp_fold_guard_dim;


foreach_guard_dim_wrapper
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> ImperativeForeachFunction guard_dim attribute(inline) =
  real_foreach_guard_dim_wrapper;


real_foreach_guard_dim_wrapper : ImperativeForeachFunction guard_dim attribute(inline) =
  imperativeForeachFunction @guard_dim foreach_guard_dim;


noOffset_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> Boxed (Stored NoneType) attribute(inline) =
  real_noOffset_guard_dim;


real_noOffset_guard_dim : Boxed (Stored NoneType) attribute(inline) =
  boxNoneValue None;


addOffset_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> Boxed (Stored NoneType) -> Boxed (Stored NoneType) -> Boxed (Stored NoneType) attribute(inline) =
  real_addOffset_guard_dim;


-- This is both 'addOffset' and 'appOffset'.
real_addOffset_guard_dim (x y : Boxed (Stored NoneType)) -> Boxed (Stored NoneType)
  attribute(inline) =
  x;


intersect_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> guard_dim -> guard_dim -> guard_dim attribute(inline) =
  real_intersect_guard_dim;


real_intersect_guard_dim (d1 d2 : guard_dim) -> guard_dim =
  -- This function is not used
  except @guard_dim;


member_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> Boxed (Stored NoneType) -> guard_dim -> bool attribute(inline) =
  real_member_guard_dim;


real_member_guard_dim
  (i : Boxed (Stored NoneType)) (d : guard_dim)
  -> bool attribute(inline, inline_sequential) =
  -- This function is not used
  except @bool;


slice_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> Boxed (Stored NoneType) -> guard_dim -> (Boxed (Stored NoneType), guard_dim)
  attribute(inline) =
  real_slice_guard_dim;


real_slice_guard_dim
  (sl : Boxed (Stored NoneType)) (dom : guard_dim)
  -> (Boxed (Stored NoneType), guard_dim) attribute(inline, inline_sequential) =
  -- This function is not used
  except @(Boxed (Stored NoneType), guard_dim);


split_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> guard_dim -> MaybeVal (guard_dim, Boxed (Stored NoneType), guard_dim)
  attribute(inline) =
  real_split_guard_dim;


real_split_guard_dim
  (dom : guard_dim)
  -> MaybeVal (guard_dim, Boxed (Stored NoneType), guard_dim) =

  nothingVal @(guard_dim, Boxed (Stored NoneType), guard_dim);


splitN_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> int -> guard_dim -> view list_dim (Subdomain guard_dim) attribute(inline) =
  real_splitN_guard_dim;


real_splitN_guard_dim
  (n : int) (d : guard_dim)
  -> view list_dim (Subdomain guard_dim) attribute(inline) =

  con_view @list_dim @(Subdomain guard_dim)
  (con_list_dim (justVal @int 1))
  (\ (x : Boxed (Stored int)) -> Subdomain guard_dim.
     con_subdomain @guard_dim (boxNoneValue None) d);


checkSubdomain_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> guard_dim -> guard_dim -> bool attribute(inline) =
  real_checkSubdomain_guard_dim;


real_checkSubdomain_guard_dim
  (d subd : guard_dim) -> bool attribute(inline) =

  -- Check is not needed
  True;


peel_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> forall a r : box.
     Repr (AsBare a) -> Boxed (Stored ParHint) ->
     (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
     view guard_dim (Stream list_dim a) -> r
  attribute(inline) =
  real_peel_guard_dim;


real_peel_guard_dim @(a r : box)
  (rep_a : ReprBox a)
  (par_hint : Boxed (Stored ParHint))
  (value_k : a -> Stream list_dim a -> r) -- Success continuation
  (empty_k : NoneType -> r)               -- Failure
  (vw : view guard_dim (Stream list_dim a))
  -> r attribute(inline, inline_sequential) =

  case vw of mk_view tyob dom visit.
  case dom of {
    guard_keep tyob.
      peel_Stream @a @r rep_a value_k empty_k (visit (boxNoneValue None))
  ; guard_skip tyob.
      empty_k None
  };


flatten_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> forall a : box. ReprBox a -> Stream guard_dim a -> Stream list_dim a
  attribute(inline) =
  real_flatten_guard_dim;


real_flatten_guard_dim @(a : box) (rep : ReprBox a) (s : Stream guard_dim a)
  -> Stream list_dim a attribute(inline) =

  case s of stream tyob par_hint i_s.
  let rs = fromIxStream @guard_dim @a i_s in
  con_stream @list_dim @a par_hint
  (con_nestedIxStream @a @guard_dim
   (ShapeDict_guard_dim_loop_breaker None)
   (map_RStream @guard_dim @a @(Stream list_dim a) (unit_Stream @a rep) rs));


generate_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> forall a : box.
     Repr (AsBare a) -> BoxOffset guard_dim -> guard_dim ->
     (BoxIndex guard_dim -> a) -> Stream guard_dim a
  attribute(inline) =
  real_generate_guard_dim;

real_generate_guard_dim @(a : box)
  (rep_a : ReprBox a)
  (off : BoxOffset guard_dim) (dom : guard_dim) (g : BoxIndex guard_dim -> a)
  -> Stream guard_dim a attribute(inline) =

  -- Create a view.  Apply the offset before calling g.
  let vw : view guard_dim a = con_view @guard_dim @a dom g in

  -- Convert to a stream
  traverse_view_real @guard_dim @a ShapeDict_guard_dim rep_a vw;


zipWith_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> forall a b c : box.
     Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
     (a -> b -> c) ->
     Stream guard_dim a -> Stream guard_dim b -> Stream guard_dim c
  attribute(inline) =
  real_zipWith_guard_dim;


real_zipWith_guard_dim @(a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : Stream guard_dim a)
  (s2 : Stream guard_dim b)
  -> Stream guard_dim c
  attribute(inline) =

  -- This function is not used
  except @(Stream guard_dim c);


fold_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> forall a acc : box.
     Repr (AsBare a) -> Repr (AsBare acc) ->
     (a -> acc -> acc) -> Stream guard_dim a -> acc -> acc
  attribute(inline) =

  real_fold_guard_dim;

real_fold_guard_dim @(a acc : box)
  (rep_a : ReprBox a)
  (rep_acc : ReprBox acc)
  (combine : a -> acc -> acc)
  (s : Stream guard_dim a)
  (init : acc)
  -> acc
  attribute(inline) =

  case fromIxStream @guard_dim @a (unStream @guard_dim @a s) of
    rStream @b tyob rep_b extract (someIndexable @t tyob2 co ix container).

  case coerce @(shape t) @guard_dim (ix_shape @t ix @b container) of {
    guard_keep tyob.
      let idx = coerce @(BoxIndex guard_dim) @(BoxIndex (shape t)) (boxNoneValue None) in
      combine (extract (ix_at @t ix @b rep_b container idx)) init
  ; guard_skip tyob.
      init
  };


imp_fold_guard_dim @(a : box)
  (rep_a : ReprBox a)
  (combine : a -> Store -> Store)
  (s : Stream guard_dim a)
  (init : Store)
  -> Store
  attribute(inline) =

  case fromIxStream @guard_dim @a (unStream @guard_dim @a s) of
    rStream @b tyob rep_b extract (someIndexable @t tyob2 co ix container).

  let dom = coerce @(shape t) @guard_dim (ix_shape @t ix @b container) in
  letfun
    combine_index (idx : BoxIndex guard_dim) (st : Store) -> Store =
      let x = ix_at @t ix @b rep_b container
              (coerce @(BoxIndex guard_dim) @(BoxIndex (shape t)) idx) in
      combine (extract x) init
  in
  foreach_guard_dim dom (boxNoneValue None) combine_index init;


foreach_guard_dim
  (dom : guard_dim)
  (off : BoxOffset guard_dim)
  (combine : BoxIndex guard_dim -> Store -> Store)
  (init : Store)
  -> Store attribute(inline) =

  case dom of {
    guard_keep tyob. combine (boxNoneValue None) init
  ; guard_skip tyob. init
  };


foreachSeq_guard_dim
  (r1 : Repr (index guard_dim)) (r2 : Repr (offset guard_dim)) (r3 : Repr (slice guard_dim))
  -> forall a : box. guard_dim -> (Boxed (Stored NoneType) -> Seq a) -> Seq a
  attribute(inline) =
  real_foreachSeq_guard_dim;


real_foreachSeq_guard_dim @(a : box)
  (d : guard_dim) (k : Boxed (Stored NoneType) -> Seq a)
  -> Seq a attribute(inline, inline_sequential) =

  guard_Seq @a (guardToBool d) (k (boxNoneValue None));


ShapeDict_list_dim : ShapeDict list_dim =
  shapeDict @list_dim (boxedinfo shapeDict @list_dim)
  repr_int
  repr_int
  repr_SliceObject
  real_noOffset_list_dim
  real_addOffset_list_dim
  real_addOffset_list_dim -- This is 'appOffset'
  real_intersect_list_dim
  real_member_list_dim
  real_slice_list_dim
  real_split_list_dim
  real_splitN_list_dim
  real_checkSubdomain_list_dim
  real_peel_list_dim
  real_flatten_list_dim
  real_generate_list_dim
  real_zipWith_list_dim
  real_fold_list_dim
  real_imp_fold_list_dim_wrapper
  real_foreach_list_dim_wrapper
  real_foreachSeq_list_dim;


-- FIXME: Handle recursion properly
-- This function is needed to break a recursive cycle
ShapeDict_list_dim_loop_breaker (dummy : NoneType)
  -> ShapeDict list_dim attribute(inline_never) =
  ShapeDict_list_dim;


imp_fold_list_dim_wrapper
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> ImperativeFoldFunction list_dim attribute(inline) =
  real_imp_fold_list_dim_wrapper;


real_imp_fold_list_dim_wrapper : ImperativeFoldFunction list_dim attribute(inline) =
  imperativeFoldFunction @list_dim imp_fold_list_dim;


foreach_list_dim_wrapper
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> ImperativeForeachFunction list_dim attribute(inline) =
  real_foreach_list_dim_wrapper;


real_foreach_list_dim_wrapper : ImperativeForeachFunction list_dim attribute(inline) =
  imperativeForeachFunction @list_dim foreach_list_dim;


noOffset_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> Boxed (Stored int) attribute(inline) =
  real_noOffset_list_dim;


real_noOffset_list_dim : Boxed (Stored int) attribute(inline) =
  -- Use data constructors so that this term can be inlined
  boxed @(Stored int) (reprSizeAlign @(Stored int) repr_int)
  (boxedinfo boxed @(Stored int) repr_int)
  (stored @int 0);


addOffset_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> Boxed (Stored int) -> Boxed (Stored int) -> Boxed (Stored int) attribute(inline) =
  real_addOffset_list_dim;


-- This is both 'addOffset' and 'appOffset'.
real_addOffset_list_dim (x y : Boxed (Stored int)) -> Boxed (Stored int)
  attribute(inline) =
  boxIntValue (unboxIntValue x +# unboxIntValue y);


-- Same as 'addOffset_list_dim', because offsets and indices have the same type
appOffset_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> Boxed (Stored int) -> Boxed (Stored int) ->  Boxed (Stored int) attribute(inline) =
  real_addOffset_list_dim;


intersect_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> list_dim -> list_dim -> list_dim attribute(inline) =
  real_intersect_list_dim;


real_intersect_list_dim (d1 d2 : list_dim)
  -> list_dim attribute(inline, inline_final) =
  case d1 of mk_list_dim tyob (m_size1 : MaybeVal int).
  case d2 of mk_list_dim tyob (m_size2 : MaybeVal int).
  con_list_dim
  (case m_size1 of {
     justVal (size1 : int).
       case m_size2 of {
         justVal (size2 : int).
           justVal @int (minI size1 size2)
       ; nothingVal.
           justVal @int size1
       }
   ; nothingVal.
       m_size2
   });


member_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> Boxed (Stored int) -> list_dim -> bool attribute(inline) =
  real_member_list_dim;


real_member_list_dim
  (i : Boxed (Stored int)) (d : list_dim)
  -> bool attribute(inline, inline_sequential) =

  let ix_i = unboxIntValue i in
  case d of mk_list_dim tyob (m_size : MaybeVal int).
  case m_size of {
    nothingVal. ix_i >=# 0
  ; justVal size_i. and (ix_i >=# 0) (ix_i <# size_i)
  };


slice_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> Boxed SliceObject -> list_dim -> (Boxed (Stored int), list_dim)
  attribute(inline) =
  real_slice_list_dim;


real_slice_list_dim
  (sl : Boxed SliceObject) (dom : list_dim)
  -> (Boxed (Stored int), list_dim) attribute(inline, inline_sequential) =

  case sl of [reprSizeAlign @SliceObject (unboxedinfo SliceObject)]
             boxed tyob (sliceObject m_slice_lo m_slice_hi m_m_stride).

  -- Find intersection of slice with domain
  letfun
    intersect_with_dom (dummy : NoneType) -> (Boxed (Stored int), list_dim) =
      case dom of mk_list_dim tyob dom_ub.
      let dom_iv = interval (justVal @int 0) dom_ub in
      let slice_iv = interval m_slice_lo m_slice_hi in
      case intersectInterval slice_iv dom_iv of interval lb ub.
      case lb of {
        justVal off.
          -- Subtract offset from the upper bound to get the size
          let dom_size =
                case ub of {
                  justVal n. justVal @int (n -# off)
                ; nothingVal. nothingVal @int
                } in
          (boxIntValue off, con_list_dim dom_size)
      ; nothingVal.
          -- Cannot happen because list is bounded
          except @(Boxed (Stored int), list_dim)
      } in
  
  -- Convert the slice to a lower and upper bound
  -- Stride must not be given
  case m_m_stride of {
    nothingVal.
      case m_slice_lo of {
        justVal lb.
          -- If high bound is less than low bound, slice is empty
          case m_slice_hi of {
            justVal ub.
              if lb ># ub
              then (boxIntValue 0, con_list_dim (justVal @int 0))
              else intersect_with_dom None
          ; nothingVal.
              intersect_with_dom None
          }
      ; nothingVal.
          intersect_with_dom None
      }
  ; justVal x. except @(Boxed (Stored int), list_dim)
  };


split_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> list_dim -> MaybeVal (list_dim, Boxed (Stored int), list_dim)
  attribute(inline) =
  real_split_list_dim;


real_split_list_dim
  (dom : list_dim)
  -> MaybeVal (list_dim, Boxed (Stored int), list_dim) =

  case dom of mk_list_dim tyob m_size.
  case m_size of {
    nothingVal. nothingVal @(list_dim, Boxed (Stored int), list_dim)
  ; justVal size_i.
      if size_i >=# 2
      then let midpoint = size_i //# 2 in
           justVal @(list_dim, Boxed (Stored int), list_dim)
           (con_list_dim (justVal @int midpoint),
            boxIntValue midpoint,
            con_list_dim (justVal @int (size_i -# midpoint)))
      else nothingVal @(list_dim, Boxed (Stored int), list_dim)
  };


splitN_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> int -> list_dim -> view list_dim (Subdomain list_dim) attribute(inline) =
  real_splitN_list_dim;


real_splitN_list_dim
  (n : int) (d : list_dim)
  -> view list_dim (Subdomain list_dim) attribute(inline) =

  case d of mk_list_dim tyob (m_size : MaybeVal int).
  case m_size of {
    justVal size.
      con_view @list_dim @(Subdomain list_dim)
      (con_list_dim (justVal @int n))
      (\ (i : (Boxed (Stored int))) -> Subdomain list_dim.
         let ui    = unboxIntValue i in
         let start = (ui *# size)        //# n in
         let end   = ((ui +# 1) *# size) //# n in
         let off   = boxIntValue start in
         let dom   = con_list_dim (justVal @int (end -# start)) in
         con_subdomain @list_dim off dom)
  ; nothingVal.
     except @(view list_dim (Subdomain list_dim))
  };


checkSubdomain_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> list_dim -> list_dim -> bool attribute(inline) =
  real_checkSubdomain_list_dim;


real_checkSubdomain_list_dim
  (d subd : list_dim) -> bool attribute(inline) =

  -- Check is not needed
  True;


peel_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> forall a r : box.
     Repr (AsBare a) -> Boxed (Stored ParHint) ->
     (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
     view list_dim (Stream list_dim a) -> r
  attribute(inline) =
  real_peel_list_dim;


real_peel_list_dim @(a r : box)
  (rep_a : ReprBox a)
  (par_hint : Boxed (Stored ParHint))
  (value_k : a -> Stream list_dim a -> r) -- Success continuation
  (empty_k : NoneType -> r)               -- Failure
  (vw : view list_dim (Stream list_dim a))
  -> r attribute(inline, inline_sequential) =

  case vw of mk_view tyob (mk_list_dim tyob2 m_bound) visit.

  letfun
    search (i : int) -> r =
      -- Loop bound check
      if case m_bound of {justVal n. i <# n; nothingVal. True}
      then letfun {
             found_value (value : a) (s : Stream list_dim a) -> r =

               -- Get the rest of this chunk of the stream
               let new_dom =
                     case m_bound of {
                       nothingVal. con_list_dim (nothingVal @int)
                     ; justVal n. con_list_dim (justVal @int (n -# i))
                     } in
               let remainder_input =
                     con_stream @list_dim @a (unboxParHintValue par_hint)
                     (viewToSplittable @list_dim @a (ShapeDict_list_dim_loop_breaker None)
                      (con_view @list_dim @(Stream list_dim a) new_dom
                       (\ (j : Boxed (Stored int)) -> Stream list_dim a.
                          visit (boxIntValue (i +# unboxIntValue j))))) in

               let remainder = chain @a s remainder_input in

               value_k value remainder

           ; not_found (dummy : NoneType) -> r = search (i +# 1)
           } in

           peel_Stream @a @r rep_a found_value not_found (visit (boxIntValue i))

      else empty_k None
  in
  search 0;


flatten_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> forall a : box. ReprBox a -> Stream list_dim a -> Stream list_dim a
  attribute(inline) =
  real_flatten_list_dim;


real_flatten_list_dim @(a : box) (rep : ReprBox a) (s : Stream list_dim a)
  -> Stream list_dim a =
  s;


generate_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> forall a : box.
     Repr (AsBare a) -> BoxOffset list_dim -> list_dim ->
     (BoxIndex list_dim -> a) -> Stream list_dim a
  attribute(inline) =
  real_generate_list_dim;


real_generate_list_dim @(a : box)
  (rep_a : ReprBox a)
  (off : BoxOffset list_dim) (dom : list_dim) (g : BoxIndex list_dim -> a)
  -> Stream list_dim a attribute(inline) =

  -- Create a view.  Apply the offset before calling g.
  let vw : view list_dim a =
        con_view @list_dim @a dom
        (\ (i : BoxIndex list_dim) -> a.
           -- Apply the offset
           g (real_addOffset_list_dim off i)) in

  -- Convert to a stream
  traverse_view_real @list_dim @a ShapeDict_list_dim rep_a vw;


zipWith_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> forall a b c : box.
     Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
     (a -> b -> c) ->
     Stream list_dim a -> Stream list_dim b -> Stream list_dim c
  attribute(inline) =
  real_zipWith_list_dim;


real_zipWith_list_dim @(a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : Stream list_dim a)
  (s2 : Stream list_dim b)
  -> Stream list_dim c
  attribute(inline) =

  letfun
    zip_using_sequences (dummy : NoneType) -> Stream list_dim c =
      con_stream @list_dim @c hintAny
      (con_seqStream @c
       (zipWith_Seq @a @b @c f
        (streamToSequence @a s1) (streamToSequence @b s2)))
  in

  case s1 of stream tyob par_hint1 i_s1.
  case i_s1 of {
    ixStream tyob rs1.
      case s2 of stream tyob par_hint2 i_s2.
      case i_s2 of {
        ixStream tyob rs2.
          -- The most restrictive parallelism hint determines amount of
          -- parallelism
          let par_hint = leastParHint par_hint1 par_hint2 in

          con_stream @list_dim @c par_hint
          (con_ixStream @list_dim @c
           (zipWith_RStream @list_dim @a @b @c ShapeDict_list_dim rep_a rep_b rep_c f rs1 rs2))

      ; seqStream tyob co sq. zip_using_sequences None
      ; nestedIxStream @d2 tyob co sh2 vw. zip_using_sequences None
      ; nestedSeqStream tyob co sq. zip_using_sequences None
      }
    ; seqStream tyob co sq. zip_using_sequences None
    ; nestedIxStream @d2 tyob co sh2 vw. zip_using_sequences None
    ; nestedSeqStream tyob co sq. zip_using_sequences None
  };


fold_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> forall a acc : box.
     Repr (AsBare a) -> Repr (AsBare acc) ->
     (a -> acc -> acc) -> Stream list_dim a -> acc -> acc
  attribute(inline) =

  real_fold_list_dim;


real_fold_list_dim @(a acc : box)
  (rep_a : ReprBox a)
  (rep_acc : ReprBox acc)
  (combine : a -> acc -> acc)
  (s : Stream list_dim a)
  (init : acc)
  -> acc
  attribute(inline,
            inline_struct(T T T D(T C) T) -- Inline if stream constructor known
           ) =

  case unStream @list_dim @a s of {
    seqStream tyob co sq. fold_Seq @a @acc combine sq init

  ; nestedIxStream @d tyob co sh rs.
      let rep_stream = repr_Box @(Stream list_dim a) in
      let outer_stream : Stream d (Stream list_dim a) =
            traverse_view_real @d @(Stream list_dim a) sh rep_stream
            (rStreamToView @d @(Stream list_dim a) rs) in

      -- Outer loop over 'dom'
      shFold @d sh @(Stream list_dim a) @acc rep_stream rep_acc
      (\ (s : Stream list_dim a) (x : acc) -> acc.
         -- Inner loop
         real_fold_list_dim @a @acc rep_a rep_acc combine s x)
      outer_stream
      init

  ; nestedSeqStream tyob co sq.
     -- Nested fold
     fold_Seq @(Stream list_dim a) @acc
     (\ (s : Stream list_dim a) (local_init : acc) -> acc.
        real_fold_list_dim @a @acc rep_a rep_acc combine s local_init)
     sq init

  ; ixStream tyob rs.
      case rStreamToView @list_dim @a rs of mk_view tyob dom gen.
      case dom of mk_list_dim tyob bound.
      -- Loop over 'dom'
      letfun
        foldit (i : int) (x : acc) -> acc =
          if case bound of {justVal n. i <# n; nothingVal. True}
          then foldit (i +# 1) (combine (gen (boxIntValue i)) x)
          else x
      in
        foldit 0 init      
  };
  --fold_Seq @a @acc combine (streamToSequence @a s) init;


imp_fold_list_dim @(a : box)
  (rep_a : ReprBox a)
  (combine : a -> Store -> Store)
  (s : Stream list_dim a)
  (init : Store)
  -> Store
  attribute(inline,
            inline_struct(T T D(T C) T) -- Stream constructor is known
           ) =

  case s of stream tyob par_hint i_s.
  case i_s of {
    seqStream tyob co sq.
      imp_fold_Seq @a combine sq init

  ; nestedIxStream @d2 tyob co sh2 (rStream @b tyob2 rep_b extract si).
      case someIndexableToView @d2 @b rep_b si of mk_view tyob2 dom gen.

      -- Outer loop over 'dom'
      let off = boxIntValue 0 in
      shForeach @d2 sh2 dom (shNoOffset @d2 sh2)
      (\ (outer_i : BoxIndex d2) (state : Store) -> Store.

         -- Inner loop
         imp_fold_list_dim @a rep_a combine (extract (gen outer_i)) state)
      init

  ; nestedSeqStream tyob co sq.
     -- Nested fold
     imp_fold_Seq @(Stream list_dim a)
     (\ (s : Stream list_dim a) (local_state : Store) -> Store.
        imp_fold_list_dim @a rep_a combine s local_state)
     sq init

  ; ixStream tyob (rStream @b tyob2 rep_b f si).

      -- Loop over the indexable object
      case someIndexableToView @list_dim @b rep_b si of mk_view tyob dom gen.

      let off = boxIntValue 0 in
      foreach_list_dim dom off
      (\ (outer_i : BoxIndex list_dim) (state : Store) -> Store.
         combine (f (gen outer_i)) state)
      init
  };


-- Loop over the entire domain and accumulate a value
foreach_list_dim
  (dom : list_dim)
  (off : BoxOffset list_dim)
  (combine : BoxIndex list_dim -> Store -> Store)
  (init : Store)
  -> Store attribute(inline) =

  case dom of mk_list_dim tyob m_size.
  case m_size of {
    justVal bound.
      let start = unboxIntValue off in
      let end = start +# bound in
      letfun
        step (i : int) (x : Store) -> Store =
          if i <# end
          then step (i +# 1) (combine (boxIntValue i) x)
          else x
      in
      step start init

  ; nothingVal.
      except @Store
  };


foreachSeq_list_dim
  (r1 : Repr (index list_dim)) (r2 : Repr (offset list_dim)) (r3 : Repr (slice list_dim))
  -> forall a : box. list_dim -> (Boxed (Stored int) -> Seq a) -> Seq a
  attribute(inline) =
  real_foreachSeq_list_dim;


real_foreachSeq_list_dim @(a : box)
  (d : list_dim) (k : Boxed (Stored int) -> Seq a)
  -> Seq a attribute(inline, inline_sequential) =

  case d of mk_list_dim tyob m_bound.

  let type state = Boxed (Stored int) in

  -- Count from 0 up to bound
  letfun
    next (s : state) -> SeqStep state (Boxed (Stored int)) =
      let i = unboxIntValue s in
      if case m_bound of {justVal n. i >=# n; nothingVal. False}
      then seqDone @state @(Boxed (Stored int))
      else seqYield @state @(Boxed (Stored int)) (boxIntValue (i +# 1)) s
  in
  let generator = con_seq @(Boxed (Stored int)) @state (boxIntValue 0) next in
  bind_Seq @(Boxed (Stored int)) @a generator k;


ShapeDict_chain_dim : ShapeDict chain_dim =
  shapeDict @chain_dim (boxedinfo shapeDict @chain_dim)
  repr_bool
  repr_NoneType
  (repr_Box @chain_dim)
  noOffset_chain_dim
  addOffset_chain_dim
  appOffset_chain_dim
  intersect_chain_dim
  member_chain_dim
  slice_chain_dim
  split_chain_dim
  splitN_chain_dim
  checkSubdomain_chain_dim
  peel_chain_dim
  flatten_chain_dim
  generate_chain_dim
  zipWith_chain_dim
  fold_chain_dim
  imp_fold_chain_dim_wrapper
  foreach_chain_dim_wrapper
  foreachSeq_chain_dim;


imp_fold_chain_dim_wrapper : ImperativeFoldFunction chain_dim =
  imperativeFoldFunction @chain_dim imp_fold_chain_dim;

foreach_chain_dim_wrapper : ImperativeForeachFunction chain_dim =
  imperativeForeachFunction @chain_dim foreach_chain_dim;


noOffset_chain_dim : Boxed (Stored NoneType) attribute(inline) =
  boxNoneValue None;


addOffset_chain_dim (x y : Boxed (Stored NoneType))
  -> Boxed (Stored NoneType) attribute(inline) = x;


appOffset_chain_dim (x : Boxed (Stored NoneType)) (y : Boxed (Stored bool))
  -> Boxed (Stored bool) attribute(inline) = y;


intersect_chain_dim (d1 d2 : chain_dim)
  -> chain_dim attribute(inline, inline_final) =
  case d1 of mk_chain_dim tyob n1.
  case d2 of mk_chain_dim tyob n2.
  mk_chain_dim tyob (oper_BITWISEAND n1 n2);


member_chain_dim (i : Boxed (Stored bool)) (d : chain_dim)
  -> bool attribute(inline, inline_sequential) =

  -- Test either the first or second bit of the number
  let test_bit = if unboxBoolValue i then 2 else 1 in
  case d of mk_chain_dim tyob n.

  -- It's a member if the selected bit of n is set
  oper_BITWISEAND n test_bit /=# 0;


slice_chain_dim (sl dom : chain_dim)
  -> (Boxed (Stored NoneType), chain_dim)
  attribute(inline, inline_sequential) =
  (boxNoneValue None, intersect_chain_dim sl dom);


split_chain_dim (dom : chain_dim)
  -> MaybeVal (chain_dim, Boxed (Stored NoneType), chain_dim) =

  -- TODO
  except @(MaybeVal (chain_dim, Boxed (Stored NoneType), chain_dim));


splitN_chain_dim (n : int) (dom : chain_dim)
  -> view list_dim (Subdomain chain_dim) =

  -- TODO
  except @(view list_dim (Subdomain chain_dim));


checkSubdomain_chain_dim
  -> chain_dim -> chain_dim -> bool attribute(inline) =
  real_checkSubdomain_chain_dim;


real_checkSubdomain_chain_dim
  (d subd : chain_dim) -> bool attribute(inline) =

  -- Check is not needed
  True;


peel_chain_dim @(a r : box)
  (rep_a : ReprBox a)
  (par_hint : Boxed (Stored ParHint))
  (value_k : a -> Stream list_dim a -> r) -- Success continuation
  (empty_k : NoneType -> r)               -- Failure
  (vw : view chain_dim (Stream list_dim a))
  -> r attribute(inline, inline_sequential) =

  -- TODO
  except @r;


flatten_chain_dim @(a : box) (rep : ReprBox a) (s : Stream chain_dim a)
  -> Stream list_dim a attribute(inline) =

  -- TODO
  except @(Stream list_dim a);


generate_chain_dim @(a : box)
  (rep_a : ReprBox a)
  (off : BoxOffset chain_dim) (dom : chain_dim) (g : BoxIndex chain_dim -> a)
  -> Stream chain_dim a
  attribute(inline) =

  -- TODO
  except @(Stream chain_dim a);


zipWith_chain_dim @(a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : Stream chain_dim a)
  (s2 : Stream chain_dim b)
  -> Stream chain_dim c attribute(inline, inline_sequential) =

  -- TODO
  except @(Stream chain_dim c);


fold_chain_dim @(a acc : box)
  (rep_a : ReprBox a)
  (rep_acc : ReprBox acc)
  (combine : a -> acc -> acc)
  (s : Stream chain_dim a)
  (init : acc)
  -> acc
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case i_s of {
    ixStream tyob (rStream @b tyob2 rep_b f (someIndexable @t tyob3 co ix_dict container)).
      case coerce @(shape t) @chain_dim (ix_shape @t ix_dict @b container) of
        mk_chain_dim tyob domain_int.

      letfun
        eval (ix : bool) (x : acc) -> acc =

          let coerced_index =
                coerce @(BoxIndex chain_dim) @(BoxIndex (shape t)) (boxBoolValue ix) in
          let y = ix_at @t ix_dict @b rep_b container coerced_index in
          combine (f y) x
      in

      -- Enumerate the elements of the domain
      let tmp1 =
            if oper_BITWISEAND domain_int 1 /=# 0
            then eval False init
            else init in

      if oper_BITWISEAND domain_int 2 /=# 0
      then eval True tmp1
      else tmp1

    -- Only the ixStream constructor is possible
  ; seqStream tyob co sq. except @acc
  ; nestedIxStream @sh tyob co ix si. except @acc
  ; nestedSeqStream tyob co sq. except @acc
  };


imp_fold_chain_dim @(a : box)
  (rep_a : ReprBox a)
  (combine : a -> Store -> Store)
  (s : Stream chain_dim a)
  (init : Store)
  -> Store
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case i_s of {
    ixStream tyob (rStream @b tyob2 rep_b f (someIndexable @t tyob3 co ix_dict container)).
      case coerce @(shape t) @chain_dim (ix_shape @t ix_dict @b container) of
        mk_chain_dim tyob domain_int.

      letfun
        eval (ix : bool) (x : Store) -> Store =

          let coerced_index =
                coerce @(BoxIndex chain_dim) @(BoxIndex (shape t)) (boxBoolValue ix) in
          let y = ix_at @t ix_dict @b rep_b container coerced_index in
          combine (f y) x
      in

      -- Enumerate the elements of the domain
      let tmp1 =
            if oper_BITWISEAND domain_int 1 /=# 0
            then eval False init
            else init in

      if oper_BITWISEAND domain_int 2 /=# 0
      then eval True tmp1
      else tmp1

    -- Only the ixStream constructor is possible
  ; seqStream tyob co sq. except @Store
  ; nestedIxStream @sh tyob co ix si. except @Store
  ; nestedSeqStream tyob co sq. except @Store
  };


foreach_chain_dim
  (dom : chain_dim)
  (off : BoxOffset chain_dim)
  (combine : BoxIndex chain_dim -> Store -> Store)
  (init : Store)
  -> Store =

  -- TODO
  except @Store;


foreachSeq_chain_dim @(a : box)
  (dom : chain_dim)
  (k : BoxIndex chain_dim -> Seq a)
  -> Seq a =

  -- TODO
  except @(Seq a);

ShapeDict_dim0 : ShapeDict dim0 =
  shapeDict @dim0 (boxedinfo shapeDict @dim0)
  repr_NoneType
  repr_NoneType
  repr_NoneType
  real_noOffset_dim0
  real_addOffset_dim0
  real_addOffset_dim0 -- This is 'appOffset'
  real_intersect_dim0
  real_member_dim0
  real_slice_dim0
  real_split_dim0
  real_splitN_dim0
  real_checkSubdomain_dim0
  real_peel_dim0
  real_flatten_dim0
  real_generate_dim0
  real_zipWith_dim0
  real_fold_dim0
  real_imp_fold_dim0_wrapper
  real_foreach_dim0_wrapper
  real_foreachSeq_dim0;


-- This is to avoid recursion
-- FIXME: handle recursion properly
ShapeDict_dim0_loop_breaker (dummy : NoneType) -> ShapeDict dim0 attribute(inline_never) =
  ShapeDict_dim0;


imp_fold_dim0_wrapper
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> ImperativeFoldFunction dim0 attribute(inline) =
  real_imp_fold_dim0_wrapper;


real_imp_fold_dim0_wrapper : ImperativeFoldFunction dim0 attribute(inline) =
  imperativeFoldFunction @dim0 imp_fold_dim0;


foreach_dim0_wrapper
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> ImperativeForeachFunction dim0 attribute(inline) =
  real_foreach_dim0_wrapper;


real_foreach_dim0_wrapper : ImperativeForeachFunction dim0 attribute(inline) =
  imperativeForeachFunction @dim0 foreach_dim0;


noOffset_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> Boxed (Stored NoneType) =
  real_noOffset_dim0;


real_noOffset_dim0 : Boxed (Stored NoneType) attribute(inline) =
  boxNoneValue None;


-- The same function works as both 'addOffset_dim0' and 'appOffset_dim0'.
addOffset_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  ->  Boxed (Stored NoneType) -> Boxed (Stored NoneType) -> Boxed (Stored NoneType) =
  real_addOffset_dim0;


-- The same function works as both 'addOffset_dim0' and 'appOffset_dim0'.
real_addOffset_dim0 (x y : Boxed (Stored NoneType)) -> Boxed (Stored NoneType) =
  x;


intersect_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> dim0 -> dim0 -> dim0 =
  real_intersect_dim0;


real_intersect_dim0 (x y : dim0) -> dim0 = x;


member_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> Boxed (Stored NoneType) -> dim0 -> bool =
  real_member_dim0;


real_member_dim0 (ix : Boxed (Stored NoneType)) (dom : dim0) -> bool =
  True;


slice_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> Boxed (Stored NoneType) -> dim0 -> (Boxed (Stored NoneType), dim0) =
  real_slice_dim0;


real_slice_dim0 (ix : Boxed (Stored NoneType)) (dom : dim0)
  -> (Boxed (Stored NoneType), dim0) attribute(inline) =
  (boxNoneValue None, dom);


split_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> dim0 -> MaybeVal (dim0, Boxed (Stored NoneType), dim0)
  attribute(inline) =
  real_split_dim0;


real_split_dim0
  (dom : dim0)
  -> MaybeVal (dim0, Boxed (Stored NoneType), dim0) =
  nothingVal @(dim0, Boxed (Stored NoneType), dim0);


splitN_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> int -> dim0 -> view list_dim (Subdomain dim0) =
  real_splitN_dim0;


real_splitN_dim0 (n : int) (dom : dim0) -> view list_dim (Subdomain dim0) =

  -- Cannot subdivide a dim0
  con_view @list_dim @(Subdomain dim0)
  (con_list_dim (justVal @int 1))
  (\ (i : Boxed (Stored int)) -> Subdomain dim0.
     con_subdomain @dim0 (boxNoneValue None) dom);


checkSubdomain_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> dim0 -> dim0 -> bool attribute(inline) =
  real_checkSubdomain_dim0;


real_checkSubdomain_dim0
  (d subd : dim0) -> bool attribute(inline) =

  -- All dim0s are equal
  True;

peel_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> forall a r : box.
     Repr (AsBare a) -> Boxed (Stored ParHint) ->
     (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
     view dim0 (Stream list_dim a) -> r =
  real_peel_dim0;


real_peel_dim0 @(a r : box)
  (rep : Repr (AsBare a))
  (par_hint : Boxed (Stored ParHint))
  (value_k : a -> Stream list_dim a -> r)
  (empty_k : NoneType -> r)
  (vw : view dim0 (Stream list_dim a)) -> r attribute(inline) =

  case vw of mk_view tyob dom f.
  peel_Stream @a @r rep value_k empty_k (f (boxNoneValue None));


generate_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> forall a : box. ReprBox a -> BoxOffset dim0 -> dim0 -> (Boxed (Stored NoneType) -> a)
  -> Stream dim0 a attribute(inline) =
  real_generate_dim0;


real_generate_dim0 @(a : box)
  (rep : Repr (AsBare a)) (off : BoxOffset dim0) (d : dim0)
  (f : Boxed (Stored NoneType) -> a)
  -> Stream dim0 a attribute(inline) =
  traverse_view_real @dim0 @a (ShapeDict_dim0_loop_breaker None) rep
  (con_view @dim0 @a con_dim0 f);


flatten_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> forall a : box. ReprBox a -> Stream dim0 a -> Stream list_dim a attribute(inline) =
  real_flatten_dim0;


real_flatten_dim0 @(a : box) (rep : Repr (AsBare a)) (s : Stream dim0 a)
  -> Stream list_dim a attribute(inline) =
  case rStreamToView @dim0 @a (fromIxStream @dim0 @a (unStream @dim0 @a s)) of
    mk_view tyob d f.

  -- Create a 1D list view
  let d : list_dim = con_list_dim (justVal @int 1) in

  real_generate_list_dim @a rep (boxIntValue 0) d
  (\ (i : Boxed (Stored int)) -> a. f (boxNoneValue None));


zipWith_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> forall a b c : box.
     Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
     (a -> b -> c) ->
     Stream dim0 a -> Stream dim0 b -> Stream dim0 c
  attribute(inline) =
  real_zipWith_dim0;


real_zipWith_dim0 @(a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : Stream dim0 a)
  (s2 : Stream dim0 b)
  -> Stream dim0 c
  attribute(inline) =

  case s1 of stream tyob par_hint1 i_s1.
  let rs1 = fromIxStream @dim0 @a i_s1 in
  case s2 of stream tyob par_hint2 i_s2.
  let rs2 = fromIxStream @dim0 @b i_s2 in

  let par_hint = leastParHint par_hint1 par_hint2 in

  con_stream @dim0 @c par_hint
  (con_ixStream @dim0 @c
   (zipWith_RStream @dim0 @a @b @c
    (ShapeDict_dim0_loop_breaker None) rep_a rep_b rep_c f rs1 rs2));


fold_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> forall a acc : box.
     Repr (AsBare a) -> Repr (AsBare acc) ->
     (a -> acc -> acc) -> Stream dim0 a -> acc -> acc
  attribute(inline) =

  real_fold_dim0;


real_fold_dim0 @(a acc : box)
  (rep_a : ReprBox a)
  (rep_acc : ReprBox acc)
  (combine : a -> acc -> acc)
  (s : Stream dim0 a)
  (init : acc)
  -> acc
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case rStreamToView @dim0 @a (fromIxStream @dim0 @a i_s) of
    mk_view tyob dom get.

  -- Apply the combining function to the value
  combine (get (boxNoneValue None)) init;


imp_fold_dim0 @(a : box)
  (rep_a : ReprBox a)
  (combine : a -> Store -> Store)
  (s : Stream dim0 a)
  (init : Store)
  -> Store
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case rStreamToView @dim0 @a (fromIxStream @dim0 @a i_s) of
    mk_view tyob dom get.

  foreach_dim0 dom (boxNoneValue None)
  (\ (i : BoxIndex dim0) (s : Store) -> Store. combine (get i) s)
  init;


foreach_dim0
  (dom : dim0)
  (off : BoxOffset dim0)
  (combine : BoxIndex dim0 -> Store -> Store)
  (init : Store)
  -> Store attribute(inline) =

  combine (boxNoneValue None) init;


foreachSeq_dim0
  (r1 : Repr (index dim0)) (r2 : Repr (offset dim0)) (r3 : Repr (slice dim0))
  -> forall a : box. dim0 -> (BoxIndex dim0 -> Seq a) -> Seq a
  attribute(inline) =
  real_foreachSeq_dim0;


real_foreachSeq_dim0 @(a : box)
  (dom : dim0)
  (k : BoxIndex dim0 -> Seq a)
  -> Seq a attribute(inline, inline_sequential) =

  k (boxNoneValue None);


ShapeDict_dim1 : ShapeDict dim1 =
  shapeDict @dim1 (boxedinfo shapeDict @dim1)
  repr_int
  repr_NoneType
  repr_SliceObject
  real_noOffset_dim1
  real_addOffset_dim1
  real_appOffset_dim1
  real_intersect_dim1
  real_member_dim1
  real_slice_dim1
  real_split_dim1
  real_splitN_dim1
  real_checkSubdomain_dim1
  real_peel_dim1
  real_flatten_dim1
  real_generate_dim1
  real_zipWith_dim1
  real_fold_dim1
  real_imp_fold_dim1_wrapper
  real_foreach_dim1_wrapper
  real_foreachSeq_dim1;


-- FIXME: Handle recursion properly
-- This function is needed to break a recursive cycle
ShapeDict_dim1_loop_breaker (dummy : NoneType)
  -> ShapeDict dim1 attribute(inline_never) =
  ShapeDict_dim1;

imp_fold_dim1_wrapper
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> ImperativeFoldFunction dim1 attribute(inline) =
  real_imp_fold_dim1_wrapper;


real_imp_fold_dim1_wrapper : ImperativeFoldFunction dim1 attribute(inline) =
  imperativeFoldFunction @dim1 imp_fold_dim1;


foreach_dim1_wrapper
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> ImperativeForeachFunction dim1 attribute(inline) =
  real_foreach_dim1_wrapper;


real_foreach_dim1_wrapper : ImperativeForeachFunction dim1 attribute(inline) =
  imperativeForeachFunction @dim1 foreach_dim1;


noOffset_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> Boxed (Stored NoneType) attribute(inline) =
  real_noOffset_dim1;


real_noOffset_dim1 : Boxed (Stored NoneType) attribute(inline) =
  boxNoneValue None;


addOffset_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> BoxOffset dim1 -> BoxOffset dim1 -> BoxOffset dim1 attribute(inline) =
  real_addOffset_dim1;


real_addOffset_dim1 (x y : BoxOffset dim1) -> BoxOffset dim1 = x;


appOffset_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> BoxOffset dim1 -> BoxIndex dim1 -> BoxIndex dim1 attribute(inline) =
  real_appOffset_dim1;


real_appOffset_dim1 (x : BoxOffset dim1) (y : BoxIndex dim1) -> BoxIndex dim1 = y;


intersect_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> dim1 -> dim1 -> dim1 attribute(inline) =
  real_intersect_dim1;

real_intersect_dim1 (d e : dim1) -> dim1 attribute(inline, inline_final) =
  case d of mk_dim1 tyob (iv1 : Interval) (m1 : LinearMap).
  case e of mk_dim1 tyob (iv2 : Interval) (m2 : LinearMap).
  case intersectLM m1 m2 of {
    justVal (m3 : LinearMap).
      let iv3 : Interval = trimInterval (intersectInterval iv1 iv2) m3 in
      con_dim1 iv3 m3
  ; nothingVal.
      con_dim1 (interval (justVal @int 0) (justVal @int 0)) (linearMap 1 0)
  };


member_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> Boxed (Stored int) -> dim1 -> bool attribute(inline) =
  real_member_dim1;


real_member_dim1 (ix : Boxed (Stored int)) (dom : dim1)
  -> bool attribute(inline) =
  case dom of mk_dim1 tyob (iv : Interval) (lm : LinearMap).
  let ix_i = unboxIntValue ix in

  -- Point must be in the interval and in the linear map
  if inInterval ix_i iv
  then inLM ix_i lm
  else False;


slice_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> BoxSlice dim1 -> dim1 -> (BoxOffset dim1, dim1) attribute(inline) =
  real_slice_dim1;


real_slice_dim1 (s : Boxed SliceObject) (d : dim1)
  -> (BoxOffset dim1, dim1) attribute(inline) =
  case s of [reprSizeAlign @SliceObject (unboxedinfo SliceObject)]
            boxed tyob u_s.
  (boxNoneValue None, internalApplyArraySlice u_s d);


split_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> dim1 -> MaybeVal (dim1, Boxed (Stored NoneType), dim1) attribute(inline) =
  real_split_dim1;


real_split_dim1 (d : dim1)
  -> MaybeVal (dim1, Boxed (Stored NoneType), dim1)
  attribute(inline, inline_final) =

  case d of mk_dim1 tyob (interval m_lo m_hi) lm.
  case lm of linearMap stride alignment.

  -- Subdivide the domain.
  let lo = case m_lo of {justVal n. n; nothingVal. except @int} in
  let hi = case m_hi of {justVal n. n; nothingVal. except @int} in
  let delta = hi -# lo in

  -- If the interval doesn't contain at least two points, the split fails.
  if delta <# stride +# stride
  then nothingVal @(dim1, Boxed (Stored NoneType), dim1)
  else
    let midpoint = hi +# lo //# 2 in
    let iv1 = trimInterval (interval (justVal @int lo) (justVal @int midpoint)) lm in
    let iv2 = trimInterval (interval (justVal @int midpoint) (justVal @int hi)) lm in

    justVal @(dim1, Boxed (Stored NoneType), dim1)
    (con_dim1 iv1 lm, boxNoneValue None, con_dim1 iv2 lm);


splitN_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> int -> dim1 -> view list_dim (Subdomain dim1) attribute(inline) =
  real_splitN_dim1;


real_splitN_dim1 (n : int) (dom : dim1)
  -> view list_dim (Subdomain dim1) attribute(inline) =
  case dom of mk_dim1 tyob (interval m_lo m_hi) lm.
  case lm of linearMap stride alignment.

  -- Get number of points in range
  let lo = case m_lo of {justVal n. n; nothingVal. except @int} in
  let hi = case m_hi of {justVal n. n; nothingVal. except @int} in
  let n_points = (hi -# lo) //# stride in

  let boxed_none = boxNoneValue None in

  -- Partition into N segments
  con_view @list_dim @(Subdomain dim1)
  (con_list_dim (justVal @int n))
   (\ (i : Boxed (Stored int)) -> Subdomain dim1.
      let ui       = unboxIntValue i in

      -- Indices of start and end points, in the range [0, n_points)
      let start_ix = (ui *# n_points)        //# n in
      let end_ix   = ((ui +# 1) *# n_points) //# n in

      -- The actual interval
      let start    = lo +# start_ix *# stride in
      let end      = lo +# end_ix *# stride in
      let dom      = con_dim1 (interval (justVal @int start) (justVal @int end)) lm in
      con_subdomain @dim1 boxed_none dom);


checkSubdomain_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> dim1 -> dim1 -> bool attribute(inline) =
  real_checkSubdomain_dim1;


real_checkSubdomain_dim1
  (d subd : dim1) -> bool attribute(inline) =

  case d of mk_dim1 tyob (interval d_m_lo d_m_hi) (linearMap d_s d_a).
  case subd of mk_dim1 tyob (interval subd_m_lo subd_m_hi) (linearMap subd_s subd_a).

  -- Strides must be equal
  case subd_m_lo of {
    justVal subd_lo.
      case subd_m_hi of {
        justVal subd_hi.
          -- Subdomain must be bounded
          if d_s ==# subd_s
          then True
          else except @bool
      ; nothingVal.
          except @bool
      }
  ; nothingVal.
      except @bool
  };


peel_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
   -> forall a r : box.
      ReprBox a -> Boxed (Stored ParHint) ->
      (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
      view dim1 (Stream list_dim a) -> r attribute(inline) =
  real_peel_dim1;


real_peel_dim1 @(a r : box)
  (rep_a : ReprBox a) (par_hint : Boxed (Stored ParHint))
  (value_k : a -> Stream list_dim a -> r) (empty_k : NoneType -> r)
  (vw : view dim1 (Stream list_dim a))
  -> r attribute(inline, inline_sequential) =

  case vw of mk_view tyob dom visit.
  case dom of mk_dim1 tyob (interval m_lo m_hi) lm.
  case lm of linearMap stride alignment.

  -- Start searching at 'lo'
  let lo = case m_lo of {justVal n. n; nothingVal. except @int} in
  let hi = case m_hi of {justVal n. n; nothingVal. except @int} in

  letfun
    search (i : int) -> r =
      -- Loop bound check
      if i <# hi
      then letfun {
             found_value (value : a) (s : Stream list_dim a) -> r =

               -- Get the rest of this chunk of the stream
               let new_dom =
                     con_dim1 (interval (justVal @int (i +# stride)) m_hi) lm in
               let remainder_input =
                     con_stream @list_dim @a (unboxParHintValue par_hint)
                     (viewToSplittable @dim1 @a (ShapeDict_dim1_loop_breaker None)
                      (con_view @dim1 @(Stream list_dim a) new_dom visit)) in

               let remainder = chain @a s remainder_input in

               value_k value remainder

           ; not_found (dummy : NoneType) -> r = search (i +# stride)
           } in

           peel_Stream @a @r rep_a found_value not_found (visit (boxIntValue i))

      else empty_k None
  in
  search lo;


flatten_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> forall a : box. ReprBox a -> Stream dim1 a -> Stream list_dim a attribute(inline) =
  real_flatten_dim1;


real_flatten_dim1 @(a : box) (rep : ReprBox a) (s : Stream dim1 a)
  -> Stream list_dim a attribute(inline) =

  -- Flatten by creating a splittable stream
  case s of stream tyob par_hint i_s.
  let rs = fromIxStream @dim1 @a i_s in
  con_stream @list_dim @a par_hint
  (con_nestedIxStream @a @dim1
   (ShapeDict_dim1_loop_breaker None)
   (map_RStream @dim1 @a @(Stream list_dim a) (unit_Stream @a rep) rs));


generate_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> forall a : box.
     Repr (AsBare a) -> BoxOffset dim1 -> dim1 ->
     (BoxIndex dim1 -> a) -> Stream dim1 a
  attribute(inline) =
  real_generate_dim1;


real_generate_dim1 @(a : box)
  (rep_a : ReprBox a)
  (off : BoxOffset dim1) (dom : dim1) (g : BoxIndex dim1 -> a)
  -> Stream dim1 a attribute(inline) =

  -- Create and traverse a view.
  -- The offset is always None, so ignore it.
  let vw = con_view @dim1 @a dom g in
  traverse_view_real @dim1 @a (ShapeDict_dim1_loop_breaker None) rep_a vw;


zipWith_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> forall a b c : box.
     Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
     (a -> b -> c) ->
     Stream dim1 a -> Stream dim1 b -> Stream dim1 c
  attribute(inline) =
  real_zipWith_dim1;


real_zipWith_dim1 @(a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : Stream dim1 a)
  (s2 : Stream dim1 b)
  -> Stream dim1 c
  attribute(inline) =

  case s1 of stream tyob par_hint1 i_s1.
  let rs1 = fromIxStream @dim1 @a i_s1 in
  case s2 of stream tyob par_hint2 i_s2.
  let rs2 = fromIxStream @dim1 @b i_s2 in

  let par_hint = leastParHint par_hint1 par_hint2 in

  con_stream @dim1 @c par_hint
  (con_ixStream @dim1 @c
   (zipWith_RStream @dim1 @a @b @c
    (ShapeDict_dim1_loop_breaker None) rep_a rep_b rep_c f rs1 rs2));


fold_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> forall a acc : box.
     Repr (AsBare a) -> Repr (AsBare acc) ->
     (a -> acc -> acc) -> Stream dim1 a -> acc -> acc
  attribute(inline) =

  real_fold_dim1;


real_fold_dim1 @(a acc : box)
  (rep_a : ReprBox a)
  (rep_acc : ReprBox acc)
  (combine : a -> acc -> acc)
  (s : Stream dim1 a)
  (init : acc)
  -> acc
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case rStreamToView @dim1 @a (fromIxStream @dim1 @a i_s) of
    mk_view tyob dom get.

  -- Loop over the elements of the domain
  case dom of mk_dim1 tyob (interval m_lo m_hi) (linearMap stride alignment).
  let lo = case m_lo of {justVal n. n; nothingVal. except @int} in
  let hi = case m_hi of {justVal n. n; nothingVal. except @int} in

  letfun
    go (i : int) (x : acc) -> acc =
      if i <# hi
      then go (i +# stride) (combine (get (boxIntValue i)) x)
      else x
  in
  go lo init;


imp_fold_dim1 @(a : box)
  (rep_a : ReprBox a)
  (combine : a -> Store -> Store)
  (s : Stream dim1 a)
  (init : Store)
  -> Store
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case rStreamToView @dim1 @a (fromIxStream @dim1 @a i_s) of
    mk_view tyob dom get.

  foreach_dim1 dom (boxNoneValue None)
  (\ (i : BoxIndex dim1) (s : Store) -> Store. combine (get i) s)
  init;


foreach_dim1
  (dom : dim1)
  (off : BoxOffset dim1)
  (combine : BoxIndex dim1 -> Store -> Store)
  (init : Store)
  -> Store attribute(inline) =

  -- Loop over the elements of the domain
  case dom of mk_dim1 tyob (interval m_lo m_hi) (linearMap stride alignment).
  let lo = case m_lo of {justVal n. n; nothingVal. except @int} in
  let hi = case m_hi of {justVal n. n; nothingVal. except @int} in

  letfun
    go (i : int) (s : Store) -> Store =
      if i <# hi
      then go (i +# stride) (combine (boxIntValue i) s)
      else s
  in
  go lo init;


foreachSeq_dim1
  (r1 : Repr (index dim1)) (r2 : Repr (offset dim1)) (r3 : Repr (slice dim1))
  -> forall a : box. dim1 -> (BoxIndex dim1 -> Seq a) -> Seq a
  attribute(inline) =
  real_foreachSeq_dim1;


real_foreachSeq_dim1 @(a : box)
  (dom : dim1)
  (k : BoxIndex dim1 -> Seq a)
  -> Seq a attribute(inline, inline_sequential) =

  case dom of mk_dim1 tyob (interval m_lo m_hi) (linearMap stride alignment).
  let lo = case m_lo of {justVal n. n; nothingVal. except @int} in

  let type state = Boxed (Stored int) in

  -- Count from 0 to upper bound by stride
  letfun
    next (s : state) -> SeqStep state (Boxed (Stored int)) =
      let i = unboxIntValue s in
      if case m_hi of {justVal n. i >=# n; nothingVal. False}
      then seqDone @state @(Boxed (Stored int))
      else seqYield @state @(Boxed (Stored int)) (boxIntValue (i +# stride)) s
  in
  let generator = con_seq @(Boxed (Stored int)) @state (boxIntValue lo) next in
  bind_Seq @(Boxed (Stored int)) @a generator k;
  

ShapeDict_dim2 : ShapeDict dim2 =
  shapeDict @dim2 (boxedinfo shapeDict @dim2)
  repr_index2
  repr_NoneType
  repr_slice2
  real_noOffset_dim2
  real_addOffset_dim2
  real_appOffset_dim2
  real_intersect_dim2
  real_member_dim2
  real_slice_dim2
  real_split_dim2
  real_splitN_dim2
  real_checkSubdomain_dim2
  real_peel_dim2
  real_flatten_dim2
  real_generate_dim2
  real_zipWith_dim2
  real_fold_dim2
  real_imp_fold_dim2_wrapper
  real_foreach_dim2_wrapper
  real_foreachSeq_dim2;

-- FIXME: Handle recursion properly
-- This function is needed to break a recursive cycle
ShapeDict_dim2_loop_breaker (dummy : NoneType)
  -> ShapeDict dim2 attribute(inline_never) =
  ShapeDict_dim2;


imp_fold_dim2_wrapper
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> ImperativeFoldFunction dim2 attribute(inline) =
  real_imp_fold_dim2_wrapper;


real_imp_fold_dim2_wrapper : ImperativeFoldFunction dim2 attribute(inline) =
  imperativeFoldFunction @dim2 imp_fold_dim2;


foreach_dim2_wrapper
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> ImperativeForeachFunction dim2 attribute(inline) =
  real_foreach_dim2_wrapper;


real_foreach_dim2_wrapper : ImperativeForeachFunction dim2 attribute(inline) =
  imperativeForeachFunction @dim2 foreach_dim2;


noOffset_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> Boxed (Stored NoneType) attribute(inline) =
  real_noOffset_dim2;


real_noOffset_dim2 : Boxed (Stored NoneType) attribute(inline) =
  boxNoneValue None;


addOffset_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> BoxOffset dim2 -> BoxOffset dim2 -> BoxOffset dim2 attribute(inline) =
  real_addOffset_dim2;


real_addOffset_dim2 (x y : BoxOffset dim2) -> BoxOffset dim2 = x;


appOffset_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> BoxOffset dim2 -> BoxIndex dim2 -> BoxIndex dim2 attribute(inline) =
  real_appOffset_dim2;


real_appOffset_dim2 (x : BoxOffset dim2) (y : BoxIndex dim2) -> BoxIndex dim2 = y;


intersect_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> dim2 -> dim2 -> dim2 attribute(inline) =
  real_intersect_dim2;

real_intersect_dim2 (d e : dim2) -> dim2 attribute(inline, inline_final) =
  case d of mk_dim2 tyob d_y d_x.
  case e of mk_dim2 tyob e_y e_x.
  con_dim2 (real_intersect_dim1 d_y e_y) (real_intersect_dim1 d_x e_x);


member_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> BoxIndex dim2 -> dim2 -> bool attribute(inline) =
  real_member_dim2;


real_member_dim2 (ix : Boxed (Tuple2 (Stored int) (Stored int))) (dom : dim2)
  -> bool attribute(inline) =

  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case ix of [sa_tuple] boxed tyob ([sa_int, sa_int] tuple2 (stored ix_y) (stored ix_x)).
  case dom of mk_dim2 tyob dom_y dom_x.

  -- Point must be a member in both projections
  if real_member_dim1 (boxIntValue ix_y) dom_y
  then real_member_dim1 (boxIntValue ix_x) dom_x
  else False;


slice_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> BoxSlice dim2 -> dim2 -> (BoxOffset dim2, dim2) attribute(inline) =
  real_slice_dim2;


real_slice_dim2 (s : BoxSlice dim2) (d : dim2)
  -> (BoxOffset dim2, dim2) attribute(inline) =
  let sa_slice = reprSizeAlign @SliceObject (unboxedinfo SliceObject) in
  case s of [reprSizeAlign @(Tuple2 SliceObject SliceObject) repr_slice2]
            boxed tyob ([sa_slice, sa_slice] tuple2 slice_y slice_x).
  case d of mk_dim2 tyob d_y d_x.
  let new_d = con_dim2 (internalApplyArraySlice slice_y d_y) (internalApplyArraySlice slice_x d_x) in
  (boxNoneValue None, new_d);


split_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> dim2 -> MaybeVal (dim2, Boxed (Stored NoneType), dim2) attribute(inline) =
  real_split_dim2;


real_split_dim2 (d : dim2)
  -> MaybeVal (dim2, Boxed (Stored NoneType), dim2)
  attribute(inline, inline_final) =

  case d of mk_dim2 tyob d_y d_x.

  -- Split along larger dimension
  if dim1Cardinality d_x >=# dim1Cardinality d_y
  then
    case real_split_dim1 d_x of {
      justVal (l, off, r).
        justVal @(dim2, Boxed (Stored NoneType), dim2)
        (con_dim2 d_y l, off, con_dim2 d_y r)
    ; nothingVal.
        nothingVal @(dim2, Boxed (Stored NoneType), dim2)
    }
  else
    case real_split_dim1 d_y of {
      justVal (l, off, r).
        justVal @(dim2, Boxed (Stored NoneType), dim2)
        (con_dim2 l d_x, off, con_dim2 r d_x)
    ; nothingVal.
        nothingVal @(dim2, Boxed (Stored NoneType), dim2)
    };


splitN_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> int -> dim2 -> view list_dim (Subdomain dim2) attribute(inline) =
  real_splitN_dim2;


real_splitN_dim2 (n : int) (dom : dim2)
  -> view list_dim (Subdomain dim2) attribute(inline) =

  case dom of mk_dim2 tyob d_y d_x.

  -- Split along larger dimension
  if dim1Cardinality d_x >=# dim1Cardinality d_y
  then
    let split_along_x = real_splitN_dim1 n d_x in
    map_view @list_dim @(Subdomain dim1) @(Subdomain dim2)
    (repr_Box @(Subdomain dim1)) (repr_Box @(Subdomain dim2))
    (\ (subd : Subdomain dim1) -> Subdomain dim2.
       case subd of subdomain tyob off subd_x.
       con_subdomain @dim2 off (con_dim2 d_y subd_x))
    split_along_x
  else
    let split_along_y = real_splitN_dim1 n d_y in
    map_view @list_dim @(Subdomain dim1) @(Subdomain dim2)
    (repr_Box @(Subdomain dim1)) (repr_Box @(Subdomain dim2))
    (\ (subd : Subdomain dim1) -> Subdomain dim2.
       case subd of subdomain tyob off subd_y.
       con_subdomain @dim2 off (con_dim2 subd_y d_x))
    split_along_y;


checkSubdomain_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> dim2 -> dim2 -> bool attribute(inline) =
  real_checkSubdomain_dim2;


real_checkSubdomain_dim2
  (d subd : dim2) -> bool attribute(inline) =

  case d of mk_dim2 tyob d_y d_x.
  case subd of mk_dim2 tyob subd_y subd_x.

  if real_checkSubdomain_dim1 d_y subd_y
  then real_checkSubdomain_dim1 d_x subd_x
  else False;


peel_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
   -> forall a r : box.
      ReprBox a -> Boxed (Stored ParHint) ->
      (a -> Stream list_dim a -> r) -> (NoneType -> r) ->
      view dim2 (Stream list_dim a) -> r attribute(inline) =
  real_peel_dim2;


real_peel_dim2 @(a r : box)
  (rep_a : ReprBox a) (par_hint : Boxed (Stored ParHint))
  (value_k : a -> Stream list_dim a -> r) (empty_k : NoneType -> r)
  (vw : view dim2 (Stream list_dim a))
  -> r attribute(inline, inline_sequential) =

  -- TODO
  except @r;


flatten_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> forall a : box. ReprBox a -> Stream dim2 a -> Stream list_dim a attribute(inline) =
  real_flatten_dim2;


real_flatten_dim2 @(a : box) (rep : ReprBox a) (s : Stream dim2 a)
  -> Stream list_dim a attribute(inline) =

  -- Flatten by creating a splittable stream
  case s of stream tyob par_hint i_s.
  let rs = fromIxStream @dim2 @a i_s in
  con_stream @list_dim @a par_hint
  (con_nestedIxStream @a @dim2
   (ShapeDict_dim2_loop_breaker None)
   (map_RStream @dim2 @a @(Stream list_dim a) (unit_Stream @a rep) rs));


generate_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> forall a : box.
     Repr (AsBare a) -> BoxOffset dim2 -> dim2 ->
     (BoxIndex dim2 -> a) -> Stream dim2 a
  attribute(inline) =
  real_generate_dim2;


real_generate_dim2 @(a : box)
  (rep_a : ReprBox a)
  (off : BoxOffset dim2) (dom : dim2) (g : BoxIndex dim2 -> a)
  -> Stream dim2 a attribute(inline) =

  -- Create and traverse a view.
  -- The offset is always None, so ignore it.
  let vw = con_view @dim2 @a dom g in
  traverse_view_real @dim2 @a (ShapeDict_dim2_loop_breaker None) rep_a vw;


zipWith_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> forall a b c : box.
     Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
     (a -> b -> c) ->
     Stream dim2 a -> Stream dim2 b -> Stream dim2 c
  attribute(inline) =
  real_zipWith_dim2;


real_zipWith_dim2 @(a b c : box)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : Stream dim2 a)
  (s2 : Stream dim2 b)
  -> Stream dim2 c
  attribute(inline) =

  case s1 of stream tyob par_hint1 i_s1.
  let rs1 = fromIxStream @dim2 @a i_s1 in
  case s2 of stream tyob par_hint2 i_s2.
  let rs2 = fromIxStream @dim2 @b i_s2 in

  let par_hint = leastParHint par_hint1 par_hint2 in

  con_stream @dim2 @c par_hint
  (con_ixStream @dim2 @c
   (zipWith_RStream @dim2 @a @b @c
    (ShapeDict_dim2_loop_breaker None) rep_a rep_b rep_c f rs1 rs2));


fold_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> forall a acc : box.
     Repr (AsBare a) -> Repr (AsBare acc) ->
     (a -> acc -> acc) -> Stream dim2 a -> acc -> acc
  attribute(inline) =

  real_fold_dim2;


real_fold_dim2 @(a acc : box)
  (rep_a : ReprBox a)
  (rep_acc : ReprBox acc)
  (combine : a -> acc -> acc)
  (s : Stream dim2 a)
  (init : acc)
  -> acc
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case rStreamToView @dim2 @a (fromIxStream @dim2 @a i_s) of
    mk_view tyob dom get.

  -- Loop over the elements of the domain
  case dom of mk_dim2 tyob dom_y dom_x.
  case dom_y of mk_dim1 tyob (interval m_lo_y m_hi_y) (linearMap stride_y alignment_y).
  case dom_x of mk_dim1 tyob (interval m_lo_x m_hi_x) (linearMap stride_x alignment_x).
  let lo_y = case m_lo_y of {justVal n. n; nothingVal. except @int} in
  let hi_y = case m_hi_y of {justVal n. n; nothingVal. except @int} in
  let lo_x = case m_lo_x of {justVal n. n; nothingVal. except @int} in
  let hi_x = case m_hi_x of {justVal n. n; nothingVal. except @int} in

  let sa_int = reprSizeAlign @(Stored int) repr_int in

  letfun {
    go2 (y x : int) (accumulator : acc) -> acc =
      if x <# hi_x
      then let idx = con_boxed @(Tuple2 (Stored int) (Stored int))
                     repr_index2
                     (tuple2 @(Stored int) @(Stored int) sa_int sa_int
                       (stored @int y) (stored @int x)) in
           go2 y (x +# stride_x) (combine (get idx) accumulator)
      else accumulator

  ; go1 (y : int) (accumulator : acc) -> acc =
      if y <# hi_y
      then let accumulator2 = go2 y lo_x accumulator in
           go1 (y +# stride_y) accumulator2
      else accumulator
  } in
  go1 lo_y init;


imp_fold_dim2 @(a : box)
  (rep_a : ReprBox a)
  (combine : a -> Store -> Store)
  (s : Stream dim2 a)
  (init : Store)
  -> Store
  attribute(inline) =

  case s of stream tyob par_hint i_s.
  case rStreamToView @dim2 @a (fromIxStream @dim2 @a i_s) of
    mk_view tyob dom get.

  foreach_dim2 dom (boxNoneValue None)
  (\ (i : BoxIndex dim2) (s : Store) -> Store. combine (get i) s)
  init;


foreach_dim2
  (dom : dim2)
  (off : BoxOffset dim2)
  (combine : BoxIndex dim2 -> Store -> Store)
  (init : Store)
  -> Store attribute(inline) =

  -- Loop over the elements of the domain
  case dom of mk_dim2 tyob dom_y dom_x.
  case dom_y of mk_dim1 tyob (interval m_lo_y m_hi_y) (linearMap stride_y alignment_y).
  case dom_x of mk_dim1 tyob (interval m_lo_x m_hi_x) (linearMap stride_x alignment_x).
  let lo_y = case m_lo_y of {justVal n. n; nothingVal. except @int} in
  let hi_y = case m_hi_y of {justVal n. n; nothingVal. except @int} in
  let lo_x = case m_lo_x of {justVal n. n; nothingVal. except @int} in
  let hi_x = case m_hi_x of {justVal n. n; nothingVal. except @int} in

  let sa_int = reprSizeAlign @(Stored int) repr_int in

  letfun {
    go2 (y x : int) (state : Store) -> Store =
      if x <# hi_x
      then let idx = con_boxed @(Tuple2 (Stored int) (Stored int))
                     repr_index2
                     (tuple2 @(Stored int) @(Stored int) sa_int sa_int
                       (stored @int y) (stored @int x)) in
           go2 y (x +# stride_x) (combine idx state)
      else state

  ; go1 (y : int) (state : Store) -> Store =
      if y <# hi_y
      then let state2 = go2 y lo_x state in
           go1 (y +# stride_y) state
      else state
  } in
  go1 lo_y init;


foreachSeq_dim2
  (r1 : Repr (index dim2)) (r2 : Repr (offset dim2)) (r3 : Repr (slice dim2))
  -> forall a : box. dim2 -> (BoxIndex dim2 -> Seq a) -> Seq a
  attribute(inline) =
  real_foreachSeq_dim2;


real_foreachSeq_dim2 @(a : box)
  (dom : dim2)
  (k : BoxIndex dim2 -> Seq a)
  -> Seq a attribute(inline, inline_sequential) =

  case dom of mk_dim2 tyob dom_y dom_x.

  real_foreachSeq_dim1 @a dom_y
  (\ (y : Boxed (Stored int)) -> Seq a.
   real_foreachSeq_dim1 @a dom_x
   (\ (x : Boxed (Stored int)) -> Seq a.
      k (pack_index2 (unboxIntValue y) (unboxIntValue x))));


{-

ShapeDict_dim3 : ShapeDict dim3 =
  shapeDict @dim3 (boxedinfo shapeDict @dim3)
  repr_index3
  repr_slice3
  ShapeDict_dim3_member
  ShapeDict_dim3_intersect
  ShapeDict_dim3_flatten
  ShapeDict_dim3_generate
  ShapeDict_dim3_map
  ShapeDict_dim3_zipWith
  ShapeDict_dim3_zipWith3
  ShapeDict_dim3_zipWith4
  ShapeDict_dim3_slice;

repr_index3 : Repr (Tuple3 (Stored int) (Stored int) (Stored int)) =
  unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int)
  repr_int repr_int repr_int;

repr_slice3 : Repr (Tuple3 SliceObject SliceObject SliceObject) =
  unboxedinfo Tuple3 @SliceObject @SliceObject @SliceObject
  (unboxedinfo SliceObject)
  (unboxedinfo SliceObject)
  (unboxedinfo SliceObject);


ShapeDict_dim3_member (dom : dim3) (ix : AsBox (index dim3))
  -> Boxed (Stored bool) =

  let sa_tuple = reprSizeAlign @(index dim3) repr_index3 in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  -- Take the conjunction of x, y, z membership conditions
  case dom of mk_dim3 tyob dom_z dom_y dom_x.
  case ix of [sa_tuple]
    boxed tyob ([sa_int, sa_int, sa_int] tuple3 (stored ix_z) (stored ix_y) (stored ix_x)).
  if unboxBoolValue (ShapeDict_dim1_member dom_z (boxIntValue ix_z))
  then if unboxBoolValue (ShapeDict_dim1_member dom_y (boxIntValue ix_y))
       then ShapeDict_dim1_member dom_x (boxIntValue ix_x)
       else boxBoolValue False
  else boxBoolValue False;


ShapeDict_dim3_intersect (domA : dim3) (domB : dim3) -> dim3 =
  -- Take the intersection in each dimension
  case domA of mk_dim3 tyob domA_z domA_y domA_x.
  case domB of mk_dim3 tyob domB_z domB_y domB_x.
  con_dim3 (real_intersect_dim1 domA_z domB_z)
           (real_intersect_dim1 domA_y domB_y)
           (real_intersect_dim1 domA_x domB_x);


ShapeDict_dim3_flatten_helper
  (iv_z : Interval)
  (iv_y : Interval)
  (iv_x : Interval)
  (stride_z : int)
  (stride_y : int)
  (stride_x : int)
  -> (list_dim, MaybeVal (MaybeVal int, int), int, int, int)
  attribute(inline, inline_final) =

  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case iv_z of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).

  -- Lower bound must be finite
  case lb_x of {
    justVal (lb_x_i : int).
      case ub_x of {
        justVal (ub_x_i : int).
          -- Domain has finite x extent
          let count_x : int = (ub_x_i -# lb_x_i) //# stride_x in

          case lb_y of {
            justVal (lb_y_i : int).
              case ub_y of {
                justVal (ub_y_i : int).
                  -- Domain has finite y extent
                    let count_y : int = (ub_y_i -# lb_y_i) //# stride_y in
                    let count_xy : int = count_x *# count_y in
                    case lb_z of {
                      justVal (lb_z_i : int).

                        -- Compute the number of points in the domain
                        let list_size : MaybeVal int =
                              case ub_z of {
                                justVal (ub_z_i : int).
                                  -- Domain is bounded on all sides
                                  let count_z : int =
                                        (ub_z_i -# lb_z_i) //# stride_z in
                                  justVal @int (count_xy *# count_z)
                              ; nothingVal.

                                  -- Domain is unbounded in the z-dimension
                                  nothingVal @int
                              } in

                        (con_list_dim list_size,
                         justVal @(MaybeVal int, int)
                         (justVal @int count_xy, count_x),
                         lb_z_i, lb_y_i, lb_x_i)

                    ; nothingVal.
                        except @(list_dim, MaybeVal (MaybeVal int, int),
                                 int, int, int)
                    }
                ; nothingVal.

                    -- Domain has infinite y extent
                    case lb_z of {
                      justVal (lb_z_i : int).
                        (con_list_dim (nothingVal @int),
                         justVal @(MaybeVal int, int)
                         (nothingVal @int, count_x),
                         lb_z_i, lb_y_i, lb_x_i)
                    ; nothingVal.
                        except @(list_dim, MaybeVal (MaybeVal int, int),
                                 int, int, int)
                    }
                }
            ; nothingVal.
                except @(list_dim, MaybeVal (MaybeVal int, int), int, int, int)
            }

      ; nothingVal.
          -- Domain has infinite x extent
          case lb_y of {
            justVal (lb_y_i : int).
              case lb_z of {
                justVal (lb_z_i : int).
                  (con_list_dim (nothingVal @int),
                   nothingVal @(MaybeVal int, int), lb_z_i, lb_y_i, lb_x_i)
              ; nothingVal.
                  except @(list_dim, MaybeVal (MaybeVal int, int),
                           int, int, int)
              }

          ; nothingVal.
              except @(list_dim, MaybeVal (MaybeVal int, int), int, int, int)
          }
      }

  ; nothingVal.
      except @(list_dim, MaybeVal (MaybeVal int, int), int, int, int)
  };


ShapeDict_dim3_flatten_helper2
  (i : int) (divisors : MaybeVal (MaybeVal int, int))
  -> (int, int, int)
  attribute(inline, inline_final) =
  case divisors of {
    justVal (divisors_yx : (MaybeVal int, int)).

      -- Finite in the X dimension
      case divisors_yx of (divisor_xy, count_x).
      case divisor_xy of {
        justVal count_xy.

          -- Finite in all dimensions
          let i_xy : int = i %# count_xy in
          let i_z : int = i //# count_xy in
          (i_z, i_xy //# count_x, i_xy %# count_x)

      ; nothingVal.
          -- Infinite in the Y dimension
          (0, i //# count_x, i %# count_x)
      }
  ; nothingVal. (0, 0, i)
  };

ShapeDict_dim3_flatten @(a : box)
  (rep : Repr (AsBare a)) (s : Stream dim3 a) -> Stream list_dim a
  attribute(inline, inline_dimensionality) =
  case s of mk_view tyob (mk_dim3 tyob2 dom_z dom_y dom_x) f.
  case dom_z of mk_dim1 tyob (iv_z : Interval) (lm_z : LinearMap).
  case dom_x of mk_dim1 tyob (iv_x : Interval) (lm_x : LinearMap).
  case dom_y of mk_dim1 tyob (iv_y : Interval) (lm_y : LinearMap).
  case iv_z of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).
  case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lm_z of linearMap (stride_z : int) (alignment_z : int).
  case lm_x of linearMap (stride_x : int) (alignment_x : int).
  case lm_y of linearMap (stride_y : int) (alignment_y : int).

  -- Compute stream dimensions and indices
  case ShapeDict_dim3_flatten_helper iv_z iv_y iv_x stride_z stride_y stride_x
  of (flattened_size : list_dim,
      divisors : MaybeVal (MaybeVal int, int),
      lb_z_i : int, lb_y_i : int, lb_x_i : int).

  con_viewStream @a
  (con_view @list_dim @a flattened_size
   (\ (si : Boxed (Stored int)) -> a.
      -- Linearize the index
      let i = unboxIntValue si in
      case ShapeDict_dim3_flatten_helper2 i divisors
      of (i_z : int, i_y : int, i_x : int).

      -- Apply the stride to get an index in the domain
      let dim2_i_z : int = lb_z_i +# i_z *# stride_z in 
      let dim2_i_y : int = lb_y_i +# i_y *# stride_y in 
      let dim2_i_x : int = lb_x_i +# i_x *# stride_x in 

      let type Sint = Stored int in
      let type index3d = Tuple3 Sint Sint Sint in
      let sa_int = reprSizeAlign @(Stored int) repr_int in
      let ix = con_boxed @index3d
               repr_index3
               (tuple3 @Sint @Sint @Sint sa_int sa_int sa_int
                (stored @int dim2_i_z) (stored @int dim2_i_y) (stored @int dim2_i_x)) in
      f ix));


ShapeDict_dim3_generate @(a : box)
  (rep : Repr (AsBare a)) (dom : dim3) (f : AsBox (index dim3) -> a)
  -> Stream dim3 a attribute(inline) =
  view_generate @dim3 ShapeDict_dim3 @a rep dom f;


ShapeDict_dim3_map @(a b : box)
  (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b))
  (transformer : a -> b)
  (s : Stream dim3 a)
  -> Stream dim3 b attribute(inline) =
  view_map @dim3
  ShapeDict_dim3 @a @b repr_a repr_b transformer s;


ShapeDict_dim3_zipWith @(a b c : box)
  (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b))
  (repr_c : Repr (AsBare c))
  (transformer : a -> b -> c)
  (sa : Stream dim3 a)
  (sb : Stream dim3 b)
  -> Stream dim3 c attribute(inline) =
  view_zipWith @dim3 ShapeDict_dim3 @a @b @c
  repr_a repr_b repr_c transformer sa sb;


ShapeDict_dim3_zipWith3 @(a b c d : box)
  (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b))
  (repr_c : Repr (AsBare c)) (repr_d : Repr (AsBare d))
  (transformer : a -> b -> c -> d)
  (sa : Stream dim3 a)
  (sb : Stream dim3 b)
  (sc : Stream dim3 c)
  -> Stream dim3 d attribute(inline) =
  view_zipWith3 @dim3 ShapeDict_dim3 @a @b @c @d
  repr_a repr_b repr_c repr_d transformer sa sb sc;


ShapeDict_dim3_zipWith4 @(a b c d e : box)
  (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b))
  (repr_c : Repr (AsBare c)) (repr_d : Repr (AsBare d))
  (repr_e : Repr (AsBare e))
  (transformer : a -> b -> c -> d -> e)
  (sa : Stream dim3 a)
  (sb : Stream dim3 b)
  (sc : Stream dim3 c)
  (sd : Stream dim3 d)
  -> Stream dim3 e attribute(inline) =
  view_zipWith4 @dim3 ShapeDict_dim3 @a @b @c @d @e
  repr_a repr_b repr_c repr_d repr_e transformer sa sb sc sd;


ShapeDict_dim3_slice @(t : box -> box) @(a : box)
  (is_dim3 : coerce @box (shape t) dim3)
  (indexable : IndexableDict t)
  (rep : Repr (AsBare a))
  (container : t a)
  (slice_argument : AsBox (slice dim3))
  -> view dim3 a attribute(inline) =
  case indexable of indexableDict tyob at_index get_shape.

  -- Compute the slice's domain
  let sa_tuple =
        reprSizeAlign @(Tuple3 SliceObject SliceObject SliceObject) repr_slice3 in
  let sa_slice = reprSizeAlign @SliceObject (unboxedinfo SliceObject) in
  case slice_argument of [sa_tuple]
    boxed tyob ([sa_slice, sa_slice, sa_slice] tuple3 slice_z slice_y slice_x).

  let dom : dim3 = coerce @(shape t) @dim3 (get_shape @a container) in
  case dom of mk_dim3 tyob dom_z dom_y dom_x.
  let slice_dom : dim3 =
        con_dim3 (internalApplyArraySlice slice_z dom_z)
                 (internalApplyArraySlice slice_y dom_y)
                 (internalApplyArraySlice slice_x dom_x) in

  view_generate @dim3
  ShapeDict_dim3 @a rep slice_dom
  (\ (i : AsBox (index dim3)) -> a.
    at_index @a rep container
    (coerce @(AsBox (index dim3)) @(AsBox (index (shape t))) i));

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Indexable dictionaries

IndexableDict_list_at_point @(a : box)
  (rep : Repr (AsBare a)) (bls : Boxed (list (AsBare a)))
  (ix : Boxed (Stored int)) -> a
  attribute(inline) =
  case bls of [reprSizeAlign @(list (AsBare a)) (unboxedinfo list @(AsBare a))]
    boxed tyob (make_list @(N : intindex) n ayref).

  let rep_arr = unboxedinfo arr @N @(AsBare a) n rep in
  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_arr] stuckBox tyob ay.
  let i = unboxIntValue ix in
  let sa = reprSizeAlign @(AsBare a) rep in
  bareToBox @(AsBare a) rep (subscript @N @(AsBare a) sa ay i);


IndexableDict_list_get_shape @(a : box)
  (bls : Boxed (list (AsBare a))) -> list_dim
  attribute(inline) =
  case bls of [reprSizeAlign @(list (AsBare a)) (unboxedinfo list @(AsBare a))]
    boxed tyob (make_list @(N : intindex) n ayref).
  case n of fiInt (size : int).
  con_list_dim (justVal @int size);


{-
IndexableDict_view @(sh : box) (dict : ShapeDict sh)
  -> IndexableDict (view sh) =
  indexableDict @(view sh) (unboxedinfo indexableDict @(view sh))
  Functor_view
  (at_point_view @sh dict)
  (get_shape_view @sh dict);


at_point_view @(sh : box) (dict : ShapeDict sh) ->
  forall a : box. Repr (AsBare a) -> view sh a -> AsBox (index sh) -> a =
  \ @(a : box)
    (rep : Repr (AsBare a)) (vw : view sh a) (ix : AsBox (index sh)) -> a.
    case vw of mk_view tyob (dom : sh) (f : AsBox (index sh) -> a).
    f ix;


get_shape_view @(sh : box) (dict : ShapeDict sh) ->
  forall a : box. view sh a -> sh =
  \ @(a : box) (vw : view sh a) -> sh.
    case vw of mk_view tyob dom f. dom;
-}


{- REPLACED BY NEW STREAM CODE


IndexableDict_array0_at_point @(a : box)
  (rep : Repr (AsBare a)) (ay : Boxed (array0 (AsBare a)))
  (ix : Boxed (Stored NoneType)) -> a
  attribute(inline) =
  case ay of [reprSizeAlign @(array0 (AsBare a)) (unboxedinfo array0 @(AsBare a))]
    boxed tyob (mk_array0 ([reprSizeAlign @(AsBare a) rep] stuckBox tyob2 ux)).
  bareToBox @(AsBare a) rep ux;


IndexableDict_array0_get_shape @(a : box)
  (ay : Boxed (array0 (AsBare a))) -> dim0
  attribute(inline) =
  con_dim0;


IndexableDict_array1_at_point @(a : box)
  (rep : Repr (AsBare a)) (ay : Boxed (array1 (AsBare a)))
  (ix : Boxed (Stored int)) -> a
  attribute(inline) =
  case ay of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @(N : intindex) lb stride size ayref).
  let rep_arr = unboxedinfo arr @N @(AsBare a) size rep in
  case ayref of [reprSizeAlign @(arr N (AsBare a)) rep_arr]
    stuckBox tyob (ay : arr N (AsBare a)).

  -- Compute real array index
  let ix_i = unboxIntValue ix in
  let real_index = (ix_i -# lb) //# stride in
  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep) ay real_index);


IndexableDict_array1_get_shape @(a : box)
  (ay : Boxed (array1 (AsBare a))) -> dim1
  attribute(inline) =
  case ay of [reprSizeAlign @(array1 (AsBare a)) (unboxedinfo array1 @(AsBare a))]
    boxed tyob (mk_array1 @(N : intindex) lb stride size ayref).
  arrayDescToDim1 @N lb stride size;


IndexableDict_array2_at_point @(a : box)
  (rep : Repr (AsBare a))
  (ay : Boxed (array2 (AsBare a)))
  (ix : AsBox (index dim2))
  -> a attribute(inline) =
  case ay of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @(M N : intindex)
                lb_y stride_y size_y lb_x stride_x size_x ayref).
  let row_repr = unboxedinfo arr @N @(AsBare a) size_x rep in
  let rep_plane = unboxedinfo arr @M @(arr N (AsBare a)) size_y row_repr in
  case ayref of [reprSizeAlign @(arr M (arr N (AsBare a))) rep_plane]
    stuckBox tyob (ay : arr M (arr N (AsBare a))).
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  -- Compute real array indices
  case ix of [reprSizeAlign @(index dim2) repr_index2]
    boxed tyob ([sa_int, sa_int] tuple2 (stored ix_y) (stored ix_x)).
  let real_index_y : int = (ix_y -# lb_y) //# stride_y in
  let real_index_x : int = (ix_x -# lb_x) //# stride_x in

  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
   (subscript @M @(arr N (AsBare a)) (reprSizeAlign @(arr N (AsBare a)) row_repr)
    ay real_index_y)
   real_index_x);


IndexableDict_array2_get_shape @(a : box)
  (ay : Boxed (array2 (AsBare a))) -> dim2
  attribute(inline) =
  case ay of [reprSizeAlign @(array2 (AsBare a)) (unboxedinfo array2 @(AsBare a))]
    boxed tyob (mk_array2 @(M N : intindex)
                lb_y stride_y size_y lb_x stride_x size_x ayref).
  con_dim2 (arrayDescToDim1 @M lb_y stride_y size_y)
           (arrayDescToDim1 @N lb_x stride_x size_x);


IndexableDict_array3_at_point @(a : box)
  (rep : Repr (AsBare a))
  (ay : Boxed (array3 (AsBare a)))
  (ix : AsBox (index dim3))
  -> a attribute(inline) =
  case ay of [reprSizeAlign @(array3 (AsBare a)) (unboxedinfo array3 @(AsBare a))]
    boxed tyob (mk_array3 @(L M N : intindex)
                lb_z stride_z size_z lb_y stride_y size_y lb_x stride_x size_x
                ayref).
  let row_repr = unboxedinfo arr @N @(AsBare a) size_x rep in
  let plane_repr = unboxedinfo arr @M @(arr N (AsBare a)) size_y row_repr in
  let arr_repr = unboxedinfo arr @L @(arr M (arr N (AsBare a))) size_z plane_repr in
  case ayref of [reprSizeAlign @(arr L (arr M (arr N (AsBare a)))) arr_repr]
    stuckBox tyob ay.
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  -- Compute real array indices
  case ix of [reprSizeAlign @(index dim3) repr_index3]
    boxed tyob ([sa_int, sa_int, sa_int]
                tuple3 (stored ix_z) (stored ix_y) (stored ix_x)).
  let real_index_z : int = (ix_z -# lb_z) //# stride_z in
  let real_index_y : int = (ix_y -# lb_y) //# stride_y in
  let real_index_x : int = (ix_x -# lb_x) //# stride_x in

  -- Copy the desired element
  bareToBox @(AsBare a) rep
  (subscript @N @(AsBare a) (reprSizeAlign @(AsBare a) rep)
   (subscript @M @(arr N (AsBare a)) (reprSizeAlign @(arr N (AsBare a)) row_repr)
     (subscript @L @(arr M (arr N (AsBare a))) (reprSizeAlign @(arr M (arr N (AsBare a))) plane_repr)
      ay real_index_z)
    real_index_y)
   real_index_x);


IndexableDict_array3_get_shape @(a : box)
  (ay : Boxed (array3 (AsBare a))) -> dim3
  attribute(inline) =
  case ay of [reprSizeAlign @(array3 (AsBare a)) (unboxedinfo array3 @(AsBare a))]
    boxed tyob (mk_array3 @(L M N : intindex)
                lb_z stride_z size_z lb_y stride_y size_y lb_x stride_x size_x
                ayref).
  con_dim3 (arrayDescToDim1 @L lb_z stride_z size_z)
           (arrayDescToDim1 @M lb_y stride_y size_y)
           (arrayDescToDim1 @N lb_x stride_x size_x);

REPLACED BY NEW STREAM CODE -}


IndexableDict_blist_at_point @(a : box)
  (rep : Repr (AsBare a))
  (ls : Boxed (blist (AsBare a)))
  (ix : Boxed (Stored int))
  -> a
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ls of [reprSizeAlign @(blist (AsBare a)) (unboxedinfo blist @(AsBare a))]
    boxed tyob (make_blist (make_list @(N : intindex) n ayref)).
  let repr_box : Repr boxed_a = unboxedinfo StuckRef @a in
  let repr_arr = unboxedinfo arr @N @boxed_a n repr_box in
  
  case ayref of [reprSizeAlign @(arr N boxed_a) repr_arr]
    stuckBox tyob (ay : arr N boxed_a).

  let ix_i = unboxIntValue ix in
  case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay ix_i of
    stuckRef val.
  val;


IndexableDict_blist_get_shape @(a : box)
  (ls : Boxed (blist (AsBare a))) -> list_dim
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ls of [reprSizeAlign @(blist (AsBare a)) (unboxedinfo blist @(AsBare a))]
    boxed tyob (make_blist (make_list @(N : intindex) n ayref)).
  case n of fiInt (size : int).
  con_list_dim (justVal @int size);


{- REPLACED BY NEW STREAM CODE

IndexableDict_barray1_at_point @(a : box)
  (rep : Repr (AsBare a))
  (ay : Boxed (barray1 (AsBare a)))
  (ix : Boxed (Stored int))
  -> a
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ay of [reprSizeAlign @(barray1 (AsBare a)) (unboxedinfo barray1 @(AsBare a))]
    boxed tyob (mk_barray1 (mk_array1 @(N : intindex) lb stride size ayref)).

  let repr_box : Repr boxed_a = unboxedinfo StuckRef @a in
  let repr_arr = unboxedinfo arr @N @boxed_a size repr_box in

  case ayref of [reprSizeAlign @(arr N boxed_a) repr_arr]
    stuckBox tyob (ay : arr N boxed_a).

  -- Compute real array index
  let ix_i = unboxIntValue ix in
  let real_index : int = (ix_i -# lb) //# stride in
  case subscript @N @boxed_a (reprSizeAlign @boxed_a repr_box) ay real_index
    of stuckRef val.
  val;


IndexableDict_barray1_get_shape @(a : box)
  (ay : Boxed (barray1 (AsBare a))) -> dim1
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ay of [reprSizeAlign @(barray1 (AsBare a)) (unboxedinfo barray1 @(AsBare a))]
    boxed tyob (mk_barray1 (mk_array1 @(N : intindex) lb stride size ayref)).
  arrayDescToDim1 @N lb stride size;


IndexableDict_barray2_at_point @(a : box)
  (rep : Repr (AsBare a))
  (ay : Boxed (barray2 (AsBare a)))
  (ix : AsBox (index dim2))
  -> a
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ay of [reprSizeAlign @(barray2 (AsBare a)) (unboxedinfo barray2 @(AsBare a))]
    boxed tyob (mk_barray2 (mk_array2 @(M N : intindex)
                            lb_y stride_y size_y lb_x stride_x size_x ayref)).

  let rep_box = unboxedinfo StuckRef @a in
  let rep_row = unboxedinfo arr @N @boxed_a size_x rep_box in
  let rep_plane = unboxedinfo arr @M @(arr N boxed_a) size_y rep_row in

  case ayref of [reprSizeAlign @(arr M (arr N boxed_a)) rep_plane]
    stuckBox tyob (ay : arr M (arr N boxed_a)).

  -- Compute real array indices
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case ix of [reprSizeAlign @(index dim2) repr_index2]
    boxed tyob ([sa_int, sa_int] tuple2 (stored ix_y) (stored ix_x)).
  let real_index_y : int = (ix_y -# lb_y) //# stride_y in
  let real_index_x : int = (ix_x -# lb_x) //# stride_x in

  -- Copy the desired element
  case subscript @N @boxed_a (reprSizeAlign @boxed_a rep_box)
       (subscript @M @(arr N boxed_a)
       (reprSizeAlign @(arr N boxed_a) rep_row) ay real_index_y) real_index_x
    of stuckRef val.
  val;


IndexableDict_barray2_get_shape @(a : box)
  (ay : Boxed (barray2 (AsBare a))) -> dim2
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ay of [reprSizeAlign @(barray2 (AsBare a)) (unboxedinfo barray2 @(AsBare a))]
    boxed tyob (mk_barray2 (mk_array2 @(M N : intindex)
                            lb_y stride_y size_y lb_x stride_x size_x ayref)).
  con_dim2 (arrayDescToDim1 @M lb_y stride_y size_y)
           (arrayDescToDim1 @N lb_x stride_x size_x);


IndexableDict_barray3_at_point @(a : box)
  (rep : Repr (AsBare a))
  (ay : Boxed (barray3 (AsBare a)))
  (ix : AsBox (index dim3))
  -> a
  attribute(inline) =
  let type boxed_a = StuckRef a in
  case ay of [reprSizeAlign @(barray3 (AsBare a)) (unboxedinfo barray3 @(AsBare a))]
    boxed tyob (mk_barray3 (mk_array3 @(L M N : intindex)
                            lb_z stride_z size_z
                            lb_y stride_y size_y
                            lb_x stride_x size_x
                            ayref)).

  let rep_box = unboxedinfo StuckRef @a in
  let rep_row = unboxedinfo arr @N @boxed_a size_x rep_box in
  let rep_plane = unboxedinfo arr @M @(arr N boxed_a) size_y rep_row in
  let rep_arr = unboxedinfo arr @L @(arr M (arr N boxed_a)) size_z rep_plane in

  case ayref of [reprSizeAlign @(arr L (arr M (arr N boxed_a))) rep_arr]
    stuckBox tyob ay.

  -- Compute real array indices
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case ix of [reprSizeAlign @(index dim3) repr_index3]
    boxed tyob ([sa_int, sa_int, sa_int]
                tuple3 (stored ix_z) (stored ix_y) (stored ix_x)).
  let real_index_z : int = (ix_z -# lb_z) //# stride_z in
  let real_index_y : int = (ix_y -# lb_y) //# stride_y in
  let real_index_x : int = (ix_x -# lb_x) //# stride_x in

  -- Copy the desired element
  case subscript @N @boxed_a (reprSizeAlign @boxed_a rep_box)
       (subscript @M @(arr N boxed_a)
        (reprSizeAlign @(arr N boxed_a) rep_row)
        (subscript @L @(arr M (arr N boxed_a))
         (reprSizeAlign @(arr M (arr N boxed_a)) rep_plane)
         ay real_index_z) real_index_y) real_index_x
    of stuckRef val.
  val;


IndexableDict_barray3_get_shape @(a : box)
  (ay : Boxed (barray3 (AsBare a)))
  -> dim3
  attribute(inline) =
  let type boxed_a = StuckRef a in 
  case ay of [reprSizeAlign @(barray3 (AsBare a)) (unboxedinfo barray3 @(AsBare a))]
    boxed tyob (mk_barray3 (mk_array3 @(L M N : intindex)
                            lb_z stride_z size_z
                            lb_y stride_y size_y
                            lb_x stride_x size_x
                            ayref)).
  con_dim3 (arrayDescToDim1 @L lb_z stride_z size_z)
           (arrayDescToDim1 @M lb_y stride_y size_y)
           (arrayDescToDim1 @N lb_x stride_x size_x);

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Comparison dictionaries

EqDict_int : EqDict (Boxed (Stored int));
EqDict_int_eq (bsx : Boxed (Stored int)) (bsy : Boxed (Stored int))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (eqI (unboxIntValue bsx) (unboxIntValue bsy));

EqDict_int_ne (bsx : Boxed (Stored int)) (bsy : Boxed (Stored int))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (neI (unboxIntValue bsx) (unboxIntValue bsy));

EqDict_float : EqDict (Boxed (Stored float));
EqDict_float_eq (bsx : Boxed (Stored float)) (bsy : Boxed (Stored float))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (eqF (unboxFloatValue bsx) (unboxFloatValue bsy));

EqDict_float_ne (bsx : Boxed (Stored float)) (bsy : Boxed (Stored float))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (neF (unboxFloatValue bsx) (unboxFloatValue bsy));

EqDict_int64 : EqDict (Boxed (Stored int64));
EqDict_int64_eq (bsx : Boxed (Stored int64)) (bsy : Boxed (Stored int64))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (eqI64 (unboxInt64Value bsx) (unboxInt64Value bsy));

EqDict_int64_ne (bsx : Boxed (Stored int64)) (bsy : Boxed (Stored int64))
  -> Boxed (Stored bool)
  attribute(inline) =
  boxBoolValue (neI64 (unboxInt64Value bsx) (unboxInt64Value bsy));

EqDict_Tuple2 : forall a b : box. Repr (AsBare a) -> Repr (AsBare b) -> EqDict a -> EqDict b
             -> EqDict (Boxed (Tuple2 (AsBare a) (AsBare b)));
EqDict_Tuple2_eq @(a b : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b))
  (eqA : EqDict a) (eqB : EqDict b)
  (bx : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (by : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb repA repB in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba repA in
  let sa_b = reprSizeAlign @bb repB in
  case eqA of eqDict tyob eq_a ne_a.
  case eqB of eqDict tyob eq_b ne_b.
  case bx of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 xa xb).
  case by of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 ya yb).

  boxBoolValue
  (and (unboxBoolValue
        (eq_a (asbox @ba repA (copy @ba repA xa))
              (asbox @ba repA (copy @ba repA ya))))
       (unboxBoolValue
        (eq_b (asbox @bb repB (copy @bb repB xb))
              (asbox @bb repB (copy @bb repB yb)))));


EqDict_Tuple2_ne @(a b : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b))
  (eqA : EqDict a) (eqB : EqDict b)
  (bx : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (by : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb repA repB in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba repA in
  let sa_b = reprSizeAlign @bb repB in
  case eqA of eqDict tyob eq_a ne_a.
  case eqB of eqDict tyob eq_b ne_b.
  case bx of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 xa xb).
  case by of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 ya yb).

  boxBoolValue
  (and (unboxBoolValue
        (ne_a (asbox @ba repA (copy @ba repA xa))
              (asbox @ba repA (copy @ba repA ya))))
       (unboxBoolValue
        ((ne_b (asbox @bb repB (copy @bb repB xb))
              (asbox @bb repB (copy @bb repB yb))))));


EqDict_Tuple3 : forall a b c : box.
                Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c)
             -> EqDict a -> EqDict b -> EqDict c
             -> EqDict (Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)));
EqDict_Tuple3_eq @(a b c : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b)) (repC : Repr (AsBare c))
  (eqA : EqDict a) (eqB : EqDict b) (eqC : EqDict c)
  (bx : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  (by : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  let type bc = AsBare c in
  let rep_tuple = unboxedinfo Tuple3 @ba @bb @bc repA repB repC in
  let sa_tuple = reprSizeAlign @(Tuple3 ba bb bc) rep_tuple in
  let sa_a = reprSizeAlign @ba repA in
  let sa_b = reprSizeAlign @bb repB in
  let sa_c = reprSizeAlign @bc repC in
  case eqA of eqDict tyob eq_a ne_a.
  case eqB of eqDict tyob eq_b ne_b.
  case eqC of eqDict tyob eq_c ne_c.
  case bx of [sa_tuple] boxed tyob ([sa_a, sa_b, sa_c] tuple3 xa xb xc).
  case by of [sa_tuple] boxed tyob ([sa_a, sa_b, sa_c] tuple3 ya yb yc).

  let eq1 : bool = unboxBoolValue
                   (eq_a (asbox @ba repA (copy @ba repA xa))
                         (asbox @ba repA (copy @ba repA ya))) in
  let eq2 : bool = unboxBoolValue
                   (eq_b (asbox @bb repB (copy @bb repB xb))
                         (asbox @bb repB (copy @bb repB yb))) in
  let eq3 : bool = unboxBoolValue
                   (eq_c (asbox @bc repC (copy @bc repC xc))
                         (asbox @bc repC (copy @bc repC yc))) in
  boxBoolValue (and (and eq1 eq2) eq3);


EqDict_Tuple3_ne @(a b c : box)
  (repA : Repr (AsBare a)) (repB : Repr (AsBare b)) (repC : Repr (AsBare c))
  (eqA : EqDict a) (eqB : EqDict b) (eqC : EqDict c)
  (bx : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  (by : Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  -> Boxed (Stored bool)
  attribute(inline) =
  let type ba = AsBare a in
  let type bb = AsBare b in
  let type bc = AsBare c in
  let rep_tuple = unboxedinfo Tuple3 @ba @bb @bc repA repB repC in
  let sa_tuple = reprSizeAlign @(Tuple3 ba bb bc) rep_tuple in
  let sa_a = reprSizeAlign @ba repA in
  let sa_b = reprSizeAlign @bb repB in
  let sa_c = reprSizeAlign @bc repC in
  case eqA of eqDict tyob eq_a ne_a.
  case eqB of eqDict tyob eq_b ne_b.
  case eqC of eqDict tyob eq_c ne_c.
  case bx of [sa_tuple] boxed tyob ([sa_a, sa_b, sa_c] tuple3 xa xb xc).
  case by of [sa_tuple] boxed tyob ([sa_a, sa_b, sa_c] tuple3 ya yb yc).

  let ne1 : bool = unboxBoolValue
                   (ne_a (asbox @ba repA (copy @ba repA xa))
                         (asbox @ba repA (copy @ba repA ya))) in
  let ne2 : bool = unboxBoolValue
                   (ne_b (asbox @bb repB (copy @bb repB xb))
                         (asbox @bb repB (copy @bb repB yb))) in
  let ne3 : bool = unboxBoolValue
                   (ne_c (asbox @bc repC (copy @bc repC xc))
                         (asbox @bc repC (copy @bc repC yc))) in
  boxBoolValue (and (and ne1 ne2) ne3);


OrdDict_int : OrdDict (Boxed (Stored int));


OrdDict_int_lt (eq_dict : EqDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (ltI (unboxIntValue x) (unboxIntValue y));


OrdDict_int_le (eq_dict : EqDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (leI (unboxIntValue x) (unboxIntValue y));


OrdDict_int_gt (eq_dict : EqDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (gtI (unboxIntValue x) (unboxIntValue y));


OrdDict_int_ge (eq_dict : EqDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (geI (unboxIntValue x) (unboxIntValue y));


OrdDict_int64 : OrdDict (Boxed (Stored int64));


OrdDict_int64_lt (eq_dict : EqDict (Boxed (Stored int64)))
  (x y : Boxed (Stored int64))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (ltI64 (unboxInt64Value x) (unboxInt64Value y));


OrdDict_int64_le (eq_dict : EqDict (Boxed (Stored int64)))
  (x y : Boxed (Stored int64))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (leI64 (unboxInt64Value x) (unboxInt64Value y));


OrdDict_int64_gt (eq_dict : EqDict (Boxed (Stored int64)))
  (x y : Boxed (Stored int64))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (gtI64 (unboxInt64Value x) (unboxInt64Value y));


OrdDict_int64_ge (eq_dict : EqDict (Boxed (Stored int64)))
  (x y : Boxed (Stored int64))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (geI64 (unboxInt64Value x) (unboxInt64Value y));


OrdDict_float : OrdDict (Boxed (Stored float));


OrdDict_float_lt (eq_dict : EqDict (Boxed (Stored float)))
  (x y : Boxed (Stored float))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (ltF (unboxFloatValue x) (unboxFloatValue y));


OrdDict_float_le (eq_dict : EqDict (Boxed (Stored float)))
  (x y : Boxed (Stored float))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (leF (unboxFloatValue x) (unboxFloatValue y));


OrdDict_float_gt (eq_dict : EqDict (Boxed (Stored float)))
  (x y : Boxed (Stored float))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (gtF (unboxFloatValue x) (unboxFloatValue y));


OrdDict_float_ge (eq_dict : EqDict (Boxed (Stored float)))
  (x y : Boxed (Stored float))
  -> Boxed (Stored bool) attribute(inline) =
  boxBoolValue (geF (unboxFloatValue x) (unboxFloatValue y));


OrdDict_Tuple2 : forall a b : box.
                 EqDict (Boxed (Tuple2 (AsBare a) (AsBare b)))
              -> Repr (AsBare a) -> Repr (AsBare b)
              -> OrdDict a -> OrdDict b
              -> OrdDict (Boxed (Tuple2 (AsBare a) (AsBare b)));

OrdDict_Tuple2_lt @(a b : box)
  (eq_dict : EqDict (Boxed (Tuple2 (AsBare a) (AsBare b))))
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b))
  (ord_a : OrdDict a) (ord_b : OrdDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b))) 
  (y : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb rep_a rep_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba rep_a in
  let sa_b = reprSizeAlign @bb rep_b in

  case ord_a of ordDict tyob eqDict_a lt_a le_a gt_a ge_a.
  case ord_b of ordDict tyob eqDict_b lt_b le_b gt_b ge_b.
  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  case y of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 y_a y_b).
  boxBoolValue (and (unboxBoolValue (lt_a (bareToBox @ba rep_a x_a)
                                          (bareToBox @ba rep_a y_a)))
                    (unboxBoolValue (lt_b (bareToBox @bb rep_b x_b)
                                          (bareToBox @bb rep_b y_b))));


OrdDict_Tuple2_le @(a b : box)
  (eq_dict : EqDict (Boxed (Tuple2 (AsBare a) (AsBare b))))
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b))
  (ord_a : OrdDict a) (ord_b : OrdDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (y : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb rep_a rep_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba rep_a in
  let sa_b = reprSizeAlign @bb rep_b in

  case ord_a of ordDict tyob eqDict_a lt_a le_a gt_a ge_a.
  case ord_b of ordDict tyob eqDict_b lt_b le_b gt_b ge_b.
  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  case y of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 y_a y_b).
  boxBoolValue (and (unboxBoolValue (le_a (bareToBox @ba rep_a x_a)
                                          (bareToBox @ba rep_a y_a)))
                    (unboxBoolValue (le_b (bareToBox @bb rep_b x_b)
                                          (bareToBox @bb rep_b y_b))));


OrdDict_Tuple2_gt @(a b : box)
  (eq_dict : EqDict (Boxed (Tuple2 (AsBare a) (AsBare b))))
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b))
  (ord_a : OrdDict a) (ord_b : OrdDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (y : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb rep_a rep_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba rep_a in
  let sa_b = reprSizeAlign @bb rep_b in

  case ord_a of ordDict tyob eqDict_a lt_a le_a gt_a ge_a.
  case ord_b of ordDict tyob eqDict_b lt_b le_b gt_b ge_b.
  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  case y of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 y_a y_b).
  boxBoolValue (and (unboxBoolValue (gt_a (bareToBox @ba rep_a x_a)
                                          (bareToBox @ba rep_a y_a)))
                    (unboxBoolValue (gt_b (bareToBox @bb rep_b x_b)
                                          (bareToBox @bb rep_b y_b))));


OrdDict_Tuple2_ge @(a b : box)
  (eq_dict : EqDict (Boxed (Tuple2 (AsBare a) (AsBare b))))
  (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b))
  (ord_a : OrdDict a) (ord_b : OrdDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (y : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Stored bool)
  attribute(inline) =

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb rep_a rep_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba rep_a in
  let sa_b = reprSizeAlign @bb rep_b in

  case ord_a of ordDict tyob eqDict_a lt_a le_a gt_a ge_a.
  case ord_b of ordDict tyob eqDict_b lt_b le_b gt_b ge_b.
  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  case y of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 y_a y_b).
  boxBoolValue (and (unboxBoolValue (ge_a (bareToBox @ba rep_a x_a)
                                          (bareToBox @ba rep_a y_a)))
                    (unboxBoolValue (ge_b (bareToBox @bb rep_b x_b)
                                          (bareToBox @bb rep_b y_b))));


-------------------------------------------------------------------------------
-- Numeric dictionaries

AdditiveDict_int : AdditiveDict (Boxed (Stored int));
AdditiveDict_int_add (x : Boxed (Stored int)) (y : Boxed (Stored int))
  -> Boxed (Stored int) =
  boxIntValue (addI (unboxIntValue x) (unboxIntValue y));
  
AdditiveDict_int_sub (x : Boxed (Stored int)) (y : Boxed (Stored int))
  -> Boxed (Stored int) =
  boxIntValue (subI (unboxIntValue x) (unboxIntValue y));

AdditiveDict_int_negate (x : Boxed (Stored int)) -> Boxed (Stored int) =
  boxIntValue (negI (unboxIntValue x));

AdditiveDict_int_zero : Boxed (Stored int) attribute(inline) = boxIntValue 0;

AdditiveDict_uint : AdditiveDict (Boxed (Stored uint));
AdditiveDict_uint_add : Boxed (Stored uint) -> Boxed (Stored uint) -> Boxed (Stored uint);
AdditiveDict_uint_sub : Boxed (Stored uint) -> Boxed (Stored uint) -> Boxed (Stored uint);
AdditiveDict_uint_negate : Boxed (Stored uint) -> Boxed (Stored uint);
AdditiveDict_uint_zero : Boxed (Stored uint);

AdditiveDict_float : AdditiveDict (Boxed (Stored float));
AdditiveDict_float_add (x : Boxed (Stored float)) (y : Boxed (Stored float))
  -> Boxed (Stored float) =
  boxFloatValue (addF (unboxFloatValue x) (unboxFloatValue y));

AdditiveDict_float_sub (x : Boxed (Stored float)) (y : Boxed (Stored float))
  -> Boxed (Stored float) =
  boxFloatValue (subF (unboxFloatValue x) (unboxFloatValue y));

AdditiveDict_float_negate (x : Boxed (Stored float)) -> Boxed (Stored float) =
  boxFloatValue (negF (unboxFloatValue x));

AdditiveDict_float_zero : Boxed (Stored float) attribute(inline) = boxFloatValue 0.0;

AdditiveDict_int64 : AdditiveDict (Boxed (Stored int64));
AdditiveDict_int64_add (x : Boxed (Stored int64)) (y : Boxed (Stored int64))
  -> Boxed (Stored int64) =
  boxInt64Value (addI64 (unboxInt64Value x) (unboxInt64Value y));
  
AdditiveDict_int64_sub (x : Boxed (Stored int64)) (y : Boxed (Stored int64))
  -> Boxed (Stored int64) =
  boxInt64Value (subI64 (unboxInt64Value x) (unboxInt64Value y));

AdditiveDict_int64_negate (x : Boxed (Stored int64)) -> Boxed (Stored int64) =
  boxInt64Value (negI64 (unboxInt64Value x));

AdditiveDict_int64_zero : Boxed (Stored int64) attribute(inline) =
  boxInt64Value (intToInt64 0);

AdditiveDict_Tuple2 : forall a b : box.
                      Repr (AsBare a) -> Repr (AsBare b)
                   -> AdditiveDict a -> AdditiveDict b
                   -> AdditiveDict (Boxed (Tuple2 (AsBare a) (AsBare b)));


AdditiveDict_Tuple2_add @(a b : box)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (y : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Tuple2 (AsBare a) (AsBare b)) =

  case additive_a of additiveDict tyob add_a sub_a negate_a zero_a.
  case additive_b of additiveDict tyob add_b sub_b negate_b zero_b.

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb repr_a repr_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba repr_a in
  let sa_b = reprSizeAlign @bb repr_b in

  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  case y of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 y_a y_b).
  con_boxed @(Tuple2 ba bb) rep_tuple
  (tuple2 @ba @bb sa_a sa_b
   (asbare @(AsBare a) repr_a (add_a (bareToBox @(AsBare a) repr_a x_a)
                                     (bareToBox @(AsBare a) repr_a y_a)))
   (asbare @(AsBare b) repr_b (add_b (bareToBox @(AsBare b) repr_b x_b)
                                     (bareToBox @(AsBare b) repr_b y_b))));


AdditiveDict_Tuple2_sub @(a b : box)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b)))
  (y : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Tuple2 (AsBare a) (AsBare b)) =

  case additive_a of additiveDict tyob add_a sub_a negate_a zero_a.
  case additive_b of additiveDict tyob add_b sub_b negate_b zero_b.

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb repr_a repr_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba repr_a in
  let sa_b = reprSizeAlign @bb repr_b in

  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  case y of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 y_a y_b).
  con_boxed @(Tuple2 ba bb) rep_tuple
  (tuple2 @ba @bb sa_a sa_b
   (asbare @(AsBare a) repr_a (sub_a (bareToBox @(AsBare a) repr_a x_a)
                                     (bareToBox @(AsBare a) repr_a y_a)))
   (asbare @(AsBare b) repr_b (sub_b (bareToBox @(AsBare b) repr_b x_b)
                                     (bareToBox @(AsBare b) repr_b y_b))));


AdditiveDict_Tuple2_negate @(a b : box)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  (x : Boxed (Tuple2 (AsBare a) (AsBare b)))
  -> Boxed (Tuple2 (AsBare a) (AsBare b)) =

  case additive_a of additiveDict tyob add_a sub_a negate_a zero_a.
  case additive_b of additiveDict tyob add_b sub_b negate_b zero_b.

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb repr_a repr_b in
  let sa_tuple = reprSizeAlign @(Tuple2 ba bb) rep_tuple in
  let sa_a = reprSizeAlign @ba repr_a in
  let sa_b = reprSizeAlign @bb repr_b in

  case x of [sa_tuple] boxed tyob ([sa_a, sa_b] tuple2 x_a x_b).
  con_boxed @(Tuple2 ba bb) rep_tuple
  (tuple2 @ba @bb sa_a sa_b
   (asbare @(AsBare a) repr_a (negate_a (bareToBox @(AsBare a) repr_a x_a)))
   (asbare @(AsBare b) repr_b (negate_b (bareToBox @(AsBare b) repr_b x_b))));


AdditiveDict_Tuple2_zero @(a b : box)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (additive_a : AdditiveDict a)
  (additive_b : AdditiveDict b)
  -> Boxed (Tuple2 (AsBare a) (AsBare b)) =

  case additive_a of additiveDict tyob add_a sub_a negate_a zero_a.
  case additive_b of additiveDict tyob add_b sub_b negate_b zero_b.

  let type ba = AsBare a in
  let type bb = AsBare b in
  let rep_tuple = unboxedinfo Tuple2 @ba @bb repr_a repr_b in

  con_boxed @(Tuple2 ba bb) rep_tuple
  (tuple2 @ba @bb (reprSizeAlign @ba repr_a) (reprSizeAlign @bb repr_b)
   (asbare @(AsBare a) repr_a zero_a)
   (asbare @(AsBare b) repr_b zero_b));


MultiplicativeDict_int : MultiplicativeDict (Boxed (Stored int));

MultiplicativeDict_int_one (additive_dict : AdditiveDict (Boxed (Stored int)))
  -> Boxed (Stored int) attribute(inline) =
  boxIntValue 1;


MultiplicativeDict_int_mul (additive_dict : AdditiveDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored int) attribute(inline) =
  boxIntValue (mulI (unboxIntValue x) (unboxIntValue y));


-- Converting int to int is the identity transformation
MultiplicativeDict_int_fromInt (additive_dict : AdditiveDict (Boxed (Stored int)))
  (x : Boxed (Stored int))
  -> Boxed (Stored int) attribute(inline) =
  x;


MultiplicativeDict_uint : MultiplicativeDict (Boxed (Stored uint));
MultiplicativeDict_uint_one
  (additive_dict : AdditiveDict (Boxed (Stored uint))) 
  -> Boxed (Stored uint) attribute(inline) =
  boxUintValue 1U;

MultiplicativeDict_uint_mul : AdditiveDict (Boxed (Stored uint)) -> Boxed (Stored uint) -> Boxed (Stored uint)
                           -> Boxed (Stored uint);
MultiplicativeDict_uint_fromInt : AdditiveDict (Boxed (Stored uint)) -> Boxed (Stored int) -> Boxed (Stored uint);


MultiplicativeDict_float : MultiplicativeDict (Boxed (Stored float));
MultiplicativeDict_float_one (additive_dict : AdditiveDict (Boxed (Stored float)))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue 1.0;


MultiplicativeDict_float_mul (additive_dict : AdditiveDict (Boxed (Stored float)))
  (x y : Boxed (Stored float)) -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (mulF (unboxFloatValue x) (unboxFloatValue y));


MultiplicativeDict_float_fromInt (additive_dict : AdditiveDict (Boxed (Stored float)))
  (x : Boxed (Stored int))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (fromintF (unboxIntValue x));


MultiplicativeDict_int64 : MultiplicativeDict (Boxed (Stored int64));

MultiplicativeDict_int64_one (additive_dict : AdditiveDict (Boxed (Stored int64)))
  -> Boxed (Stored int64) attribute(inline) =
  boxInt64Value (intToInt64 1);


MultiplicativeDict_int64_mul (additive_dict : AdditiveDict (Boxed (Stored int64)))
  (x y : Boxed (Stored int64))
  -> Boxed (Stored int64) attribute(inline) =
  boxInt64Value (mulI64 (unboxInt64Value x) (unboxInt64Value y));


-- Converting int to int is the identity transformation
MultiplicativeDict_int64_fromInt (additive_dict : AdditiveDict (Boxed (Stored int64)))
  (x : Boxed (Stored int))
  -> Boxed (Stored int64) attribute(inline) =
  boxInt64Value (intToInt64 (unboxIntValue x));


RemainderDict_int_floordiv (mul_dict : MultiplicativeDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored int) attribute(inline) =
  boxIntValue (floordivI (unboxIntValue x) (unboxIntValue y));


RemainderDict_int_mod (mul_dict : MultiplicativeDict (Boxed (Stored int)))
  (x y : Boxed (Stored int))
  -> Boxed (Stored int) attribute(inline) =
  boxIntValue (modI (unboxIntValue x) (unboxIntValue y));


RemainderDict_uint_floordiv : MultiplicativeDict (Boxed (Stored uint)) -> uint -> uint -> uint;
RemainderDict_uint_mod : MultiplicativeDict (Boxed (Stored uint)) -> uint -> uint -> uint;


RemainderDict_float_floordiv (mul_dict : MultiplicativeDict (Boxed (Stored float)))
  (x y : Boxed (Stored float)) -> Boxed (Stored int) attribute(inline) =
  boxIntValue (floordivF (unboxFloatValue x) (unboxFloatValue y));


RemainderDict_float_mod (mul_dict : MultiplicativeDict (Boxed (Stored float)))
  (x y : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (modF (unboxFloatValue x) (unboxFloatValue y));


FractionalDict_float_div (mul_dict : MultiplicativeDict (Boxed (Stored float)))
  (x y : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (divF (unboxFloatValue x) (unboxFloatValue y));


FloatingDict_float_fromfloat (x : Boxed (Stored float))
  -> Boxed (Stored float) = x;


FloatingDict_float_power (x : Boxed (Stored float)) (y : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (powF (unboxFloatValue x) (unboxFloatValue y));


FloatingDict_float_exp (x : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (expF (unboxFloatValue x));


FloatingDict_float_log (x : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (logF (unboxFloatValue x));


FloatingDict_float_sqrt (x : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (sqrtF (unboxFloatValue x));


FloatingDict_float_sin (x : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (sinF (unboxFloatValue x));


FloatingDict_float_cos (x : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (cosF (unboxFloatValue x));


FloatingDict_float_tan (x : Boxed (Stored float))
  -> Boxed (Stored float) attribute(inline) =
  boxFloatValue (tanF (unboxFloatValue x));


FloatingDict_float_pi : Boxed (Stored float) =
  boxFloatValue 3.141592653589793;


VectorDict_float_scale : float -> float -> float;
VectorDict_float_magnitude : float -> float;
VectorDict_float_dot : float -> float -> float;

-------------------------------------------------------------------------------
-- Cartesian domain dictionaries

loBound_dim0
  (dom : dim0)
  -> Init (Maybe (index dim0))
  attribute(inline) =
  just @(Stored NoneType)
  (reprSizeAlign @(Stored NoneType) repr_NoneType)
  (stored @NoneType None);


hiBound_dim0
  (dom : dim0)
  -> Init (Maybe (index dim0))
  attribute(inline) =
  just @(Stored NoneType)
  (reprSizeAlign @(Stored NoneType) repr_NoneType)
  (stored @NoneType None);


stride_dim0
  (dom : dim0)
  -> Init (index dim0)
  attribute(inline) =
  stored @NoneType None;


arrayDomain_dim0
  (lo : index dim0)
  (hi : index dim0)
  -> dim0
  attribute(inline) =
  con_dim0;


displaceDomain_dim0
  (dom : dim0)
  (ix : index dim0)
  -> dim0
  attribute(inline) =
  con_dim0;


multiplyDomain_dim0
  (dom : dim0)
  (n : Stored NoneType)
  -> dim0
  attribute(inline) =
  con_dim0;


divideDomain_dim0
  (dom : dim0)
  (n : Stored NoneType)
  -> dim0
  attribute(inline) =
  con_dim0;


multiplyIndex_dim0 :
    AsBox (index dim0) -> AsBox (index dim0) -> AsBox (index dim0);

divideIndex_dim0 :
    AsBox (index dim0) -> AsBox (index dim0) -> AsBox (index dim0);

unbounded_dim0 :
    dim0;


loBound_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> dim1 -> Boxed (Maybe (index dim1)) attribute(inline) =
  real_loBound_dim1;


real_loBound_dim1
  (dom : dim1) -> Boxed (Maybe (index dim1))
  attribute(inline, inline_sequential) =
  let rep_maybe = unboxedinfo Maybe @(Stored int) repr_int in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case dom of mk_dim1 tyob (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case lb of {
    justVal x.  con_boxed @(Maybe (index dim1)) rep_maybe
                (just @(Stored int) sa_int (stored @int x))
  ; nothingVal. con_boxed @(Maybe (index dim1)) rep_maybe
                (nothing @(Stored int) sa_int)
  };


hiBound_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> dim1 -> Boxed (Maybe (index dim1)) attribute(inline) =
  real_hiBound_dim1;


real_hiBound_dim1
  (dom : dim1) -> Boxed (Maybe (index dim1))
  attribute(inline, inline_sequential) =
  let rep_maybe = unboxedinfo Maybe @(Stored int) repr_int in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case dom of mk_dim1 tyob (iv : Interval) (lm : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case ub of {
    justVal x.  con_boxed @(Maybe (index dim1)) rep_maybe
                (just @(Stored int) sa_int (stored @int x))
  ; nothingVal. con_boxed @(Maybe (index dim1)) rep_maybe
                (nothing @(Stored int) sa_int)
  };


stride_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> dim1 -> Boxed (index dim1)
  attribute(inline) =
  real_stride_dim1;


real_stride_dim1
  (dom : dim1) -> Boxed (index dim1)
  attribute(inline) =
  case dom of mk_dim1 tyob (iv : Interval) (lm : LinearMap).
  case lm of linearMap (stride : int) (alignment : int).
  boxIntValue stride;
  

arrayDomain_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> AsBox (index dim1) -> AsBox (index dim1) -> dim1 attribute(inline) =
  real_arrayDomain_dim1;


real_arrayDomain_dim1
  (lo : AsBox (index dim1))
  (hi : AsBox (index dim1))
  -> dim1
  attribute(inline, inline_final) =
  let lo_i = unboxIntValue lo in
  let hi_i = unboxIntValue hi in

  -- Check for empty range
  if lo_i ># hi_i
  then con_dim1 (interval (justVal @int 0) (justVal @int 0)) (linearMap 1 0)
  else con_dim1 (interval (justVal @int lo_i) (justVal @int hi_i))
                (linearMap 1 0);


displaceDomain_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> dim1 -> AsBox (index dim1) -> dim1 attribute(inline) =
  real_displaceDomain_dim1;


real_displaceDomain_dim1
  (dom : dim1)
  (ix : AsBox (index dim1))
  -> dim1
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 tyob (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case m of linearMap (stride : int) (alignment : int).
  let offset_i = unboxIntValue ix in

  let lb2 : MaybeVal int =
        case lb of {
          justVal lb_i. justVal @int (lb_i +# offset_i)
        ; nothingVal. nothingVal @int
        } in
  let ub2 : MaybeVal int =
        case ub of {
          justVal ub_i. justVal @int (ub_i +# offset_i)
        ; nothingVal. nothingVal @int
        } in
  con_dim1 (interval lb2 ub2)
           (linearMap stride ((alignment +# offset_i) %# stride));


multiplyDomain_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> dim1 -> Boxed (Stored int) -> dim1 attribute(inline) =
  real_multiplyDomain_dim1;


real_multiplyDomain_dim1
  (dom : dim1)
  (n : Boxed (Stored int))
  -> dim1
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 tyob (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case m of linearMap (stride : int) (alignment : int).
  let n_u = unboxIntValue n in

  -- Stride must remain positive
  if n_u <=# 0 then except @dim1 else
  
  let lb2 : MaybeVal int =
        case lb of {
          justVal lb_i. justVal @int (lb_i *# n_u)
        ; nothingVal. nothingVal @int
        } in

  let ub2 : MaybeVal int =
        case ub of {
          justVal ub_i. justVal @int (ub_i *# n_u)
        ; nothingVal. nothingVal @int
        } in
  con_dim1 (interval lb2 ub2)
           (linearMap (stride *# n_u) (alignment *# n_u));


divideDomain_dim1
  (is_cartesian : coerce @box dim1 dim1)
  -> dim1 -> Boxed (Stored int) -> dim1 attribute(inline) =
  real_divideDomain_dim1;


real_divideDomain_dim1
  (dom : dim1)
  (n : Boxed (Stored int))
  -> dim1
  attribute(inline, inline_sequential) =
  case dom of mk_dim1 tyob (iv : Interval) (m : LinearMap).
  case iv of interval (lb : MaybeVal int) (ub : MaybeVal int).
  case m of linearMap (stride : int) (alignment : int).
  let n_u = unboxIntValue n in

  -- Stride must remain positive
  if n_u <=# 0 then except @dim1 else

  -- Ensure that it divides exactly
  if or (stride %# n_u /=# 0) (alignment %# n_u /=# 0)
  then except @(dim1) else
  
  let lb2 : MaybeVal int =
        case lb of {
          justVal lb_i. justVal @int (lb_i //# n_u)
        ; nothingVal. nothingVal @int
        } in

  let ub2 : MaybeVal int =
        case ub of {
          justVal ub_i. justVal @int (ub_i //# n_u)
        ; nothingVal. nothingVal @int
        } in
  con_dim1 (interval lb2 ub2)
           (linearMap (stride //# n_u) (alignment //# n_u));


multiplyIndex_dim1 :
  coerce @box dim1 dim1 ->
    AsBox (index dim1) -> AsBox (index dim1) -> AsBox (index dim1);

divideIndex_dim1 :
  coerce @box dim1 dim1 ->
    AsBox (index dim1) -> AsBox (index dim1) -> AsBox (index dim1);

unbounded_dim1 :
  coerce @box dim1 dim1 -> dim1;


loBound_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> dim2 -> Boxed (Maybe (index dim2))
  attribute(inline) =
  real_loBound_dim2;


real_loBound_dim2 (dom : dim2) -> Boxed (Maybe (index dim2))
  attribute(inline, inline_final) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let rep_maybe = unboxedinfo Maybe @(index dim2) rep_tuple in
  case dom of mk_dim2 tyob dom_y dom_x.
  case dom_y of mk_dim1 tyob (iv_y : Interval) (lm : LinearMap).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case lb_y of {
    justVal (y : int).
      case dom_x of mk_dim1 tyob iv_x lm.
      case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
      case lb_x of {
        justVal (x : int).
          con_boxed @(Maybe (index dim2)) rep_maybe
          (just @(Tuple2 (Stored int) (Stored int)) sa_tuple
                (tuple2 @(Stored int) @(Stored int) sa_int sa_int
                 (stored @int y) (stored @int x)))
      ; nothingVal.
          con_boxed @(Maybe (index dim2)) rep_maybe
          (nothing @(Tuple2 (Stored int) (Stored int)) sa_tuple)
      }
  ; nothingVal.
      con_boxed @(Maybe (index dim2)) rep_maybe
      (nothing @(Tuple2 (Stored int) (Stored int)) sa_tuple)
  };
  

hiBound_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> dim2 -> Boxed (Maybe (index dim2))
  attribute(inline, inline_final) =
  real_hiBound_dim2;


real_hiBound_dim2 (dom : dim2) -> Boxed (Maybe (index dim2))
  attribute(inline, inline_final) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let rep_maybe = unboxedinfo Maybe @(index dim2) rep_tuple in
  case dom of mk_dim2 tyob (dom_y : dim1) (dom_x : dim1).
  case dom_y of mk_dim1 tyob (iv_y : Interval) (lm : LinearMap).
  case iv_y of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case ub_y of {
    justVal (y : int).
      case dom_x of mk_dim1 tyob (iv_x : Interval) (lm : LinearMap).
      case iv_x of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
      case ub_x of {
        justVal (x : int).
          con_boxed @(Maybe (index dim2)) rep_maybe
          (just @(Tuple2 (Stored int) (Stored int)) sa_tuple
                (tuple2 @(Stored int) @(Stored int) sa_int sa_int
                (stored @int y) (stored @int x)))
      ; nothingVal.
          con_boxed @(Maybe (index dim2)) rep_maybe
          (nothing @(Tuple2 (Stored int) (Stored int)) sa_tuple)
      }
  ; nothingVal.
      con_boxed @(Maybe (index dim2)) rep_maybe
      (nothing @(Tuple2 (Stored int) (Stored int)) sa_tuple)
  };


stride_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> dim2 -> Boxed (index dim2)
  attribute(inline) =
  real_stride_dim2;

real_stride_dim2
  (dom : dim2) -> Boxed (index dim2)
  attribute(inline) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case dom of mk_dim2 tyob (dom_y : dim1) (dom_x : dim1).
  con_boxed @(index dim2) rep_tuple
  (tuple2 @(Stored int) @(Stored int) sa_int sa_int
   (stored @int (unboxIntValue (real_stride_dim1 dom_y)))
   (stored @int (unboxIntValue (real_stride_dim1 dom_x))));


arrayDomain_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> Boxed (index dim2) -> Boxed (index dim2) -> dim2 attribute(inline) =
  real_arrayDomain_dim2;


real_arrayDomain_dim2
  (lo : Boxed (index dim2))
  (hi : Boxed (index dim2))
  -> dim2
  attribute(inline) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case lo of [sa_tuple]
    boxed tyob ([sa_int, sa_int] tuple2 (stored lo_y_i) (stored lo_x_i)).
  case hi of [sa_tuple]
    boxed tyob ([sa_int, sa_int] tuple2 (stored hi_y_i) (stored hi_x_i)).
  con_dim2 (con_dim1 (interval (justVal @int lo_y_i) (justVal @int hi_y_i))
                     (linearMap 1 0))
           (con_dim1 (interval (justVal @int lo_x_i) (justVal @int hi_x_i))
                     (linearMap 1 0));


displaceDomain_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> dim2 -> Boxed (index dim2) -> dim2 attribute(inline) =
  real_displaceDomain_dim2;


real_displaceDomain_dim2
  (dom : dim2)
  (ix : Boxed (index dim2))
  -> dim2
  attribute(inline) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case ix of [sa_tuple]
    boxed tyob ([sa_int, sa_int] tuple2 (stored ix_y) (stored ix_x)).
  let b_y = boxIntValue ix_y in
  let b_x = boxIntValue ix_x in
  case dom of mk_dim2 tyob (dom_y : dim1) (dom_x : dim1).
  con_dim2 (real_displaceDomain_dim1 dom_y b_y)
           (real_displaceDomain_dim1 dom_x b_x);


multiplyDomain_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> dim2 -> Boxed (Tuple2 (Stored int) (Stored int)) -> dim2 attribute(inline) =
  real_multiplyDomain_dim2;


real_multiplyDomain_dim2
  (dom : dim2)
  (v : Boxed (Tuple2 (Stored int) (Stored int)))
  -> dim2
  attribute(inline) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case dom of mk_dim2 tyob (dom_y : dim1) (dom_x : dim1).
  case v of [sa_tuple]
    boxed tyob ([sa_int, sa_int] tuple2 (stored v_y) (stored v_x)).
  let b_y = boxIntValue v_y in
  let b_x = boxIntValue v_x in
  con_dim2 (real_multiplyDomain_dim1 dom_y b_y)
           (real_multiplyDomain_dim1 dom_x b_x);
  
  
divideDomain_dim2
  (is_cartesian : coerce @box dim2 dim2)
  -> dim2 -> Boxed (Tuple2 (Stored int) (Stored int)) -> dim2
  attribute(inline) =
  real_divideDomain_dim2;


real_divideDomain_dim2
  (dom : dim2)
  (v : Boxed (Tuple2 (Stored int) (Stored int)))
  -> dim2
  attribute(inline) =
  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_tuple = reprSizeAlign @(Tuple2 (Stored int) (Stored int)) rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in
  case dom of mk_dim2 tyob (dom_y : dim1) (dom_x : dim1).
  case v of [sa_tuple]
    boxed tyob ([sa_int, sa_int] tuple2 (stored v_y) (stored v_x)).
  let b_y = boxIntValue v_y in
  let b_x = boxIntValue v_x in
  con_dim2 (real_divideDomain_dim1 dom_y b_y)
           (real_divideDomain_dim1 dom_x b_x);


multiplyIndex_dim2 :
    coerce @box dim2 dim2 ->
    AsBox (index dim2) -> AsBox (index dim2) -> AsBox (index dim2);

divideIndex_dim2 :
    coerce @box dim2 dim2 ->
    AsBox (index dim2) -> AsBox (index dim2) -> AsBox (index dim2);

unbounded_dim2 :
    coerce @box dim2 dim2 ->
    dim2;


loBound_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> dim3 -> Boxed (Maybe (index dim3))
  attribute(inline) =
  real_loBound_dim3;


real_loBound_dim3
  (dom : dim3) -> Boxed (Maybe (index dim3))
  attribute(inline, inline_final) =
  let type ix = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let rep_maybe = unboxedinfo Maybe @ix rep_tuple in
  let sa_tuple = reprSizeAlign @ix rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case dom of mk_dim3 tyob dom_z dom_y dom_x.
  case dom_z of mk_dim1 tyob (interval lb_z ub_z) lm.
  case lb_z of {
    justVal (z : int).
      case dom_y of mk_dim1 tyob (interval lb_y ub_y) lm.
      case lb_y of {
        justVal (y : int).
          case dom_x of mk_dim1 tyob (interval lb_x ub_x) lm.
          case lb_x of {
            justVal (x : int).
              con_boxed @(Maybe ix) rep_maybe
              (just @ix sa_tuple
                    (tuple3 @(Stored int) @(Stored int) @(Stored int)
                     sa_int sa_int sa_int
                     (stored @int z) (stored @int y) (stored @int x)))
          ; nothingVal.
              con_boxed @(Maybe ix) rep_maybe (nothing @ix sa_tuple)
          }
      ; nothingVal.
          con_boxed @(Maybe ix) rep_maybe (nothing @ix sa_tuple)
      }
  ; nothingVal.
      con_boxed @(Maybe ix) rep_maybe (nothing @ix sa_tuple)
  };
  

hiBound_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> dim3 -> Boxed (Maybe (index dim3))
  attribute(inline) =
  real_hiBound_dim3;


real_hiBound_dim3
  (dom : dim3) -> Boxed (Maybe (index dim3))
  attribute(inline, inline_final) =
  let type ix = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let rep_maybe = unboxedinfo Maybe @ix rep_tuple in
  let sa_tuple = reprSizeAlign @ix rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case dom of mk_dim3 tyob (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case dom_z of mk_dim1 tyob (interval lb_z ub_z) (lm : LinearMap).
  case ub_z of {
    justVal (z : int).
      case dom_y of mk_dim1 tyob (interval lb_y ub_y) (lm : LinearMap).
      case ub_y of {
        justVal (y : int).
          case dom_x of mk_dim1 tyob (interval lb_x ub_x) (lm : LinearMap).
          case ub_x of {
            justVal (x : int).
              con_boxed @(Maybe ix) rep_maybe
              (just @ix sa_tuple
                    (tuple3 @(Stored int) @(Stored int) @(Stored int)
                     sa_int sa_int sa_int
                     (stored @int z) (stored @int y) (stored @int x)))
          ; nothingVal.
              con_boxed @(Maybe ix) rep_maybe (nothing @ix sa_tuple)
          }
      ; nothingVal.
          con_boxed @(Maybe ix) rep_maybe (nothing @ix sa_tuple)
      }
  ; nothingVal.
      con_boxed @(Maybe ix) rep_maybe (nothing @ix sa_tuple)
  };


stride_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> dim3 -> AsBox (index dim3)
  attribute(inline) =
  real_stride_dim3;


real_stride_dim3
  (dom : dim3) -> AsBox (index dim3)
  attribute(inline) =
  let type ix = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let sa_tuple = reprSizeAlign @ix rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case dom of mk_dim3 tyob (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  con_boxed @(index dim3) rep_tuple
  (tuple3 @(Stored int) @(Stored int) @(Stored int) sa_int sa_int sa_int
   (stored @int (unboxIntValue (real_stride_dim1 dom_z)))
   (stored @int (unboxIntValue (real_stride_dim1 dom_y)))
   (stored @int (unboxIntValue (real_stride_dim1 dom_x))));


arrayDomain_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> Boxed (index dim3) -> Boxed (index dim3) -> dim3
  attribute(inline) =
  real_arrayDomain_dim3;


real_arrayDomain_dim3
  (lo : Boxed (index dim3))
  (hi : Boxed (index dim3))
  -> dim3
  attribute(inline) =
  let type ix = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let sa_tuple = reprSizeAlign @ix rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case lo of [sa_tuple]
    boxed tyob ([sa_int, sa_int, sa_int] tuple3 (stored lo_z_i) (stored lo_y_i) (stored lo_x_i)).
  case hi of [sa_tuple]
    boxed tyob ([sa_int, sa_int, sa_int] tuple3 (stored hi_z_i) (stored hi_y_i) (stored hi_x_i)).
  con_dim3 (con_dim1 (interval (justVal @int lo_z_i) (justVal @int hi_z_i))
                     (linearMap 1 0))
           (con_dim1 (interval (justVal @int lo_y_i) (justVal @int hi_y_i))
                     (linearMap 1 0))
           (con_dim1 (interval (justVal @int lo_x_i) (justVal @int hi_x_i))
                     (linearMap 1 0));


displaceDomain_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> dim3 -> Boxed (index dim3) -> dim3
  attribute(inline) =
  real_displaceDomain_dim3;


real_displaceDomain_dim3
  (dom : dim3)
  (ix : Boxed (index dim3))
  -> dim3
  attribute(inline) =
  let type ix_type = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let sa_tuple = reprSizeAlign @ix_type rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case dom of mk_dim3 tyob (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case ix of [sa_tuple]
    boxed tyob ([sa_int, sa_int, sa_int] tuple3 (stored ix_z) (stored ix_y) (stored ix_x)).
  let b_z = boxIntValue ix_z in
  let b_y = boxIntValue ix_y in
  let b_x = boxIntValue ix_x in
  con_dim3 (real_displaceDomain_dim1 dom_z b_z)
           (real_displaceDomain_dim1 dom_y b_y)
           (real_displaceDomain_dim1 dom_x b_x);


multiplyDomain_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> dim3 -> Boxed (index dim3) -> dim3 attribute(inline) =
  real_multiplyDomain_dim3;


real_multiplyDomain_dim3
  (dom : dim3)
  (v : Boxed (index dim3))
  -> dim3
  attribute(inline) =
  let type ix_type = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let sa_tuple = reprSizeAlign @ix_type rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case dom of mk_dim3 tyob (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case v of [sa_tuple]
    boxed tyob ([sa_int, sa_int, sa_int] tuple3 (stored v_z) (stored v_y) (stored v_x)).
  let b_z = boxIntValue v_z in
  let b_y = boxIntValue v_y in
  let b_x = boxIntValue v_x in
  con_dim3 (real_multiplyDomain_dim1 dom_z b_z)
           (real_multiplyDomain_dim1 dom_y b_y)
           (real_multiplyDomain_dim1 dom_x b_x);
  
  
divideDomain_dim3
  (is_cartesian : coerce @box dim3 dim3)
  -> dim3 -> Boxed (index dim3) -> dim3
  attribute(inline) =
  real_divideDomain_dim3;


real_divideDomain_dim3
  (dom : dim3)
  (v : Boxed (index dim3))
  -> dim3
  attribute(inline) =
  let type ix_type = Tuple3 (Stored int) (Stored int) (Stored int) in
  let rep_tuple =
        unboxedinfo Tuple3 @(Stored int) @(Stored int) @(Stored int) repr_int repr_int repr_int in
  let sa_tuple = reprSizeAlign @ix_type rep_tuple in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  case dom of mk_dim3 tyob (dom_z : dim1) (dom_y : dim1) (dom_x : dim1).
  case v of [sa_tuple]
    boxed tyob ([sa_int, sa_int, sa_int] tuple3 (stored v_z) (stored v_y) (stored v_x)).
  let b_z = boxIntValue v_z in
  let b_y = boxIntValue v_y in
  let b_x = boxIntValue v_x in
  con_dim3 (real_divideDomain_dim1 dom_z b_z)
           (real_divideDomain_dim1 dom_y b_y)
           (real_divideDomain_dim1 dom_x b_x);

multiplyIndex_dim3 :
    coerce @box dim3 dim3 ->
    AsBox (index dim3) -> AsBox (index dim3) -> AsBox (index dim3);

divideIndex_dim3 :
    coerce @box dim3 dim3 ->
    AsBox (index dim3) -> AsBox (index dim3) -> AsBox (index dim3);

unbounded_dim3 :
    coerce @box dim3 dim3 ->
    dim3;

-------------------------------------------------------------------------------
-- Boxing/unboxing helper functions

boxIntValue (n : int) -> Boxed (Stored int) =
  let rep_Sint = repr_Stored @int (unboxedinfo int) in
  boxed @(Stored int)
  (reprSizeAlign @(Stored int) rep_Sint)
  (boxedinfo boxed @(Stored int) rep_Sint)
  (stored @int n);

unboxIntValue (n : Boxed (Stored int)) -> int =
  case n of [reprSizeAlign @(Stored int) repr_int]
    boxed tyob (stored un). un;

boxUintValue (n : uint) -> Boxed (Stored uint) =
  let rep_Suint = repr_Stored @uint (unboxedinfo uint) in
  boxed @(Stored uint)
  (reprSizeAlign @(Stored uint) rep_Suint)
  (boxedinfo boxed @(Stored uint) rep_Suint)
  (stored @uint n);

unboxUintValue (n : Boxed (Stored uint)) -> uint =
  case n of [reprSizeAlign @(Stored uint) repr_uint]
    boxed tyob (stored un). un;

boxFloatValue (n : float) -> Boxed (Stored float) =
  let rep_Sfloat = repr_Stored @float (unboxedinfo float) in
  boxed @(Stored float)
  (reprSizeAlign @(Stored float) rep_Sfloat)
  (boxedinfo boxed @(Stored float) rep_Sfloat)
  (stored @float n);

unboxFloatValue (n : Boxed (Stored float)) -> float =
  case n of [reprSizeAlign @(Stored float) repr_float]
    boxed tyob (stored un). un;

boxInt64Value (n : int64) -> Boxed (Stored int64) =
  let rep_Sint = repr_Stored @int64 (unboxedinfo int64) in
  boxed @(Stored int64)
  (reprSizeAlign @(Stored int64) rep_Sint)
  (boxedinfo boxed @(Stored int64) rep_Sint)
  (stored @int64 n);

unboxInt64Value (n : Boxed (Stored int64)) -> int64 =
  case n of [reprSizeAlign @(Stored int64) repr_int64]
    boxed tyob (stored un). un;

boxBoolValue (n : bool) -> Boxed (Stored bool) =
  let rep_Sbool = repr_Stored @bool (unboxedinfo bool) in
  boxed @(Stored bool)
  (reprSizeAlign @(Stored bool) rep_Sbool)
  (boxedinfo boxed @(Stored bool) rep_Sbool)
  (stored @bool n);

unboxBoolValue (n : Boxed (Stored bool)) -> bool =
  case n of [reprSizeAlign @(Stored bool) repr_bool]
    boxed tyob (stored un). un;

boxNoneValue (n : NoneType) -> Boxed (Stored NoneType) =
  let rep_SNone = repr_Stored @NoneType (unboxedinfo NoneType) in
  boxed @(Stored NoneType)
  (reprSizeAlign @(Stored NoneType) rep_SNone)
  (boxedinfo boxed @(Stored NoneType) rep_SNone)
  (stored @NoneType n);

unboxNoneValue (n : Boxed (Stored NoneType)) -> NoneType =
  case n of  [reprSizeAlign @(Stored NoneType) repr_NoneType]
    boxed tyob (stored un). un;

unboxRefInit @(a : box) (w : Init (Ref a)) -> a =
  let rep_Ref = unboxedinfo Ref @a in
  case con_stuckBox @(Ref a) rep_Ref w of [reprSizeAlign @(Ref a) rep_Ref]
    stuckBox tyob (ref x). x;

boxParHintValue (x : ParHint) -> Boxed (Stored ParHint) =
  let rep_ph = repr_Stored @ParHint (unboxedinfo ParHint) in
  boxed @(Stored ParHint)
  (reprSizeAlign @(Stored ParHint) rep_ph)
  (boxedinfo boxed @(Stored ParHint) rep_ph)
  (stored @ParHint x);

unboxParHintValue (x : Boxed (Stored ParHint)) -> ParHint =
  let rep_ph = repr_Stored @ParHint (unboxedinfo ParHint) in
  case x of [reprSizeAlign @(Stored ParHint) rep_ph]
    boxed tyob (stored y). y;

-------------------------------------------------------------------------------
-- other arithmetic

eqI : int -> int -> bool;
neI : int -> int -> bool;
ltI : int -> int -> bool;
leI : int -> int -> bool;
gtI : int -> int -> bool;
geI : int -> int -> bool;

addI : int -> int -> int attribute(builtin);
subI : int -> int -> int attribute(builtin);
negI : int -> int attribute(builtin);
-- zeroI = 0;

mulI : int -> int -> int attribute(builtin);
floordivI : int -> int -> int;
modI : int -> int -> int attribute(builtin);

minI : int -> int -> int;
maxI : int -> int -> int attribute(builtin);

eqU : uint -> uint -> bool attribute(builtin);
neU : uint -> uint -> bool;
ltU : uint -> uint -> bool;
leU : uint -> uint -> bool;
gtU : uint -> uint -> bool;
geU : uint -> uint -> bool;

addU : uint -> uint -> uint attribute(builtin);
subU : uint -> uint -> uint attribute(builtin);
negU : uint -> uint;
-- zeroU = 0;

mulU : uint -> uint -> uint;
floordivU : uint -> uint -> uint;
modU : uint -> uint -> uint attribute(builtin);

minU : uint -> uint -> uint;
maxU : uint -> uint -> uint attribute(builtin);

eqF : float -> float -> bool;
neF : float -> float -> bool;
ltF : float -> float -> bool;
leF : float -> float -> bool;
gtF : float -> float -> bool;
geF : float -> float -> bool;

addF : float -> float -> float;
subF : float -> float -> float;
negF : float -> float;
-- zeroF = 0.0;

mulF : float -> float -> float;
fromintF : int -> float;
floordivF : float -> float -> int;
modF : float -> float -> float;
divF : float -> float -> float;
powF : float -> float -> float;
expF : float -> float;
logF : float -> float;
sqrtF : float -> float;
sinF : float -> float;
cosF : float -> float;
tanF : float -> float;

eqI64 : int64 -> int64 -> bool;
neI64 : int64 -> int64 -> bool;
ltI64 : int64 -> int64 -> bool;
leI64 : int64 -> int64 -> bool;
gtI64 : int64 -> int64 -> bool;
geI64 : int64 -> int64 -> bool;

addI64 : int64 -> int64 -> int64;
subI64 : int64 -> int64 -> int64;
negI64 : int64 -> int64;
zeroI64 : int64 = intToInt64 0;

mulI64 : int64 -> int64 -> int64;

uintToInt : uint -> int attribute(builtin);
intToUint : int -> uint attribute(builtin);
intToInt64 : int -> int64;

floor : float -> int;

oper_BITWISEAND : int -> int -> int;
oper_BITWISEOR : int -> int -> int;
oper_BITWISEXOR : int -> int -> int;

lshift : int -> int -> int;
rshift : int -> int -> int;

or : bool -> bool -> bool attribute(builtin);
and : bool -> bool -> bool attribute(builtin);
not : bool -> bool attribute(builtin);

fromCursor : forall a : bare. cursor a -> a;
toCursor : forall a : bare. a -> cursor a;

subscript : forall n : intindex, a : bare.
            SizeAlign a
         -> arr n a
         -> int
         -> a
         attribute(conlike);

-- Like subscript, but returns a cursor pointing to a subarray
subarray : forall n n2 : intindex, a : bare.
           SizeAlign a
        -> arr n a
        -> int
        -> cursor (arr n2 a)
         attribute(conlike);

-- Like subscript, but modifies an output pointer
subscript_out : forall n : intindex, a : bare.
                SizeAlign a
             -> OutPtr (arr n a)
             -> int
             -> OutPtr a;

-- Like subscript_out, but returns a subarray
subarray_out : forall n n2 : intindex, a : bare.
               SizeAlign a
            -> OutPtr (arr n a)
            -> int
            -> OutPtr (arr n2 a);

-------------------------------------------------------------------------------
-- integer index arithmetic

-- Promote an integer to a type index
defineIntIndex : int -> SomeIInt;

type plus_i : intindex -> intindex -> intindex;
type minus_i : intindex -> intindex -> intindex;
type min_i : intindex -> intindex -> intindex;
type max_i : intindex -> intindex -> intindex;

zero_fii : FIInt 0;
one_fii : FIInt 1;

-- Operations on finite indexed ints aren't inlined until near the end,
-- because they don't enable other optimizations.  By delaying inlining,
-- code doesn't expand as much.

plus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	 -> FIInt (plus_i m n)
	 attribute(inline, inline_final) =
  case x of fiInt (x_i : int).
  case y of fiInt (y_i : int).
  fiInt @(plus_i m n) (x_i +# y_i);


minus_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	  -> FIInt (minus_i m n)
	  attribute(inline, inline_final) =
  case x of fiInt (x_i : int).
  case y of fiInt (y_i : int).
  fiInt @(minus_i m n) (x_i -# y_i);


min_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (min_i m n)
	attribute(inline, inline_final) =
  case x of fiInt (x_i : int).
  case y of fiInt (y_i : int).
  fiInt @(min_i m n) (minI x_i y_i);


max_fii @(m n : intindex) (x : FIInt m) (y : FIInt n)
	-> FIInt (max_i m n)
	attribute(inline, inline_final) =
  case x of fiInt (x_i : int).
  case y of fiInt (y_i : int).
  fiInt @(max_i m n) (maxI x_i y_i);


zero_ii : IInt 0 = iInt @0 (fiInt @0 0);

one_ii : IInt 1 = iInt @1 (fiInt @1 1);

plus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (plus_i m n) attribute(inline) =
  let type sum_t = plus_i m n in
  case a of {
    iInt (fa : FIInt m).
      case b of {
        iInt (fb : FIInt n). iInt @sum_t (plus_fii @m @n fa fb)
      ; iPosInfty. iPosInfty @sum_t
      ; iNegInfty. iNegInfty @sum_t
      }
  ; iPosInfty.
      case b of {
        iInt (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty. iPosInfty @sum_t
      ; iNegInfty. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  ; iNegInfty.
      case b of {
        iInt (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty. iNegInfty @sum_t
      }
  };


minus_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (minus_i m n) attribute(inline) =
  let type sum_t = minus_i m n in
  case a of {
    iInt (fa : FIInt m).
      case b of {
        iInt (fb : FIInt n). iInt @sum_t (minus_fii @m @n fa fb)
      ; iPosInfty. iNegInfty @sum_t
      ; iNegInfty. iPosInfty @sum_t
      }
  ; iPosInfty.
      case b of {
        iInt (fb : FIInt n). iPosInfty @sum_t
      ; iPosInfty. except @(IInt sum_t) -- Cannot add +inf and -inf
      ; iNegInfty. iPosInfty @sum_t
      }
  ; iNegInfty.
      case b of {
        iInt (fb : FIInt n). iNegInfty @sum_t
      ; iPosInfty. iNegInfty @sum_t
      ; iNegInfty. except @(IInt sum_t) -- Cannot add +inf and -inf
      }
  };


min_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (min_i m n) attribute(inline) =
  let type sum_t = min_i m n in
  case a of {
    iInt (fa : FIInt m).
      case b of {
        iInt (fb : FIInt n). iInt @sum_t (min_fii @m @n fa fb)
      ; iPosInfty.
          case fa of fiInt (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iNegInfty. iNegInfty @sum_t
      }
  ; iPosInfty.
      case b of {
        iInt (fb : FIInt n).
	  case fb of fiInt (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty. iPosInfty @sum_t
      ; iNegInfty. iNegInfty @sum_t
      }
  ; iNegInfty.
      iNegInfty @sum_t
  };


max_ii @(m n : intindex) (a : IInt m) (b : IInt n)
  -> IInt (max_i m n) attribute(inline) =
  let type sum_t = max_i m n in
  case a of {
    iInt (fa : FIInt m).
      case b of {
        iInt (fb : FIInt n). iInt @sum_t (max_fii @m @n fa fb)
      ; iNegInfty.
          case fa of fiInt (a_i : int). iInt @sum_t (fiInt @sum_t a_i)
      ; iPosInfty. iPosInfty @sum_t
      }
  ; iNegInfty.
      case b of {
        iInt (fb : FIInt n).
	  case fb of fiInt (b_i : int). iInt @sum_t (fiInt @sum_t b_i)
      ; iPosInfty. iPosInfty @sum_t
      ; iNegInfty. iNegInfty @sum_t
      }
  ; iPosInfty.
      iPosInfty @sum_t
  };


-- Determine if there are integers that are greater than or equal to @x@,
-- but less than @y@.
-- The result is False if @x == y@.
range_nonempty_ii @(m n : intindex) (x : IInt m) (y : IInt n) -> bool
  attribute(inline) =
  case x of {
    iInt (fx : FIInt m).
      case fx of fiInt (x_i : int).
      case y of {
        iInt (fy : FIInt n).
          case fy of fiInt (y_i : int).
          x_i <# y_i
      ; iPosInfty. True
      ; iNegInfty. False
      }
  ; iNegInfty.
      case y of {
        iNegInfty. False
      ; iInt (fy : FIInt n). True
      ; iPosInfty. True
      }
  ; iPosInfty. False
  };


gcd : int -> int -> int;
extgcd_x : int -> int -> int;

-- Test whether an interval is empty.
isEmptyInterval (iv : Interval) -> bool =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).
  case l of {
    justVal (ll : int).
      case u of {
        justVal (uu : int). ll ==# uu
      ; nothingVal. False
    }
  ; nothingVal. False
  };


-- Get the number of points in an interval.  Error if interval is not finite.
dim1Cardinality (d : dim1) -> int attribute(inline) =
  case d of mk_dim1 tyob (interval lb ub) (linearMap stride alignment).
  case lb of {
    justVal lb_i.
      case ub of {
        justVal ub_i.
          (ub_i -# lb_i) //# stride
      ; nothingVal.
          except @int
      }
  ; nothingVal.
      except @int
  };


-- Decide whether 'i' is in the interval.
inInterval (i : int) (iv : Interval) -> bool =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).

  -- Is 'i' within the lower bound?
  if case l of {
       nothingVal. True
     ; justVal (ll : int). i >=# ll
     }
  then -- Is 'i' within the upper bound?
       case u of {
         nothingVal. True
       ; justVal (uu : int). i <# uu
       }
  else False;


-- Compute the intersection of two intervals.
--
-- This must be inlined late (postfinal) so that looping code
-- gets optimized independently of the if-conditions in this
-- function.  Inlining too early introduces join points that
-- interfere with optimization.
intersectInterval (iv1 : Interval) (iv2 : Interval) -> Interval
  attribute(inline, inline_postfinal) =
  case iv1 of interval (l1 : MaybeVal int) (u1 : MaybeVal int).
  case iv2 of interval (l2 : MaybeVal int) (u2 : MaybeVal int).

  -- Lower bound is the maximum of the two bounds
  let l3 : MaybeVal int =
        case l1 of {
          nothingVal.
            l2
        ; justVal (ll1 : int).
            case l2 of {
              nothingVal.
                l1
            ; justVal (ll2 : int).
                justVal @int (maxI ll1 ll2)
            }
        } in

  -- Upper bound is the minimum of the two bounds
  let u3 : MaybeVal int =
        case u1 of {
          nothingVal.
            u2
        ; justVal (uu1 : int).
            case u2 of {
              nothingVal.
                u1
            ; justVal (uu2 : int).
                justVal @int (minI uu1 uu2)
            }
        } in
  case l3 of {
    justVal (x : int).
      case u3 of {
        justVal (y : int).
          if x ># y
          then interval (justVal @int 0) (justVal @int 0) -- Empty interval
          else interval l3 u3
      ; nothingVal.
          interval l3 u3
      }
  ; nothingVal.
      interval l3 u3
  };


-- Get an interval consisting of the points {x + y | x <- i1, y <- i2}.
convolveInterval (i1 : Interval) (i2 : Interval) -> Interval
  attribute(inline, inline_final) =

  case i1 of interval (lo1 : MaybeVal int) (hi1 : MaybeVal int).
  case i2 of interval (lo2 : MaybeVal int) (hi2 : MaybeVal int).

  -- If either input is empty, the result is empty
  if or (isEmptyInterval i1) (isEmptyInterval i2)
  then interval (justVal @int 0) (justVal @int 0) else

  -- Add the lower bounds
  let lo3 : MaybeVal int =
        case lo1 of {
          justVal (ilo1 : int).
            case lo2 of {
              justVal (ilo2 : int). justVal @int (ilo1 +# ilo2)
            ; nothingVal. nothingVal @int
            }
        ; nothingVal. nothingVal @int
        } in

  -- Add the upper bounds.  Since the upper bound is exclusive,
  -- we must subtract 1 from the result.
  let hi3 : MaybeVal int =
        case hi1 of {
          justVal (ihi1 : int).
            case hi2 of {
              justVal (ihi2 : int). justVal @int (ihi1 +# ihi2 -# 1)
            ; nothingVal. nothingVal @int
            }
        ; nothingVal. nothingVal @int
        } in
  interval lo3 hi3;


-- Test whether i1 is a subset of i2.
subsetInterval (i1 : Interval) (i2 : Interval) -> bool attribute(inline) =

  case i1 of interval (lo1 : MaybeVal int) (hi1 : MaybeVal int).
  case i2 of interval (lo2 : MaybeVal int) (hi2 : MaybeVal int).

  -- An empty interval is a subset of anything
  if isEmptyInterval i1 then True else

  -- Check that each bound of i1 is inside the bound of i2
  let lower_subset : bool =
        case lo2 of {
          justVal (ilo2 : int).
            case lo1 of {
              justVal (ilo1 : int). ilo1 >=# ilo2
            ; nothingVal. False
            }
        ; nothingVal. True
        } in
  let upper_subset : bool =
        case hi2 of {
          justVal (ihi2 : int).
            case hi1 of {
              justVal (ihi1 : int). ihi1 <=# ihi2
            ; nothingVal. False
            }
        ; nothingVal. True
        } in
  and lower_subset upper_subset;


-- Decide whether 'i' is a member of the linear map's range.
inLM (i : int) (m : LinearMap) -> bool =
  case m of linearMap (s : int) (a : int). (i %# s) ==# (a %# s);
  

-- Evaluate a linear map at 'i'. 
evalLM (i : int) (m : LinearMap) -> int =
  case m of linearMap (s : int) (a : int). s *# i +# a;


-- Evaluate the inverse of a linear map at 'i'.
-- The result is undefined if 'i' is not in the range of the map.
invEvalLM (i : int) (m : LinearMap) -> int =
  case m of linearMap (s : int) (a : int). (i -# a) //# s;


-- Compute the intersection of two linear maps.
-- If the intersection is empty, 'Nothing' is returned.
intersectLM (m1 : LinearMap) (m2 : LinearMap) -> MaybeVal LinearMap
  attribute(inline, inline_final) =
  case m1 of linearMap (s1 : int) (a1 : int).
  case m2 of linearMap (s2 : int) (a2 : int).

  -- Special case handling when stride is 1
  if s1 ==# 1 then justVal @LinearMap m2 else
  if s2 ==# 1 then justVal @LinearMap m1 else

  let g : int = gcd s1 s2 in
  let align_remainder : int = (a2 -# a1) %# g in
  let align_quot : int = (a2 -# a1) //# g in

  -- Check if intersection is empty
  if align_remainder /=# 0 then nothingVal @LinearMap else

  let s1p : int = s1 //# g in
  let s2p : int = s2 //# g in
  let s3 : int = s1p *# s2 in
  let yp : int = extgcd_x s1p s2p in
  let y : int = align_quot *# yp in
  let a3 : int = (s1 *# y +# a1) %# s3 in
  justVal @LinearMap (linearMap s3 a3);


trimInterval (iv : Interval) (m : LinearMap) -> Interval
  attribute(inline, inline_final) =
  case iv of interval (l : MaybeVal int) (u : MaybeVal int).
  case m of linearMap (s : int) (a : int).

  let l2 : MaybeVal int =
        case l of {
          nothingVal. nothingVal @int
        ; justVal (n : int). justVal @int (n +# (a -# n) %# s) 
        } in
  let u2 : MaybeVal int =
        case u of {
          nothingVal. nothingVal @int
        ; justVal (n : int). justVal @int (n +# (a -# n) %# s) 
        } in
  interval l2 u2;


internalApplyListSlice (slice_obj : SliceObject) (dom : list_dim)
  -> (list_dim, LinearMap)
  attribute(inline, inline_final) =
  case slice_obj of sliceObject m_slice_lo m_slice_hi m_m_stride.
  case dom of mk_list_dim tyob (list_size : MaybeVal int).
  let stride : int =
        case m_m_stride of {
          nothingVal. 1
        ; justVal (m_stride : MaybeVal int).
            case m_stride of {
              nothingVal. 1
            ; justVal (stride : int). stride
            }
        } in
  if stride ==# 0 then except @(list_dim, LinearMap) else
  let counting_up : bool = stride ># 0 in

  -- Get the slice's inclusive lower bound.
  -- There must be a lower bound, determined either by the slice or the
  -- list domain.
  let slice_lo : int =
        if counting_up
        then case m_slice_lo of {
               nothingVal. 0
             ; justVal (l : int). maxI 0 l
             }
        else case m_slice_lo of {
               justVal (h : int).
                 case list_size of {
                   justVal (n : int). minI h (n -# 1)
                 ; nothingVal. h
                 }
             ; nothingVal.
                 case list_size of {
                   justVal (n : int). n -# 1
                 ; nothingVal. except @int
                 }
             } in

  -- Get the slice's exclusive upper bound.
  let slice_hi : MaybeVal int =
        if counting_up
        then case m_slice_hi of {
               nothingVal.
                 list_size
             ; justVal (h : int).
                 case list_size of {
                   nothingVal. justVal @int h
                 ; justVal (n : int). justVal @int (minI h n)
                 }
             }
        else case m_slice_hi of {
               nothingVal. justVal @int -1
             ; justVal (h : int). justVal @int (maxI h -1)
             } in

  -- If the slice is nonempty, this is the map from slice member to list member
  let linear_map : LinearMap = linearMap stride slice_lo in

  -- Compute the new list size, which may be unbounded
  let size : MaybeVal int =
        case slice_hi of {
          nothingVal. nothingVal @int
        ; justVal (h : int).
            let abs_stride : int = if counting_up
                                   then stride
                                   else negI stride in

            let abs_delta : int =
                  let delta : int = h -# slice_lo in
                  if delta <# 0
                  then negI delta
                  else delta in

            justVal @int ((abs_delta +# abs_stride -# 1) //# abs_stride)
        } in
  case size of {
    justVal (n : int).
      if n <# 0
      then (con_list_dim (justVal @int 0), linearMap 0 0)
      else (con_list_dim size, linear_map)
  ; nothingVal. (con_list_dim size, linear_map)
  };


sliceToDomain (slice_obj : SliceObject) -> dim1
  attribute(inline, inline_final) =
  case slice_obj of
    sliceObject (m_slice_lo : MaybeVal int)
                (m_slice_hi : MaybeVal int)
                (m_m_stride : MaybeVal (MaybeVal int)).
  let stride : int =
        case m_m_stride of {
          nothingVal. 1
        ; justVal (m_stride : MaybeVal int).
            case m_stride of {
              nothingVal. 1
            ; justVal (stride : int). stride
            }
        } in
  let alignment : int =
        case m_slice_lo of {
          nothingVal. 0
        ; justVal (n : int). n %# stride
        } in

  -- Stride must be positive
  if stride <=# 0 then except @dim1 else

  let map : LinearMap = linearMap stride alignment in
  let iv : Interval = trimInterval (interval m_slice_lo m_slice_hi) map in
  con_dim1 iv map;


internalApplyArraySlice (slice_obj : SliceObject) (dom : dim1) -> dim1 =
  let slice_dom : dim1 = sliceToDomain slice_obj in
  real_intersect_dim1 slice_dom dom;


-- Pick the most restrictive parallelism hint
leastParHint (x y : ParHint) -> ParHint =
  case x of {
    hintAny. y
  ; hintSeq. x
  ; hintLocalPar.
      case y of {
        hintAny. hintLocalPar
      ; hintSeq. hintSeq
      ; hintLocalPar. hintLocalPar
      ; hintPar. hintLocalPar
      }
  ; hintPar.
      case y of {
        hintAny. hintPar
      ; hintSeq. hintSeq
      ; hintLocalPar. hintLocalPar
      ; hintPar. hintPar
      }
  };

-- Create a parallelism hint for an inner loop.
-- This returns a smaller-scale level of parallelism than was given in the
-- argument.
innerLoopParHint (x : ParHint) -> ParHint =
  case x of {
    hintAny.      hintSeq
  ; hintSeq.      hintSeq
  ; hintLocalPar. hintSeq
  ; hintPar.      hintLocalPar
  };

-------------------------------------------------------------------------------
-- Coercions

-- Construct an identity coercion.  This function is safe.
idCoercion @(a : box) -> coerce @box a a attribute(inline, builtin) =
  makeIdCoercion @a None;

idBareCoercion @(a : bare) -> coerce @bare a a attribute(inline) =
  makeIdBareCoercion @a None;

makeIdCoercion : forall a : box. NoneType -> coerce @box a a;
makeIdBareCoercion : forall a : bare. NoneType -> coerce @bare a a;

-- The type functions 'index' and 'cartesianDomain' are inverses where
-- they are defined.
cartesianIndexCoercion : forall sh : box.
                         coerce @box (cartesianDomain (index sh)) sh;

-- Construct a coercion.  This function is unsafe.
unsafeMakeCoercion : forall a b : box. coerce @box a b;

-- Construct a coercion.  This function is unsafe.
unsafeMakeBareCoercion : forall a b : bare. coerce @bare a b;

-- Construct a coercion.  This function is unsafe.
unsafeMakeViewCoercion : forall d : box.
                         coerce @(bare -> box) (Stream d) (view d);

-------------------------------------------------------------------------------
-- Debugging

traceInt_int : int -> int -> int;
traceInt_box : forall a : box. int -> a -> a;

-------------------------------------------------------------------------------
-- Domain functions

fun_list_dim (size : Maybe (Stored int)) -> list_dim
  attribute(inline) =
  con_list_dim (case size of [reprSizeAlign @(Stored int) repr_int] {
                  just (stored i). justVal @int i
                ; nothing. nothingVal @int
                });


fun_dim1 (lo_bound : Maybe (Stored int)) (hi_bound : Maybe (Stored int))
         (stride : int) (alignment : int) -> dim1
  attribute(inline) =

  letfun
    cvt_Maybe (x : Maybe (Stored int)) -> MaybeVal int =
      case x of [reprSizeAlign @(Stored int) repr_int] {
        just (si : Stored int).
          case si of stored i. justVal @int i
      ; nothing.
          nothingVal @int
      } in

  if stride <=# 0 then except @dim1 else

  -- Create an interval from the given bounds.  If the low bound is
  -- greater than the high bound, use an empty interval.
  let iv : Interval =
        case lo_bound of [reprSizeAlign @(Stored int) repr_int] {
          just (lb : Stored int).
            case lb of stored lb_i.
            case hi_bound of [reprSizeAlign @(Stored int) repr_int] {
              just (ub : Stored int).
                case ub of stored ub_i.
                if lb_i ># ub_i
                then interval (justVal @int 0) (justVal @int 0)
                else interval (justVal @int lb_i) (justVal @int ub_i)
            ; nothing.
                interval (justVal @int lb_i) (nothingVal @int)
            }
        ; nothing.
          case hi_bound of [reprSizeAlign @(Stored int) repr_int] {
            just (ub : Stored int).
              case ub of stored ub_i.
              interval (nothingVal @int) (justVal @int ub_i)
          ; nothing.
              interval (nothingVal @int) (nothingVal @int)
          }
        } in
  let m : LinearMap = linearMap stride (alignment %# stride) in
  con_dim1 (trimInterval iv m) m;


make_sliceObject
  (has_lower : Boxed (Stored bool))
  (lower : Boxed (Stored int))
  (has_upper : Boxed (Stored bool))
  (upper : Boxed (Stored int))
  (has_has_stride : Boxed (Stored bool))
  (has_stride : Boxed (Stored bool))
  (stride : Boxed (Stored int))
  -> Boxed SliceObject
  attribute(inline) =

  con_boxed @SliceObject
  (unboxedinfo SliceObject)
  (sliceObject
   (if unboxBoolValue has_lower
    then justVal @int (unboxIntValue lower)
    else nothingVal @int)
   (if unboxBoolValue has_upper
    then justVal @int (unboxIntValue upper)
    else nothingVal @int)
   (if unboxBoolValue has_has_stride
    then justVal @(MaybeVal int)
         (if unboxBoolValue has_stride
          then justVal @int (unboxIntValue stride)
          else nothingVal @int)
    else nothingVal @(MaybeVal int)));


-------------------------------------------------------------------------------
-- Stream consumers

{-
reduce_list_dim @(a : bare)
  (rep : Repr a)
  (f : a -> a -> Init a)
  (init : a)
  (vw : view list_dim (AsBox a))
  -> Init a
  attribute(inline, inline_dimensionality) =
  case vw of mk_view tyob (dom : list_dim) gen.

  letfun
    gen2 (x : Stored int) (ret : OutPtr a) -> Store =
      case x of stored ux. asbare @a rep (gen (boxIntValue ux)) ret
  in

  primitive_list_dim_reduce @a rep dom gen2 f init;


reduce1_list_dim @(a : bare)
  (rep : Repr a)
  (f : a -> a -> Init a)
  (vw : view list_dim (AsBox a))
  -> Init a
  attribute(inline, inline_dimensionality) =
  case vw of mk_view tyob (dom : list_dim) gen.

  letfun
    gen2 (x : Stored int) (ret : OutPtr a) -> Store =
      case x of stored ux. asbare @a rep (gen (boxIntValue ux)) ret
  in

  primitive_list_dim_reduce1 @a rep dom gen2 f;


reduce_dim1 : forall a : bare.
    Repr a
  -> (a -> a -> Init a)
  -> a
  -> view dim1 (AsBox a)
  -> Init a;

scatter_dim1 : forall i r : bare.
               Repr i -> Repr r -> Scatter r i -> view dim1 (AsBox i) -> Init r;

reduce1_dim1 : forall a : bare.
     Repr a
  -> (a -> a -> Init a)
  -> view dim1 (AsBox a)
  -> Init a;

scatter_list_dim @(i r : bare)
  (repr_i : Repr i)
  (repr_r : Repr r)
  (op : Scatter r i)
  (src : view list_dim (AsBox i))
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_dimensionality) =

  case src of mk_view (dom : list_dim) gen.

  letfun
    gen2 (x : Stored int) (ret : OutPtr i) -> Store =
      case x of stored ux. asbare @i repr_i (gen (boxIntValue ux)) ret
  in

  primitive_list_dim_scatter @i @r repr_i repr_r dom op gen2 ret;
-}

permute1D_list_dim @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (vw : view list_dim (Boxed (Tuple2 (Stored int) a)))
  (ret : OutPtr (array1 a))
  -> Store
  attribute(inline) =

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        unboxedinfo Tuple2 @(Stored int) @a repr_int rep in

  let rep_array : Repr (array1 a) = unboxedinfo array1 @a in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  -- Create an array of the given size
  case dim1ToArraySize dom of arraySize @(N : intindex) lb stride count.
  case count of fiInt (count_int : int).

  mk_array1 @a @N lb stride count
  (con_stuckBox @(arr N a) (unboxedinfo arr @N @a count rep)

   (\ (ret : OutPtr (arr N a)) -> Store.

    -- Loop over the inputs
    case vw of mk_view tyob (mk_list_dim tyob2 msize) gen.
    case msize of {
      justVal (size : int).
        case defineIntIndex size of
          someIInt @(M : intindex) (count : FIInt M).

        -- For each input value
        doall @M count
        (\ (i : int) -> Store.

           -- Get a value
           case gen (boxIntValue i) of [reprSizeAlign @(Tuple2 (Stored int) a) rep_tuple]
             boxed tyob ([sa_int, reprSizeAlign @a rep] tuple2 (stored ix) val).

           -- Convert to real index
           let offset_index : int = ix -# lb in
           let real_index : int = offset_index //# stride in

           -- Check bounds
           if offset_index %# stride /=# 0 then except @Store else
           if or (real_index <# 0) (real_index >=# count_int) then except @Store else

           -- Write it to the output
           copy @a rep val
           (subscript_out @N @a (reprSizeAlign @a rep) ret real_index))
    ; nothingVal.
        except @Store
    }))
  ret;


boxedPermute1D_list_dim @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (vw : view list_dim (Boxed (Tuple2 (Stored int) a)))
  (ret : OutPtr (barray1 a))
  -> Store
  attribute(inline) =

  let type Boxed_a = StuckRef (AsBox a) in

  let rep_Ref : Repr (StuckRef (AsBox a)) = repr_StuckRef @(AsBox a) in

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        unboxedinfo Tuple2 @(Stored int) @a repr_int rep in

  -- Create an array of the given size
  case dim1ToArraySize dom of arraySize @(N : intindex) lb stride count.
  case count of fiInt (count_int : int).

  let rep_arr = unboxedinfo arr @N @Boxed_a count rep_Ref in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  mk_barray1 @a
  (mk_array1 @Boxed_a @N lb stride count
   (con_stuckBox @(arr N Boxed_a) rep_arr

    (\ (ret : OutPtr (arr N Boxed_a)) -> Store.

     -- Loop over the inputs
     case vw of mk_view tyob (mk_list_dim tyob2 msize) gen.
     case msize of {
       justVal (size : int).
         case defineIntIndex size of
           someIInt @(M : intindex) (count : FIInt M).

         -- For each input value
         doall @M count
         (\ (i : int) -> Store.
            -- Get a value
            case gen (boxIntValue i) of [reprSizeAlign @(Tuple2 (Stored int) a) rep_tuple]
              boxed tyob ([sa_int, reprSizeAlign @a rep] tuple2 (stored ix) val).

            -- Convert to real index
            let offset_index : int = ix -# lb in
            let real_index : int = offset_index //# stride in

            -- Check bounds
            if offset_index %# stride /=# 0 then except @Store else
            if or (real_index <# 0) (real_index >=# count_int) then except @Store else

            -- Write it to the output
            stuckRef @(AsBox a)
            (asbox @a rep (copy @a rep val))
            (subscript_out @N @Boxed_a (reprSizeAlign @Boxed_a rep_Ref) ret real_index))
     ; nothingVal.
         except @Store
     })))
  ret;


{-
fold_list_dim @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Init acc)
  (init : acc)
  (vw : view list_dim (AsBox a))
  (ret : OutPtr acc)
  -> Store
  attribute(inline, inline_dimensionality) =

  case vw of mk_view tyob (dom : list_dim) g.

  primitive_list_dim_fold @acc repr_acc dom
  (\ (ix : index list_dim) (x : acc) (ret : OutPtr acc) -> Store.
     case ix of stored u_ix.
     f x (boxToBare @a repr_a (g (boxIntValue u_ix))) ret)
  init
  ret;

fold_dim1 : forall a acc : bare.
            Repr a -> Repr acc
         -> (acc -> a -> Init acc)
         -> acc
         -> view dim1 (AsBox a)
         -> Init acc;

reduce_dim2 : forall a : bare.
     Repr a
  -> (a -> a -> Init a)
  -> a
  -> view dim2 (AsBox a)
  -> Init a;

reduce1_dim2 : forall a : bare.
     Repr a
  -> (a -> a -> Init a)
  -> view dim2 (AsBox a)
  -> Init a;

scatter_dim2 : forall i r : bare.
               Repr i -> Repr r -> Scatter r i -> view dim2 (AsBox i) -> Init r;

fold_dim2 : forall a acc : bare.
            Repr a -> Repr acc
         -> (acc -> a -> Init acc)
         -> acc
         -> view dim2 (AsBox a)
         -> Init acc;
-}

-------------------------------------------------------------------------------
-- Stream and Traversable dictionary-like internal methods

{- REPLACED BY NEW STREAM CODE
view_generate @(sh : box) (shape_dict : ShapeDict sh)
  -> forall a : box. Repr (AsBare a) -> sh -> (AsBox (index sh) -> a) -> view sh a
  attribute(inline, inline_dimensionality) =

  \ @(a : box) (rep : Repr (AsBare a)) (dom : sh) (f : AsBox (index sh) -> a)
    -> view sh a.
    con_view @sh @a dom f;


view_map @(sh : box) (shape_dict : ShapeDict sh)
  -> forall a b : box. Repr (AsBare a) -> Repr (AsBare b)
  -> (a -> b) -> view sh a -> view sh b
  attribute(inline, inline_dimensionality) =

  \ @(a b : box) (rep_a : Repr (AsBare a)) (rep_b : Repr (AsBare b))
    (t : a -> b) (s1 : view sh a) -> view sh b.

    case s1 of mk_view tyob (d : sh) (f : AsBox (index sh) -> a).
    con_view @sh @b d
    (\ (ix : AsBox (index sh)) -> b. t (f ix));


view_zipWith @(sh : box)
  (shape_dict : ShapeDict sh)
  -> forall a b c : box. Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) ->
     (a -> b -> c) ->
     view sh a ->
     view sh b ->
     view sh c
  attribute(inline, inline_dimensionality) =

  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten
    shape_generate shape_map shape_zipWith shape_zipWith3 shape_zipWith4
    shape_slice.

  \ @(a b c : box) (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b)) (repr_c : Repr (AsBare c))
     (t : a -> b -> c)
     (sa : view sh a)
     (sb : view sh b)
     -> view sh c.
    case sa of mk_view tyob (dA : sh) fA.
    case sb of mk_view tyob (dB : sh) fB.
    let dC : sh = shape_intersect dA dB in
    con_view @sh @c dC
    (\ (ix : AsBox (index sh)) -> c. t (fA ix) (fB ix));


view_zipWith3 @(sh : box)
  (shape_dict : ShapeDict sh)
  -> forall a b c d : box. Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) -> Repr (AsBare d) ->
     (a -> b -> c -> d) ->
     view sh a ->
     view sh b ->
     view sh c ->
     view sh d
  attribute(inline, inline_dimensionality) =

  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten
    shape_generate shape_map shape_zipWith shape_zipWith3 shape_zipWith4
    shape_slice.

  \ @(a b c d : box) (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b)) (repr_c : Repr (AsBare c)) (repr_d : Repr (AsBare d))
     (t : a -> b -> c -> d)
     (sa : view sh a)
     (sb : view sh b)
     (sc : view sh c)
     -> view sh d.
    case sa of mk_view tyob (dA : sh) fA.
    case sb of mk_view tyob (dB : sh) fB.
    case sc of mk_view tyob (dC : sh) fC.
    let dD : sh = shape_intersect (shape_intersect dA dB) dC in
    con_view @sh @d dD
    (\ (ix : AsBox (index sh)) -> d. t (fA ix) (fB ix) (fC ix));


view_zipWith4 @(sh : box)
  (shape_dict : ShapeDict sh)
  -> forall a b c d e : box. Repr (AsBare a) -> Repr (AsBare b) -> Repr (AsBare c) -> Repr (AsBare d) -> Repr (AsBare e) ->
     (a -> b -> c -> d -> e) ->
     view sh a ->
     view sh b ->
     view sh c ->
     view sh d ->
     view sh e
  attribute(inline, inline_dimensionality) =

  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten
    shape_generate shape_map shape_zipWith shape_zipWith3 shape_zipWith4
    shape_slice.

  \ @(a b c d e : box)
     (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b)) (repr_c : Repr (AsBare c)) (repr_d : Repr (AsBare d)) (repr_e : Repr (AsBare e))
     (t : a -> b -> c -> d -> e)
     (sa : view sh a)
     (sb : view sh b)
     (sc : view sh c)
     (sd : view sh d)
     -> view sh e.
    case sa of mk_view tyob (dA : sh) fA.
    case sb of mk_view tyob (dB : sh) fB.
    case sc of mk_view tyob (dC : sh) fC.
    case sd of mk_view tyob (dD : sh) fD.
    let dE : sh =
          shape_intersect (shape_intersect (shape_intersect dA dB) dC) dD in
    con_view @sh @e dE
    (\ (ix : AsBox (index sh)) -> e. t (fA ix) (fB ix) (fC ix) (fD ix));



Sequence_flatten : forall a : bare. Repr a -> Sequence (AsBox a) -> Stream dim1 (AsBox a);

Sequence_generate @(a : bare)
  (rep : Repr a) (size : list_dim) (f : index list_dim -> Init a)
  -> Sequence (AsBox a)
  attribute(inline, inline_final) =

  let type Sint = Stored int in
  let type st = Boxed (Stored int) in
  case size of mk_list_dim tyob (m_list_size : MaybeVal int).
  case m_list_size of {
    justVal (list_size : int).
      -- Finite stream
      letfun
        next (state : st) -> StreamNext st (AsBox a) =
	  case state of [reprSizeAlign @Sint repr_int]
            boxed tyob (state_s : Sint).
	  case state_s of stored (state_u : int).
	  if state_u <# list_size
	  then let next_value : AsBox a =
	             asbox @a rep (f state_s) in
	       let next_state = boxIntValue (state_u +# 1) in
	       streamValue @st @(AsBox a) next_state next_value
	  else streamEmpty @st @(AsBox a)
      in
      con_sequence @(AsBox a) @st (boxIntValue 0) next

  ; nothingVal.
      -- Infinite stream
      letfun
        next (state : st) -> StreamNext st (AsBox a) =
	  case state of [reprSizeAlign @Sint repr_int]
            boxed tyob (state_s : Stored int).
	  case state_s of stored (state_u : int).
	  let next_value : AsBox a =
	        asbox @a rep (f state_s) in
	  let next_state = boxIntValue (state_u +# 1) in
	  streamValue @st @(AsBox a) next_state next_value
      in
      con_sequence @(AsBox a) @st (boxIntValue 0) next
  };


Sequence_from_llist @(a : bare) (rep : Repr a) (l : llist a)
  -> Sequence (AsBox a) attribute(inline, inline_final) =
  con_sequence @(AsBox a) @(llist a) l
  (\ (l : llist a) -> StreamNext (llist a) (AsBox a).
     case l of [reprSizeAlign @a rep] {
       cons tyob (h : a) (t : llist a).
         streamValue @(llist a) @(AsBox a) t (asbox @a rep (copy @a rep h))
     ; nil tyob. streamEmpty @(llist a) @(AsBox a)
     });


Sequence_map @(a b : bare) (repr_a : Repr a) (repr_b : Repr b)
          (transformer : a -> Init b) (sq : Sequence (AsBox a))
  -> Sequence (AsBox b)
  attribute(inline, inline_final) =
  case sq of sequence @st tyob state next.

  letfun
    go (state : st) -> StreamNext st (AsBox b) =
      case next state of {
        streamValue (next_state : st) (value : AsBox a).
          let output_value : AsBox b =
		asbox @b repr_b (transformer (boxToBare @a repr_a value))
          in streamValue @st @(AsBox b) next_state output_value;

        streamEmpty.
          streamEmpty @st @(AsBox b)
      }
  in con_sequence @(AsBox b) @st state go;


Sequence_zipWith
  @(a b c : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c)
  (transformer : a -> b -> Init c)
  (sqA : Sequence (AsBox a))
  (sqB : Sequence (AsBox b))
  -> Sequence (AsBox c)
  attribute(inline, inline_final) =

  case sqA of sequence @(st_a : box) tyob state_a next_a.
  case sqB of sequence @(st_b : box) tyob state_b next_b.

  let type st_c = Tuple2 (StuckRef st_a) (StuckRef st_b) in
  let rep_st_c = unboxedinfo Tuple2 @(StuckRef st_a) @(StuckRef st_b)
                 (unboxedinfo StuckRef @st_a) (unboxedinfo StuckRef @st_b) in
  letfun
    go (state : Boxed st_c) -> StreamNext (Boxed st_c) (AsBox c) =
      -- Unpack the state
      case unpack_Tuple2_box @st_a @st_b state of (state_a, state_b).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue (next_state_a : st_a) (value_a : AsBox a).
          
	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue (next_state_b : st_b) (value_b : AsBox b).

	      -- Create output value
	      let value : AsBox c =
		    asbox @c repr_c
                    (transformer (boxToBare @a repr_a value_a)
                                 (boxToBare @b repr_b value_b)) in
	      let next_state : Boxed st_c =
                    pack_Tuple2_box @st_a @st_b next_state_a next_state_b in
	      streamValue @(Boxed st_c) @(AsBox c) next_state value;

	    streamEmpty.
	      streamEmpty @(Boxed st_c) @(AsBox c)
          };

	streamEmpty.
	  streamEmpty @(Boxed st_c) @(AsBox c)
      }
  in con_sequence @(AsBox c) @(Boxed st_c)
     (pack_Tuple2_box @st_a @st_b state_a state_b)
     go;


Sequence_zipWith3
  @(a b c d : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d)
  (transformer : a -> b -> c -> Init d)
  (sqA : Sequence (AsBox a))
  (sqB : Sequence (AsBox b))
  (sqC : Sequence (AsBox c))
  -> Sequence (AsBox d)
  attribute(inline, inline_final) =
  case sqA of sequence @(st_a : box) tyob state_a next_a.
  case sqB of sequence @(st_b : box) tyob state_b next_b.
  case sqC of sequence @(st_c : box) tyob state_c next_c.

  let type st_d = Tuple3 (StuckRef st_a) (StuckRef st_b) (StuckRef st_c) in
  let rep_st_d = unboxedinfo Tuple3
                 @(StuckRef st_a) @(StuckRef st_b) @(StuckRef st_c)
                 (unboxedinfo StuckRef @st_a)
                 (unboxedinfo StuckRef @st_b)
                 (unboxedinfo StuckRef @st_c) in

  letfun
    go (state : Boxed st_d) -> StreamNext (Boxed st_d) (AsBox d) =
      case unpack_Tuple3_box @st_a @st_b @st_c state
        of (state_a, state_b, state_c).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue (next_state_a : st_a) (value_a : AsBox a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue (next_state_b : st_b) (value_b : AsBox b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue (next_state_c : st_c) (value_c : AsBox c).

                  -- Create output value
                  let value : AsBox d =
                        asbox @d repr_d
                        (transformer
                         (boxToBare @a repr_a value_a)
                         (boxToBare @b repr_b value_b)
                         (boxToBare @c repr_c value_c)) in
                  let next_state : Boxed st_d =
                        pack_Tuple3_box @st_a @st_b @st_c next_state_a next_state_b next_state_c in
                  streamValue @(Boxed st_d) @(AsBox d) next_state value;

                  streamEmpty.
                    streamEmpty @(Boxed st_d) @(AsBox d)
                };

              streamEmpty.
                streamEmpty @(Boxed st_d) @(AsBox d)
            };

        streamEmpty.
          streamEmpty @(Boxed st_d) @(AsBox d)
      }
  in con_sequence @(AsBox d) @(Boxed st_d)
       (pack_Tuple3_box @st_a @st_b @st_c state_a state_b state_c)
       go;


Sequence_zipWith4
  @(a b c d e : bare)
  (repr_a : Repr a) (repr_b : Repr b) (repr_c : Repr c) (repr_d : Repr d) (repr_e : Repr e)
  (transformer : a -> b -> c -> d -> Init e)
  (sqA : Sequence (AsBox a))
  (sqB : Sequence (AsBox b))
  (sqC : Sequence (AsBox c))
  (sqD : Sequence (AsBox d))
  -> Sequence (AsBox e)
  attribute(inline, inline_final) =
  case sqA of sequence @(st_a : box) tyob state_a next_a.
  case sqB of sequence @(st_b : box) tyob state_b next_b.
  case sqC of sequence @(st_c : box) tyob state_c next_c.
  case sqD of sequence @(st_d : box) tyob state_d next_d.

  let type st_e = Tuple4 (StuckRef st_a) (StuckRef st_b) (StuckRef st_c) (StuckRef st_d) in
  let rep_st_e = unboxedinfo Tuple4
                 @(StuckRef st_a) @(StuckRef st_b) @(StuckRef st_c) @(StuckRef st_d)
                 (unboxedinfo StuckRef @st_a)
                 (unboxedinfo StuckRef @st_b)
                 (unboxedinfo StuckRef @st_c)
                 (unboxedinfo StuckRef @st_d) in
  
  letfun
    go (state : Boxed st_e) -> StreamNext (Boxed st_e) (AsBox e) =
      case unpack_Tuple4_box @st_a @st_b @st_c @st_d state
        of (state_a, state_b, state_c, state_d).

      -- Get next value of stream A
      case next_a state_a of {
        streamValue (next_state_a : st_a) (value_a : AsBox a).

	  -- Get next value of stream B
	  case next_b state_b of {
            streamValue (next_state_b : st_b) (value_b : AsBox b).

              -- Get next value of stream C
              case next_c state_c of {
                streamValue (next_state_c : st_c) (value_c : AsBox c).

                  -- Get next value of stream D
                  case next_d state_d of {
                    streamValue (next_state_d : st_d) (value_d : AsBox d).

                      -- Create output value
                      let value : AsBox e =
                            asbox @e repr_e
                            (transformer
                             (boxToBare @a repr_a value_a)
                             (boxToBare @b repr_b value_b)
                             (boxToBare @c repr_c value_c)
                             (boxToBare @d repr_d value_d)) in
                      let next_state : Boxed st_e =
                            pack_Tuple4_box @st_a @st_b @st_c @st_d
                            next_state_a next_state_b next_state_c next_state_d in
                      streamValue @(Boxed st_e) @(AsBox e) next_state value;

                      streamEmpty.
                        streamEmpty @(Boxed st_e) @(AsBox e)
                    };

                  streamEmpty.
                    streamEmpty @(Boxed st_e) @(AsBox e)
                };

              streamEmpty.
                streamEmpty @(Boxed st_e) @(AsBox e)
            };

        streamEmpty.
          streamEmpty @(Boxed st_e) @(AsBox e)
      }
  in con_sequence @(AsBox e) @(Boxed st_e)
       (pack_Tuple4_box @st_a @st_b @st_c @st_d
                            state_a state_b state_c state_d)
       go;

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Sequence operations

--view1_fold : forall a acc : bare.
--          -> Repr a -> Repr acc
--          -> (acc -> a -> Init acc) -> acc -> view list_dim a
--          -> Init acc;

{- REPLACED BY NEW STREAM CODE

Sequence_reduce @(a : bare)
  (rep : Repr a)
  (f : a -> a -> Init a)
  (init : a)
  (sq : Sequence (AsBox a))
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  Sequence_fold @a @a rep rep f init sq ret;


Sequence_reduce1 @(a : bare)
  (rep : Repr a)
  (f : a -> a -> Init a)
  (sq : Sequence (AsBox a))
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  -- Use the stream's first element as the initial value
  case sq of sequence @(st : box) tyob state next.

  case next state of {
    streamValue (next_state : st) (init : AsBox a).
      let u_init = boxToBare @a rep init in
      let new_sequence = con_sequence @(AsBox a) @st next_state next in
      Sequence_fold @a @a rep rep f u_init new_sequence ret;

    streamEmpty.
      except @Store
  };

{-
Sequence_scatter @(i r : bare)
  (repr_i : Repr i)
  (repr_r : Repr r)
  (op : Scatter r i)
  (src : Sequence (AsBox i))
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_sequential) =

  case op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (make_updater : i -> updF)
    (make_init : iniF).

  finish_scatter @r @s repr_r repr_s finalizer
  (Sequence_partial_scatter @i @s @iniF @updF
   repr_i repr_s initializer updater make_updater make_init src)
  ret;

Sequence_permute1D @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (s : Sequence (AsBox (Tuple2 (Stored int) a)))
  (ret : OutPtr (array1 a))
  -> Store
  attribute(inline, inline_final) =

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        repr_Tuple2 @(Stored int) @a repr_int rep in

  let rep_array : Repr (array1 a) = repr_array1 @a in

  let type SEffTok = Stored EffTok in

  -- Create an array of the given size
  case dim1ToArraySize dom of arraySize @(N : intindex) lb stride size.
  case size of fiInt (size_int : int).

  mk_array1 @a @N lb stride size
  (stuckBox @(arr N a)

   (\ (ret : OutPtr (arr N a)) -> Store.

    -- Loop over the inputs
    case boxed @SEffTok (stored @EffTok emptyEffTok) of boxed eff_tok_in.

    case boxed @SEffTok
         (Sequence_fold @(Tuple2 (Stored int) a) @SEffTok
          rep_tuple repr_EffTok
          (\ (acc : SEffTok) (x : Tuple2 (Stored int) a)
             (eff_ret : OutPtr SEffTok)
             -> Store.

             case x of tuple2 (s_index : Stored int) (val : a).
             case s_index of stored ix.

             -- Convert to real index
             let offset_index : int = ix -# lb in
             let real_index : int = offset_index //# stride in

             -- Check bounds
             if offset_index %# stride /=# 0 then except @Store else
             if or (real_index <# 0) (real_index >=# size_int) then except @Store else

             -- Store it
             case acc of stored (u_acc : EffTok).
             let new_acc : Store =
                   seqStore u_acc
                   (copy @a rep val
                    (subscript_out @N @a (reprSizeAlign @a rep) ret real_index)) in
             stored @Store new_acc eff_ret)
          eff_tok_in s) of
      boxed eff_tok_out.

    case eff_tok_out of stored tok.
    fromEffTok @(arr N a) tok))
  ret;


Sequence_boxedPermute1D @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (s : Sequence (AsBox (Tuple2 (Stored int) a)))
  (ret : OutPtr (barray1 a))
  -> Store
  attribute(inline, inline_final) =

  let type Boxed_a = StuckRef (AsBox a) in

  let rep_Ref : Repr Boxed_a = repr_StuckRef @(AsBox a) in

  let rep_tuple : Repr (Tuple2 (Stored int) a) =
        repr_Tuple2 @(Stored int) @a repr_int rep in

  let type SEffTok = Stored EffTok in

  -- Create an array of the given size
  case dim1ToArraySize dom of arraySize @(N : intindex) lb stride size.
  case size of fiInt (size_int : int).

  mk_barray1 @a
  (mk_array1 @Boxed_a @N lb stride size
   (stuckBox @(arr N Boxed_a)

    (\ (ret : OutPtr (arr N Boxed_a)) -> Store.

     -- Loop over the inputs
     case boxed @SEffTok (stored @EffTok emptyEffTok) of boxed eff_tok_in.

     case boxed @SEffTok
          (Sequence_fold @(Tuple2 (Stored int) a) @SEffTok
           rep_tuple repr_EffTok
           (\ (acc : SEffTok) (x : Tuple2 (Stored int) a)
              (eff_ret : OutPtr SEffTok)
              -> Store.

              case x of tuple2 (s_index : Stored int) (val : a).
              case s_index of stored ix.

              -- Convert to real index
              let offset_index : int = ix -# lb in
              let real_index : int = offset_index //# stride in

              -- Check bounds
              if offset_index %# stride /=# 0 then except @Store else
              if or (real_index <# 0) (real_index >=# size_int) then except @Store else

              -- Store it
              case acc of stored (u_acc : EffTok).
              let new_acc : EffTok =
                    seqEffTok u_acc
                    (toEffTok @Boxed_a
                     (stuckRef @(AsBox a)
                      (asbox @a rep (copy @a rep val))
                      (subscript_out @N @Boxed_a (reprSizeAlign @Boxed_a rep_Ref) ret real_index))) in
              stored @EffTok new_acc eff_ret)
           eff_tok_in s) of
       boxed eff_tok_out.

     case eff_tok_out of stored tok.
     fromEffTok @(arr N Boxed_a) tok)))
  ret;

-}

Sequence_fold @(a acc : bare)
  (repr_a : Repr a)
  (repr_acc : Repr acc)
  (f : acc -> a -> Init acc)
  (init : acc)
  (src : Sequence (AsBox a))
  (ret : OutPtr acc)
  -> Store
  attribute(inline, inline_final) =
  case src of sequence @(st : box) tyob state next.

  letfun
    go (state : st) (accumulator : AsBox acc) (ret : OutPtr acc)
      -> Store =
      case next state of {

        -- Obtain value from stream
        streamValue (next_state : st) (result : AsBox a).
          -- Compute the new value
          let new_accumulator : AsBox acc =
                asbox @acc repr_acc
                (f (boxToBare @acc repr_acc accumulator) (boxToBare @a repr_a result))

          in go next_state new_accumulator ret;

	-- Stream is depleted
	streamEmpty.
	  asbare @acc repr_acc accumulator ret
      }
  in go state (asbox @acc repr_acc (copy @acc repr_acc init)) ret;


Sequence_parallel_reduce @(a : bare)
  (rep : Repr a)
  (dom : list_dim)
  (f : a -> a -> Init a)
  (init : a)
  (g : Stored int -> Sequence (AsBox a))
  (ret : OutPtr a)
  -> Store =
  case dom of mk_list_dim tyob (list_size : MaybeVal int).
  case list_size of {
    justVal (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type b = AsBox a in
      letfun
        combiner (x : b) (y : b) -> b =
          asbox @a rep (f (boxToBare @a rep x) (boxToBare @a rep y))
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =

          -- Reduce over the sequence [lb, lb + count)
          let acc = boxToBare @a rep acc_in in
          case count of fiInt (count_i : int).
          asbox @a rep
          (Sequence_reduce @a rep f acc
           (Sequence_generate_bind @a (con_list_dim (justVal @int count_i))
            (\ (si : Boxed (Stored int)) -> Sequence (AsBox a).
               -- Add 'lb' to the index
               case boxIntValue (lb +# unboxIntValue si) of [reprSizeAlign @(Stored int) repr_int]
                 boxed tyob real_si.
               g real_si)))
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = asbox @a rep (copy @a rep init) in
      asbare @a rep
      (blocked_1d_reduce @N @b count combiner boxed_init reducer)
      ret

  ; nothingVal.
      except @Store
  };


Sequence_parallel_build @(a : bare)
  (rep : Repr a) (dom : list_dim) (f : Stored int -> Sequence (AsBox a))
  (ret : OutPtr (list a))
  -> Store
  attribute(inline) =

  let reduced_tree : PBTree a = PBTree_parallel_build @a rep dom f in

  PBTree_flatten @a rep reduced_tree ret;


-- Run a blocked parallel computation over a sequence.
-- Collect the results into a tree, where each tree leaf is the result of one
-- parallel step.
PBTree_parallel_build @(a : bare)
  (rep : Repr a) (dom : list_dim)
  (f : Stored int -> Sequence (AsBox a))
  -> PBTree a
  attribute(inline) =

  case dom of mk_list_dim tyob (list_size : MaybeVal int).
  case list_size of {
    justVal (size : int).
      letfun
        -- Sequentially build a list from a subset of the original range.
        -- Put the list in a tree leaf.
        rangeProc @(M : intindex)
          (start : int) (count : FIInt M) (init : PBTree a) -> PBTree a =
          case count of fiInt (count_new : int).
          let count_i : int = count_new in
          let outLeaf : PBTree a =
                con_pbLeaf @a
                (Sequence_list_build @a rep
                 (Sequence_generate_bind @a (con_list_dim (justVal @int count_i))
                  (\ (si : Boxed (Stored int)) -> Sequence (AsBox a).
                     -- Add 'start' to the index
                     case boxIntValue (start +# unboxIntValue si) of [reprSizeAlign @(Stored int) repr_int]
                       boxed tyob real_si.
                     f real_si))) in
          PBTree_branch @a outLeaf init in

      case defineIntIndex size of someIInt @n (range_count : FIInt n).

      -- Create lists in parallel and build a tree out of them
      blocked_1d_reduce @n @(PBTree a)
      range_count (PBTree_branch @a) (con_pbEmpty @a) rangeProc

  ; nothingVal.
      except @(PBTree a)
  };

{-
Sequence_parallel_scatter @(i r : bare)
  (rep_i : Repr i) (rep_r : Repr r)
  (dom : list_dim)
  (scatter : Scatter r i)
  (f : Stored int -> Sequence (AsBox i))
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case scatter of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (rep_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (update_func : i -> updF)
    (init_func : iniF).

  let type bs = StuckBox s in

  letfun
    -- Version of 'combiner' for boxed objects
    boxed_combiner (x : bs) (y : bs) -> bs =
      case x of stuckBox ux.
      case y of stuckBox uy.
      stuckBox @s (combiner ux uy)
  in

  case dom of mk_list_dim (maybe_size : MaybeVal int).

  case maybe_size of {
    justVal (count : int).
      case defineIntIndex count of someIInt @(N : intindex) (size : FIInt N).

      -- Perform a parallel reduction over this range
      case blocked_1d_reduceip @N @bs size
           boxed_combiner
           (\ @(M : intindex) (start : int) (range_size : FIInt M) -> bs.
              -- Sequential reduction over this sub-range
              case range_size of fiInt (range_count : int).
              let subdom : list_dim = mk_list_dim (justVal @int range_count) in
                    
              stuckBox @s
              (Sequence_partial_scatter @i @s @iniF @updF rep_i rep_s
               initializer updater update_func init_func
               (Sequence_generate_bind @i subdom
                (\ (sindex : Boxed (Stored int)) -> Sequence (AsBox i).
                   -- Add 'start' to the index
                   let uindex = unboxIntValue sindex in
                   case stuckBox @(Stored int)
                        (stored @int (uindex +# start)) of
                     stuckBox sindex2.
                     f sindex2)))) of
        stuckBox (final_state : s).

      -- Create the final object
      finish_scatter @r @s rep_r rep_s finalizer
      (copy @s rep_s final_state) ret

  ; nothingVal.
      except @Store
  };
-}

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- High-level overloaded stream and container functions


reduce @(t : box -> box) @(a : box)
  (sh : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep : ReprBox a)
  (f : a -> a -> a) (z : a) (x : t a) -> a attribute(inline) =

  case traversable of traversableDict tyob traverse build.

  reduce_Stream @(shape t) @a sh rep f z (traverse @a rep x);


reduce1 @(t : box -> box) @(a : box)
  (sh : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep : ReprBox a)
  (f : a -> a -> a) (x : t a) -> a attribute(inline) =

  case traversable of traversableDict tyob traverse build.

  let flat_stream = shFlatten @(shape t) sh @a rep (traverse @a rep x) in

  peel_Stream @a @a rep
  (\ (init : a) (s : Stream list_dim a) -> a.
     reduce_Stream @list_dim @a ShapeDict_list_dim rep f init s)
  (\ (dummy : NoneType) -> a.
     -- Error: input is empty
     except @a)
  flat_stream;


sum @(t : box -> box) @(a : box)
  (sh : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep : ReprBox a)
  (additive : AdditiveDict a)
  (x : t a) -> a attribute(inline) =

  case additive of additiveDict tyob add sub neg zero.
  reduce @t @a sh traversable rep add zero x;


filter @(t : box -> box) @(a : box)
  (has_list_dim : coerce @box (shape t) list_dim)
  (traversable : TraversableDict t)
  (rep : ReprBox a)
  (test : a -> Boxed (Stored bool))
  (x : t a)
  -> t a attribute(inline) =

  case traversable of traversableDict tyob traverse build.

  let s_in = coerce @(Stream (shape t) a) @(Stream list_dim a)
             (traverse @a rep x) in

  let s_out = coerce @(Stream list_dim a) @(Stream (shape t) a)
              (filter_Stream @a rep test s_in) in

  build @a rep s_out;


-- Get a stream of the indices of each element of the domain
indices @(d : box) (sh : ShapeDict d) (dom : d)
  -> Stream d (BoxIndex d) attribute(inline) =

  shGenerate @d sh @(BoxIndex d) (shRepIndex @d sh) (shNoOffset @d sh) dom
  (\ (x : BoxIndex d) -> BoxIndex d. x);


zip @(s t : box -> box) @(a b : box)
  (same_shape : coerce @box (shape s) (shape t))
  (sh : ShapeDict (shape s))
  (traversable_s : TraversableDict s)
  (traversable_t : TraversableDict t)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (x : s a)
  (y : t b)
  -> Stream (shape s) (Boxed (Tuple2 (AsBare a) (AsBare b)))
  attribute(inline) =

  case traversable_s of traversableDict tyob traverse_s build_s.
  case traversable_t of traversableDict tyob traverse_t build_t.

  let type tuple = Boxed (Tuple2 (AsBare a) (AsBare b)) in
  let rep_tuple = unboxedinfo Tuple2 @(AsBare a) @(AsBare b) rep_a rep_b in

  shZipWith @(shape s) sh @a @b @tuple rep_a rep_b rep_tuple
  (\ (x : a) (y : b) -> tuple.
    con_boxed @(Tuple2 (AsBare a) (AsBare b)) rep_tuple
    (tuple2 @(AsBare a) @(AsBare b)
     (reprSizeAlign @(AsBare a) rep_a) (reprSizeAlign @(AsBare b) rep_b)
     (asbare @(AsBare a) rep_a x)
     (asbare @(AsBare b) rep_b y)))
  (traverse_s @a rep_a x)
  (coerce @(Stream (shape t) b) @(Stream (shape s) b) (traverse_t @b rep_b y));


zip3 @(s t u : box -> box) @(a b c : box)
  (same_shape1 : coerce @box (shape s) (shape t))
  (same_shape2 : coerce @box (shape s) (shape u))
  (sh : ShapeDict (shape s))
  (traversable_s : TraversableDict s)
  (traversable_t : TraversableDict t)
  (traversable_u : TraversableDict u)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (x : s a)
  (y : t b)
  (z : u c)
  -> Stream (shape s) (Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  attribute(inline) =

  case traversable_s of traversableDict tyob traverse_s build_s.
  case traversable_t of traversableDict tyob traverse_t build_t.
  case traversable_u of traversableDict tyob traverse_u build_u.

  let type tuple_xy = Boxed (Tuple2 (AsBare a) (AsBare b)) in
  let rep_tuple_xy = unboxedinfo Tuple2 @(AsBare a) @(AsBare b) rep_a rep_b in

  let type tuple_xyz = Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)) in
  let rep_tuple_xyz = unboxedinfo Tuple3 @(AsBare a) @(AsBare b) @(AsBare c) rep_a rep_b rep_c in

  let sa_a = reprSizeAlign @(AsBare a) rep_a in
  let sa_b = reprSizeAlign @(AsBare b) rep_b in
  let sa_c = reprSizeAlign @(AsBare c) rep_c in

  let s_xy : Stream (shape s) tuple_xy =
      shZipWith @(shape s) sh @a @b @tuple_xy rep_a rep_b rep_tuple_xy
      (\ (x : a) (y : b) -> tuple_xy.
        con_boxed @(Tuple2 (AsBare a) (AsBare b)) rep_tuple_xy
        (tuple2 @(AsBare a) @(AsBare b) sa_a sa_b
         (asbare @(AsBare a) rep_a x)
         (asbare @(AsBare b) rep_b y)))
      (traverse_s @a rep_a x)
      (coerce @(Stream (shape t) b) @(Stream (shape s) b) (traverse_t @b rep_b y)) in

  shZipWith @(shape s) sh @tuple_xy @c @tuple_xyz rep_tuple_xy rep_c rep_tuple_xyz
  (\ (xy : tuple_xy) (z : c) -> tuple_xyz.
     case xy of [reprSizeAlign @(Tuple2 (AsBare a) (AsBare b)) rep_tuple_xy]
                boxed tyob ([sa_a, sa_b] tuple2 x y).

     con_boxed @(Tuple3 (AsBare a) (AsBare b) (AsBare c)) rep_tuple_xyz
     (tuple3 @(AsBare a) @(AsBare b) @(AsBare c) sa_a sa_b sa_c
      (copy @(AsBare a) rep_a x)
      (copy @(AsBare b) rep_b y)
      (asbare @(AsBare c) rep_c z)))
  s_xy
  (coerce @(Stream (shape u) c) @(Stream (shape s) c) (traverse_u @c rep_c z));


zip4 @(s t u v : box -> box) @(a b c d : box)
  (same_shape1 : coerce @box (shape s) (shape t))
  (same_shape2 : coerce @box (shape s) (shape u))
  (same_shape3 : coerce @box (shape s) (shape v))
  (sh : ShapeDict (shape s))
  (traversable_s : TraversableDict s)
  (traversable_t : TraversableDict t)
  (traversable_u : TraversableDict u)
  (traversable_v : TraversableDict v)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (rep_d : ReprBox d)
  (x : s a)
  (y : t b)
  (z : u c)
  (w : v d)
  -> Stream (shape s) (Boxed (Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)))
  attribute(inline) =

  case traversable_s of traversableDict tyob traverse_s build_s.
  case traversable_t of traversableDict tyob traverse_t build_t.
  case traversable_u of traversableDict tyob traverse_u build_u.
  case traversable_v of traversableDict tyob traverse_v build_v.

  let type tuple_xy = Boxed (Tuple2 (AsBare a) (AsBare b)) in
  let rep_tuple_xy = unboxedinfo Tuple2 @(AsBare a) @(AsBare b) rep_a rep_b in

  let type tuple_zw = Boxed (Tuple2 (AsBare c) (AsBare d)) in
  let rep_tuple_zw = unboxedinfo Tuple2 @(AsBare c) @(AsBare d) rep_c rep_d in

  let type tuple_xyzw = Boxed (Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)) in
  let rep_tuple_xyzw = unboxedinfo Tuple4 @(AsBare a) @(AsBare b) @(AsBare c) @(AsBare d)
                       rep_a rep_b rep_c rep_d in

  let sa_a = reprSizeAlign @(AsBare a) rep_a in
  let sa_b = reprSizeAlign @(AsBare b) rep_b in
  let sa_c = reprSizeAlign @(AsBare c) rep_c in
  let sa_d = reprSizeAlign @(AsBare d) rep_d in

  let s_xy : Stream (shape s) tuple_xy =
      shZipWith @(shape s) sh @a @b @tuple_xy rep_a rep_b rep_tuple_xy
      (\ (x : a) (y : b) -> tuple_xy.
        con_boxed @(Tuple2 (AsBare a) (AsBare b)) rep_tuple_xy
        (tuple2 @(AsBare a) @(AsBare b) sa_a sa_b
         (asbare @(AsBare a) rep_a x)
         (asbare @(AsBare b) rep_b y)))
      (traverse_s @a rep_a x)
      (coerce @(Stream (shape t) b) @(Stream (shape s) b) (traverse_t @b rep_b y)) in

  let s_zw : Stream (shape s) tuple_zw =
      shZipWith @(shape s) sh @c @d @tuple_zw rep_c rep_d rep_tuple_zw
      (\ (z : c) (w : d) -> tuple_zw.
        con_boxed @(Tuple2 (AsBare c) (AsBare d)) rep_tuple_zw
        (tuple2 @(AsBare c) @(AsBare d) sa_c sa_d
         (asbare @(AsBare c) rep_c z)
         (asbare @(AsBare d) rep_d w)))
      (coerce @(Stream (shape u) c) @(Stream (shape s) c) (traverse_u @c rep_c z))
      (coerce @(Stream (shape v) d) @(Stream (shape s) d) (traverse_v @d rep_d w)) in

  shZipWith @(shape s) sh @tuple_xy @tuple_zw @tuple_xyzw
  rep_tuple_xy rep_tuple_zw rep_tuple_xyzw
  (\ (xy : tuple_xy) (zw : tuple_zw) -> tuple_xyzw.
     case xy of [reprSizeAlign @(Tuple2 (AsBare a) (AsBare b)) rep_tuple_xy]
                boxed tyob ([sa_a, sa_b] tuple2 x y).
     case zw of [reprSizeAlign @(Tuple2 (AsBare c) (AsBare d)) rep_tuple_zw]
                boxed tyob ([sa_c, sa_d] tuple2 z w).

     con_boxed @(Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d))
     rep_tuple_xyzw
     (tuple4 @(AsBare a) @(AsBare b) @(AsBare c) @(AsBare d) sa_a sa_b sa_c sa_d
      (copy @(AsBare a) rep_a x)
      (copy @(AsBare b) rep_b y)
      (copy @(AsBare c) rep_c z)
      (copy @(AsBare d) rep_d w)))
  s_xy
  s_zw;


count : Stream list_dim (Boxed (Stored int)) = count_helper None;

count_helper (x : NoneType) -> Stream list_dim (Boxed (Stored int)) =
  let type index_list_dim = Boxed (Stored int) in
  traverse_view_real @list_dim @index_list_dim ShapeDict_list_dim repr_int
  (con_view @list_dim @index_list_dim (con_list_dim (nothingVal @int))
   (\ (x : index_list_dim) -> index_list_dim. x));

range (length : Boxed (Stored int)) -> Stream list_dim (Boxed (Stored int))
  attribute(inline) =

  let type index_list_dim = Boxed (Stored int) in
  let dom = con_list_dim (justVal @int (unboxIntValue length)) in
  traverse_view_real @list_dim @index_list_dim ShapeDict_list_dim repr_int
  (con_view @list_dim @index_list_dim dom
   (\ (x : index_list_dim) -> index_list_dim. x));


arrayRange @(sh : box) (shp : ShapeDict sh) (cartesian : CartesianDict sh)
  (lo hi : BoxIndex sh)
  -> Stream sh (AsBox (index sh))
  attribute(inline) =

  let type ix = index sh in

  case cartesian of cartesianDict tyob has_shape loBound hiBound get_stride
    arrayDomain displaceDomain multiplyDomain divideDomain
    multiplyIndex divideIndex unbounded.

  indices @sh shp (arrayDomain lo hi);


fun_indices @(sh : box) (shape_dict : ShapeDict sh) (shp : sh)
  -> Stream sh (BoxIndex sh)
  attribute(inline) =

  let rep_index = shRepIndex @sh shape_dict in
  shGenerate @sh shape_dict @(BoxIndex sh)
  rep_index (shNoOffset @sh shape_dict) shp
  (\ (x : BoxIndex sh) -> BoxIndex sh. x);


{- REPLACED BY NEW STREAM CODE

fun_map @(t : box -> box)
        @(a b : box)
        (traversable : TraversableDict t)
        (shape_dict : ShapeDict (shape t))
        (repr_a : Repr (AsBare a))
        (repr_b : Repr (AsBare b))
        (transformer : a -> b)
        (container : t a)
        -> t b
 	attribute(inline) =
  let type sh = shape t in

  case traversable of traversableDict tyob traverse build.

  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  build @b repr_b
  (shape_map @a @b repr_a repr_b transformer
   (traverse @a repr_a container));


fun_filter @(t : box -> box) @(a : box)
     (traversable : TraversableDict t)
     (is_list : coerce @box (shape t) list_dim)
     (rep : Repr (AsBare a))
     (predicate : a -> Boxed (Stored bool))
     (input : t a)
     -> t a
     attribute(inline) =
  case traversable of traversableDict tyob traverse build.

  -- Traverse the input
  let input_stream : Stream1 a =
        coerce @(Stream (shape t) a) @(Stream1 a)
        (traverse @a rep input) in

  -- Guard.  For each stream element,
  -- return the element if predicate evaluates to true.
  -- Otherwise, return nothing.
  let s : Stream1 a =
        Stream1_bind @a @a rep rep input_stream
        (\ (x : a) -> Stream1 a.
           if unboxBoolValue (predicate x)
           then con_sequenceStream @a (Sequence_return @(AsBare a) rep (asbare @(AsBare a) rep x))
           else con_sequenceStream @a (Sequence_empty @(AsBare a) rep)) in

  -- Build the return value
  build @a rep (coerce @(Stream1 a) @(Stream (shape t) a) s);


fun_zip @(t1 t2 : box -> box) @(a b : box)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (equal12 : coerce @box (shape t1) (shape t2))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr (AsBare a)) (reprB : Repr (AsBare b))
        (inputA : t1 a) (inputB : t2 b)
  -> Stream (shape t1) (Boxed (Tuple2 (AsBare a) (AsBare b)))
  attribute(inline) =
  case traversable1 of traversableDict tyob traverse1 build1.
  case traversable2 of traversableDict tyob traverse2 build2.
  let stream1 = traverse1 @a reprA inputA in
  let stream2 =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in

  let type sh = shape t1 in
  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  let rep_tuple = unboxedinfo Tuple2 @(AsBare a) @(AsBare b) reprA reprB in
  let sa_a = reprSizeAlign @(AsBare a) reprA in
  let sa_b = reprSizeAlign @(AsBare b) reprB in

  letfun
    transformer (x : a) (y : b) -> Boxed (Tuple2 (AsBare a) (AsBare b)) =
      con_boxed @(Tuple2 (AsBare a) (AsBare b)) rep_tuple
      (tuple2 @(AsBare a) @(AsBare b) sa_a sa_b
       (asbare @(AsBare a) reprA x) (asbare @(AsBare b) reprB y))
  in

  shape_zipWith @a @b @(Boxed (Tuple2 (AsBare a) (AsBare b)))
  reprA reprB (unboxedinfo Tuple2 @(AsBare a) @(AsBare b) reprA reprB)
  transformer stream1 stream2;

fun_zip3 @(t1 t2 t3 : box -> box) @(a b c : box)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (equal12 : coerce @box (shape t1) (shape t2))
        (equal23 : coerce @box (shape t2) (shape t3))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr (AsBare a)) (reprB : Repr (AsBare b)) (reprC : Repr (AsBare c))
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c)
  -> Stream (shape t1) (Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  attribute(inline) =
  case traversable1 of traversableDict tyob traverse1 build1.
  case traversable2 of traversableDict tyob traverse2 build2.
  case traversable3 of traversableDict tyob traverse3 build3.
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in

  let type sh = shape t1 in
  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  let rep_tuple = unboxedinfo Tuple3 @(AsBare a) @(AsBare b) @(AsBare c) reprA reprB reprC in
  let sa_a = reprSizeAlign @(AsBare a) reprA in
  let sa_b = reprSizeAlign @(AsBare b) reprB in
  let sa_c = reprSizeAlign @(AsBare c) reprC in

  letfun
    transformer (x : a) (y : b) (z : c)
      -> Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)) =
      con_boxed @(Tuple3 (AsBare a) (AsBare b) (AsBare c)) rep_tuple
      (tuple3 @(AsBare a) @(AsBare b) @(AsBare c) sa_a sa_b sa_c
       (asbare @(AsBare a) reprA x) (asbare @(AsBare b) reprB y) (asbare @(AsBare c) reprC z))
  in

  shape_zipWith3 @a @b @c @(Boxed (Tuple3 (AsBare a) (AsBare b) (AsBare c)))
  reprA reprB reprC (unboxedinfo Tuple3 @(AsBare a) @(AsBare b) @(AsBare c) reprA reprB reprC)
  transformer stream1 stream2 stream3;


fun_zip4 @(t1 t2 t3 t4 : box -> box) @(a b c d : box)
        (traversable1 : TraversableDict t1)
        (traversable2 : TraversableDict t2)
        (traversable3 : TraversableDict t3)
        (traversable4 : TraversableDict t4)
        (equal12 : coerce @box (shape t1) (shape t2))
        (equal23 : coerce @box (shape t2) (shape t3))
        (equal34 : coerce @box (shape t3) (shape t4))
	(shape_dict : ShapeDict (shape t1))
        (reprA : Repr (AsBare a)) (reprB : Repr (AsBare b)) (reprC : Repr (AsBare c)) (reprD : Repr (AsBare d))
        (inputA : t1 a) (inputB : t2 b) (inputC : t3 c) (inputD : t4 d)
  -> Stream (shape t1) (Boxed (Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)))
  attribute(inline) =

  case traversable1 of traversableDict tyob traverse1 build1.
  case traversable2 of traversableDict tyob traverse2 build2.
  case traversable3 of traversableDict tyob traverse3 build3.
  case traversable4 of traversableDict tyob traverse4 build4.
  let stream1 : Stream (shape t1) a = traverse1 @a reprA inputA in
  let stream2 : Stream (shape t1) b =
        coerce @(Stream (shape t2) b) @(Stream (shape t1) b)
	(traverse2 @b reprB inputB) in
  let stream3 : Stream (shape t1) c =
        coerce @(Stream (shape t3) c) @(Stream (shape t1) c)
	(traverse3 @c reprC inputC) in
  let stream4 : Stream (shape t1) d =
        coerce @(Stream (shape t4) d) @(Stream (shape t1) d)
	(traverse4 @d reprD inputD) in

  let type sh = shape t1 in
  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  let rep_tuple =
        unboxedinfo Tuple4 @(AsBare a) @(AsBare b) @(AsBare c) @(AsBare d) reprA reprB reprC reprD in
  let sa_a = reprSizeAlign @(AsBare a) reprA in
  let sa_b = reprSizeAlign @(AsBare b) reprB in
  let sa_c = reprSizeAlign @(AsBare c) reprC in
  let sa_d = reprSizeAlign @(AsBare d) reprD in

  letfun
    transformer (x : a) (y : b) (z : c) (w : d)
      -> Boxed (Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)) =
      con_boxed @(Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)) rep_tuple
      (tuple4 @(AsBare a) @(AsBare b) @(AsBare c) @(AsBare d) sa_a sa_b sa_c sa_d
       (asbare @(AsBare a) reprA x) (asbare @(AsBare b) reprB y)
       (asbare @(AsBare c) reprC z) (asbare @(AsBare d) reprD w))
  in

  shape_zipWith4 @a @b @c @d @(Boxed (Tuple4 (AsBare a) (AsBare b) (AsBare c) (AsBare d)))
  reprA reprB reprC reprD
  (unboxedinfo Tuple4 @(AsBare a) @(AsBare b) @(AsBare c) @(AsBare d) reprA reprB reprC reprD)
  transformer stream1 stream2 stream3 stream4;


fun_reduce @(t : box -> box) @(a : box)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (rep : Repr (AsBare a))
  (reducer : a -> a -> a)
  (init : a)
  (input : t a)
  -> a
  attribute(inline, inline_dimensionality) =
  let type sh = shape t in

  case traversable of traversableDict tyob traverse build.

  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  letfun
    bare_f (x : AsBare a) (y : AsBare a) (ret : OutPtr (AsBare a)) -> Store =
      asbare @(AsBare a) rep
      (reducer (bareToBox @(AsBare a) rep x) (bareToBox @(AsBare a) rep y)) ret
  in

  let b_init = boxToBare @(AsBare a) rep init in

  let s : Stream1 a = shape_flatten @a rep (traverse @a rep input) in
  case s of {
    viewStream tyob vw.
      asbox @(AsBare a) rep
      (reduce_list_dim @(AsBare a) rep bare_f b_init vw)
  ; sequenceStream tyob sq.
      asbox @(AsBare a) rep
      (Sequence_reduce @(AsBare a) rep bare_f b_init sq)
  };


fun_reduce1 @(t : box -> box) @(a : box)
  (traversable : TraversableDict t)
  (shape_dict : ShapeDict (shape t))
  (rep : Repr (AsBare a))
  (reducer : a -> a -> a)
  (input : t a)
  -> a
  attribute(inline, inline_dimensionality) =
  let type sh = shape t in

  case traversable of traversableDict tyob traverse build.

  case shape_dict of
    shapeDict tyob index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  letfun
    bare_f (x : AsBare a) (y : AsBare a) (ret : OutPtr (AsBare a)) -> Store =
      asbare @(AsBare a) rep
      (reducer (bareToBox @(AsBare a) rep x) (bareToBox @(AsBare a) rep y)) ret
  in

  let s : Stream1 a = shape_flatten @a rep (traverse @a rep input) in
  case s of {
    viewStream tyob (vw : view list_dim a).
      asbox @(AsBare a) rep
      (reduce1_list_dim @(AsBare a) rep bare_f vw)
  ; sequenceStream tyob (sq : Sequence a).
      asbox @(AsBare a) rep
      (Sequence_reduce1 @(AsBare a) rep bare_f sq)
  };


fun_sum @(t : box -> box) @(a : box)
  (traversable : TraversableDict t)
  (shp : ShapeDict (shape t))
  (rep : Repr (AsBare a))
  (additive : AdditiveDict a)
  (src : t a)
  -> a
  attribute(inline) =

  case additive of additiveDict tyob add sub negate zero.
  fun_reduce @t @a traversable shp rep add zero src;




displaceView @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (cartesian : CartesianDict (shape t))
  (additive : AdditiveDict (AsBox (index (shape t))))
  (rep : Repr (AsBare a))
  (c : t a)
  (disp : AsBox (index (shape t)))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in
  let type ix = index (shape t) in
  case cartesian of cartesianDict tyob has_shape loBound hiBound get_stride
    arrayDomain displaceDomain multiplyDomain divideDomain
    multiplyIndex divideIndex unbounded.

  case indexable of indexableDict tyob at_index get_shape.

  case additive of additiveDict tyob add sub negate zero.

  -- Note that we transform from new index to old index by subtracting the
  -- displacement 
  view_generate @sh shape_dict @a rep (displaceDomain (get_shape @a c) disp)
  (\ (i : AsBox ix) -> a. at_index @a rep c (sub i disp));


multiplyView @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (cartesian : CartesianDict (shape t))
  (additive : AdditiveDict (AsBox (index (shape t))))
  (rep : Repr (AsBare a))
  (c : t a)
  (scale : AsBox (index (shape t)))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in
  let type ix = index (shape t) in

  case cartesian of cartesianDict tyob has_shape loBound hiBound get_stride
    arrayDomain displaceDomain multiplyDomain divideDomain
    multiplyIndex divideIndex unbounded.

  case indexable of indexableDict tyob at_index get_shape.

  -- Note that we transform from new index to old index by dividing the
  -- scale factor 
  view_generate @sh shape_dict @a rep (multiplyDomain (get_shape @a c) scale)
  (\ (i : AsBox ix) -> a. at_index @a rep c (divideIndex i scale));


divideView @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (cartesian : CartesianDict (shape t))
  (additive : AdditiveDict (AsBox (index (shape t))))
  (rep : Repr (AsBare a))
  (c : t a)
  (scale : AsBox (index (shape t)))
  -> view (shape t) a
  attribute(inline) =

  let type sh = shape t in
  let type ix = index (shape t) in

  case cartesian of cartesianDict tyob has_shape loBound hiBound get_stride
    arrayDomain displaceDomain multiplyDomain divideDomain
    multiplyIndex divideIndex unbounded.

  case indexable of indexableDict tyob at_index get_shape.

  -- Note that we transform from new index to old index by multiplying the
  -- scale factor.
  -- 'divideDomain' will throw an error if the scale factor is invalid.
  view_generate @sh shape_dict @a rep (divideDomain (get_shape @a c) scale)
  (\ (i : AsBox ix) -> a. at_index @a rep c (multiplyIndex i scale));

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Domain loops (sequential)

{- REPLACED BY NEW STREAM CODE

primitive_list_dim_chain @(a : bare) (rep : Repr a)
  (v1 : view list_dim (AsBox a))
  (v2 : view list_dim (AsBox a))
  -> view list_dim (AsBox a)
  attribute(inline, inline_final) =
  case v1 of mk_view tyob (dom1 : list_dim) f1.
  case v2 of mk_view tyob (dom2 : list_dim) f2.

  case dom1 of mk_list_dim tyob (size1 : MaybeVal int).
  case dom2 of mk_list_dim tyob (size2 : MaybeVal int).
  case size1 of {
    justVal (sz : int).
      let dom : list_dim =
            con_list_dim (case size2 of {
                            justVal (sz2 : int). justVal @int (sz +# sz2)
                          ; nothingVal. nothingVal @int}) in
      con_view @list_dim @(AsBox a) dom
      (\ (ix : Boxed (Stored int)) -> AsBox a.
         -- Get a value from the first or the second view
         let i = unboxIntValue ix in
         if i <# sz
         then f1 ix
         else f2 (boxIntValue (i -# sz)))

  ; nothingVal.
      -- The first domain is infinite, so the second is unreachable
      con_view @list_dim @(AsBox a) dom1 f1
  };


primitive_list_dim_reduce @(a : bare)
  (rep : Repr a)
  (dom : list_dim)
  (generator : Stored int -> Init a)
  (reducer : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_list_dim tyob (m_size : MaybeVal int).
  case m_size of {
    justVal (size : int).
      case defineIntIndex size of someIInt @(N : intindex) (sz : FIInt N).

      for @N @a rep sz init
      (\ (i : int) (x : a) (loop_ret : OutPtr a) -> Store.
         case boxIntValue i of [reprSizeAlign @(Stored int) repr_int]
           boxed tyob (s_i : Stored int).
         let y = initToBare @a rep (generator s_i) in
         reducer x y loop_ret)
      ret

  ; nothingVal.
      -- Can't evaluate on an infinite domain
      except @Store
  };


primitive_list_dim_reduce1 @(a : bare)
  (rep : Repr a)
  (dom : list_dim)
  (generator : Stored int -> Init a)
  (reducer : a -> a -> Init a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =
  case dom of mk_list_dim tyob (m_size : MaybeVal int).
  case m_size of {
    justVal (size : int).
      -- Can't reduce on empty range
      if size ==# 0 then except @Store else

      -- Evaluate at index 0 to get initial value
      case boxIntValue 0 of [reprSizeAlign @(Stored int) repr_int]
        boxed tyob s_zero.
      let init = initToBare @a rep (generator s_zero) in

      -- Reduce remaining values
      case defineIntIndex (size -# 1) of someIInt @N (sz : FIInt N).

      for @N @a rep sz init
      (\ (i : int) (x : a) (loop_ret : OutPtr a) -> Store.
         case boxIntValue (i +# 1) of [reprSizeAlign @(Stored int) repr_int]
           boxed tyob s_i.
         let y = initToBare @a rep (generator s_i) in
         reducer x y loop_ret)
      ret

  ; nothingVal.
      -- Can't evaluate on an infinite domain
      except @Store
  };

{-
primitive_list_dim_scatter @(i r : bare)
  (repr_i : Repr i)
  (repr_r : Repr r)
  (dom : list_dim)
  (op : Scatter r i)
  (src : Stored int -> Init i)
  (ret : OutPtr r)
  -> Store
  attribute(inline, inline_sequential) =

  case op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (repr_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (make_updater : i -> updF)
    (make_init : iniF).

  finish_scatter @r @s repr_r repr_s finalizer
  (partial_list_dim_scatter @i @s @iniF @updF repr_i repr_s
   initializer updater make_updater make_init dom src)
  ret;
-}


primitive_list_dim_fold @(acc : bare)
  (rep : Repr acc)
  (d : list_dim)
  (f : index list_dim -> acc -> Init acc)
  (init : acc)
  (ret : OutPtr acc)
  -> Store
  attribute(inline) =

  case d of mk_list_dim tyob (list_size : MaybeVal int).
  case list_size of {
    justVal (size : int).
      case defineIntIndex size of someIInt @N (count : FIInt N).
      
      for @N @acc rep count init
      (\ (i : int) (loop_acc : acc) (ret : OutPtr acc) -> Store.
         case boxIntValue i of [reprSizeAlign @(Stored int) repr_int]
           boxed tyob real_index.

         -- Accumulate value
         f real_index loop_acc ret)
      ret

  ; nothingVal.
      except @Store
  };


primitive_dim1_reduce @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (generator : Stored int -> Init a)
  (reducer : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store
  attribute(inline, inline_final) =

  case dim1ToArraySize dom of arraySize @N lb stride size.

  let linear_map : LinearMap = linearMap stride lb in

  for @N @a rep size init
  (\ (i : int) (x : a) (loop_ret : OutPtr a) -> Store.
     let logical_i : int = evalLM i linear_map in
     case boxIntValue logical_i of [reprSizeAlign @(Stored int) repr_int]
       boxed tyob s_i.
     let y = initToBare @a rep (generator s_i) in
     reducer x y loop_ret)
  ret;


primitive_dim1_reduce1 : forall a : bare.
    Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;


primitive_dim1_fold @(acc : bare)
  (rep : Repr acc)
  (d : dim1)
  (f : index dim1 -> acc -> Init acc)
  (init : acc)
  (ret : OutPtr acc)
  -> Store
  attribute(inline) =

  case dim1ToArraySize d of arraySize @(N : intindex) lb stride count.

  -- Loop over the domain
  for @N @acc rep count init
  (\ (i : int) (loop_acc : acc) (ret : OutPtr acc) -> Store.

     -- Compute the real index in this loop iteration
     case boxIntValue (lb +# i *# stride) of [reprSizeAlign @(Stored int) repr_int]
       boxed tyob real_index.

     -- Accumulate value
     f real_index loop_acc ret)
  ret;


primitive_dim2_reduce : forall a : bare. Repr a -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

primitive_dim2_reduce1 : forall a : bare. Repr a -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Domain loops (parallel)

{- REPLACED BY NEW STREAM CODE

parallel_list_dim_reduce @(a : bare)
  (rep : Repr a)
  (dom : list_dim)
  (g : Stored int -> Init a)
  (f : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store =

  case dom of mk_list_dim tyob (list_size : MaybeVal int).
  case list_size of {
    justVal (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type b = AsBox a in
      letfun
        combiner (x : b) (y : b) -> b =
          asbox @a rep (f (boxToBare @a rep x) (boxToBare @a rep y))
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
          for_box @range_N @b count acc_in
          (\ (i : int) (acc_loop : b) -> b.
            -- Add the lower bound to get the real index
            case boxIntValue (i +# lb) of [reprSizeAlign @(Stored int) repr_int]
              boxed tyob real_index.

            -- Call 'g' to compute a value, and 'f' to combine it
            let x = boxToBare @a rep acc_loop in
            let y = initToBare @a rep (g real_index) in
            asbox @a rep (f x y))
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = asbox @a rep (copy @a rep init) in
      asbare @a rep
      (blocked_1d_reduce @N @b count combiner boxed_init reducer)
      ret

  ; nothingVal.
      except @Store
  };


parallel_dim1_reduce @(a : bare)
  (rep : Repr a)
  (dom : dim1)
  (g : Stored int -> Init a)
  (f : a -> a -> Init a)
  (init : a)
  (ret : OutPtr a)
  -> Store
  attribute(inline) =

  case dom of
    mk_dim1 tyob (interval lower_bound upper_bound) (linearMap stride alignment).
  case lower_bound of {
    justVal (lb : int).
      case upper_bound of {
        justVal (ub : int).          
          -- Create combiner and reducer functions using 'f' and 'g'
          let type b = AsBox a in
          letfun
            combiner (x : b) (y : b) -> b =
              asbox @a rep (f (boxToBare @a rep x) (boxToBare @a rep y))
          in
          letfun
            reducer @(range_N : intindex)
              (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
              for_box @range_N @b count acc_in
              (\ (i : int) (acc_loop : b) -> b.
                -- Compute the real index from iteration 'i'
                case boxIntValue (lb +# i *# stride) of [reprSizeAlign @(Stored int) repr_int]
                  boxed tyob real_index.

                -- Call 'g' to compute a value, and 'f' to combine it
                let x = boxToBare @a rep acc_loop in
                let y = initToBare @a rep (g real_index) in
                asbox @a rep (f x y))
          in
          let size : int = (ub -# lb) //# stride in
          case defineIntIndex size of
            someIInt @(N : intindex) (count : FIInt N).
          let boxed_init : b = asbox @a rep (copy @a rep init) in
          asbare @a rep
          (blocked_1d_reduce @N @b count combiner boxed_init reducer)
          ret

      ; nothingVal.
          except @Store
      }
  ; nothingVal.
      except @Store
  };


parallel_list_dim_reduce1 @(a : bare)
  (rep : Repr a)
  (dom : list_dim)
  (g : Stored int -> Init a)
  (f : a -> a -> Init a)
  (ret : OutPtr a)
  -> Store =

  let mrepr : Repr (Maybe a) = unboxedinfo Maybe @a rep in
  case dom of mk_list_dim tyob (list_size : MaybeVal int).
  case list_size of {
    justVal (size : int).
      -- Create combiner and reducer functions using 'f' and 'g'
      let type ma = Maybe a in
      let type b = AsBox ma in
      letfun
        combiner (x : b) (y : b) -> b =
          -- Combine 'Maybe' values.  Use 'f' if both values are 'Just'.
          case boxToBare @ma mrepr x of [reprSizeAlign @a rep] {
            just (bx : a).
              case boxToBare @ma mrepr y of [reprSizeAlign @a rep] {
                just (by : a). asbox @ma mrepr (just @a (reprSizeAlign @a rep) (f bx by))
              ; nothing. x
            }
          ; nothing. y
          }
      in
      letfun
        reducer @(range_N : intindex)
          (lb : int) (count : FIInt range_N) (acc_in : b) -> b =
          let m_acc_in = boxToBare @ma mrepr acc_in in

          letfun
            reduce_with_initial_value @(subrange_N : intindex)
              (subrange_lb : int)
              (subrange_count : FIInt subrange_N)
              (subrange_acc : a)
              -> b =
            asbox @ma mrepr
            (just @a (reprSizeAlign @a rep)
             (for @subrange_N @a rep subrange_count subrange_acc
              (\ (i : int) (x : a) (ret : OutPtr a) -> Store.
                 -- Add the lower bound to get the real index
                 case boxIntValue (i +# subrange_lb) of [reprSizeAlign @(Stored int) repr_int]
                   boxed tyob real_index.
               
                 -- Call 'g' to compute a value, and 'f' to combine it
                 let y = initToBare @a rep (g real_index) in
                 f x y ret)))
          in
          -- Get an initial value.  The value comes from either
          -- the given accumulator or the beginning of the range.
          -- We know the range is nonempty.
          case m_acc_in of [reprSizeAlign @a rep] {
            just (b_acc_in : a).
              reduce_with_initial_value @range_N lb count b_acc_in
          ; nothing.
              case boxIntValue lb of [reprSizeAlign @(Stored int) repr_int]
                boxed tyob (first_index : Stored int).
              let b_acc_in = initToBare @a rep (g first_index) in

              reduce_with_initial_value @(minus_i range_N 1)
              (lb +# 1)
              (minus_fii @range_N @1 count one_fii)
              b_acc_in
          }
      in
      case defineIntIndex size of someIInt @(N : intindex) (count : FIInt N).
      let boxed_init : b = asbox @ma mrepr (nothing @a (reprSizeAlign @a rep)) in
      let m_result =
            boxToBare @ma mrepr
            (blocked_1d_reduce @N @b count combiner boxed_init reducer) in
      case m_result of [reprSizeAlign @a rep] {
        just (result : a). copy @a rep result ret
      ; nothing. except @Store
      }

  ; nothingVal.
      except @Store
  };

{-
parallel_list_dim_scatter @(i r : bare)
  (repr_i : Repr i) (repr_r : Repr r)
  (dom : list_dim)
  (op : Scatter r i)
  (f : Stored int -> Init i)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case op of
    mk_scatter @(s : bare) @(iniF : box) @(updF : box)
    (rep_s : Repr s)
    (initializer : iniF -> OutPtr s -> EffTok)
    (updater : updF -> i -> EffTok -> OutPtr s -> EffTok)
    (combiner : s -> s -> Init s)
    (finalizer : UpdateInPlaceFinalizer s r)
    (update_func : i -> updF)
    (init_func : iniF).

  let type bs = StuckBox s in

  letfun
    -- Version of 'combiner' for boxed objects
    boxed_combiner (x : bs) (y : bs) -> bs =
      case x of stuckBox ux.
      case y of stuckBox uy.
      stuckBox @s (combiner ux uy)
  in

  case dom of mk_list_dim (maybe_size : MaybeVal int).

  case maybe_size of {
    justVal (count : int).
      case defineIntIndex count of someIInt @(N : intindex) (size : FIInt N).

      -- Perform a parallel reduction over this range
      case blocked_1d_reduceip @N @bs size
           boxed_combiner
           (\ @(M : intindex) (start : int) (range_size : FIInt M) -> bs.
              -- Sequential reduction over this sub-range
              case range_size of fiInt (range_count : int).
              let subdom : list_dim = mk_list_dim (justVal @int range_count) in
                    
              stuckBox @s
              (partial_list_dim_scatter @i @s @iniF @updF repr_i rep_s
               initializer updater update_func init_func subdom
               (\ (sindex : Stored int) (local_ret : OutPtr i) -> Store.
                  -- Add 'start' to the index
                  case sindex of stored uindex.
                  case stuckBox @(Stored int)
                       (stored @int (uindex +# start)) of stuckBox sindex2.
                  f sindex2 local_ret))) of
        stuckBox (final_state : s).

      -- Create the final object
      finish_scatter @r @s repr_r rep_s finalizer
      (copy @s rep_s final_state) ret

  ; nothingVal.
      except @Store
  };
-}

parallel_dim1_reduce1 : forall a : bare.
     Repr a
  -> dim1
  -> (Stored int -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

parallel_dim2_reduce : forall a : bare.
     Repr a
  -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> a
  -> Init a;

parallel_dim2_reduce1 : forall a : bare.
     Repr a
  -> dim2
  -> (Tuple2 (Stored int) (Stored int) -> Init a)
  -> (a -> a -> Init a)
  -> Init a;

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Other functions

fun_undefined @(a : box) (dummy : Boxed (Stored NoneType)) -> a = except @a;

-- Convert an indexed int to a finite indexed int.  Raise an exception
-- if not finite.
fromIndInt @(N : intindex) (ii : IInt N) -> FIInt N attribute(inline) =
  case ii of {
    iInt (fii : FIInt N). fii
  ; iPosInfty. except @(FIInt N)
  ; iNegInfty. except @(FIInt N)
  };

-- A dummy boxed object that is used as a placeholder for a dead value.
deadBox : forall a : box. a;

-- A dummy referenced object that is used as a placeholder for a dead value.
deadRef : forall a : bare. Init a;

-- Do nothing to a boxed value.
-- This function is used for selectively inhibiting optimizations.
preserve : forall a : box. a -> a;

fun_isNothing @(a : box)
  (rep : Repr (AsBare a)) (x : Boxed (Maybe (AsBare a)))
  -> Boxed (Stored bool) attribute(inline) =
  let rep_maybe = unboxedinfo Maybe @(AsBare a) rep in
  case x of [reprSizeAlign @(Maybe (AsBare a)) rep_maybe] boxed tyob ux.
  case ux of [reprSizeAlign @(AsBare a) rep] {
    just value. boxBoolValue False
  ; nothing.    boxBoolValue True
  };


fun_isJust @(a : box)
  (rep : Repr (AsBare a)) (x : Boxed (Maybe (AsBare a)))
  -> Boxed (Stored bool) attribute(inline) =
  let rep_maybe = unboxedinfo Maybe @(AsBare a) rep in
  case x of [reprSizeAlign @(Maybe (AsBare a)) rep_maybe] boxed tyob ux.
  case ux of [reprSizeAlign @(AsBare a) rep] {
    just value. boxBoolValue True
  ; nothing.    boxBoolValue False
  };
  

fun_fromJust @(a : box) (rep : Repr (AsBare a)) (x : Boxed (Maybe (AsBare a)))
  -> a attribute(inline) =
  let rep_maybe = unboxedinfo Maybe @(AsBare a) rep in
  case x of [reprSizeAlign @(Maybe (AsBare a)) rep_maybe] boxed tyob ux.
  case ux of [reprSizeAlign @(AsBare a) rep] {
    just value. bareToBox @(AsBare a) rep value
  ; nothing. except @a
  };


isCons @(a : box) (rep : Repr (AsBare a)) (l : llist (AsBare a))
  -> Boxed (Stored bool) attribute(inline) =
  case l of [reprSizeAlign @(AsBare a) rep] {
    cons tyob h t. boxBoolValue True
  ; nil tyob. boxBoolValue False
  };


isNil @(a : box) (rep : Repr (AsBare a)) (l : llist (AsBare a))
  -> Boxed (Stored bool) attribute(inline) =
  case l of [reprSizeAlign @(AsBare a) rep] {
    cons tyob h t. boxBoolValue False
  ; nil tyob. boxBoolValue True
  };


head @(a : box) (rep : Repr (AsBare a)) (l : llist (AsBare a))
  -> a attribute(inline) =
  case l of [reprSizeAlign @(AsBare a) rep] {
    cons tyob h t. bareToBox @(AsBare a) rep h
  ; nil tyob. except @a
  };


tail @(a : box) (rep : Repr (AsBare a)) (l : llist (AsBare a))
  -> llist (AsBare a) attribute(inline) =
  case l of [reprSizeAlign @(AsBare a) rep] {
    cons tyob h t. t
  ; nil tyob. except @(llist (AsBare a))
  };


arr1D_build @(N : intindex) @(a : bare)
  (rep : Repr a) (size : FIInt N)
  (is_parallel : bool)
  (f : int -> Init a)
  (arr_ptr : OutPtr (arr N a))
  -> Store
  attribute(inline) =

  let sa = reprSizeAlign @a rep in

  -- Call either 'parallel_doall' or 'doall'
  if is_parallel
  then
    parallel_doall @N size
    (\ (i : int) -> Store.
       f i (subscript_out @N @a sa arr_ptr i))
  else
    doall @N size
    (\ (i : int) -> Store.
       f i (subscript_out @N @a sa arr_ptr i));


arr2D_build @(M N : intindex) @(a : bare)
  (rep : Repr a)
  (size_y : FIInt M) (size_x : FIInt N)
  (is_parallel : bool)
  (f : int -> int -> Init a)
  (arr_ptr : OutPtr (arr M (arr N a)))
  -> Store
  attribute(inline) =

  let sa = reprSizeAlign @a rep in
  let row_repr : Repr (arr N a) = unboxedinfo arr @N @a size_x rep in
  let row_sa = reprSizeAlign @(arr N a) row_repr in

  -- Call either 'parallel_doall' or 'doall'
  if is_parallel
  then
    parallel_doall @M size_y
    (\ (y : int) -> Store.
       doall @N size_x
       (\ (x : int) -> Store.
          f y x
          (subscript_out @N @a sa
           (subscript_out @M @(arr N a) row_sa arr_ptr y) x)))
  else
    doall @M size_y
    (\ (y : int) -> Store.
       doall @N size_x
       (\ (x : int) -> Store.
          f y x
          (subscript_out @N @a sa
           (subscript_out @M @(arr N a) row_sa arr_ptr y) x)));

arr3D_build @(L M N : intindex) @(a : bare)
  (rep : Repr a)
  (size_z : FIInt L)
  (size_y : FIInt M)
  (size_x : FIInt N)
  (f : int -> int -> int -> Init a)
  (arr_ptr : OutPtr (arr L (arr M (arr N a))))
  -> Store
  attribute(inline) =

  let row_repr : Repr (arr N a) = unboxedinfo arr @N @a size_x rep in
  let plane_repr : Repr (arr M (arr N a)) =
        unboxedinfo arr @M @(arr N a) size_y row_repr in
  doall @L size_z
  (\ (z : int) -> Store.
     doall @M size_y
     (\ (y : int) -> Store.
        doall @N size_x
        (\ (x : int) -> Store.
           f z y x
           (subscript_out @N @a (reprSizeAlign @a rep)
            (subscript_out @M @(arr N a) (reprSizeAlign @(arr N a) row_repr)
             (subscript_out @L @(arr M (arr N a)) (reprSizeAlign @(arr M (arr N a)) plane_repr)
              arr_ptr z) y) x))));

{- REPLACED BY NEW STREAM CODE

-- Wrapper around viewToSequence
Stream1ToSequence @(a : box) (rep : Repr (AsBare a)) (s : Stream list_dim a)
  -> Sequence a attribute(inline) =
  case s of {
    sequenceStream tyob sq. sq
  ; viewStream tyob vw. viewToSequence @(AsBare a) rep vw
  };


viewToSequence @(a : bare) (rep : Repr a) (vw : view list_dim (AsBox a))
  -> Sequence (AsBox a) attribute(inline, inline_dimensionality) =
  case vw of mk_view tyob (dom : list_dim) f.
  letfun
    bare_f (x : Stored int) (ret : OutPtr a) -> Store =
      asbare @a rep (f (bareToBox @(Stored int) repr_int x)) ret
  in
  Sequence_generate @a rep dom bare_f;


sequenceToView @(a : bare) (rep : Repr a) (sq : Sequence (AsBox a))
  -> view list_dim (AsBox a) attribute(inline, inline_dimensionality) =
  -- Write the entire sequence to a list
  let rep_list = unboxedinfo list @a in
  case initToBare @(list a) rep_list (Sequence_list_build @a rep sq) of
    make_list @(N : intindex) size ay_ref.
  let rep_arr = unboxedinfo arr @N @a size rep in
  case ay_ref of [reprSizeAlign @(arr N a) rep_arr] stuckBox tyob ay.

  -- Then traverse the list

  case size of fiInt (size_i : int).
  let dom : list_dim = con_list_dim (justVal @int size_i) in
  view_generate @list_dim ShapeDict_list_dim @(AsBox a) rep dom
  (\ (bi : Boxed (Stored int)) -> AsBox a.
     let i = unboxIntValue bi in
     bareToBox @a rep (subscript @N @a (reprSizeAlign @a rep) ay i));


-- Given a mapping from old to new domains and from new to old indices,
-- transform a view.
view_transform @(sh : box) @(a : bare)
  (rep : Repr a)
  (transform_domain : sh -> sh)
  (transform_index : AsBox (index sh) -> AsBox (index sh))
  (vw : view sh (AsBox a))
  -> view sh (AsBox a)
  attribute(inline, inline_dimensionality) =
  case vw of mk_view tyob (dom : sh) f.
  con_view @sh @(AsBox a) (transform_domain dom)
  (\ (i : AsBox (index sh)) -> AsBox a. f (transform_index i));


count : Stream list_dim (Boxed (Stored int)) attribute(inline) =
  con_viewStream @(Boxed (Stored int))
  (view_generate @list_dim ShapeDict_list_dim @(Boxed (Stored int)) repr_int
   (con_list_dim (nothingVal @int))
   (\ (i : Boxed (Stored int)) -> Boxed (Stored int). i));


-- Workaround for inlining restrictions
count_helper (dummy : NoneType) -> Stream list_dim (Boxed (Stored int))
  attribute(inline) =
  con_viewStream @(Boxed (Stored int))
  (view_generate @list_dim ShapeDict_list_dim @(Boxed (Stored int)) repr_int
   (con_list_dim (nothingVal @int))
   (\ (i : Boxed (Stored int)) -> Boxed (Stored int). i));


range (length : Boxed (Stored int)) -> Stream list_dim (Boxed (Stored int))
  attribute(inline) =
  con_viewStream @(Boxed (Stored int))
  (view_generate @list_dim ShapeDict_list_dim @(Boxed (Stored int)) repr_int
   (con_list_dim (justVal @int (unboxIntValue length)))
   (\ (i : Boxed (Stored int)) -> Boxed (Stored int). i));


singletonIter @(a : box) (rep : Repr (AsBare a)) (x : a) -> Stream list_dim a
  attribute(inline) =
  con_viewStream @a (singleton_list_dim_view @a rep x);


-- Helper function for 'singletonIter'
singleton_list_dim_view @(a : box) (rep : Repr (AsBare a)) (x : a)
  -> view list_dim a
  attribute(inline, inline_dimensionality) =
  view_generate @list_dim ShapeDict_list_dim @a rep
  (con_list_dim (justVal @int 1))
  (\ (i : Boxed (Stored int)) -> a. x);

{-

-- Helper function for stream rewriting transformations
peel_generate_bind @(a r : bare)
  (rep_a : Repr a)
  (rep_r : Repr r)
  (dom : list_dim)
  (proceed : int -> list_dim -> Init r -> Init r)
  (failure : Init r)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case dom of mk_list_dim (msize : MaybeVal int).
  case msize of {
    justVal (size : int).
      letfun
        -- Loop over each element of the domain
        loop (i : int) (ret : OutPtr r) -> Store =
          if i <# size
          then let new_dom : list_dim =
                     mk_list_dim (justVal @int (size -# i -# 1)) in

               -- Pass the index, leftover domain, and loop continuation
               -- to 'proceed'.  'proceed' will call the continuation or
               -- do its own thing.
               proceed i new_dom (loop (i +# 1)) ret
          else failure ret
      in loop 0 ret

  ; nothingVal.
      except @Store
  };


peel_generate @(a r : bare)
  (rep_a : Repr a)
  (rep_r : Repr r)
  (dom : list_dim)
  (proceed : list_dim -> Init r)
  (failure : Init r)
  (ret : OutPtr r)
  -> Store
  attribute(inline) =

  case dom of mk_list_dim (msize : MaybeVal int).
  case msize of {
    justVal (size : int).
      if size ==# 0
      then failure ret
      else let new_dom : list_dim = mk_list_dim (justVal @int (size -# 1)) in
           proceed new_dom ret

  ; nothingVal.
      except @Store
  };

-}

chain @(a : box)
  (rep : Repr (AsBare a)) (i1 : Stream list_dim a) (i2 : Stream list_dim a)
  -> Stream list_dim a
  attribute(inline) =
  case i1 of {
    viewStream tyob (v1 : view list_dim a).
      case i2 of {
        viewStream tyob (v2 : view list_dim a).
          con_viewStream @a (primitive_list_dim_chain @(AsBare a) rep v1 v2)
      ; sequenceStream tyob (s2 : Sequence a).
          con_sequenceStream @a
          (Sequence_chain @(AsBare a) rep (viewToSequence @(AsBare a) rep v1) s2)
      }
  ; sequenceStream tyob (s1 : Sequence a).
      case i2 of {
        viewStream tyob (v2 : view list_dim a).
          con_sequenceStream @a
          (Sequence_chain @(AsBare a) rep s1 (viewToSequence @(AsBare a) rep v2))
      ; sequenceStream tyob (s2 : Sequence a).
          con_sequenceStream @a
          (Sequence_chain @(AsBare a) rep s1 s2)
      }
  };

REPLACED BY NEW STREAM CODE -}


len @(t : box -> box) @(a : box)
  (is_linear : coerce @box (shape t) list_dim)
  (indexable : IndexableDict t)
  (container : t a)
  -> Boxed (Stored int)
  attribute(inline) =

  let sh = coerce @(shape t) @list_dim (ix_shape @t indexable @a container) in
  case sh of mk_list_dim tyob (list_size : MaybeVal int).
  case list_size of {
    justVal n. boxIntValue n
  ; nothingVal. except @(Boxed (Stored int))
  };


width @(t : box -> box) @(a : box)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (container : t a)
  -> Boxed (Stored int)
  attribute(inline) =

  let sh : dim2 =
        coerce @(shape t) @dim2 (ix_shape @t indexable @a container) in
  case sh of mk_dim2 tyob (dim_y : dim1) (dim_x : dim1).
  case dim_x of mk_dim1 tyob (interval lb ub) (lm : LinearMap).
  case lb of {
    justVal lb_i.
      case ub of {
        justVal ub_i. boxIntValue (ub_i -# lb_i)
      ; nothingVal. except @(Boxed (Stored int))
      }
    ; nothingVal. except @(Boxed (Stored int))
  };


height @(t : box -> box) @(a : box)
  (is_2d : coerce @box (shape t) dim2)
  (indexable : IndexableDict t)
  (container : t a)
  -> Boxed (Stored int)
  attribute(inline) =

  let sh : dim2 =
        coerce @(shape t) @dim2 (ix_shape @t indexable @a container) in
  case sh of mk_dim2 tyob (dim_y : dim1) (dim_x : dim1).
  case dim_y of mk_dim1 tyob (interval lb ub) (lm : LinearMap).
  case lb of {
    justVal (lb_i : int).
      case ub of {
        justVal ub_i. boxIntValue (ub_i -# lb_i)
      ; nothingVal. except @(Boxed (Stored int))
      }
    ; nothingVal. except @(Boxed (Stored int))
  };


safeIndex @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (rep : Repr (AsBare a))
  (container : t a)
  (ix : AsBox (index (shape t)))
  -> a
  attribute(inline) =

  let type sh = shape t in
  let container_shape = ix_shape @t indexable @a container in
  if shMember @sh shape_dict ix container_shape
  then ix_at @t indexable @a rep container ix
  else except @a;


safeSlice @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_dict : ShapeDict (shape t))
  (rep : Repr (AsBare a))
  (container : t a)
  (sl : AsBox (slice (shape t)))
  -> view (shape t) a
  attribute(inline) =

  case shSlice @(shape t) shape_dict sl
       (ix_shape @t indexable @a container) of
    (off, dom).
  let sliced_object = ix_slice @t indexable @a rep container dom off in
  someIndexableToView @(shape t) @a rep sliced_object;


rows @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (shape t) dim2)
  (rep : ReprBox a)
  (container : t a)
  -> view dim1 (view dim1 a)
  attribute(inline) =

  let at_index = ix_at @t indexable in

  case coerce @(shape t) @dim2 (ix_shape @t indexable @a container) of
    mk_dim2 tyob (shape_y : dim1) (shape_x : dim1).

  let sa_int = reprSizeAlign @(Stored int) repr_int in
  let none_val = boxNoneValue None in

  -- Create a view over all y
  build_view_real @dim1 @(view dim1 a) ShapeDict_dim1
  (real_generate_dim1 @(view dim1 a)
   (repr_Box @(view dim1 a)) none_val shape_y
   (\ (y : BoxIndex dim1) -> view dim1 a.

      -- Create a view over all x
      build_view_real @dim1 @a ShapeDict_dim1
      (real_generate_dim1 @a rep none_val shape_x
       (\ (x : BoxIndex dim1) -> a.

          -- Read from the data structure at (y, x)
          let idx = pack_index2 (unboxIntValue y) (unboxIntValue x) in
          at_index @a rep container
          (coerce @(BoxIndex dim2) @(BoxIndex (shape t)) idx)))));


outerproduct @(t u : box -> box) @(a b : box)
  (traversable_t : TraversableDict t)
  (traversable_u : TraversableDict u)
  (t_is_linear : coerce @box (shape t) dim1)
  (u_is_linear : coerce @box (shape u) dim1)
  (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b))
  (container_t : t a)
  (container_u : u b)
  -> Stream dim2 (Boxed (Tuple2 (AsBare a) (AsBare b)))
  attribute(inline) =

  case traversable_t of traversableDict tyob traverseT buildT.
  case traversable_u of traversableDict tyob traverseU buildU.

  let sa : Stream dim1 a =
        coerce @(Stream (shape t) a) @(Stream dim1 a)
        (traverseT @a repr_a container_t) in
  let sb : Stream dim1 b =
        coerce @(Stream (shape u) b) @(Stream dim1 b)
        (traverseU @b repr_b container_u) in

  outerproduct_Stream @a @b repr_a repr_b sa sb;


outerproduct_Stream @(a b : box)
  (repr_a : Repr (AsBare a)) (repr_b : Repr (AsBare b))
  (sa : Stream dim1 a)
  (sb : Stream dim1 b)
  -> Stream dim2 (Boxed (Tuple2 (AsBare a) (AsBare b)))
  attribute(inline) =

  let type Sint = Stored int in
  let type out_type = Boxed (Tuple2 (AsBare a) (AsBare b)) in
  let out_repr = unboxedinfo Tuple2 @(AsBare a) @(AsBare b) repr_a repr_b in

  case sa of stream tyob hint_a i_sa.
  case sb of stream tyob hint_b i_sb.
  let par_hint = leastParHint hint_a hint_b in

  case fromIxStream @dim1 @a i_sa of
    rStream @a2 tyob rep_a2 extractA (someIndexable @tA tyob2 co ixA containerA).
  case fromIxStream @dim1 @b i_sb of
    rStream @b2 tyob rep_b2 extractB (someIndexable @tB tyob2 co ixB containerB).

  -- Compute dimensions of the result
  let dom = con_dim2 (coerce @(shape tA) @dim1 (ix_shape @tA ixA @a2 containerA))
                     (coerce @(shape tB) @dim1 (ix_shape @tB ixB @b2 containerB)) in

  letfun
    getA (idx : BoxIndex dim1) -> a =
      extractA (ix_at @tA ixA @a2 rep_a2 containerA
                (coerce @(BoxIndex dim1) @(BoxIndex (shape tA)) idx)) in

  letfun
    getB (idx : BoxIndex dim1) -> b =
      extractB (ix_at @tB ixB @b2 rep_b2 containerB
                (coerce @(BoxIndex dim1) @(BoxIndex (shape tB)) idx)) in

  real_generate_dim2 @out_type out_repr (boxNoneValue None) dom
  (\ (idx : BoxIndex dim2) -> out_type.
     case unpack_index2 idx of (idx_y, idx_x).
     let valueA = getA (boxIntValue idx_y) in
     let valueB = getB (boxIntValue idx_x) in

     con_boxed @(Tuple2 (AsBare a) (AsBare b)) out_repr
     (tuple2 @(AsBare a) @(AsBare b)
      (reprSizeAlign @(AsBare a) repr_a)
      (reprSizeAlign @(AsBare b) repr_b)
      (asbare @(AsBare a) repr_a valueA) (asbare @(AsBare b) repr_b valueB)));


{-
  

cols @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (shape_is_dim2 : coerce @box (shape t) dim2)
  (rep : Repr (AsBare a))
  (container : t a)
  -> view dim1 (view dim1 a)
  attribute(inline) =
  case indexable of indexableDict tyob at_index get_shape.
  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 tyob (shape_y : dim1) (shape_x : dim1).

  let rep_tuple = unboxedinfo Tuple2 @(Stored int) @(Stored int) repr_int repr_int in
  let sa_int = reprSizeAlign @(Stored int) repr_int in

  view_generate @dim1
  ShapeDict_dim1 @(view dim1 a)
  (repr_Box @(view dim1 a)) shape_x
  (\ (s_x : Boxed (Stored int)) -> view dim1 a.
    view_generate @dim1
    ShapeDict_dim1 @a rep shape_y
    (\ (s_y : Boxed (Stored int)) -> a.
      let ix = con_boxed @(index dim2) rep_tuple
               (tuple2 @(Stored int) @(Stored int) sa_int sa_int
                (asbare @(Stored int) repr_int s_y)
                (asbare @(Stored int) repr_int s_x)) in
       at_index @a rep container
       (coerce @(Boxed (index dim2)) @(AsBox (index (shape t))) ix)));


-}
{-
transpose : forall t : box -> box, a : box.
            IndexableDict t
	 -> coerce @box (shape t) dim2
	 -> Repr (AsBare a)
	 -> t a -> view dim2 a;


boxedStencil2D @(t : box -> box) @(a b : box)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (output_dom : dim2)
  (stencil_dom : dim2)
  (gen_f : view dim2 a -> b)
  (input : t a)
  -> Boxed (barray2 (AsBare b))
  attribute(inline, inline_dimensionality) =

  -- This function is defined in terms of stencil2D.
  let type boxed_b = StuckRef b in
  let repr_boxed_b : Repr boxed_b = repr_StuckRef @b in

  boxed @(barray2 (AsBare b))
  (mk_barray2 @(AsBare b)
   (asbare @(array2 boxed_b) (repr_array2 @boxed_b)
    (stencil2D @t @a @(AsBox boxed_b)
     indexable is_2d repr_a repr_boxed_b
     output_dom stencil_dom
     (\ (vw : view dim2 a) -> AsBox boxed_b.

        -- Call 'gen_f' and re-box the result
        boxed @boxed_b
        (stuckRef @b (gen_f vw)))
     input)));


stencil2D @(t : box -> box) @(a b : box)
  (indexable : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (output_dom : dim2)
  (stencil_dom : dim2)
  (gen_f : view dim2 a -> b)
  (input : t a)
  -> Boxed (array2 (AsBare b))
  attribute(inline, inline_dimensionality) =

  case indexable of indexableDict at_index get_shape.

  let type return_type = Boxed (array2 (AsBare b)) in
  let input_dom : dim2 = coerce @(shape t) @dim2 (get_shape @a input) in

  case output_dom of mk_dim2 (output_dom_y : dim1) (output_dom_x : dim1).
  case output_dom_y of mk_dim1 (output_y_iv : Interval) (output_y_lm : LinearMap).
  case output_dom_x of mk_dim1 (output_x_iv : Interval) (output_x_lm : LinearMap).
  case output_y_lm of linearMap (output_y_stride : int) (output_y_align : int).
  case output_x_lm of linearMap (output_x_stride : int) (output_x_align : int).

  case input_dom of mk_dim2 (input_dom_y : dim1) (input_dom_x : dim1).
  case input_dom_y of mk_dim1 (input_y_iv : Interval) (input_y_lm : LinearMap).
  case input_dom_x of mk_dim1 (input_x_iv : Interval) (input_x_lm : LinearMap).
  case input_y_lm of linearMap (input_y_stride : int) (input_y_align : int).
  case input_x_lm of linearMap (input_x_stride : int) (input_x_align : int).

  case stencil_dom of mk_dim2 (stencil_dom_y : dim1) (stencil_dom_x : dim1).
  case stencil_dom_y of mk_dim1 (stencil_y_iv : Interval) (stencil_y_lm : LinearMap).
  case stencil_dom_x of mk_dim1 (stencil_x_iv : Interval) (stencil_x_lm : LinearMap).
  case stencil_y_lm of linearMap (stencil_y_stride : int) (stencil_y_align : int).
  case stencil_x_lm of linearMap (stencil_x_stride : int) (stencil_x_align : int).

  -- Verify that all stencil inputs are in the input domain:

  -- 1. any linear combination of output and stencil strides must be a
  -- multiple of the input stride.
  if gcd output_y_stride stencil_y_stride %# input_y_stride /=# 0
  then except @return_type else

  if gcd output_x_stride stencil_x_stride %# input_x_stride /=# 0
  then except @return_type else

  -- 2. The alignment of the output plus the alignment of the stencil must be
  --    equal to the alignment of the input, modulo the input stride.
  if (output_y_align +# stencil_y_align -# input_y_align) %# input_y_stride /=# 0
  then except @return_type else

  if (output_x_align +# stencil_x_align -# input_x_align) %# input_x_stride /=# 0
  then except @return_type else

  -- 3. The bounds of the output range plus the bounds of the stencil range
  --    must be within the bounds of the input range.
  if not (subsetInterval (convolveInterval output_y_iv stencil_y_iv) input_y_iv)
  then except @return_type else

  if not (subsetInterval (convolveInterval output_x_iv stencil_x_iv) input_x_iv)
  then except @return_type else

  -- Loop over all stencil indices
  let output_view : view dim2 b =
        view_generate @dim2 ShapeDict_dim2 @b repr_b output_dom
        (\ (ix : Boxed (index dim2)) -> b.
           case ix of boxed u_ix.
           case u_ix of tuple2 ix_y ix_x.
           case ix_y of stored o_y.
           case ix_x of stored o_x.

           -- Apply the generator function to a view of the input array
           gen_f
           (view_generate @dim2 ShapeDict_dim2 @a repr_a stencil_dom
            (\ (s_ix : Boxed (index dim2)) -> a.
               case s_ix of boxed u_s_ix.
               case u_s_ix of tuple2 s_ix_y s_ix_x.
               case s_ix_y of stored s_y.
               case s_ix_x of stored s_x.

               -- The real index is the output index plus the stencil index
               let real_ix = boxed @(index dim2)
                             (tuple2 @(Stored int) @(Stored int)
                              (stored @int (o_y +# s_y))
                              (stored @int (o_x +# s_x))) in
               at_index @a repr_a input
               (coerce @(AsBox (index dim2)) @(AsBox (index (shape t))) real_ix)))) in

  TraversableDict_array2_build @b repr_b output_view;


boxedStencil3D @(t : box -> box) @(a b : box)
  (indexable : IndexableDict t)
  (is_3d : coerce @box (shape t) dim3)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (output_dom : dim3)
  (stencil_dom : dim3)
  (gen_f : view dim3 a -> b)
  (input : t a)
  -> Boxed (barray3 (AsBare b))
  attribute(inline, inline_dimensionality) =

  -- This function is defined in terms of stencil3D.
  let type boxed_b = StuckRef b in
  let repr_boxed_b : Repr boxed_b = repr_StuckRef @b in

  boxed @(barray3 (AsBare b))
  (mk_barray3 @(AsBare b)
   (asbare @(array3 (StuckRef b)) (repr_array3 @(StuckRef b))
    (stencil3D @t @a @(AsBox (StuckRef b))
     indexable is_3d repr_a repr_boxed_b
     output_dom stencil_dom
     (\ (vw : view dim3 a) -> Boxed boxed_b.
        boxed @boxed_b (stuckRef @b (gen_f vw)))
     input)));


stencil3D @(t : box -> box) @(a b : box)
  (indexable : IndexableDict t)
  (is_3d : coerce @box (shape t) dim3)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (output_dom : dim3)
  (stencil_dom : dim3)
  (gen_f : view dim3 a -> b)
  (input : t a)
  -> Boxed (array3 (AsBare b))
  attribute(inline, inline_dimensionality) =

  case indexable of indexableDict at_index get_shape.

  let type return_type = Boxed (array3 (AsBare b)) in
  let input_dom : dim3 = coerce @(shape t) @dim3 (get_shape @a input) in

  case output_dom of mk_dim3 (output_dom_z : dim1) (output_dom_y : dim1) (output_dom_x : dim1).
  case output_dom_z of mk_dim1 (output_z_iv : Interval) (output_z_lm : LinearMap).
  case output_dom_y of mk_dim1 (output_y_iv : Interval) (output_y_lm : LinearMap).
  case output_dom_x of mk_dim1 (output_x_iv : Interval) (output_x_lm : LinearMap).
  case output_z_lm of linearMap (output_z_stride : int) (output_z_align : int).
  case output_y_lm of linearMap (output_y_stride : int) (output_y_align : int).
  case output_x_lm of linearMap (output_x_stride : int) (output_x_align : int).

  case input_dom of mk_dim3 (input_dom_z : dim1) (input_dom_y : dim1) (input_dom_x : dim1).
  case input_dom_z of mk_dim1 (input_z_iv : Interval) (input_z_lm : LinearMap).
  case input_dom_y of mk_dim1 (input_y_iv : Interval) (input_y_lm : LinearMap).
  case input_dom_x of mk_dim1 (input_x_iv : Interval) (input_x_lm : LinearMap).
  case input_z_lm of linearMap (input_z_stride : int) (input_z_align : int).
  case input_y_lm of linearMap (input_y_stride : int) (input_y_align : int).
  case input_x_lm of linearMap (input_x_stride : int) (input_x_align : int).

  case stencil_dom of mk_dim3 (stencil_dom_z : dim1) (stencil_dom_y : dim1) (stencil_dom_x : dim1).
  case stencil_dom_z of mk_dim1 (stencil_z_iv : Interval) (stencil_z_lm : LinearMap).
  case stencil_dom_y of mk_dim1 (stencil_y_iv : Interval) (stencil_y_lm : LinearMap).
  case stencil_dom_x of mk_dim1 (stencil_x_iv : Interval) (stencil_x_lm : LinearMap).
  case stencil_z_lm of linearMap (stencil_z_stride : int) (stencil_z_align : int).
  case stencil_y_lm of linearMap (stencil_y_stride : int) (stencil_y_align : int).
  case stencil_x_lm of linearMap (stencil_x_stride : int) (stencil_x_align : int).

  -- Verify that all stencil inputs are in the input domain:

  -- 1. any linear combination of output and stencil strides must be a
  -- multiple of the input stride.
  if gcd output_z_stride stencil_z_stride %# input_z_stride /=# 0
  then except @return_type else

  if gcd output_y_stride stencil_y_stride %# input_y_stride /=# 0
  then except @return_type else

  if gcd output_x_stride stencil_x_stride %# input_x_stride /=# 0
  then except @return_type else

  -- 2. The alignment of the output plus the alignment of the stencil must be
  --    equal to the alignment of the input, modulo the input stride.
  if (output_z_align +# stencil_z_align -# input_z_align) %# input_z_stride /=# 0
  then except @return_type else

  if (output_y_align +# stencil_y_align -# input_y_align) %# input_y_stride /=# 0
  then except @return_type else

  if (output_x_align +# stencil_x_align -# input_x_align) %# input_x_stride /=# 0
  then except @return_type else

  -- 3. The bounds of the output range plus the bounds of the stencil range
  --    must be within the bounds of the input range.
  if not (subsetInterval (convolveInterval output_z_iv stencil_z_iv) input_z_iv)
  then except @return_type else

  if not (subsetInterval (convolveInterval output_y_iv stencil_y_iv) input_y_iv)
  then except @return_type else

  if not (subsetInterval (convolveInterval output_x_iv stencil_x_iv) input_x_iv)
  then except @return_type else

  -- Loop over all stencil indices
  let type Sint = Stored int in
  let output_view : view dim3 b =
        view_generate @dim3 ShapeDict_dim3 @b repr_b output_dom
        (\ (ix : Boxed (index dim3)) -> b.
           case ix of boxed u_ix.
           case u_ix of tuple3 ix_z ix_y ix_x.
           case ix_z of stored o_z.
           case ix_y of stored o_y.
           case ix_x of stored o_x.

           -- Apply the generator function to a view of the input array
           gen_f
           (view_generate @dim3 ShapeDict_dim3 @a repr_a stencil_dom
            (\ (s_ix : Boxed (index dim3)) -> a.
               case s_ix of boxed u_s_ix.
               case u_s_ix of tuple3 s_ix_z s_ix_y s_ix_x.
               case s_ix_z of stored s_z.
               case s_ix_y of stored s_y.
               case s_ix_x of stored s_x.

               -- The real index is the output index plus the stencil index
               let real_index = boxed @(index dim3)
                                (tuple3 @Sint @Sint @Sint
                                 (stored @int (o_z +# s_z))
                                 (stored @int (o_y +# s_y))
                                 (stored @int (o_x +# s_x))) in
               at_index @a repr_a input
               (coerce @(AsBox (index dim3)) @(AsBox (index (shape t))) real_index)))) in

  TraversableDict_array3_build @b repr_b output_view;


extend2D @(t : box -> box) @(a : box)
  (indexable_dict : IndexableDict t)
  (is_2d : coerce @box (shape t) dim2)
  (rep : Repr (AsBare a))
  (container : t a)
  -> view dim2 a
  attribute(inline, inline_sequential) =
  case indexable_dict of indexableDict at_index get_shape.

  let type Sint = Stored int in
  case coerce @(shape t) @dim2 (get_shape @a container) of
    mk_dim2 (dim_y : dim1) (dim_x : dim1).
  case dim_y of mk_dim1 (y_interval : Interval) (y_linear_map : LinearMap).
  case y_interval of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case y_linear_map of linearMap (stride_y : int) (alignment_y : int).
  case dim_x of mk_dim1 (x_interval : Interval) (x_linear_map : LinearMap).
  case x_interval of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case x_linear_map of linearMap (stride_x : int) (alignment_x : int).

  -- Input must be nonempty
  if or (case lb_y of {
           justVal (lb_y_i : int).
             case ub_y of {
               justVal (ub_y_i : int). lb_y_i ==# ub_y_i
             ; nothingVal. False
             }
         ; nothingVal. False
         })
         (case lb_x of {
           justVal (lb_x_i : int).
             case ub_x of {
               justVal (ub_x_i : int). lb_x_i ==# ub_x_i
             ; nothingVal. False
             }
         ; nothingVal. False
         })
  then except @(view dim2 a) else

  -- Create a view with no bounds
  let unbounded_interval : Interval =
        interval (nothingVal @int) (nothingVal @int) in
  let dom : dim2 =
        mk_dim2 (mk_dim1 unbounded_interval y_linear_map)
                (mk_dim1 unbounded_interval x_linear_map) in

  mk_view @dim2 @a dom
  (\ (ix : Boxed (Tuple2 Sint Sint)) -> a.
     case ix of boxed u_ix.
     case u_ix of tuple2 sy sx.
     case sy of stored y.
     case sx of stored x.

     -- Coerce the x and y indices to be in bounds
     letfun
       coerce_to_bounds
         (i : int) (lb : MaybeVal int) (ub : MaybeVal int) (stride : int)
         -> int =
         letfun
           coerce_upper (dummy : NoneType) -> int =
             case ub of {
               justVal (ub_i : int).
                 if i >=# ub_i then ub_i -# stride else i
             ; nothingVal. i
             } in
         case lb of {
           justVal (lb_i : int).
             if i <# lb_i then lb_i else coerce_upper None
         ; nothingVal. coerce_upper None
         } in
     let real_y : int = coerce_to_bounds y lb_y ub_y stride_y in
     let real_x : int = coerce_to_bounds x lb_x ub_x stride_x in

     -- Create new index
     let inbounds_ix = boxed @(Tuple2 Sint Sint)
          (tuple2 @Sint @Sint
           (stored @int real_y) (stored @int real_x)) in
     at_index @a rep container
     (coerce @(AsBox (index dim2)) @(AsBox (index (shape t))) inbounds_ix));


extend3D @(t : box -> box) @(a : box)
  (indexable : IndexableDict t)
  (is_3d : coerce @box (shape t) dim3)
  (rep : Repr (AsBare a))
  (container : t a)
  -> view dim3 a
  attribute(inline, inline_sequential) =
  case indexable of indexableDict at_index get_shape.

  case coerce @(shape t) @dim3 (get_shape @a container) of
    mk_dim3 (dim_z : dim1) (dim_y : dim1) (dim_x : dim1).
  case dim_z of mk_dim1 (z_interval : Interval) (z_linear_map : LinearMap).
  case z_interval of interval (lb_z : MaybeVal int) (ub_z : MaybeVal int).
  case z_linear_map of linearMap (stride_z : int) (alignment_z : int).
  case dim_y of mk_dim1 (y_interval : Interval) (y_linear_map : LinearMap).
  case y_interval of interval (lb_y : MaybeVal int) (ub_y : MaybeVal int).
  case y_linear_map of linearMap (stride_y : int) (alignment_y : int).
  case dim_x of mk_dim1 (x_interval : Interval) (x_linear_map : LinearMap).
  case x_interval of interval (lb_x : MaybeVal int) (ub_x : MaybeVal int).
  case x_linear_map of linearMap (stride_x : int) (alignment_x : int).

  -- Input must be nonempty
  if or (case lb_z of {
           justVal (lb_z_i : int).
             case ub_z of {
               justVal (ub_z_i : int). lb_z_i ==# ub_z_i
             ; nothingVal. False
             }
         ; nothingVal. False
         })
        (or (case lb_y of {
               justVal (lb_y_i : int).
                 case ub_y of {
                   justVal (ub_y_i : int). lb_y_i ==# ub_y_i
                 ; nothingVal. False
                 }
             ; nothingVal. False
             })
             (case lb_x of {
               justVal (lb_x_i : int).
                 case ub_x of {
                   justVal (ub_x_i : int). lb_x_i ==# ub_x_i
                 ; nothingVal. False
                 }
             ; nothingVal. False
             }))
  then except @(view dim3 a) else

  -- Create a view with no bounds
  let unbounded_interval : Interval =
        interval (nothingVal @int) (nothingVal @int) in
  let dom : dim3 =
        mk_dim3 (mk_dim1 unbounded_interval z_linear_map)
                (mk_dim1 unbounded_interval y_linear_map)
                (mk_dim1 unbounded_interval x_linear_map) in

  let type Sint = Stored int in
  mk_view @dim3 @a dom
  (\ (ix : Boxed (Tuple3 Sint Sint Sint)) -> a.
     case ix of boxed u_ix.
     case u_ix of tuple3 sz sy sx.
     case sz of stored z.
     case sy of stored y.
     case sx of stored x.

     -- Coerce the indices to be in bounds
     letfun
       coerce_to_bounds
         (i : int) (lb : MaybeVal int) (ub : MaybeVal int) (stride : int)
         -> int =
         letfun
           coerce_upper (dummy : NoneType) -> int =
             case ub of {
               justVal (ub_i : int).
                 if i >=# ub_i then ub_i -# stride else i
             ; nothingVal. i
             } in
         case lb of {
           justVal (lb_i : int).
             if i <# lb_i then lb_i else coerce_upper None
         ; nothingVal. coerce_upper None
         } in
     let real_z : int = coerce_to_bounds z lb_z ub_z stride_z in
     let real_y : int = coerce_to_bounds y lb_y ub_y stride_y in
     let real_x : int = coerce_to_bounds x lb_x ub_x stride_x in

     -- Create new index
     let inbounds_ix = boxed @(Tuple3 Sint Sint Sint)
                       (tuple3 @Sint @Sint @Sint
                        (stored @int real_z) (stored @int real_y) (stored @int real_x)) in
     at_index @a rep container
     (coerce @(AsBox (index dim3)) @(AsBox (index (shape t))) inbounds_ix));


-- Take the union of an inner and outer view
unionView3D @(a : box) (rep : Repr (AsBare a))
  (inner : view dim3 a) (edge : view dim3 a)
  -> view dim3 a attribute(inline, inline_dimensionality) =

  case inner of mk_view (inner_dom : dim3) inner_f.
  case edge of mk_view (edge_dom : dim3) edge_f.

  case inner_dom of mk_dim3 (inner_dom_z : dim1) (inner_dom_y : dim1) (inner_dom_x : dim1).
  case inner_dom_z of mk_dim1 (inner_z_iv : Interval) (inner_z_lm : LinearMap).
  case inner_dom_y of mk_dim1 (inner_y_iv : Interval) (inner_y_lm : LinearMap).
  case inner_dom_x of mk_dim1 (inner_x_iv : Interval) (inner_x_lm : LinearMap).
  case inner_z_lm of linearMap (inner_z_stride : int) (inner_z_align : int).
  case inner_y_lm of linearMap (inner_y_stride : int) (inner_y_align : int).
  case inner_x_lm of linearMap (inner_x_stride : int) (inner_x_align : int).

  case edge_dom of mk_dim3 (edge_dom_z : dim1) (edge_dom_y : dim1) (edge_dom_x : dim1).
  case edge_dom_z of mk_dim1 (edge_z_iv : Interval) (edge_z_lm : LinearMap).
  case edge_dom_y of mk_dim1 (edge_y_iv : Interval) (edge_y_lm : LinearMap).
  case edge_dom_x of mk_dim1 (edge_x_iv : Interval) (edge_x_lm : LinearMap).
  case edge_z_lm of linearMap (edge_z_stride : int) (edge_z_align : int).
  case edge_y_lm of linearMap (edge_y_stride : int) (edge_y_align : int).
  case edge_x_lm of linearMap (edge_x_stride : int) (edge_x_align : int).

  -- Verify that the inner domain is a subset of the outer domain.
  -- The outer domain's stride must divide the inner domain's stride.
  if inner_z_stride %# edge_z_stride /=# 0
  then except @(view dim3 a) else

  if inner_y_stride %# edge_y_stride /=# 0
  then except @(view dim3 a) else

  if inner_x_stride %# edge_x_stride /=# 0
  then except @(view dim3 a) else

  -- The outer domain's stride must divide the difference in alignments.
  if (edge_z_align -# inner_z_align) %# edge_z_stride /=# 0
  then except @(view dim3 a) else

  if (edge_y_align -# inner_y_align) %# edge_y_stride /=# 0
  then except @(view dim3 a) else

  if (edge_x_align -# inner_x_align) %# edge_x_stride /=# 0
  then except @(view dim3 a) else

  -- THe inner domain's interval is a subset of the outer domain's interval
  if not (subsetInterval inner_x_iv edge_x_iv)
  then except @(view dim3 a) else

  if not (subsetInterval inner_y_iv edge_y_iv)
  then except @(view dim3 a) else

  if not (subsetInterval inner_z_iv edge_z_iv)
  then except @(view dim3 a) else

  let type Sint = Stored int in

  -- If an element of the new map is an element of the inner view,
  -- its value is the inner view's; otherwise it is the outer view's
  view_generate @dim3 ShapeDict_dim3 @a rep edge_dom
  (\ (ix : Boxed (Tuple3 Sint Sint Sint)) -> a.

    case ix of boxed u_ix.
    case u_ix of tuple3 sz sy sx.
    case sz of stored z.
    case sy of stored y.
    case sx of stored x.

    -- Is this part of the inner view?
    let in_stride : bool =
          and (and (inLM z inner_z_lm) (inLM y inner_y_lm))
              (inLM x inner_x_lm) in
    let in_interval : bool =
          and (and (inInterval z inner_z_iv) (inInterval y inner_y_iv))
              (inInterval x inner_x_iv) in

    if and in_stride in_interval
    then inner_f ix
    else edge_f ix);


permute1D @(t : box -> box) @(a : box)
  (shape_dict : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep_s : Repr (AsBare (t a)))
  (rep_a : Repr (AsBare a))
  (dom : dim1)
  (src : t (Boxed (Tuple2 (Stored int) (AsBare a))))
  -> Boxed (array1 (AsBare a))
  attribute(inline) =

  let type indexval = Tuple2 (Stored int) (AsBare a) in

  let type sh = shape t in
  case traversable of traversableDict traverse build.

  case shape_dict of
    shapeDict index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  let rep_tuple : Repr indexval =
        repr_Tuple2 @(Stored int) @(AsBare a) repr_int rep_a in

  -- Do a sequential in-place update
  case shape_flatten @(AsBox indexval)
       rep_tuple (traverse @(AsBox indexval) rep_tuple src) of {
    viewStream vw.
      boxed @(array1 (AsBare a))
      (permute1D_list_dim @(AsBare a) rep_a dom vw)

  ; sequenceStream sq.
      boxed @(array1 (AsBare a))
      (Sequence_permute1D @(AsBare a) rep_a dom sq)
  };


boxedPermute1D @(t : box -> box) @(a : box)
  (shape_dict : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (rep_s : Repr (AsBare (t a)))
  (rep_a : Repr (AsBare a))
  (dom : dim1)
  (src : t (Boxed (Tuple2 (Stored int) (AsBare a))))
  -> Boxed (barray1 (AsBare a))
  attribute(inline) =

  let type indexval = Tuple2 (Stored int) (AsBare a) in

  let type sh = shape t in
  case traversable of traversableDict traverse build.

  case shape_dict of
    shapeDict index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  let rep_tuple : Repr indexval =
        repr_Tuple2 @(Stored int) @(AsBare a) repr_int rep_a in

  -- Do a sequential in-place update
  case shape_flatten @(AsBox indexval)
       rep_tuple (traverse @(AsBox indexval) rep_tuple src) of {
    viewStream vw.
      boxed @(barray1 (AsBare a))
      (boxedPermute1D_list_dim @(AsBare a) rep_a dom vw)

  ; sequenceStream sq.
      boxed @(barray1 (AsBare a))
      (Sequence_boxedPermute1D @(AsBare a) rep_a dom sq)
  };


fun_scatter @(t : box -> box) @(i r : box)
  (shape_dict : ShapeDict (shape t))
  (traversable : TraversableDict t)
  (repr_s : Repr (AsBare (t i)))
  (repr_i : Repr (AsBare i))
  (repr_r : Repr (AsBare r))
  (op : Scatter (AsBare r) (AsBare i))
  (src : t i)
  -> r
  attribute(inline) =

  let type sh = shape t in
  case traversable of traversableDict traverse build.

  case shape_dict of
    shapeDict index_repr slice_repr
    shape_member shape_intersect shape_flatten shape_generate
    shape_map shape_zipWith shape_zipWith3 shape_zipWith4 shape_slice.

  -- Do a sequential in-place update
  case shape_flatten @i repr_i (traverse @i repr_i src) of {
    viewStream vw.
      asbox @(AsBare r) repr_r
      (scatter_list_dim @(AsBare i) @(AsBare r) repr_i repr_r op vw)

  ; sequenceStream sq.
      asbox @(AsBare r) repr_r
      (Sequence_scatter @(AsBare i) @(AsBare r) repr_i repr_r op sq)
  };


histogram @(sh : box)
  (shape_dict : ShapeDict sh)
  (lo_bound : Boxed (Stored int))
  (hi_bound : Boxed (Stored int))
  (input : Stream sh (Boxed (Stored int)))
  -> Boxed (array1 (Stored int))
  attribute(inline) =

  let type Sint = Stored int in
  let type SNone = Stored NoneType in
  let sr : Scatter (array1 Sint) (Tuple2 Sint SNone) =
        array1Scatter @(AsBox Sint) @(AsBox SNone)
        repr_NoneType
        repr_int
        (mk_dim1 (interval (justVal @int (unboxIntValue lo_bound))
                           (justVal @int (unboxIntValue hi_bound)))
                 (linearMap 1 0))
        countingScatter in

  let traversable =
        traversableDict @(Stream sh)
        (\ @(a : box) (rep : Repr (AsBare a)) (x : Stream sh a)
           -> Stream sh a. x)
        (\ @(a : box) (rep : Repr (AsBare a)) (x : Stream sh a)
           -> Stream sh a. x) in

  -- For each input value x, create a tuple (x, None)
  let tupled_input =
        fun_map @(Stream sh)
                @(Boxed Sint) @(Boxed (Tuple2 Sint SNone))
                traversable
                shape_dict
                repr_int
                (repr_Tuple2 @Sint @SNone repr_int repr_NoneType)
                (\ (x : Boxed Sint) -> Boxed (Tuple2 Sint SNone).
                  boxed @(Tuple2 Sint SNone)
                  (tuple2 @Sint @SNone (asbare @Sint repr_int x)
                                       (stored @NoneType None)))
                input in

  fun_scatter @(Stream sh)
  @(Boxed (Tuple2 Sint SNone)) @(Boxed (array1 Sint))
  shape_dict
  traversable
  (repr_Box @(Stream sh (Boxed (Tuple2 Sint SNone))))
  (repr_Tuple2 @Sint @SNone repr_int repr_NoneType)
  (repr_array1 @(Stored int))
  sr
  tupled_input;

-------------------------------------------------------------------------------
-- Other rewritable functions

-}

{- REPLACED BY NEW STREAM CODE

Stream1_return @(a : box) (rep : Repr (AsBare a)) (x : a) -> Stream1 a
  attribute(inline) =
  con_sequenceStream @a
  (Sequence_return @(AsBare a) rep (asbare @(AsBare a) rep x));


Stream1_guard @(a : box)
  (rep : Repr (AsBare a))
  (condition : Boxed (Stored bool))
  (s : Stream1 a)
  -> Stream1 a
  attribute(inline) =
  let sq = Stream1ToSequence @a rep s in
  con_sequenceStream @a (Sequence_guard @(AsBare a) rep (unboxBoolValue condition) sq);


Stream1_bind @(a b : box)
  (repr_a : Repr (AsBare a))
  (repr_b : Repr (AsBare b))
  (s : Stream1 a)
  (t : a -> Stream1 b)
  -> Stream1 b
  attribute(inline) =
  let sq = Stream1ToSequence @a repr_a s in
  letfun
    sq_t (x : a) -> Sequence b = Stream1ToSequence @b repr_b (t x)
  in
  
  con_sequenceStream @b (Sequence_bind @(AsBare a) @(AsBare b) repr_a sq sq_t);


Sequence_empty @(a : bare) (rep : Repr a) -> Sequence (AsBox a)
  attribute(inline, inline_final) =
  let type st = Boxed (Stored NoneType) in
  con_sequence @(AsBox a) @st (boxNoneValue None)
  (\ (x : st) -> StreamNext st (AsBox a). streamEmpty @st @(AsBox a));


Sequence_return @(a : bare)
  (rep : Repr a)
  (ret : Init a)
  -> Sequence (AsBox a)
  attribute(inline, inline_final) =
  let type st = Boxed (Stored bool) in
  con_sequence @(AsBox a) @st
  (boxBoolValue False)
  (\ (depleted : st) -> StreamNext st (AsBox a).
     if unboxBoolValue depleted
     then streamEmpty @st @(AsBox a)
     else streamValue @st @(AsBox a)
     	  (boxBoolValue True)
	  (asbox @a rep ret));


Sequence_chain @(a : bare)
  (rep : Repr a)
  (s1 : Sequence (AsBox a))
  (s2 : Sequence (AsBox a))
  -> Sequence (AsBox a)
  attribute(inline, inline_final) =
  -- Create a stream consisting of all contents of s1 followed by all contents
  -- of s2
  case s1 of sequence @(state1 : box) tyob (s1 : state1) f1.
  case s2 of sequence @(state2 : box) tyob (s2 : state2) f2.

  let type state = ChainState state1 state2 in
  con_sequence @(AsBox a) @state (chainFromFirst @state1 @state2 (boxedinfo chainFromFirst @state1 @state2) s1 s2)
  (\ (s : state) -> StreamNext state (AsBox a).
     letfun
       pull_from_second (s2 : state2) -> StreamNext state (AsBox a) =
         -- Pull from second stream
         case f2 s2 of {
           streamValue (new_s2 : state2) (result : AsBox a).
             streamValue @state @(AsBox a) (chainFromNext @state1 @state2 (boxedinfo chainFromNext @state1 @state2) new_s2) result
         ; streamEmpty.
             streamEmpty @state @(AsBox a)
         } in
     case s of {
       chainFromFirst tyob (s1 : state1) (s2 : state2).
         -- Pull from first stream
         case f1 s1 of {
           streamValue (new_s1 : state1) (result : AsBox a).
             streamValue @state @(AsBox a) (chainFromFirst @state1 @state2 (boxedinfo chainFromFirst @state1 @state2) new_s1 s2) result
         ; streamEmpty.
             pull_from_second s2
         }
     ; chainFromNext tyob (s2 : state2).
         pull_from_second s2
     });


Sequence_guard @(a : bare)
  (rep : Repr a) (condition : bool) (s : Sequence (AsBox a)) -> Sequence (AsBox a)
  attribute(inline) =
  if condition then s else Sequence_empty @a rep;


Sequence_bind @(bare_a bare_b : bare)
  (rep : Repr bare_a)
  (src : Sequence (AsBox bare_a))
  (trans : AsBox bare_a -> Sequence (AsBox bare_b))
  -> Sequence (AsBox bare_b)
  attribute(inline, inline_final) =
  case src of sequence @(src_st : box) tyob src_state src_next.

  let type a = AsBox bare_a in
  let type b = AsBox bare_b in
  let type bind_state = BindState src_st a b in

  letfun {
    next_from_source (src_state : src_st) -> StreamNext bind_state b =
      case src_next src_state of {
        streamValue src_next_state src_value.
	  case trans src_value of
	    sequence @(trans_st : box) tyob trans_state trans_next.
	  next_from_trans @trans_st src_next_state trans_state trans_next
      ; streamEmpty.
	  streamEmpty @bind_state @b
      };

    next_from_trans @(trans_st : box)
      (src_state : src_st)
      (trans_state : trans_st)
      (trans_next : trans_st -> StreamNext trans_st b)
      -> StreamNext bind_state b =
      case trans_next trans_state of {
        streamValue trans_next_state trans_value.
          let next_state : bind_state =
	        bindFromTrans @src_st @a @b @trans_st
                (boxedinfo bindFromTrans @src_st @a @b)
		src_state trans_next_state trans_next in
          streamValue @bind_state @b next_state trans_value
      ; streamEmpty.
	  next_from_source src_state
      };

    next (state : bind_state) -> StreamNext bind_state b =
      case state of {
        bindFromSource tyob (src_state : src_st).
	  next_from_source src_state
      ; bindFromTrans @(trans_st : box) tyob
      	(src_state : src_st)
	(trans_state : trans_st)
	(trans_next : trans_st -> StreamNext trans_st b).
	  next_from_trans @trans_st src_state trans_state trans_next
      }
  } in

  con_sequence @b @bind_state
  (bindFromSource @src_st @a @b
   (boxedinfo bindFromSource @src_st @a @b) src_state)
  next;


-- A fused version of 'bind' and 'generate'.
Sequence_generate_bind @(a : bare)
  (shp : list_dim) (transformer : Boxed (Stored int) -> Sequence (AsBox a))
  -> Sequence (AsBox a)
  attribute(inline, inline_final) =
  Sequence_bind @(Stored int) @a repr_int
  (Sequence_generate @(Stored int) repr_int shp (copy @(Stored int) repr_int))
  transformer;

{-
view_array1_build : forall a : bare.
                    Repr a
                 -> view dim1 (AsBox a)
                 -> Init (array1 a);
-}

Sequence_list_build @(a : bare)
  (rep : Repr a) (sq : Sequence (AsBox a)) (ret : OutPtr (list a))
  -> Store
  attribute(inline, inline_sequential) =

  let type acc = Stored (ListBuilder a) in
  let repr_acc : Repr acc = repr_Stored @(ListBuilder a) (unboxedinfo ListBuilder @a) in

  -- Build a list by repeatedly appending to it
  append_build_list @a rep
  (\ (writer : Init a -> ListBuilder a -> ListBuilder a)
     (init_state : ListBuilder a)
     -> ListBuilder a.
     case con_stuckBox @acc repr_acc (stored @(ListBuilder a) init_state) of
       [reprSizeAlign @acc repr_acc]
       stuckBox tyob (stored_init_state : acc).

     -- The list-building process is a fold
     case con_stuckBox @acc repr_acc
          (Sequence_fold @a @acc rep repr_acc
           (\ (local_state : acc) (item : a) (ret : OutPtr acc) -> Store.
              case local_state of
                stored (u_local_state : ListBuilder a).

              -- Call the writer to save this value to the list
              let u_new_state : ListBuilder a =
                    writer (copy @a rep item) u_local_state in

              stored @(ListBuilder a) u_new_state ret)
           stored_init_state
           sq) of [reprSizeAlign @acc repr_acc]
       stuckBox tyob (stored_final_state : acc).
       case stored_final_state of stored final_state.
       final_state)
  ret;


Sequence_array1_build : forall a : bare.
		        Repr a
		     -> Sequence (AsBox a)
		     -> Init (array1 a);

llist_fold @(a r : bare)
  (repr_a : Repr a)
  (repr_r : Repr r)
  (f : a -> r -> Init r)
  (init : r)
  (source : llist a)
  (ret : OutPtr r)
  -> Store attribute(inline, inline_final) =

  letfun
    go (source : llist a) (acc : r) (ret : OutPtr r) -> Store =
      case source of {
        cons (h : a) (t : llist a).
          case stuckBox @r (f h acc) of [reprSizeAlign @r repr_r]
            stuckBox new_acc.
          go t new_acc ret
      ; nil. copy @r repr_r acc ret
      } in

  go source init ret;

REPLACED BY NEW STREAM CODE -}

-------------------------------------------------------------------------------
-- Loops


-- Distribute the given indexable object into up to n parts, and apply
-- a function to each part to crae a thunk.
-- If the object cannot be split into n parts, the list will be shorter than n.
distribute @(N : intindex) @(d : box) @(a b : box)
  (rep : ReprBox a)
  (shape_dict : ShapeDict d) (n : FIInt N) (dat : SomeIndexable d a)
  (f : SomeIndexable d a -> NoneType -> b)
  -> llist (Tuple2 (offset d) (AsBare (NoneType -> b)))
  attribute(inline) =

  let type list_elt = Tuple2 (offset d) (AsBare (NoneType -> b)) in

  let rep_offset = shRepOffset @d shape_dict in
  let rep_fn = unboxedinfo Ref @(NoneType -> b) in
  let rep_list_elt =
        unboxedinfo Tuple2 @(offset d) @(Ref (NoneType -> b))
        rep_offset rep_fn in
  let sa_list_elt = reprSizeAlign @list_elt rep_list_elt in

  case dat of someIndexable @t tyob co indexable_dict x.

  letfun {
    one (off : BoxOffset d) (dom : d) (tl : llist list_elt)
      -> llist list_elt =

      let dom_ = coerce @d @(shape t) dom in
      let off_ = coerce @(AsBox (offset d)) @(AsBox (offset (shape t))) off in
      let sliced_object =
            coerce @(SomeIndexable (shape t) a) @(SomeIndexable d a)
            (ix_slice @t indexable_dict @a rep x dom_ off_) in
      let list_head =
            tuple2 @(offset d) @(Ref (NoneType -> b))
            (reprSizeAlign @(offset d) rep_offset)
            (reprSizeAlign @(Ref (NoneType -> b)) rep_fn)
            (asbare @(offset d) rep_offset off)
            (ref @(NoneType -> b) (f sliced_object)) in

      con_cons @list_elt rep_list_elt list_head tl

  ; fill (count : int) (off : BoxOffset d) (dom : d) (tl : llist list_elt)
      -> llist list_elt =

      -- Handle zero outputs
      if count ==# 0
      then tl

      -- For one output, use the current domain and offset
      else if count ==# 1
      then one off dom tl

      -- Handle other cases by splitting the domain
      else case shSplit @d shape_dict dom of {
        justVal (d1, delta_offset, d2).
          let first_half = count //# 2 in
          let second_half = count -# first_half in
          let off2 = shAddOffset @d shape_dict off delta_offset in

          -- Continue splitting each subdomain
          fill first_half off d1 (fill second_half off2 d2 tl)

      ; nothingVal.
          -- Could not split the domain
          one off dom tl
      }
  }
  in

  -- Split the domain until enough pieces are produced
  let dom = coerce @(shape t) @d (ix_shape @t indexable_dict @a x) in

  case n of fiInt n_int.
  fill n_int (shNoOffset @d shape_dict) dom (con_nil @list_elt rep_list_elt);


-- A loop with no dependences
doall : forall n : intindex. FIInt n -> (int -> Store) -> Store;

-- A mutating loop with no dependences
doall_mutable : forall n : intindex.
                FIInt n
             -> (int -> Store -> Store)
             -> Store -> Store;

-- A distributed doall loop
farm : forall N : intindex, a : box.
       FIInt N
    -> TypeObject (StuckBox (arr N (StuckRef a)))
    -> bool
    -> StuckBox (arr N (Ref (NoneType -> a)))
    -> StuckBox (arr N (StuckRef a));

-- Sequential loop
for @(N : intindex) @(acc : bare)
  (rep : Repr acc) (count : FIInt N) (init : acc)
  (f : int -> acc -> Init acc) (ret : OutPtr acc)
  -> Store
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of fiInt (bound : int).

  -- Main loop
  letfun
    loop (i : int) (x : acc) (r : OutPtr acc) -> Store =
      if i ==# bound
      then copy @acc rep x r
      else case con_stuckBox @acc rep (f i x) of [reprSizeAlign @acc rep]
             stuckBox tyob y.
           loop (i +# 1) y r
  in loop 0 init ret;


for_box @(N : intindex) @(acc : box)
  (count : FIInt N)
  (init : acc)
  (f : int -> acc -> acc)
  -> acc
  attribute(inline, inline_final) =

  -- Unpack the indexed int
  case count of fiInt (bound : int).

  -- Main loop
  letfun
    loop (i : int) (x : acc) -> acc =
      if i ==# bound
      then x
      else loop (i +# 1) (f i x)
  in loop 0 init;


parallel_doall @(N : intindex)
  (count : FIInt N)
  (f : int -> Store)
  -> Store
  attribute(inline, inline_sequential) =

  letfun
    do_range @(M : intindex)
      (lb : int) (range_count : FIInt M)
      -> Store =
    doall @M range_count
    (\ (range_i : int) -> Store. f (range_i +# lb))
  in
  blocked_doall @N count do_range;


parallel_doall2 : forall M N : intindex.
        FIInt M
     -> FIInt N
     -> (int -> int -> Store)
     -> Store;

{-
-- Blocked parallel reduction, implemented in low-level.
blocked_1d_reduce :
    forall N : intindex, acc : box.
    FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> acc			-- Initial value
 -> (forall M : intindex. int -> FIInt M -> acc -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked 2D parallel reduction
blocked_2d_reduce :
    forall M N : intindex, acc : box.
    FIInt M		-- Size of range
 -> FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> acc			-- Initial value
 -> (forall M N : intindex. int -> FIInt M -> int -> FIInt N -> acc -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;

-- Blocked parallel in-place reduction, implemented in low-level.

blocked_1d_reduceip :
    forall N : intindex, acc : box.
    FIInt N		-- Size of range
 -> (acc -> acc -> acc) -- Reducer
 -> (forall M : intindex. int -> FIInt M -> acc)
    -- ^ Generate and combine a value on a part of the domain
 -> acc;
-}

-- Blocked parallel loop
blocked_doall :
    forall N : intindex.
    FIInt N
 -> (forall M : intindex. int -> FIInt M -> Store)
 -> Store;

-- Blocked 2D parallel loop
blocked_doall2 :
    forall M N : intindex.
    FIInt M
 -> FIInt N
 -> (forall M N : intindex. int -> FIInt M -> int -> FIInt N -> Store)
 -> Store;

-- General parallel reduction
blocked_greduce :
    forall d a : box.
    BoxOffset d                         -- Identity offset
 -> (BoxOffset d -> d -> MaybeVal (d, BoxOffset d, d)) -- Split and add offset
 -> (a -> a -> a)                       -- Combine
 -> (BoxOffset d -> d -> a)             -- Reduce
 -> (NoneType -> a)                     -- Unit (as a thunk)
 -> d                                   -- Domain
 -> a;                                  -- Result

-- Blocked parallel loop over a PBTree
blocked_PBTree_doall :
    forall a b : bare.
    PBTree a
 -> (int -> PBTree a -> Store)
 -> Store;




-------------------------------------------------------------------------------
-- Sequences

-- A sequence of values.
-- This data structure is based on the "Stream Fusion" paper.
data Seq (a : box) : box
{
  seq @(s : box) (s, s -> SeqStep s a);
};

con_seq @(a s : box) (state : s) (next : s -> SeqStep s a)
  -> Seq a attribute(inline) =
  seq @a @s (boxedinfo seq @a) state next;

data SeqStep (s a : box) : val
{
  seqYield (s, a);           -- Produce a new state and a value
  seqSkip (s);               -- Produce a new state, but no value
  seqDone ();                -- End of sequence
};

data BindStateSeq (s a : box) : box
{
    outer_Seq (s);
    inner_Seq @(sp : box) (s, sp, sp -> SeqStep sp a);
};

bind_Seq @(a b : box) (sq : Seq a) (k : a -> Seq b)
  -> Seq b attribute(inline, inline_final) =
  case sq of seq @s tyob st g.
  let type bind_state = BindStateSeq s b in
  let outer_info = boxedinfo outer_Seq @s @b in
  let inner_info = boxedinfo inner_Seq @s @b in

  letfun
    gp (c : bind_state) -> SeqStep bind_state b =
        case c of {
          outer_Seq tyob p.
            case g p of {
              seqYield new_state x.
                case k x of seq @sp tyob s2 g2.
                seqSkip @bind_state @b
                (inner_Seq @s @b @sp inner_info new_state s2 g2)
            ; seqSkip new_state.
                seqSkip @bind_state @b
                (outer_Seq @s @b outer_info new_state)
            ; seqDone.
                seqDone @bind_state @b
            }
        ; inner_Seq @sp tyob st s2 g2.
            case g2 s2 of {
              seqYield new_state x.
                seqYield @bind_state @b
                (inner_Seq @s @b @sp inner_info st new_state g2)
                x
            ; seqSkip new_state.
                seqSkip @bind_state @b
                (inner_Seq @s @b @sp inner_info st new_state g2)
            ; seqDone.
                seqSkip @bind_state @b
                (outer_Seq @s @b outer_info st)
            }
        }
  in
  con_seq @b @bind_state (outer_Seq @s @b outer_info st) gp;

concat_Seq @(a : box) (sq1 : Seq a) (sq2 : Seq a)
  -> Seq a attribute(inline, inline_final) =
  case sq1 of seq @st1 tyob s1 g1.
  case sq2 of seq @st2 tyob s2 g2.

  let type concat_state = Either st1 st2 in
  let L_info = boxedinfo left @st1 @st2 in
  let R_info = boxedinfo right @st1 @st2 in

  letfun
    g (c : concat_state) -> SeqStep concat_state a =
        case c of {
          left tyob p.
            case g1 s1 of {
              seqYield new_state x.
                seqYield @concat_state @a (left @st1 @st2 L_info new_state) x
            ; seqSkip new_state.
                seqSkip @concat_state @a (left @st1 @st2 L_info new_state)
            ; seqDone.
                seqSkip @concat_state @a (right @st1 @st2 R_info s2)
            }
        ; right tyob p.
            case g2 s2 of {
              seqYield new_state x.
                seqYield @concat_state @a (right @st1 @st2 R_info new_state) x
            ; seqSkip new_state.
                seqSkip @concat_state @a (right @st1 @st2 R_info new_state)
            ; seqDone.
                seqDone @concat_state @a
            }
        }
  in
  con_seq @a @concat_state (con_left @st1 @st2 s1) g;

peel_Seq @(a : box) (sq : Seq a)
  -> Boxed (Maybe (Tuple2 (StuckRef a) (Ref (Seq a))))
  attribute(inline, inline_final) =

  case sq of seq @s tyob state generator.

  let a_info = unboxedinfo StuckRef @a in
  let a_sa = reprSizeAlign @(StuckRef a) a_info in
  let ref_info = unboxedinfo Ref @(Seq a) in
  let ref_sa = reprSizeAlign @(Ref (Seq a)) ref_info in
  let peeled_info = unboxedinfo Tuple2 @(StuckRef a) @(Ref (Seq a))
                    a_info ref_info in
  let type peeled = Tuple2 (StuckRef a) (Ref (Seq a)) in
  let maybe_info = unboxedinfo Maybe @peeled peeled_info in

  letfun
    peel (state : s) -> Boxed (Maybe peeled) =

      case generator state of {
        seqYield new_state x.
          con_boxed @(Maybe peeled) maybe_info
          (just @peeled (reprSizeAlign @peeled peeled_info)
           (tuple2 @(StuckRef a) @(Ref (Seq a)) a_sa ref_sa
            (stuckRef @a x)
            (ref @(Seq a) (con_seq @a @s new_state generator))))

      ; seqSkip new_state. peel new_state

      ; seqDone. 
          con_boxed @(Maybe peeled) maybe_info
          (nothing @peeled (reprSizeAlign @peeled peeled_info))
      }
   in
   peel state;

map_Seq @(a b : box) (f : a -> b) (sq : Seq a)
  -> Seq b attribute(inline, inline_final) =
  case sq of seq @s tyob state generator.
  letfun
    g (state : s) -> SeqStep s b =
      case generator state of {
        seqYield new_state x.   seqYield @s @b new_state (f x)
      ; seqSkip new_state.      seqSkip @s @b new_state
      ; seqDone.                seqDone @s @b
      }
    in
    con_seq @b @s state g;

-- State of the 'zipWith' Stream
data ZipWithState (s1 s2 a : box) : box
{
  zipWithState (s1, s2, Maybe (StuckRef a));
};

con_zipWithState_noValue @(s1 s2 a : box) (x : s1) (y : s2)
  -> ZipWithState s1 s2 a attribute(inline) =

  zipWithState @s1 @s2 @a (boxedinfo zipWithState @s1 @s2 @a)
  x y (nothing @(StuckRef a) (reprSizeAlign @(StuckRef a) (unboxedinfo StuckRef @a)));


con_zipWithState_value @(s1 s2 a : box) (x : s1) (y : s2) (z : a)
  -> ZipWithState s1 s2 a attribute(inline) =

  zipWithState @s1 @s2 @a (boxedinfo zipWithState @s1 @s2 @a)
  x y (just @(StuckRef a) (reprSizeAlign @(StuckRef a) (unboxedinfo StuckRef @a))
       (stuckRef @a z));


zipWith_Seq @(a b c : box)
  (f : a -> b -> c) (sqA : Seq a) (sqB : Seq b) -> Seq c
  attribute(inline, inline_final) =

  case sqA of seq @s1 tyob state1 generator1.
  case sqB of seq @s2 tyob state2 generator2.

  let sa_StuckRef = reprSizeAlign @(StuckRef a) (unboxedinfo StuckRef @a) in

  let type s = ZipWithState s1 s2 a in

  letfun
    g (state : s) -> SeqStep s c =
      letfun
        -- A value has been obtained from the first stream.
        -- Pull from the second.
        g_with_value (state1 : s1) (state2 : s2) (x : a) -> SeqStep s c =
          case generator2 state2 of {
            seqYield new_state2 y.
              seqYield @s @c
              (con_zipWithState_noValue @s1 @s2 @a state1 new_state2)
              (f x y)
          ; seqSkip new_state2.
              seqSkip @s @c
              (con_zipWithState_value @s1 @s2 @a state1 new_state2 x)
          ; seqDone.
              seqDone @s @c
          }
      in

      case state of zipWithState tyob state1 state2 m_x.

      -- Is a value available from the first stream?
      case m_x of [sa_StuckRef] {
        just (stuckRef x). g_with_value state1 state2 x
      ; nothing.
          -- Pull from the first stream
          case generator1 state1 of {
            seqYield new_state1 x.
              g_with_value new_state1 state2 x
          ; seqSkip new_state1.
              seqSkip @s @c
              (con_zipWithState_noValue @s1 @s2 @a new_state1 state2)
          ; seqDone.
              seqDone @s @c
          }
      }
  in

  con_seq @c @s (con_zipWithState_noValue @s1 @s2 @a state1 state2) g;


fold_Seq @(a acc : box) (f: a -> acc -> acc) (sq: Seq a) (ac : acc)
  -> acc attribute(inline, inline_final) =
  case sq of seq @s tyob state generator.
  letfun
    go (state : s) (ac : acc) -> acc =
      case generator state of {
        seqYield new_state x.   go new_state (f x ac)
      ; seqSkip new_state.      go new_state ac
      ; seqDone.                ac
      }
    in
    go state ac;


imp_fold_Seq @(a : box) (f: a -> Store -> Store) (sq: Seq a) (ac : Store)
  -> Store attribute(inline, inline_final) =
  case sq of seq @s tyob state generator.
  letfun
    go (state : s) (ac : Store) -> Store =
      case generator state of {
        seqYield new_state x.   go new_state (f x ac)
      ; seqSkip new_state.      go new_state ac
      ; seqDone.                ac
      }
    in
    go state ac;


unit_Seq @(a : box) (x : a) -> Seq a attribute(inline, inline_sequential) =
  letfun
    f (state : Boxed (Stored bool)) -> SeqStep (Boxed (Stored bool)) a =
      if unboxBoolValue state
      then seqYield @(Boxed (Stored bool)) @a (boxBoolValue False) x
      else seqDone @(Boxed (Stored bool)) @a
  in
  con_seq @a @(Boxed (Stored bool)) (boxBoolValue True) f;


empty_Seq @(a : box) -> Seq a =
  let type s = Boxed (Stored NoneType) in
  letfun f (state : s) -> SeqStep s a = seqDone @s @a in
  con_seq @a @s (boxNoneValue None) f;


-- State of a 'guard' sequence
data GuardState (a : box) : box
{
  guardState (bool, a);
};

guard_Seq @(a : box) (b : bool) (sq : Seq a)
  -> Seq a attribute(inline, inline_sequential) =

  case sq of seq @inner_s tyob inner_state generator.
  let type s = GuardState inner_s in

  let state_tyob = boxedinfo guardState @inner_s in
  letfun
    f (state : s) -> SeqStep s a =
      case state of guardState tyob flag inner_state.
      if flag
      then case generator inner_state of {
             seqYield inner_state2 x.
               seqYield @s @a (guardState @inner_s state_tyob True inner_state2) x
           ; seqSkip inner_state2.
               seqSkip @s @a (guardState @inner_s state_tyob True inner_state2)
           ; seqDone.
               seqDone @s @a
           }
      else seqDone @s @a
  in
  con_seq @a @s (guardState @inner_s state_tyob b inner_state) f;


Seq_from_llist @(a : box) (rep : Repr (AsBare a)) (l : llist (AsBare a))
  -> Seq a attribute(inline, inline_sequential) =

  let type list_type = llist (AsBare a) in

  con_seq @a @list_type l
  (\ (l : list_type) -> SeqStep list_type a.
     case l of [reprSizeAlign @(AsBare a) rep] {
       cons tyob h t. seqYield @list_type @a t (asbox @(AsBare a) rep (copy @(AsBare a) rep h))
     ; nil tyob. seqDone @list_type @a
     });
  

-------------------------------------------------------------------------------
-- RStream functions

map_RStream @(d a b : box) (f : a -> b) (rs : RStream d a)
  -> RStream d b attribute(inline) =
  case rs of rStream @c tyob rep g ix.
  con_rStream @d @b @c rep (\ (x : c) -> b. f (g x)) ix;


zipWith_RStream @(d : box) @(a b c : box)
  (sh : ShapeDict d)
  (rep_a : ReprBox a)
  (rep_b : ReprBox b)
  (rep_c : ReprBox c)
  (f : a -> b -> c)
  (s1 : RStream d a)
  (s2 : RStream d b)
  -> RStream d c
  attribute(inline) =

  case s1 of rStream @aprime tyob rep_aprime f1 si1.
  case s2 of rStream @bprime tyob rep_bprime f2 si2.

  let type tuple = Boxed (Tuple2 (StuckRef aprime) (StuckRef bprime)) in
  let rep_tuple = unboxedinfo Tuple2 @(StuckRef aprime) @(StuckRef bprime)
                  (unboxedinfo StuckRef @aprime)
                  (unboxedinfo StuckRef @bprime) in

  letfun
    call_f (t : tuple) -> c =
      case unpack_Tuple2_box @aprime @bprime t of (x, y).
      f (f1 x) (f2 y)
  in

  con_rStream @d @c @tuple rep_tuple call_f
  (con_someIndexable @d @tuple @(Zip2Indexable d)
    (idCoercion @d)
    (Indexable_Zip2Indexable @d sh)
    (zip_Indexable @d @aprime @bprime @tuple sh
     rep_aprime rep_bprime
     (pack_Tuple2_box @aprime @bprime) si1 si2));


rStreamToSeq @(a : box) (rs : RStream list_dim a) -> Seq a attribute(inline) =
  case rs of rStream @b tyob rep f si.
  map_Seq @b @a f (viewToSeq @b (someIndexableToView @list_dim @b rep si));


rStreamToView @(sh a : box) (rs : RStream sh a)
  -> view sh a attribute(inline) =
  case rs of rStream @b tyob rep f si.
  real_map_view @sh @b @a f (someIndexableToView @sh @b rep si);


-- Convert an ixStream to an rStream.  Error if not an ixStream.
-- This should only be used for streams that don't have shape list_dim,
-- since they're guaranteed to be ixStreams.
fromIxStream @(sh a : box) (s : IStream sh a)
  -> RStream sh a attribute(inline) =

  case s of {
    ixStream tyob rs. rs
  ; nestedIxStream @d2 tyob co sh2 rs. except @(RStream sh a)
  ; nestedSeqStream tyob co sq. except @(RStream sh a)
  ; seqStream tyob co sq. except @(RStream sh a)
  };


-------------------------------------------------------------------------------


unit_Stream @(a : box) (rep : ReprBox a) (x : a) -> Stream list_dim a
  attribute(inline, inline_sequential) =

  {-
  -- Create a dim0 stream
  let vw = con_view @dim0 @a con_dim0
           (\ (idx : Boxed (Stored NoneType)) -> a. x) in
  traverse_view_real @list_dim @a ShapeDict_list_dim rep vw;
  -}  
  con_stream @list_dim @a hintSeq (con_seqStream @a (unit_Seq @a x));


empty_Stream @(a : box)
  -> Stream list_dim a attribute(inline, inline_sequential) =
  con_stream @list_dim @a hintSeq (con_seqStream @a (empty_Seq @a));


guard_Stream @(a : box) (rep : ReprBox a) (condition : bool)
  (s : Stream list_dim a)
  -> Stream list_dim a
  attribute(inline,
            inline_sequential,
            inline_struct(T T D(T C)) -- Inline if stream constructor is known
           ) =

  case s of stream tyob par_hint i_s.
  let s2 = case i_s of {
             seqStream tyob co sq.
               con_seqStream @a (guard_Seq @a condition sq)

           ; nestedIxStream @d2 tyob co sh_d2 rs.
               -- Push the guard down
               nestedIxStream @list_dim @a @d2 tyob co sh_d2
               (map_RStream @d2 @(Stream list_dim a) @(Stream list_dim a)
                (guard_Stream @a rep condition) rs)

           ; nestedSeqStream tyob co sq.
               -- Push the guard down
               nestedSeqStream @list_dim @a tyob co
               (map_Seq @(Stream list_dim a) @(Stream list_dim a)
                (guard_Stream @a rep condition) sq)

           ; ixStream tyob rs.
               con_nestedIxStream @a @list_dim ShapeDict_list_dim
               (map_RStream @list_dim @a @(Stream list_dim a)
                (\ (x : a) -> Stream list_dim a.
                   con_stream @list_dim @a hintAny
                   (con_seqStream @a
                    (guard_Seq @a condition (unit_Seq @a x))))
                rs)
           }
  in con_stream @list_dim @a par_hint s2;


filter_Stream @(a : box) (rep : ReprBox a)
  (test : a -> Boxed (Stored bool)) (s : Stream list_dim a)
  -> Stream list_dim a attribute(inline) =

  bind_Stream @a @a s
  (\ (x : a) -> Stream list_dim a.
     guard_Stream @a rep (unboxBoolValue (test x)) (unit_Stream @a rep x));


bind_Stream @(a b : box) (s : Stream list_dim a) (t : a -> Stream list_dim b)
  -> Stream list_dim b
  attribute(inline,
            inline_struct(D(T C) T) -- Inline if stream constructor is known
           ) =

  case s of stream tyob par_hint i_s.
  let u = case i_s of {
            seqStream tyob co sq.
              con_nestedSeqStream @b
              (map_Seq @a @(Stream list_dim b) t sq)
              {-con_seqStream @b
              (bind_Seq @a @b sq
               (\ (x : a) -> Seq b. streamToSequence @b (t x)))-}

          ; nestedIxStream @sh tyob co shape_sh (rStream @c tyob2 rep_c extract si).
              letfun
                extract2 (x : c) -> Stream list_dim b =
                  bind_Stream @a @b (extract x) t
              in

              con_nestedIxStream @b @sh shape_sh
              (con_rStream @sh @(Stream list_dim b) @c rep_c extract2 si)

          ; nestedSeqStream tyob co sq.
             letfun
               transform (x : Stream list_dim a) -> Stream list_dim b =
                 bind_Stream @a @b x t
              in
              con_nestedSeqStream @b
              (map_Seq @(Stream list_dim a) @(Stream list_dim b) transform sq)

          ; ixStream tyob (rStream @c tyob2 rep_c extract si).
              let dom = case si of someIndexable @s tyob co ix container.
                        coerce @(shape s) @list_dim
                        (ix_shape @s ix @c container) in
              letfun extract2 (x : c) -> Stream list_dim b = t (extract x) in

              con_nestedIxStream @b @list_dim ShapeDict_list_dim
              (con_rStream @list_dim @(Stream list_dim b) @c rep_c extract2 si)
          } in
  con_stream @list_dim @b par_hint u;

