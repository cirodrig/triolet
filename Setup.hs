
import Data.List
import Data.Maybe
import System.FilePath
import System.Directory
import System.IO.Error

import Distribution.ModuleName hiding(main)
import Distribution.PackageDescription
import Distribution.Simple
import Distribution.Simple.Build.PathsModule
import Distribution.Simple.BuildPaths
import Distribution.Simple.LocalBuildInfo
import Distribution.Simple.Program
import Distribution.Simple.Setup
import Distribution.Simple.Utils
import Distribution.Verbosity

makeProgram = simpleProgram "make"
cabalMakeFile = "cabal.mk"

-- | The directories where source files belonging to the \"pyon\" program are
pyonSearchPaths :: LocalBuildInfo -> Executable -> [FilePath]
pyonSearchPaths lbi exe = autogenModulesDir lbi : hsSourceDirs (buildInfo exe)

-- | The directory where object files belonging to the \"pyon\" program go
pyonBuildDir :: LocalBuildInfo -> FilePath
pyonBuildDir lbi = buildDir lbi </> "pyon"

-- | A Makefile rule.
--
-- The strings in the rule are subject to minimal checking.  The target and
-- prerequisites may contain Makefile functions and variables, but shouldn't  
-- contain newlines, spaces, or special characters.  Newlines are permitted
-- in the command.
-- When generating a Makefile, a tab character is added to each line of the
-- command.
data MakeRule =
  MakeRule
  { makeTarget :: String
  , makePrerequisites :: [String]
  , makeCommand :: String
  }

formatMakeRule :: MakeRule -> String
formatMakeRule rule =
  let criterion =
        makeTarget rule ++ " : " ++
        concat (intersperse " " $ makePrerequisites rule)
      command = unlines $ map ('\t':) $ lines $ makeCommand rule
  in criterion ++ '\n' : command ++ "\n\n"

-- | Generate a rule to compile a .hs file
--
-- > D/A/B.o : E/A/B.hs
-- > 	mkdir -p D
-- > 	$(HC) -c $< $(HS_C_OPTS)
-- > 	touch D/A/B.hi
compileHsFile :: FilePath       -- ^ Build path
              -> ModuleName     -- ^ Module to compile
              -> FilePath       -- ^ Source file
              -> MakeRule
compileHsFile build_path mod src =
  let o_file = build_path </> toFilePath mod `addExtension` ".o"
      o_path = takeDirectory o_file
      hi_file = build_path </> toFilePath mod `addExtension` ".hi"
  in MakeRule o_file [src] $
     "mkdir -p " ++ o_path ++ "\n\
     \$(HC) -c $< $(HS_C_OPTS)\n\
     \touch " ++ hi_file

-- | Generate a rule to compile a .hs-boot file
--
-- > D/A/B.o-boot : E/A/B.hs-boot
-- > 	mkdir -p D
-- > 	$(HC) -c $< $(HS_C_OPTS)
compileHsBootFile :: FilePath       -- ^ Build directory
                  -> ModuleName     -- ^ Module to compile
                  -> FilePath       -- ^ Source file
                  -> MakeRule
compileHsBootFile build_path mod src =
  let o_file = build_path </> toFilePath mod `addExtension` ".o-boot"
      o_path = takeDirectory o_file
  in MakeRule o_file [src] $
     "mkdir -p " ++ o_path ++ "\n\
     \$(HC) -c $< $(HS_C_OPTS)"

-- Remove a file, but recover on error
lenientRemoveFile verb f = removeFile f `catch` check_err 
  where
    check_err e 
      | isDoesNotExistError e = return ()
      | otherwise = 
        let msg = "Could not remove file '" ++ f ++ "':" ++ show e
        in warn verb msg

-- Write configured variables and rules into a makefile for use by 'make'
writeCabalMakefile :: [(String, String)] -- key/value pairs
                   -> [MakeRule]
                   -> IO ()
writeCabalMakefile defs rules = writeFile cabalMakeFile text
  where
    text = "# Auto-generated by Setup.hs\n" ++
           concat ([k ++ "=" ++ protect v ++ "\n" | (k,v) <- defs]) ++
           concatMap formatMakeRule rules
      
    -- Format a string so that it will be read in by 'make' as a string.
    protect s = s

-- Write the auto-generated 'paths' module
writePathsModule verb pkg_desc lbi = do
  let paths_module =
        Distribution.Simple.Build.PathsModule.generate pkg_desc lbi
      autogen_dir = autogenModulesDir lbi
      autogen_filename =
        toFilePath (autogenModuleName pkg_desc) `addExtension` ".hs"

  createDirectoryIfMissingVerbose verb True autogen_dir
  rewriteFile (autogen_dir </> autogen_filename) paths_module

-- | Find module sources, including boot files.
generateRules :: Verbosity
              -> LocalBuildInfo
              -> Executable
              -> IO ([MakeRule], [FilePath])
generateRules verb lbi exe = do
  info verb "Locating Haskell source files"
  hs_files <- mapM find_hs_file all_modules
  boot_files <- mapM find_boot_file all_modules
  
  let rules = hs_files ++ catMaybes boot_files
      -- The prerequisites are the source files
      source_files = concatMap makePrerequisites rules
      
  return (rules, source_files)
  where
    all_modules = fromString "Main" : exeModules exe
    source_paths = pyonSearchPaths lbi exe
    build_dir = pyonBuildDir lbi
    
    find_hs_file mod = do
      f <- find_file $ toFilePath mod `addExtension` ".hs"
      case f of
        Nothing -> die $ "File does not exist: " ++ toFilePath mod
        Just source_path ->
          return $ compileHsFile build_dir mod source_path

    find_boot_file mod = do
      f <- find_file $ toFilePath mod `addExtension` ".hs-boot"
      case f of
        Nothing -> return Nothing
        Just source_path ->
          return $ Just $ compileHsBootFile build_dir mod source_path
    
    -- Find a file on one of the source paths.
    find_file relpath = find_first $ map (</> relpath) source_paths
      where
        find_first (p:ps) = do
          exists <- doesFileExist p
          if exists then return (Just p) else find_first ps

        find_first [] = return Nothing

runMake lbi flags args =
  let verb = fromFlag $ buildVerbosity flags  
  in runDbProgram verb makeProgram (withPrograms lbi) args

-------------------------------------------------------------------------------
-- Hooks

-- Build hook: run make
doBuild pkg_desc lbi hooks flags = do
  -- Generate modules if they don't alredy exist
  writePathsModule verb pkg_desc lbi
  
  -- Build the executable
  withExe pkg_desc build_exe
  where
    verb = fromFlag $ buildVerbosity flags

    build_exe exe = do
      (rules, files) <- generateRules verb lbi exe

      let object_files =
            [pyonBuildDir lbi </> toFilePath mod `addExtension` ".o"
            | mod <- fromString "Main" : exeModules exe]
      let variables =
            [ ("PYON_SOURCE_FILES", concat $ intersperse " " files)
            , ("PYON_OBJECT_FILES", concat $ intersperse " " object_files)]
      writeCabalMakefile variables rules
      
      -- Generate dependences
      main_path <- findFile (pyonSearchPaths lbi exe) (modulePath exe)
      let include_args =    
            ["-i" ++ path | path <- pyonSearchPaths lbi exe]
          dep_args =
            ["-M", "-dep-makefile", "depend_hs.mk",
             "-odir", pyonBuildDir lbi,
             "-hidir", pyonBuildDir lbi] ++ include_args ++
            [main_path]
      
      rawSystemExit verb "ghc" dep_args

      runMake lbi flags ["build"]

-- Post-configure hook:
-- Generate the auto-generated "paths" module
-- Put makefile variables in "cabal.mk"
doPostConf orig_post_conf args flags pkg_desc lbi = do
  let verb = fromFlag $ configVerbosity flags
  
  orig_post_conf args flags pkg_desc lbi
  
doClean orig_clean pkg_desc _lbi hooks flags = do
  let verb = fromFlag $ cleanVerbosity flags
  lenientRemoveFile verb cabalMakeFile
  
  orig_clean pkg_desc _lbi hooks flags

hooks = autoconfUserHooks
  { hookedPrograms = makeProgram : hookedPrograms autoconfUserHooks
  , postConf = doPostConf (postConf autoconfUserHooks)
  , cleanHook = doClean (cleanHook autoconfUserHooks)
  , buildHook = doBuild
  }

main = defaultMainWithHooks hooks
